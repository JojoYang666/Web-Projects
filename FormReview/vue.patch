Index: public/node_modules/vue-resource/test/http.test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/http.test.js	(revision )
+++ public/node_modules/vue-resource/test/http.test.js	(revision )
@@ -0,0 +1,34 @@
+var Vue = require('vue');
+var VueResource = require('../dist/vue-resource.common.js');
+
+Vue.use(VueResource);
+
+describe('Vue.http', function () {
+
+    it('post("jsfiddle.net/html")', () => {
+
+        return Vue.http.post('http://jsfiddle.net/echo/html/', {html: 'text'}, {emulateJSON: true}).then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(typeof res.body).toBe('string');
+            expect(res.body).toBe('text');
+
+        });
+
+    });
+
+    it('post("jsfiddle.net/json")', () => {
+
+        return Vue.http.post('http://jsfiddle.net/echo/json/', {json: JSON.stringify({foo: 'bar'})}, {emulateJSON: true}).then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(typeof res.body).toBe('object');
+            expect(res.body.foo).toBe('bar');
+
+        });
+
+    });
+
+});
Index: public/node_modules/vue/src/compiler/parser/entity-decoder.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/parser/entity-decoder.js	(revision )
+++ public/node_modules/vue/src/compiler/parser/entity-decoder.js	(revision )
@@ -0,0 +1,9 @@
+/* @flow */
+
+let decoder
+
+export function decode (html: string): string {
+  decoder = decoder || document.createElement('div')
+  decoder.innerHTML = html
+  return decoder.textContent
+}
Index: public/node_modules/vue/src/entries/web-server-renderer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/entries/web-server-renderer.js	(revision )
+++ public/node_modules/vue/src/entries/web-server-renderer.js	(revision )
@@ -0,0 +1,28 @@
+/* @flow */
+
+process.env.VUE_ENV = 'server'
+
+import { createRenderer as _createRenderer } from 'server/create-renderer'
+import { createBundleRendererCreator } from 'server/create-bundle-renderer'
+import { isUnaryTag } from 'web/compiler/util'
+import modules from 'web/server/modules/index'
+import baseDirectives from 'web/server/directives/index'
+
+export function createRenderer (options?: Object = {}): {
+  renderToString: Function,
+  renderToStream: Function
+} {
+  return _createRenderer({
+    isUnaryTag,
+    modules,
+    // user can provide server-side implementations for custom directives
+    // when creating the renderer.
+    directives: Object.assign(baseDirectives, options.directives),
+    // component cache (optional)
+    cache: options.cache,
+    // page template (optional)
+    template: options.template
+  })
+}
+
+export const createBundleRenderer = createBundleRendererCreator(createRenderer)
Index: public/node_modules/vue/src/core/global-api/use.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/global-api/use.js	(revision )
+++ public/node_modules/vue/src/core/global-api/use.js	(revision )
@@ -0,0 +1,22 @@
+/* @flow */
+
+import { toArray } from '../util/index'
+
+export function initUse (Vue: GlobalAPI) {
+  Vue.use = function (plugin: Function | Object) {
+    /* istanbul ignore if */
+    if (plugin.installed) {
+      return
+    }
+    // additional parameters
+    const args = toArray(arguments, 1)
+    args.unshift(this)
+    if (typeof plugin.install === 'function') {
+      plugin.install.apply(plugin, args)
+    } else if (typeof plugin === 'function') {
+      plugin.apply(null, args)
+    }
+    plugin.installed = true
+    return this
+  }
+}
Index: public/node_modules/vue/dist/vue.common.min.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.common.min.js	(revision )
+++ public/node_modules/vue/dist/vue.common.min.js	(revision )
@@ -0,0 +1,7 @@
+/*!
+ * Vue.js v2.0.3
+ * (c) 2014-2016 Evan You
+ * Released under the MIT License.
+ */
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Vue=e()}(this,function(){"use strict";function t(t){return null==t?"":"object"==typeof t?JSON.stringify(t,null,2):String(t)}function e(t){var e=parseFloat(t,10);return e||0===e?e:t}function n(t,e){for(var n=Object.create(null),r=t.split(","),i=0;i<r.length;i++)n[r[i]]=!0;return e?function(t){return n[t.toLowerCase()]}:function(t){return n[t]}}function r(t,e){if(t.length){var n=t.indexOf(e);if(n>-1)return t.splice(n,1)}}function i(t,e){return Ye.call(t,e)}function o(t){return"string"==typeof t||"number"==typeof t}function a(t){var e=Object.create(null);return function(n){var r=e[n];return r||(e[n]=t(n))}}function s(t,e){function n(n){var r=arguments.length;return r?r>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n}function c(t,e){e=e||0;for(var n=t.length-e,r=new Array(n);n--;)r[n]=t[n+e];return r}function u(t,e){for(var n in e)t[n]=e[n];return t}function l(t){return null!==t&&"object"==typeof t}function f(t){return an.call(t)===sn}function d(t){for(var e={},n=0;n<t.length;n++)t[n]&&u(e,t[n]);return e}function p(){}function v(t){return t.reduce(function(t,e){return t.concat(e.staticKeys||[])},[]).join(",")}function h(t,e){return t==e||!(!l(t)||!l(e))&&JSON.stringify(t)===JSON.stringify(e)}function m(t,e){for(var n=0;n<t.length;n++)if(h(t[n],e))return n;return-1}function _(t){var e=(t+"").charCodeAt(0);return 36===e||95===e}function y(t,e,n,r){Object.defineProperty(t,e,{value:n,enumerable:!!r,writable:!0,configurable:!0})}function g(t){if(!ln.test(t)){var e=t.split(".");return function(t){for(var n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}}function b(t){return/native code/.test(t.toString())}function C(t){wn.target&&$n.push(wn.target),wn.target=t}function w(){wn.target=$n.pop()}function $(){An.length=0,kn={},xn=On=!1}function A(){for(On=!0,An.sort(function(t,e){return t.id-e.id}),Sn=0;Sn<An.length;Sn++){var t=An[Sn],e=t.id;kn[e]=null,t.run()}gn&&un.devtools&&gn.emit("flush"),$()}function k(t){var e=t.id;if(null==kn[e]){if(kn[e]=!0,On){for(var n=An.length-1;n>=0&&An[n].id>t.id;)n--;An.splice(Math.max(n,Sn)+1,0,t)}else An.push(t);xn||(xn=!0,bn(A))}}function x(t,e){var n,r;e||(e=En,e.clear());var i=Array.isArray(t),o=l(t);if((i||o)&&Object.isExtensible(t)){if(t.__ob__){var a=t.__ob__.dep.id;if(e.has(a))return;e.add(a)}if(i)for(n=t.length;n--;)x(t[n],e);else if(o)for(r=Object.keys(t),n=r.length;n--;)x(t[r[n]],e)}}function O(t,e){t.__proto__=e}function S(t,e,n){for(var r=0,i=n.length;r<i;r++){var o=n[r];y(t,o,e[o])}}function j(t){if(l(t)){var e;return i(t,"__ob__")&&t.__ob__ instanceof Mn?e=t.__ob__:Pn.shouldConvert&&!un._isServer&&(Array.isArray(t)||f(t))&&Object.isExtensible(t)&&!t._isVue&&(e=new Mn(t)),e}}function T(t,e,n,r){var i=new wn,o=Object.getOwnPropertyDescriptor(t,e);if(!o||o.configurable!==!1){var a=o&&o.get,s=o&&o.set,c=j(n);Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:function(){var e=a?a.call(t):n;return wn.target&&(i.depend(),c&&c.dep.depend(),Array.isArray(e)&&L(e)),e},set:function(e){var r=a?a.call(t):n;e!==r&&(s?s.call(t,e):n=e,c=j(e),i.notify())}})}}function E(t,e,n){if(Array.isArray(t))return t.length=Math.max(t.length,e),t.splice(e,1,n),n;if(i(t,e))return void(t[e]=n);var r=t.__ob__;if(!(t._isVue||r&&r.vmCount))return r?(T(r.value,e,n),r.dep.notify(),n):void(t[e]=n)}function D(t,e){var n=t.__ob__;t._isVue||n&&n.vmCount||i(t,e)&&(delete t[e],n&&n.dep.notify())}function L(t){for(var e=void 0,n=0,r=t.length;n<r;n++)e=t[n],e&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&L(e)}function N(t){t._watchers=[],P(t),M(t),I(t),U(t),R(t)}function P(t){var e=t.$options.props;if(e){var n=t.$options.propsData||{},r=t.$options._propKeys=Object.keys(e),i=!t.$parent;Pn.shouldConvert=i;for(var o=function(i){var o=r[i];T(t,o,Dt(o,e,n,t))},a=0;a<r.length;a++)o(a);Pn.shouldConvert=!0}}function M(t){var e=t.$options.data;e=t._data="function"==typeof e?e.call(t):e||{},f(e)||(e={});for(var n=Object.keys(e),r=t.$options.props,o=n.length;o--;)r&&i(r,n[o])||z(t,n[o]);j(e),e.__ob__&&e.__ob__.vmCount++}function I(t){var e=t.$options.computed;if(e)for(var n in e){var r=e[n];"function"==typeof r?(In.get=B(r,t),In.set=p):(In.get=r.get?r.cache!==!1?B(r.get,t):s(r.get,t):p,In.set=r.set?s(r.set,t):p),Object.defineProperty(t,n,In)}}function B(t,e){var n=new Tn(e,t,p,{lazy:!0});return function(){return n.dirty&&n.evaluate(),wn.target&&n.depend(),n.value}}function U(t){var e=t.$options.methods;if(e)for(var n in e)t[n]=null==e[n]?p:s(e[n],t)}function R(t){var e=t.$options.watch;if(e)for(var n in e){var r=e[n];if(Array.isArray(r))for(var i=0;i<r.length;i++)V(t,n,r[i]);else V(t,n,r)}}function V(t,e,n){var r;f(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,r)}function H(t){var e={};e.get=function(){return this._data},Object.defineProperty(t.prototype,"$data",e),t.prototype.$set=E,t.prototype.$delete=D,t.prototype.$watch=function(t,e,n){var r=this;n=n||{},n.user=!0;var i=new Tn(r,t,e,n);return n.immediate&&e.call(r,i.value),function(){i.teardown()}}}function z(t,e){_(e)||Object.defineProperty(t,e,{configurable:!0,enumerable:!0,get:function(){return t._data[e]},set:function(n){t._data[e]=n}})}function F(t){var e=new Bn(t.tag,t.data,t.children,t.text,t.elm,t.ns,t.context,t.componentOptions);return e.isStatic=t.isStatic,e.key=t.key,e.isCloned=!0,e}function q(t){for(var e=new Array(t.length),n=0;n<t.length;n++)e[n]=F(t[n]);return e}function K(t,e,n,r){r+=e;var i=t.__injected||(t.__injected={});if(!i[r]){i[r]=!0;var o=t[e];o?t[e]=function(){o.apply(this,arguments),n.apply(this,arguments)}:t[e]=n}}function W(t,e,n,r,i){var o,a,s,c,u,l;for(o in t)if(a=t[o],s=e[o],a)if(s){if(a!==s)if(Array.isArray(s)){s.length=a.length;for(var f=0;f<s.length;f++)s[f]=a[f];t[o]=s}else s.fn=a,t[o]=s}else l="!"===o.charAt(0),u=l?o.slice(1):o,Array.isArray(a)?n(u,a.invoker=J(a),l):(a.invoker||(c=a,a=t[o]={},a.fn=c,a.invoker=G(a)),n(u,a.invoker,l));else;for(o in e)t[o]||(u="!"===o.charAt(0)?o.slice(1):o,r(u,e[o].invoker))}function J(t){return function(e){for(var n=arguments,r=1===arguments.length,i=0;i<t.length;i++)r?t[i](e):t[i].apply(null,n)}}function G(t){return function(e){var n=1===arguments.length;n?t.fn(e):t.fn.apply(null,arguments)}}function Z(t,e,n){if(o(t))return[Q(t)];if(Array.isArray(t)){for(var r=[],i=0,a=t.length;i<a;i++){var s=t[i],c=r[r.length-1];Array.isArray(s)?r.push.apply(r,Z(s,e,(n||"")+"_"+i)):o(s)?c&&c.text?c.text+=String(s):""!==s&&r.push(Q(s)):s instanceof Bn&&(s.text&&c&&c.text?c.text+=s.text:(e&&X(s,e),s.tag&&null==s.key&&null!=n&&(s.key="__vlist"+n+"_"+i+"__"),r.push(s)))}return r}}function Q(t){return new Bn(void 0,void 0,void 0,String(t))}function X(t,e){if(t.tag&&!t.ns&&(t.ns=e,t.children))for(var n=0,r=t.children.length;n<r;n++)X(t.children[n],e)}function Y(t){return t&&t.filter(function(t){return t&&t.componentOptions})[0]}function tt(t){var e=t.$options,n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._watcher=null,t._inactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}function et(t){t.prototype._mount=function(t,e){var n=this;return n.$el=t,n.$options.render||(n.$options.render=Un),nt(n,"beforeMount"),n._watcher=new Tn(n,function(){n._update(n._render(),e)},p),e=!1,null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n},t.prototype._update=function(t,e){var n=this;n._isMounted&&nt(n,"beforeUpdate");var r=n.$el,i=Rn;Rn=n;var o=n._vnode;n._vnode=t,o?n.$el=n.__patch__(o,t):n.$el=n.__patch__(n.$el,t,e),Rn=i,r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el),n._isMounted&&nt(n,"updated")},t.prototype._updateFromParent=function(t,e,n,r){var i=this,o=!(!i.$options._renderChildren&&!r);if(i.$options._parentVnode=n,i.$options._renderChildren=r,t&&i.$options.props){Pn.shouldConvert=!1;for(var a=i.$options._propKeys||[],s=0;s<a.length;s++){var c=a[s];i[c]=Dt(c,i.$options.props,t,i)}Pn.shouldConvert=!0}if(e){var u=i.$options._parentListeners;i.$options._parentListeners=e,i._updateListeners(e,u)}o&&(i.$slots=gt(r,i._renderContext),i.$forceUpdate())},t.prototype.$forceUpdate=function(){var t=this;t._watcher&&t._watcher.update()},t.prototype.$destroy=function(){var t=this;if(!t._isBeingDestroyed){nt(t,"beforeDestroy"),t._isBeingDestroyed=!0;var e=t.$parent;!e||e._isBeingDestroyed||t.$options.abstract||r(e.$children,t),t._watcher&&t._watcher.teardown();for(var n=t._watchers.length;n--;)t._watchers[n].teardown();t._data.__ob__&&t._data.__ob__.vmCount--,t._isDestroyed=!0,nt(t,"destroyed"),t.$off(),t.$el&&(t.$el.__vue__=null),t.__patch__(t._vnode,null)}}}function nt(t,e){var n=t.$options[e];if(n)for(var r=0,i=n.length;r<i;r++)n[r].call(t);t.$emit("hook:"+e)}function rt(t,e,n,r,i){if(t&&(l(t)&&(t=$t.extend(t)),"function"==typeof t)){if(!t.cid)if(t.resolved)t=t.resolved;else if(t=lt(t,function(){n.$forceUpdate()}),!t)return;e=e||{};var o=ft(e,t);if(t.options.functional)return it(t,o,e,n,r);var a=e.on;e.on=e.nativeOn,t.options.abstract&&(e={}),pt(e);var s=t.options.name||i,c=new Bn("vue-component-"+t.cid+(s?"-"+s:""),e,void 0,void 0,void 0,void 0,n,{Ctor:t,propsData:o,listeners:a,tag:i,children:r});return c}}function it(t,e,n,r,i){var o={},a=t.options.props;if(a)for(var c in a)o[c]=Dt(c,a,e);var u=t.options.render.call(null,s(ht,{_self:Object.create(r)}),{props:o,data:n,parent:r,children:Z(i),slots:function(){return gt(i,r)}});return u instanceof Bn&&(u.functionalContext=r,n.slot&&((u.data||(u.data={})).slot=n.slot)),u}function ot(t,e){var n=t.componentOptions,r={_isComponent:!0,parent:e,propsData:n.propsData,_componentTag:n.tag,_parentVnode:t,_parentListeners:n.listeners,_renderChildren:n.children},i=t.data.inlineTemplate;return i&&(r.render=i.render,r.staticRenderFns=i.staticRenderFns),new n.Ctor(r)}function at(t,e){if(!t.child||t.child._isDestroyed){var n=t.child=ot(t,Rn);n.$mount(e?t.elm:void 0,e)}}function st(t,e){var n=e.componentOptions,r=e.child=t.child;r._updateFromParent(n.propsData,n.listeners,e,n.children)}function ct(t){t.child._isMounted||(t.child._isMounted=!0,nt(t.child,"mounted")),t.data.keepAlive&&(t.child._inactive=!1,nt(t.child,"activated"))}function ut(t){t.child._isDestroyed||(t.data.keepAlive?(t.child._inactive=!0,nt(t.child,"deactivated")):t.child.$destroy())}function lt(t,e){if(!t.requested){t.requested=!0;var n=t.pendingCallbacks=[e],r=!0,i=function(e){if(l(e)&&(e=$t.extend(e)),t.resolved=e,!r)for(var i=0,o=n.length;i<o;i++)n[i](e)},o=function(t){},a=t(i,o);return a&&"function"==typeof a.then&&!t.resolved&&a.then(i,o),r=!1,t.resolved}t.pendingCallbacks.push(e)}function ft(t,e){var n=e.options.props;if(n){var r={},i=t.attrs,o=t.props,a=t.domProps;if(i||o||a)for(var s in n){var c=on(s);dt(r,o,s,c,!0)||dt(r,i,s,c)||dt(r,a,s,c)}return r}}function dt(t,e,n,r,o){if(e){if(i(e,n))return t[n]=e[n],o||delete e[n],!0;if(i(e,r))return t[n]=e[r],o||delete e[r],!0}return!1}function pt(t){t.hook||(t.hook={});for(var e=0;e<Hn.length;e++){var n=Hn[e],r=t.hook[n],i=Vn[n];t.hook[n]=r?vt(i,r):i}}function vt(t,e){return function(n,r){t(n,r),e(n,r)}}function ht(t,e,n){return e&&(Array.isArray(e)||"object"!=typeof e)&&(n=e,e=void 0),mt(this._self,t,e,n)}function mt(t,e,n,r){if(!n||!n.__ob__){if(!e)return Un();if("string"==typeof e){var i,o=un.getTagNamespace(e);return un.isReservedTag(e)?new Bn(e,n,Z(r,o),void 0,void 0,o,t):(i=Et(t.$options,"components",e))?rt(i,n,t,r,e):new Bn(e,n,Z(r,o),void 0,void 0,o,t)}return rt(e,n,t,r)}}function _t(t){t.$vnode=null,t._vnode=null,t._staticTrees=null,t._renderContext=t.$options._parentVnode&&t.$options._parentVnode.context,t.$slots=gt(t.$options._renderChildren,t._renderContext),t.$createElement=s(ht,t),t.$options.el&&t.$mount(t.$options.el)}function yt(n){n.prototype.$nextTick=function(t){bn(t,this)},n.prototype._render=function(){var t=this,e=t.$options,n=e.render,r=e.staticRenderFns,i=e._parentVnode;if(t._isMounted)for(var o in t.$slots)t.$slots[o]=q(t.$slots[o]);r&&!t._staticTrees&&(t._staticTrees=[]),t.$vnode=i;var a;try{a=n.call(t._renderProxy,t.$createElement)}catch(e){if(un.errorHandler)un.errorHandler.call(null,e,t);else{if(un._isServer)throw e;setTimeout(function(){throw e},0)}a=t._vnode}return a instanceof Bn||(a=Un()),a.parent=i,a},n.prototype._h=ht,n.prototype._s=t,n.prototype._n=e,n.prototype._e=Un,n.prototype._q=h,n.prototype._i=m,n.prototype._m=function(t,e){var n=this._staticTrees[t];if(n&&!e)return Array.isArray(n)?q(n):F(n);if(n=this._staticTrees[t]=this.$options.staticRenderFns[t].call(this._renderProxy),Array.isArray(n))for(var r=0;r<n.length;r++)"string"!=typeof n[r]&&(n[r].isStatic=!0,n[r].key="__static__"+t+"_"+r);else n.isStatic=!0,n.key="__static__"+t;return n};var r=function(t){return t};n.prototype._f=function(t){return Et(this.$options,"filters",t,!0)||r},n.prototype._l=function(t,e){var n,r,i,o,a;if(Array.isArray(t))for(n=new Array(t.length),r=0,i=t.length;r<i;r++)n[r]=e(t[r],r);else if("number"==typeof t)for(n=new Array(t),r=0;r<t;r++)n[r]=e(r+1,r);else if(l(t))for(o=Object.keys(t),n=new Array(o.length),r=0,i=o.length;r<i;r++)a=o[r],n[r]=e(t[a],a,r);return n},n.prototype._t=function(t,e){var n=this.$slots[t];return n||e},n.prototype._b=function(t,e,n){if(e)if(l(e)){Array.isArray(e)&&(e=d(e));for(var r in e)if("class"===r||"style"===r)t[r]=e[r];else{var i=n||un.mustUseProp(r)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={});i[r]=e[r]}}else;return t},n.prototype._k=function(t){return un.keyCodes[t]}}function gt(t,e){var n={};if(!t)return n;for(var r,i,o=Z(t)||[],a=[],s=0,c=o.length;s<c;s++)if(i=o[s],(i.context===e||i.functionalContext===e)&&i.data&&(r=i.data.slot)){var u=n[r]||(n[r]=[]);"template"===i.tag?u.push.apply(u,i.children):u.push(i)}else a.push(i);return a.length&&(1!==a.length||" "!==a[0].text&&!a[0].isComment)&&(n.default=a),n}function bt(t){t._events=Object.create(null);var e=t.$options._parentListeners,n=s(t.$on,t),r=s(t.$off,t);t._updateListeners=function(e,i){W(e,i||{},n,r,t)},e&&t._updateListeners(e)}function Ct(t){t.prototype.$on=function(t,e){var n=this;return(n._events[t]||(n._events[t]=[])).push(e),n},t.prototype.$once=function(t,e){function n(){r.$off(t,n),e.apply(r,arguments)}var r=this;return n.fn=e,r.$on(t,n),r},t.prototype.$off=function(t,e){var n=this;if(!arguments.length)return n._events=Object.create(null),n;var r=n._events[t];if(!r)return n;if(1===arguments.length)return n._events[t]=null,n;for(var i,o=r.length;o--;)if(i=r[o],i===e||i.fn===e){r.splice(o,1);break}return n},t.prototype.$emit=function(t){var e=this,n=e._events[t];if(n){n=n.length>1?c(n):n;for(var r=c(arguments,1),i=0,o=n.length;i<o;i++)n[i].apply(e,r)}return e}}function wt(t){function e(t,e){var r=t.$options=Object.create(n(t));r.parent=e.parent,r.propsData=e.propsData,r._parentVnode=e._parentVnode,r._parentListeners=e._parentListeners,r._renderChildren=e._renderChildren,r._componentTag=e._componentTag,e.render&&(r.render=e.render,r.staticRenderFns=e.staticRenderFns)}function n(t){var e=t.constructor,n=e.options;if(e.super){var r=e.super.options,i=e.superOptions;r!==i&&(e.superOptions=r,n=e.options=Tt(r,e.extendOptions),n.name&&(n.components[n.name]=e))}return n}t.prototype._init=function(t){var r=this;r._uid=zn++,r._isVue=!0,t&&t._isComponent?e(r,t):r.$options=Tt(n(r),t||{},r),r._renderProxy=r,r._self=r,tt(r),bt(r),nt(r,"beforeCreate"),N(r),nt(r,"created"),_t(r)}}function $t(t){this._init(t)}function At(t,e){var n,r,o;for(n in e)r=t[n],o=e[n],i(t,n)?l(r)&&l(o)&&At(r,o):E(t,n,o);return t}function kt(t,e){return e?t?t.concat(e):Array.isArray(e)?e:[e]:t}function xt(t,e){var n=Object.create(t||null);return e?u(n,e):n}function Ot(t){if(t.components){var e,n=t.components;for(var r in n){var i=r.toLowerCase();Xe(i)||un.isReservedTag(i)||(e=n[r],f(e)&&(n[r]=$t.extend(e)))}}}function St(t){var e=t.props;if(e){var n,r,i,o={};if(Array.isArray(e))for(n=e.length;n--;)r=e[n],"string"==typeof r&&(i=en(r),o[i]={type:null});else if(f(e))for(var a in e)r=e[a],i=en(a),o[i]=f(r)?r:{type:r};t.props=o}}function jt(t){var e=t.directives;if(e)for(var n in e){var r=e[n];"function"==typeof r&&(e[n]={bind:r,update:r})}}function Tt(t,e,n){function r(r){var i=Kn[r]||Wn;l[r]=i(t[r],e[r],n,r)}Ot(e),St(e),jt(e);var o=e.extends;if(o&&(t="function"==typeof o?Tt(t,o.options,n):Tt(t,o,n)),e.mixins)for(var a=0,s=e.mixins.length;a<s;a++){var c=e.mixins[a];c.prototype instanceof $t&&(c=c.options),t=Tt(t,c,n)}var u,l={};for(u in t)r(u);for(u in e)i(t,u)||r(u);return l}function Et(t,e,n,r){if("string"==typeof n){var i=t[e],o=i[n]||i[en(n)]||i[nn(en(n))];return o}}function Dt(t,e,n,r){var o=e[t],a=!i(n,t),s=n[t];if(Pt(o.type)&&(a&&!i(o,"default")?s=!1:""!==s&&s!==on(t)||(s=!0)),void 0===s){s=Lt(r,o,t);var c=Pn.shouldConvert;Pn.shouldConvert=!0,j(s),Pn.shouldConvert=c}return s}function Lt(t,e,n){if(i(e,"default")){var r=e.default;return l(r),"function"==typeof r&&e.type!==Function?r.call(t):r}}function Nt(t){var e=t&&t.toString().match(/^\s*function (\w+)/);return e&&e[1]}function Pt(t){if(!Array.isArray(t))return"Boolean"===Nt(t);for(var e=0,n=t.length;e<n;e++)if("Boolean"===Nt(t[e]))return!0;return!1}function Mt(t){t.use=function(t){if(!t.installed){var e=c(arguments,1);return e.unshift(this),"function"==typeof t.install?t.install.apply(t,e):t.apply(null,e),t.installed=!0,this}}}function It(t){t.mixin=function(e){t.options=Tt(t.options,e)}}function Bt(t){t.cid=0;var e=1;t.extend=function(t){t=t||{};var n=this,r=0===n.cid;if(r&&t._Ctor)return t._Ctor;var i=t.name||n.options.name,o=function(t){this._init(t)};return o.prototype=Object.create(n.prototype),o.prototype.constructor=o,o.cid=e++,o.options=Tt(n.options,t),o.super=n,o.extend=n.extend,un._assetTypes.forEach(function(t){o[t]=n[t]}),i&&(o.options.components[i]=o),o.superOptions=n.options,o.extendOptions=t,r&&(t._Ctor=o),o}}function Ut(t){un._assetTypes.forEach(function(e){t[e]=function(n,r){return r?("component"===e&&f(r)&&(r.name=r.name||n,r=t.extend(r)),"directive"===e&&"function"==typeof r&&(r={bind:r,update:r}),this.options[e+"s"][n]=r,r):this.options[e+"s"][n]}})}function Rt(t){var e={};e.get=function(){return un},Object.defineProperty(t,"config",e),t.util=Jn,t.set=E,t.delete=D,t.nextTick=bn,t.options=Object.create(null),un._assetTypes.forEach(function(e){t.options[e+"s"]=Object.create(null)}),u(t.options.components,Zn),Mt(t),It(t),Bt(t),Ut(t)}function Vt(t){for(var e=t.data,n=t,r=t;r.child;)r=r.child._vnode,r.data&&(e=Ht(r.data,e));for(;n=n.parent;)n.data&&(e=Ht(e,n.data));return zt(e)}function Ht(t,e){return{staticClass:Ft(t.staticClass,e.staticClass),class:t.class?[t.class,e.class]:e.class}}function zt(t){var e=t.class,n=t.staticClass;return n||e?Ft(n,qt(e)):""}function Ft(t,e){return t?e?t+" "+e:t:e||""}function qt(t){var e="";if(!t)return e;if("string"==typeof t)return t;if(Array.isArray(t)){for(var n,r=0,i=t.length;r<i;r++)t[r]&&(n=qt(t[r]))&&(e+=n+" ");return e.slice(0,-1)}if(l(t)){for(var o in t)t[o]&&(e+=o+" ");return e.slice(0,-1)}return e}function Kt(t){return sr(t)?"svg":"math"===t?"math":void 0}function Wt(t){if(!dn)return!0;if(cr(t))return!1;if(t=t.toLowerCase(),null!=ur[t])return ur[t];var e=document.createElement(t);return t.indexOf("-")>-1?ur[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ur[t]=/HTMLUnknownElement/.test(e.toString())}function Jt(t){if("string"==typeof t){if(t=document.querySelector(t),!t)return document.createElement("div")}return t}function Gt(t,e){var n=document.createElement(t);return"select"!==t?n:(e.data&&e.data.attrs&&"multiple"in e.data.attrs&&n.setAttribute("multiple","multiple"),n)}function Zt(t,e){return document.createElementNS(or[t],e)}function Qt(t){return document.createTextNode(t)}function Xt(t){return document.createComment(t)}function Yt(t,e,n){t.insertBefore(e,n)}function te(t,e){t.removeChild(e)}function ee(t,e){t.appendChild(e)}function ne(t){return t.parentNode}function re(t){return t.nextSibling}function ie(t){return t.tagName}function oe(t,e){t.textContent=e}function ae(t){return t.childNodes}function se(t,e,n){t.setAttribute(e,n)}function ce(t,e){var n=t.data.ref;if(n){var i=t.context,o=t.child||t.elm,a=i.$refs;e?Array.isArray(a[n])?r(a[n],o):a[n]===o&&(a[n]=void 0):t.data.refInFor?Array.isArray(a[n])?a[n].push(o):a[n]=[o]:a[n]=o}}function ue(t){return null==t}function le(t){return null!=t}function fe(t,e){return t.key===e.key&&t.tag===e.tag&&t.isComment===e.isComment&&!t.data==!e.data}function de(t,e,n){var r,i,o={};for(r=e;r<=n;++r)i=t[r].key,le(i)&&(o[i]=r);return o}function pe(t){function e(t){return new Bn($.tagName(t).toLowerCase(),{},[],void 0,t)}function n(t,e){function n(){0===--n.listeners&&r(t)}return n.listeners=e,n}function r(t){var e=$.parentNode(t);$.removeChild(e,t)}function i(t,e,n){var r,i=t.data;if(t.isRootInsert=!n,le(i)&&(le(r=i.hook)&&le(r=r.init)&&r(t),le(r=t.child)))return u(t,e),t.elm;var o=t.children,s=t.tag;return le(s)?(t.elm=t.ns?$.createElementNS(t.ns,s):$.createElement(s,t),l(t),a(t,o,e),le(i)&&c(t,e)):t.isComment?t.elm=$.createComment(t.text):t.elm=$.createTextNode(t.text),t.elm}function a(t,e,n){if(Array.isArray(e))for(var r=0;r<e.length;++r)$.appendChild(t.elm,i(e[r],n,!0));else o(t.text)&&$.appendChild(t.elm,$.createTextNode(t.text))}function s(t){for(;t.child;)t=t.child._vnode;return le(t.tag)}function c(t,e){for(var n=0;n<C.create.length;++n)C.create[n](dr,t);g=t.data.hook,le(g)&&(g.create&&g.create(dr,t),g.insert&&e.push(t))}function u(t,e){t.data.pendingInsert&&e.push.apply(e,t.data.pendingInsert),t.elm=t.child.$el,s(t)?(c(t,e),l(t)):(ce(t),e.push(t))}function l(t){var e;le(e=t.context)&&le(e=e.$options._scopeId)&&$.setAttribute(t.elm,e,""),le(e=Rn)&&e!==t.context&&le(e=e.$options._scopeId)&&$.setAttribute(t.elm,e,"")}function f(t,e,n,r,o,a){for(;r<=o;++r)$.insertBefore(t,i(n[r],a),e)}function d(t){var e,n,r=t.data;if(le(r))for(le(e=r.hook)&&le(e=e.destroy)&&e(t),e=0;e<C.destroy.length;++e)C.destroy[e](t);if(le(e=t.children))for(n=0;n<t.children.length;++n)d(t.children[n])}function p(t,e,n,r){for(;n<=r;++n){var i=e[n];le(i)&&(le(i.tag)?(v(i),d(i)):$.removeChild(t,i.elm))}}function v(t,e){if(e||le(t.data)){var i=C.remove.length+1;for(e?e.listeners+=i:e=n(t.elm,i),le(g=t.child)&&le(g=g._vnode)&&le(g.data)&&v(g,e),g=0;g<C.remove.length;++g)C.remove[g](t,e);le(g=t.data.hook)&&le(g=g.remove)?g(t,e):e()}else r(t.elm)}function h(t,e,n,r,o){for(var a,s,c,u,l=0,d=0,v=e.length-1,h=e[0],_=e[v],y=n.length-1,g=n[0],b=n[y],C=!o;l<=v&&d<=y;)ue(h)?h=e[++l]:ue(_)?_=e[--v]:fe(h,g)?(m(h,g,r),h=e[++l],g=n[++d]):fe(_,b)?(m(_,b,r),_=e[--v],b=n[--y]):fe(h,b)?(m(h,b,r),C&&$.insertBefore(t,h.elm,$.nextSibling(_.elm)),h=e[++l],b=n[--y]):fe(_,g)?(m(_,g,r),C&&$.insertBefore(t,_.elm,h.elm),_=e[--v],g=n[++d]):(ue(a)&&(a=de(e,l,v)),s=le(g.key)?a[g.key]:null,ue(s)?($.insertBefore(t,i(g,r),h.elm),g=n[++d]):(c=e[s],c.tag!==g.tag?($.insertBefore(t,i(g,r),h.elm),g=n[++d]):(m(c,g,r),e[s]=void 0,C&&$.insertBefore(t,g.elm,h.elm),g=n[++d])));l>v?(u=ue(n[y+1])?null:n[y+1].elm,f(t,u,n,d,y,r)):d>y&&p(t,e,l,v)}function m(t,e,n,r){if(t!==e){if(e.isStatic&&t.isStatic&&e.key===t.key&&e.isCloned)return void(e.elm=t.elm);var i,o=e.data,a=le(o);a&&le(i=o.hook)&&le(i=i.prepatch)&&i(t,e);var c=e.elm=t.elm,u=t.children,l=e.children;if(a&&s(e)){for(i=0;i<C.update.length;++i)C.update[i](t,e);le(i=o.hook)&&le(i=i.update)&&i(t,e)}ue(e.text)?le(u)&&le(l)?u!==l&&h(c,u,l,n,r):le(l)?(le(t.text)&&$.setTextContent(c,""),f(c,null,l,0,l.length-1,n)):le(u)?p(c,u,0,u.length-1):le(t.text)&&$.setTextContent(c,""):t.text!==e.text&&$.setTextContent(c,e.text),a&&le(i=o.hook)&&le(i=i.postpatch)&&i(t,e)}}function _(t,e,n){if(n&&t.parent)t.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}function y(t,e,n){e.elm=t;var r=e.tag,i=e.data,o=e.children;if(le(i)&&(le(g=i.hook)&&le(g=g.init)&&g(e,!0),le(g=e.child)))return u(e,n),!0;if(le(r)){if(le(o)){var s=$.childNodes(t);if(s.length){var l=!0;if(s.length!==o.length)l=!1;else for(var f=0;f<o.length;f++)if(!y(s[f],o[f],n)){l=!1;break}if(!l)return!1}else a(e,o,n)}le(i)&&c(e,n)}return!0}var g,b,C={},w=t.modules,$=t.nodeOps;for(g=0;g<pr.length;++g)for(C[pr[g]]=[],b=0;b<w.length;++b)void 0!==w[b][pr[g]]&&C[pr[g]].push(w[b][pr[g]]);return function(t,n,r,o){if(!n)return void(t&&d(t));var a,c,u=!1,l=[];if(t){var f=le(t.nodeType);if(!f&&fe(t,n))m(t,n,l,o);else{if(f){if(1===t.nodeType&&t.hasAttribute("server-rendered")&&(t.removeAttribute("server-rendered"),r=!0),r&&y(t,n,l))return _(n,l,!0),t;t=e(t)}if(a=t.elm,c=$.parentNode(a),i(n,l),n.parent&&(n.parent.elm=n.elm,s(n)))for(var v=0;v<C.create.length;++v)C.create[v](dr,n.parent);null!==c?($.insertBefore(c,n.elm,$.nextSibling(a)),p(c,[t],0,0)):le(t.tag)&&d(t)}}else u=!0,i(n,l);return _(n,l,u),n.elm}}function ve(t,e){if(t.data.directives||e.data.directives){var n,r,i,o=t===dr,a=he(t.data.directives,t.context),s=he(e.data.directives,e.context),c=[],u=[];for(n in s)r=a[n],i=s[n],r?(i.oldValue=r.value,_e(i,"update",e,t),i.def&&i.def.componentUpdated&&u.push(i)):(_e(i,"bind",e,t),i.def&&i.def.inserted&&c.push(i));if(c.length){var l=function(){c.forEach(function(n){_e(n,"inserted",e,t)})};o?K(e.data.hook||(e.data.hook={}),"insert",l,"dir-insert"):l()}if(u.length&&K(e.data.hook||(e.data.hook={}),"postpatch",function(){u.forEach(function(n){_e(n,"componentUpdated",e,t)})},"dir-postpatch"),!o)for(n in a)s[n]||_e(a[n],"unbind",t)}}function he(t,e){var n=Object.create(null);if(!t)return n;var r,i;for(r=0;r<t.length;r++)i=t[r],i.modifiers||(i.modifiers=hr),n[me(i)]=i,i.def=Et(e.$options,"directives",i.name,!0);return n}function me(t){return t.rawName||t.name+"."+Object.keys(t.modifiers||{}).join(".")}function _e(t,e,n,r){var i=t.def&&t.def[e];i&&i(n.elm,t,n,r)}function ye(t,e){if(t.data.attrs||e.data.attrs){var n,r,i,o=e.elm,a=t.data.attrs||{},s=e.data.attrs||{};s.__ob__&&(s=e.data.attrs=u({},s));for(n in s)r=s[n],i=a[n],i!==r&&ge(o,n,r);for(n in a)null==s[n]&&(nr(n)?o.removeAttributeNS(er,rr(n)):Yn(n)||o.removeAttribute(n))}}function ge(t,e,n){tr(e)?ir(n)?t.removeAttribute(e):t.setAttribute(e,e):Yn(e)?t.setAttribute(e,ir(n)||"false"===n?"false":"true"):nr(e)?ir(n)?t.removeAttributeNS(er,rr(e)):t.setAttributeNS(er,e,n):ir(n)?t.removeAttribute(e):t.setAttribute(e,n)}function be(t,e){var n=e.elm,r=e.data,i=t.data;if(r.staticClass||r.class||i&&(i.staticClass||i.class)){var o=Vt(e),a=n._transitionClasses;a&&(o=Ft(o,qt(a))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}function Ce(t,e){if(t.data.on||e.data.on){var n=e.data.on||{},r=t.data.on||{},i=e.elm._v_add||(e.elm._v_add=function(t,n,r){e.elm.addEventListener(t,n,r)}),o=e.elm._v_remove||(e.elm._v_remove=function(t,n){e.elm.removeEventListener(t,n)});W(n,r,i,o,e.context)}}function we(t,e){if(t.data.domProps||e.data.domProps){var n,r,i=e.elm,o=t.data.domProps||{},a=e.data.domProps||{};a.__ob__&&(a=e.data.domProps=u({},a));for(n in o)null==a[n]&&(i[n]=void 0);for(n in a)if("textContent"!==n&&"innerHTML"!==n||!e.children||(e.children.length=0),r=a[n],"value"===n){i._value=r;var s=null==r?"":String(r);i.value===s||i.composing||(i.value=s)}else i[n]=r}}function $e(t,e){if(t.data&&t.data.style||e.data.style){var n,r,i=e.elm,o=t.data.style||{},a=e.data.style||{};if("string"==typeof a)return void(i.style.cssText=a);var s=a.__ob__;Array.isArray(a)&&(a=e.data.style=d(a)),s&&(a=e.data.style=u({},a));for(r in o)null==a[r]&&(i.style[wr(r)]="");for(r in a)n=a[r],n!==o[r]&&(i.style[wr(r)]=null==n?"":n)}}function Ae(t,e){if(t.classList)e.indexOf(" ")>-1?e.split(/\s+/).forEach(function(e){return t.classList.add(e)}):t.classList.add(e);else{var n=" "+t.getAttribute("class")+" ";n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function ke(t,e){if(t.classList)e.indexOf(" ")>-1?e.split(/\s+/).forEach(function(e){return t.classList.remove(e)}):t.classList.remove(e);else{for(var n=" "+t.getAttribute("class")+" ",r=" "+e+" ";n.indexOf(r)>=0;)n=n.replace(r," ");t.setAttribute("class",n.trim())}}function xe(t){Er(function(){Er(t)})}function Oe(t,e){(t._transitionClasses||(t._transitionClasses=[])).push(e),Ae(t,e)}function Se(t,e){t._transitionClasses&&r(t._transitionClasses,e),ke(t,e)}function je(t,e,n){var r=Te(t,e),i=r.type,o=r.timeout,a=r.propCount;if(!i)return n();var s=i===kr?Sr:Tr,c=0,u=function(){t.removeEventListener(s,l),n()},l=function(e){e.target===t&&++c>=a&&u()};setTimeout(function(){c<a&&u()},o+1),t.addEventListener(s,l)}function Te(t,e){var n,r=window.getComputedStyle(t),i=r[Or+"Delay"].split(", "),o=r[Or+"Duration"].split(", "),a=Ee(i,o),s=r[jr+"Delay"].split(", "),c=r[jr+"Duration"].split(", "),u=Ee(s,c),l=0,f=0;e===kr?a>0&&(n=kr,l=a,f=o.length):e===xr?u>0&&(n=xr,l=u,f=c.length):(l=Math.max(a,u),n=l>0?a>u?kr:xr:null,f=n?n===kr?o.length:c.length:0);var d=n===kr&&Dr.test(r[Or+"Property"]);return{type:n,timeout:l,propCount:f,hasTransform:d}}function Ee(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map(function(e,n){return De(e)+De(t[n])}))}function De(t){return 1e3*Number(t.slice(0,-1))}function Le(t){var e=t.elm;e._leaveCb&&(e._leaveCb.cancelled=!0,e._leaveCb());var n=Pe(t.data.transition);if(n&&!e._enterCb&&1===e.nodeType){var r=n.css,i=n.type,o=n.enterClass,a=n.enterActiveClass,s=n.appearClass,c=n.appearActiveClass,u=n.beforeEnter,l=n.enter,f=n.afterEnter,d=n.enterCancelled,p=n.beforeAppear,v=n.appear,h=n.afterAppear,m=n.appearCancelled,_=Rn.$vnode,y=_&&_.parent?_.parent.context:Rn,g=!y._isMounted||!t.isRootInsert;if(!g||v||""===v){var b=g?s:o,C=g?c:a,w=g?p||u:u,$=g&&"function"==typeof v?v:l,A=g?h||f:f,k=g?m||d:d,x=r!==!1&&!hn,O=$&&($._length||$.length)>1,S=e._enterCb=Me(function(){x&&Se(e,C),S.cancelled?(x&&Se(e,b),k&&k(e)):A&&A(e),e._enterCb=null});t.data.show||K(t.data.hook||(t.data.hook={}),"insert",function(){var n=e.parentNode,r=n&&n._pending&&n._pending[t.key];r&&r.tag===t.tag&&r.elm._leaveCb&&r.elm._leaveCb(),$&&$(e,S)},"transition-insert"),w&&w(e),x&&(Oe(e,b),Oe(e,C),xe(function(){Se(e,b),S.cancelled||O||je(e,i,S)})),t.data.show&&$&&$(e,S),x||O||S()}}}function Ne(t,e){function n(){m.cancelled||(t.data.show||((r.parentNode._pending||(r.parentNode._pending={}))[t.key]=t),u&&u(r),v&&(Oe(r,s),Oe(r,c),xe(function(){Se(r,s),m.cancelled||h||je(r,a,m)})),l&&l(r,m),v||h||m())}var r=t.elm;r._enterCb&&(r._enterCb.cancelled=!0,r._enterCb());var i=Pe(t.data.transition);if(!i)return e();if(!r._leaveCb&&1===r.nodeType){var o=i.css,a=i.type,s=i.leaveClass,c=i.leaveActiveClass,u=i.beforeLeave,l=i.leave,f=i.afterLeave,d=i.leaveCancelled,p=i.delayLeave,v=o!==!1&&!hn,h=l&&(l._length||l.length)>1,m=r._leaveCb=Me(function(){r.parentNode&&r.parentNode._pending&&(r.parentNode._pending[t.key]=null),v&&Se(r,c),m.cancelled?(v&&Se(r,s),d&&d(r)):(e(),f&&f(r)),r._leaveCb=null});p?p(n):n()}}function Pe(t){if(t){if("object"==typeof t){var e={};return t.css!==!1&&u(e,Lr(t.name||"v")),u(e,t),e}return"string"==typeof t?Lr(t):void 0}}function Me(t){var e=!1;return function(){e||(e=!0,t())}}function Ie(t,e,n){var r=e.value,i=t.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=t.options.length;s<c;s++)if(a=t.options[s],i)o=m(r,Ue(a))>-1,a.selected!==o&&(a.selected=o);else if(h(Ue(a),r))return void(t.selectedIndex!==s&&(t.selectedIndex=s));i||(t.selectedIndex=-1)}}function Be(t,e){for(var n=0,r=e.length;n<r;n++)if(h(Ue(e[n]),t))return!1;return!0}function Ue(t){return"_value"in t?t._value:t.value}function Re(t){t.target.composing=!0}function Ve(t){t.target.composing=!1,He(t.target,"input")}function He(t,e){var n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function ze(t){return!t.child||t.data&&t.data.transition?t:ze(t.child._vnode)}function Fe(t){var e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?Fe(Y(e.children)):t}function qe(t){var e={},n=t.$options;for(var r in n.propsData)e[r]=t[r];var i=n._parentListeners;for(var o in i)e[en(o)]=i[o].fn;return e}function Ke(t,e){return/\d-keep-alive$/.test(e.tag)?t("keep-alive"):null}function We(t){for(;t=t.parent;)if(t.data.transition)return!0;
+}function Je(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function Ge(t){t.data.newPos=t.elm.getBoundingClientRect()}function Ze(t){var e=t.data.pos,n=t.data.newPos,r=e.left-n.left,i=e.top-n.top;if(r||i){t.data.moved=!0;var o=t.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}var Qe,Xe=n("slot,component",!0),Ye=Object.prototype.hasOwnProperty,tn=/-(\w)/g,en=a(function(t){return t.replace(tn,function(t,e){return e?e.toUpperCase():""})}),nn=a(function(t){return t.charAt(0).toUpperCase()+t.slice(1)}),rn=/([^-])([A-Z])/g,on=a(function(t){return t.replace(rn,"$1-$2").replace(rn,"$1-$2").toLowerCase()}),an=Object.prototype.toString,sn="[object Object]",cn=function(){return!1},un={optionMergeStrategies:Object.create(null),silent:!1,devtools:!1,errorHandler:null,ignoredElements:null,keyCodes:Object.create(null),isReservedTag:cn,isUnknownElement:cn,getTagNamespace:p,mustUseProp:cn,_assetTypes:["component","directive","filter"],_lifecycleHooks:["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated"],_maxUpdateCount:100,_isServer:!1},ln=/[^\w.$]/,fn="__proto__"in{},dn="undefined"!=typeof window&&"[object Object]"!==Object.prototype.toString.call(window),pn=dn&&window.navigator.userAgent.toLowerCase(),vn=pn&&/msie|trident/.test(pn),hn=pn&&pn.indexOf("msie 9.0")>0,mn=pn&&pn.indexOf("edge/")>0,_n=pn&&pn.indexOf("android")>0,yn=pn&&/iphone|ipad|ipod|ios/.test(pn),gn=dn&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,bn=function(){function t(){r=!1;var t=n.slice(0);n.length=0;for(var e=0;e<t.length;e++)t[e]()}var e,n=[],r=!1;if("undefined"!=typeof Promise&&b(Promise)){var i=Promise.resolve();e=function(){i.then(t),yn&&setTimeout(p)}}else if("undefined"==typeof MutationObserver||!b(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())e=function(){setTimeout(t,0)};else{var o=1,a=new MutationObserver(t),s=document.createTextNode(String(o));a.observe(s,{characterData:!0}),e=function(){o=(o+1)%2,s.data=String(o)}}return function(t,i){var o=i?function(){t.call(i)}:t;n.push(o),r||(r=!0,e())}}();Qe="undefined"!=typeof Set&&b(Set)?Set:function(){function t(){this.set=Object.create(null)}return t.prototype.has=function(t){return void 0!==this.set[t]},t.prototype.add=function(t){this.set[t]=1},t.prototype.clear=function(){this.set=Object.create(null)},t}();var Cn=0,wn=function(){this.id=Cn++,this.subs=[]};wn.prototype.addSub=function(t){this.subs.push(t)},wn.prototype.removeSub=function(t){r(this.subs,t)},wn.prototype.depend=function(){wn.target&&wn.target.addDep(this)},wn.prototype.notify=function(){for(var t=this.subs.slice(),e=0,n=t.length;e<n;e++)t[e].update()},wn.target=null;var $n=[],An=[],kn={},xn=!1,On=!1,Sn=0,jn=0,Tn=function(t,e,n,r){void 0===r&&(r={}),this.vm=t,t._watchers.push(this),this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.expression=e.toString(),this.cb=n,this.id=++jn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new Qe,this.newDepIds=new Qe,"function"==typeof e?this.getter=e:(this.getter=g(e),this.getter||(this.getter=function(){})),this.value=this.lazy?void 0:this.get()};Tn.prototype.get=function(){C(this);var t=this.getter.call(this.vm,this.vm);return this.deep&&x(t),w(),this.cleanupDeps(),t},Tn.prototype.addDep=function(t){var e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))},Tn.prototype.cleanupDeps=function(){for(var t=this,e=this.deps.length;e--;){var n=t.deps[e];t.newDepIds.has(n.id)||n.removeSub(t)}var r=this.depIds;this.depIds=this.newDepIds,this.newDepIds=r,this.newDepIds.clear(),r=this.deps,this.deps=this.newDeps,this.newDeps=r,this.newDeps.length=0},Tn.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():k(this)},Tn.prototype.run=function(){if(this.active){var t=this.get();if(t!==this.value||l(t)||this.deep){var e=this.value;if(this.value=t,this.user)try{this.cb.call(this.vm,t,e)}catch(t){if(!un.errorHandler)throw t;un.errorHandler.call(null,t,this.vm)}else this.cb.call(this.vm,t,e)}}},Tn.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},Tn.prototype.depend=function(){for(var t=this,e=this.deps.length;e--;)t.deps[e].depend()},Tn.prototype.teardown=function(){var t=this;if(this.active){this.vm._isBeingDestroyed||this.vm._vForRemoving||r(this.vm._watchers,this);for(var e=this.deps.length;e--;)t.deps[e].removeSub(t);this.active=!1}};var En=new Qe,Dn=Array.prototype,Ln=Object.create(Dn);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(t){var e=Dn[t];y(Ln,t,function(){for(var n=arguments,r=arguments.length,i=new Array(r);r--;)i[r]=n[r];var o,a=e.apply(this,i),s=this.__ob__;switch(t){case"push":o=i;break;case"unshift":o=i;break;case"splice":o=i.slice(2)}return o&&s.observeArray(o),s.dep.notify(),a})});var Nn=Object.getOwnPropertyNames(Ln),Pn={shouldConvert:!0,isSettingProps:!1},Mn=function(t){if(this.value=t,this.dep=new wn,this.vmCount=0,y(t,"__ob__",this),Array.isArray(t)){var e=fn?O:S;e(t,Ln,Nn),this.observeArray(t)}else this.walk(t)};Mn.prototype.walk=function(t){for(var e=Object.keys(t),n=0;n<e.length;n++)T(t,e[n],t[e[n]])},Mn.prototype.observeArray=function(t){for(var e=0,n=t.length;e<n;e++)j(t[e])};var In={enumerable:!0,configurable:!0,get:p,set:p},Bn=function(t,e,n,r,i,o,a,s){this.tag=t,this.data=e,this.children=n,this.text=r,this.elm=i,this.ns=o,this.context=a,this.functionalContext=void 0,this.key=e&&e.key,this.componentOptions=s,this.child=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1},Un=function(){var t=new Bn;return t.text="",t.isComment=!0,t},Rn=null,Vn={init:at,prepatch:st,insert:ct,destroy:ut},Hn=Object.keys(Vn),zn=0;wt($t),H($t),Ct($t),et($t),yt($t);var Fn,qn=p,Kn=un.optionMergeStrategies;Kn.data=function(t,e,n){return n?t||e?function(){var r="function"==typeof e?e.call(n):e,i="function"==typeof t?t.call(n):void 0;return r?At(r,i):i}:void 0:e?"function"!=typeof e?t:t?function(){return At(e.call(this),t.call(this))}:e:t},un._lifecycleHooks.forEach(function(t){Kn[t]=kt}),un._assetTypes.forEach(function(t){Kn[t+"s"]=xt}),Kn.watch=function(t,e){if(!e)return t;if(!t)return e;var n={};u(n,t);for(var r in e){var i=n[r],o=e[r];i&&!Array.isArray(i)&&(i=[i]),n[r]=i?i.concat(o):[o]}return n},Kn.props=Kn.methods=Kn.computed=function(t,e){if(!e)return t;if(!t)return e;var n=Object.create(null);return u(n,t),u(n,e),n};var Wn=function(t,e){return void 0===e?t:e},Jn=Object.freeze({defineReactive:T,_toString:t,toNumber:e,makeMap:n,isBuiltInTag:Xe,remove:r,hasOwn:i,isPrimitive:o,cached:a,camelize:en,capitalize:nn,hyphenate:on,bind:s,toArray:c,extend:u,isObject:l,isPlainObject:f,toObject:d,noop:p,no:cn,genStaticKeys:v,looseEqual:h,looseIndexOf:m,isReserved:_,def:y,parsePath:g,hasProto:fn,inBrowser:dn,UA:pn,isIE:vn,isIE9:hn,isEdge:mn,isAndroid:_n,isIOS:yn,devtools:gn,nextTick:bn,get _Set(){return Qe},mergeOptions:Tt,resolveAsset:Et,warn:qn,formatComponentName:Fn,validateProp:Dt}),Gn={name:"keep-alive",abstract:!0,created:function(){this.cache=Object.create(null)},render:function(){var t=Y(this.$slots.default);if(t&&t.componentOptions){var e=t.componentOptions,n=null==t.key?e.Ctor.cid+"::"+e.tag:t.key;this.cache[n]?t.child=this.cache[n].child:this.cache[n]=t,t.data.keepAlive=!0}return t},destroyed:function(){var t=this;for(var e in this.cache){var n=t.cache[e];nt(n.child,"deactivated"),n.child.$destroy()}}},Zn={KeepAlive:Gn};Rt($t),Object.defineProperty($t.prototype,"$isServer",{get:function(){return un._isServer}}),$t.version="2.0.3";var Qn,Xn=n("value,selected,checked,muted"),Yn=n("contenteditable,draggable,spellcheck"),tr=n("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),er="http://www.w3.org/1999/xlink",nr=function(t){return":"===t.charAt(5)&&"xlink"===t.slice(0,5)},rr=function(t){return nr(t)?t.slice(6,t.length):""},ir=function(t){return null==t||t===!1},or={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ar=n("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template"),sr=n("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),cr=function(t){return ar(t)||sr(t)},ur=Object.create(null),lr=Object.freeze({createElement:Gt,createElementNS:Zt,createTextNode:Qt,createComment:Xt,insertBefore:Yt,removeChild:te,appendChild:ee,parentNode:ne,nextSibling:re,tagName:ie,setTextContent:oe,childNodes:ae,setAttribute:se}),fr={create:function(t,e){ce(e)},update:function(t,e){t.data.ref!==e.data.ref&&(ce(t,!0),ce(e))},destroy:function(t){ce(t,!0)}},dr=new Bn("",{},[]),pr=["create","update","remove","destroy"],vr={create:ve,update:ve,destroy:function(t){ve(t,dr)}},hr=Object.create(null),mr=[fr,vr],_r={create:ye,update:ye},yr={create:be,update:be},gr={create:Ce,update:Ce},br={create:we,update:we},Cr=["Webkit","Moz","ms"],wr=a(function(t){if(Qn=Qn||document.createElement("div"),t=en(t),"filter"!==t&&t in Qn.style)return t;for(var e=t.charAt(0).toUpperCase()+t.slice(1),n=0;n<Cr.length;n++){var r=Cr[n]+e;if(r in Qn.style)return r}}),$r={create:$e,update:$e},Ar=dn&&!hn,kr="transition",xr="animation",Or="transition",Sr="transitionend",jr="animation",Tr="animationend";Ar&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Or="WebkitTransition",Sr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(jr="WebkitAnimation",Tr="webkitAnimationEnd"));var Er=dn&&window.requestAnimationFrame||setTimeout,Dr=/\b(transform|all)(,|$)/,Lr=a(function(t){return{enterClass:t+"-enter",leaveClass:t+"-leave",appearClass:t+"-enter",enterActiveClass:t+"-enter-active",leaveActiveClass:t+"-leave-active",appearActiveClass:t+"-enter-active"}}),Nr=dn?{create:function(t,e){e.data.show||Le(e)},remove:function(t,e){t.data.show?e():Ne(t,e)}}:{},Pr=[_r,yr,gr,br,$r,Nr],Mr=Pr.concat(mr),Ir=pe({nodeOps:lr,modules:Mr});hn&&document.addEventListener("selectionchange",function(){var t=document.activeElement;t&&t.vmodel&&He(t,"input")});var Br={inserted:function(t,e,n){if("select"===n.tag){var r=function(){Ie(t,e,n.context)};r(),(vn||mn)&&setTimeout(r,0)}else"textarea"!==n.tag&&"text"!==t.type||e.modifiers.lazy||(_n||(t.addEventListener("compositionstart",Re),t.addEventListener("compositionend",Ve)),hn&&(t.vmodel=!0))},componentUpdated:function(t,e,n){if("select"===n.tag){Ie(t,e,n.context);var r=t.multiple?e.value.some(function(e){return Be(e,t.options)}):e.value!==e.oldValue&&Be(e.value,t.options);r&&He(t,"change")}}},Ur={bind:function(t,e,n){var r=e.value;n=ze(n);var i=n.data&&n.data.transition;r&&i&&!hn&&Le(n);var o="none"===t.style.display?"":t.style.display;t.style.display=r?o:"none",t.__vOriginalDisplay=o},update:function(t,e,n){var r=e.value,i=e.oldValue;if(r!==i){n=ze(n);var o=n.data&&n.data.transition;o&&!hn?r?(Le(n),t.style.display=t.__vOriginalDisplay):Ne(n,function(){t.style.display="none"}):t.style.display=r?t.__vOriginalDisplay:"none"}}},Rr={model:Br,show:Ur},Vr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String},Hr={name:"transition",props:Vr,abstract:!0,render:function(t){var e=this,n=this.$slots.default;if(n&&(n=n.filter(function(t){return t.tag}),n.length)){var r=this.mode,i=n[0];if(We(this.$vnode))return i;var o=Fe(i);if(!o)return i;if(this._leaving)return Ke(t,i);var a=o.key=null==o.key||o.isStatic?"__v"+(o.tag+this._uid)+"__":o.key,s=(o.data||(o.data={})).transition=qe(this),c=this._vnode,l=Fe(c);if(o.data.directives&&o.data.directives.some(function(t){return"show"===t.name})&&(o.data.show=!0),l&&l.data&&l.key!==a){var f=l.data.transition=u({},s);if("out-in"===r)return this._leaving=!0,K(f,"afterLeave",function(){e._leaving=!1,e.$forceUpdate()},a),Ke(t,i);if("in-out"===r){var d,p=function(){d()};K(s,"afterEnter",p,a),K(s,"enterCancelled",p,a),K(f,"delayLeave",function(t){d=t},a)}}return i}}},zr=u({tag:String,moveClass:String},Vr);delete zr.mode;var Fr={props:zr,render:function(t){for(var e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=qe(this),s=0;s<i.length;s++){var c=i[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(o.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var d=r[f];d.data.transition=a,d.data.pos=d.elm.getBoundingClientRect(),n[d.key]?u.push(d):l.push(d)}this.kept=t(e,null,u),this.removed=l}return t(e,null,o)},beforeUpdate:function(){this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept},updated:function(){var t=this.prevChildren,e=this.moveClass||this.name+"-move";if(t.length&&this.hasMove(t[0].elm,e)){t.forEach(Je),t.forEach(Ge),t.forEach(Ze);document.body.offsetHeight;t.forEach(function(t){if(t.data.moved){var n=t.elm,r=n.style;Oe(n,e),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Sr,n._moveCb=function t(r){r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Sr,t),n._moveCb=null,Se(n,e))})}})}},methods:{hasMove:function(t,e){if(!Ar)return!1;if(null!=this._hasMove)return this._hasMove;Oe(t,e);var n=Te(t);return Se(t,e),this._hasMove=n.hasTransform}}},qr={Transition:Hr,TransitionGroup:Fr};return $t.config.isUnknownElement=Wt,$t.config.isReservedTag=cr,$t.config.getTagNamespace=Kt,$t.config.mustUseProp=Xn,u($t.options.directives,Rr),u($t.options.components,qr),$t.prototype.__patch__=un._isServer?p:Ir,$t.prototype.$mount=function(t,e){return t=t&&!un._isServer?Jt(t):void 0,this._mount(t,e)},setTimeout(function(){un.devtools&&gn&&gn.emit("init",$t)},0),$t});
\ No newline at end of file
Index: public/node_modules/vue-select2/test/specs/vue-select.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/test/specs/vue-select.js	(revision )
+++ public/node_modules/vue-select2/test/specs/vue-select.js	(revision )
@@ -0,0 +1,420 @@
+var assert = require("assert");
+var Vue = require("vue");
+var Demo = require("../../demo/demo.vue");
+var VueI18n = require("../../lib/vue-i18n-plugin/src/vue-i18n.js");
+var VueSelect = require("../../src/vue-select.js");
+
+var getVM = function(rootId, initResult1, initResult2, initResult3) {
+  return Vue.extend({
+    template: "<div><demo v-ref:demo :result1.sync='result1' :result2.sync='result2'  :result3.sync='result3'></demo></div>",
+    el: function() {
+      var el = document.createElement("div");
+      el.id = rootId;
+      document.body.appendChild(el);
+      return el;
+    },
+    components: {
+      "demo": Demo
+    },
+    data: function() {
+      return {
+        result1: initResult1,
+        result2: initResult2,
+        result3: initResult3
+      };
+    }
+  });
+};
+
+describe("vue-select", function() {
+
+  describe("static render", function() {
+    var VM = getVM("static-render", null, "value2", "value6");
+    var vm = new VM();
+
+    it("select1", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#static-render");
+        var select1 = root.find(".vue-select1");
+        assert.equal(select1.prop("tagName"), "SELECT");
+        assert.equal(select1.prop("name"), "select1");
+        var options1 = select1.find("option");
+        assert.equal(options1.length, 3);
+        assert.equal(options1[0].text, "value1");
+        assert.equal(options1[0].value, "value1");
+        assert.equal(options1[1].text, "value2");
+        assert.equal(options1[1].value, "value2");
+        assert.equal(options1[2].text, "value3");
+        assert.equal(options1[2].value, "value3");
+
+        // check the value of the select1
+        assert.equal(select1.val(), null);
+
+        // check the text content of select1
+        var select1Text = select1.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select1Text.text(), "");
+
+        //  check results
+        var result1 = root.find(".vue-result1");
+        assert.equal(result1.text(), "");
+
+        // check vm data
+        assert.equal(vm.result1, null);
+
+        done();
+      });
+    });
+
+    it("select2", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#static-render");
+        //  check select2
+        var select2 = root.find(".vue-select2");
+        assert.equal(select2.prop("tagName"), "SELECT");
+        assert.equal(select2.prop("name"), "select2");
+        var options2 = select2.find("option");
+        assert.equal(options2.length, 3);
+        assert.equal(options2[0].text, "name1");
+        assert.equal(options2[0].value, "value1");
+        assert.equal(options2[1].text, "name2");
+        assert.equal(options2[1].value, "value2");
+        assert.equal(options2[2].text, "name3");
+        assert.equal(options2[2].value, "value3");
+
+        // check the value of the select2
+        assert.equal(select2.val(), "value2");
+
+        // check the text content of select2
+        var select2Text = select2.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select2Text.text(), "name2");
+
+        //  check results
+        var result2 = root.find(".vue-result2");
+        assert.equal(result2.text(), "value2");
+
+        // check vm data
+        assert.equal(vm.result2, "value2");
+
+        done();
+      });
+    });
+
+    it("select3", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#static-render");
+        //  check select3
+        var select3 = root.find(".vue-select3");
+        assert.equal(select3.prop("tagName"), "SELECT");
+        assert.equal(select3.prop("name"), "select3");
+        var optgroups3 = select3.find("optgroup");
+        assert.equal(optgroups3.length, 2);
+        var options3_1 = $(optgroups3[0]).find("option");
+        assert.equal(options3_1.length, 3);
+        assert.equal(options3_1[0].text, "name1");
+        assert.equal(options3_1[0].value, "value1");
+        assert.equal(options3_1[1].text, "name2");
+        assert.equal(options3_1[1].value, "value2");
+        assert.equal(options3_1[2].text, "name3");
+        assert.equal(options3_1[2].value, "value3");
+
+        var options3_2 = $(optgroups3[1]).find("option");
+        assert.equal(options3_2.length, 3);
+        assert.equal(options3_2[0].text, "name4");
+        assert.equal(options3_2[0].value, "value4");
+        assert.equal(options3_2[1].text, "name5");
+        assert.equal(options3_2[1].value, "value5");
+        assert.equal(options3_2[2].text, "name6");
+        assert.equal(options3_2[2].value, "value6");
+
+        // check the value of the select3
+        assert.equal(select3.val(), "value6");
+
+        // check the text content of select1
+        var select3Text = select3.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select3Text.text(), "name6");
+
+        //  check results
+        var result3 = root.find(".vue-result3");
+        assert.equal(result3.text(), "value6");
+
+        // check vm data
+        assert.equal(vm.result3, "value6");
+
+        done();
+      });
+    });
+  });
+
+  describe("change the model", function() {
+    var VM = getVM("change-model", "", "value2", "value6");
+    var vm = new VM();
+    it("select1", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-model");
+        var select1 = root.find(".vue-select1");
+        var select1Text = select1.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select1.val(), null);
+        assert.equal(select1Text.text(), "");
+        // change the vm
+        vm.result1 = "value2";
+        vm.$nextTick(function() {
+          assert.equal(select1.val(), "value2");
+          assert.equal(select1Text.text(), "value2");
+          done();
+        });
+      });
+    });
+
+    it("select2", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-model");
+        var select2 = root.find(".vue-select2");
+        var select2Text = select2.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select2.val(), "value2");
+        assert.equal(select2Text.text(), "name2");
+        // change the vm
+        vm.result2 = "value1";
+        vm.$nextTick(function() {
+          assert.equal(select2.val(), "value1");
+          assert.equal(select2Text.text(), "name1");
+          // change the vm
+          vm.result2 = null;
+          vm.$nextTick(function() {
+            assert.equal(select2.val(), null);
+            assert.equal(select2Text.text(), "");
+            done();
+          });
+        });
+      });
+    });
+
+    it("select3", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-model");
+        var select3 = root.find(".vue-select3");
+        var select3Text = select3.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select3.val(), "value6");
+        assert.equal(select3Text.text(), "name6");
+        // change the vm
+        vm.result3 = "value3";
+        vm.$nextTick(function() {
+          assert.equal(select3.val(), "value3");
+          assert.equal(select3Text.text(), "name3");
+          done();
+        });
+      });
+    });
+  });
+
+  describe("change the selection", function() {
+    var VM = getVM("change-selection", "", "value2", "value6");
+    var vm = new VM();
+
+    it("select1", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-selection");
+        var select1 = root.find(".vue-select1");
+        var select1Text = select1.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select1.val(), null);
+        assert.equal(select1Text.text(), "");
+        // change the selection
+        select1.val("value2").trigger("change");
+        vm.$nextTick(function() {
+          assert.equal(select1.val(), "value2");
+          assert.equal(select1Text.text(), "value2");
+          assert.equal(vm.result1, "value2");
+          done();
+        });
+      });
+    });
+
+
+    it("select2", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-selection");
+        var select2 = root.find(".vue-select2");
+        var select2Text = select2.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select2.val(), "value2");
+        assert.equal(select2Text.text(), "name2");
+        // change the selection
+        select2.val("value3").trigger("change");
+        vm.$nextTick(function() {
+          assert.equal(select2.val(), "value3");
+          assert.equal(select2Text.text(), "name3");
+          assert.equal(vm.result2, "value3");
+          done();
+        });
+      });
+    });
+
+
+    it("select3", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-selection");
+        var select3 = root.find(".vue-select3");
+        var select3Text = select3.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select3.val(), "value6");
+        assert.equal(select3Text.text(), "name6");
+        // change the selection
+        select3.val("value4").trigger("change");
+        vm.$nextTick(function() {
+          assert.equal(select3.val(), "value4");
+          assert.equal(select3Text.text(), "name4");
+          assert.equal(vm.result3, "value4");
+          done();
+        });
+      });
+    });
+  });
+
+  describe("change the options", function() {
+    var VM = getVM("change-options", "value1", "value2", "value6");
+    var vm = new VM();
+
+    it("select1", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-options");
+        var select1 = root.find(".vue-select1");
+        var select1Text = select1.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select1Text.text(), "value1");
+        assert.equal(vm.result1, "value1");
+        var demo = vm.$refs.demo;
+        demo.options1 = ["val1", "val2", "val3", "val4"];
+        vm.$nextTick(function() {
+          var options1 = select1.find("option");
+          assert.equal(options1.length, 4);
+          assert.equal(options1[0].text, "val1");
+          assert.equal(options1[0].value, "val1");
+          assert.equal(options1[1].text, "val2");
+          assert.equal(options1[1].value, "val2");
+          assert.equal(options1[2].text, "val3");
+          assert.equal(options1[2].value, "val3");
+          assert.equal(options1[3].text, "val4");
+          assert.equal(options1[3].value, "val4");
+          assert.equal(select1Text.text(), "");
+          assert.equal(vm.result1, null);
+          done();
+        });
+      });
+    });
+
+    it("select2", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-options");
+        var select2 = root.find(".vue-select2");
+        var select2Text = select2.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select2Text.text(), "name2");
+        assert.equal(vm.result2, "value2");
+        var demo = vm.$refs.demo;
+        demo.options2 = [{
+          text: "item1",
+          value: "value1"
+        }, {
+          text: "item2",
+          value: "value2"
+        }];
+        vm.$nextTick(function() {
+          var options2 = select2.find("option");
+          assert.equal(options2.length, 2);
+          assert.equal(options2[0].text, "item1");
+          assert.equal(options2[0].value, "value1");
+          assert.equal(options2[1].text, "item2");
+          assert.equal(options2[1].value, "value2");
+          assert.equal(select2Text.text(), "item2");
+          assert.equal(vm.result2, "value2");
+          done();
+        });
+      });
+    });
+
+    it("select3", function(done) {
+      vm.$nextTick(function() {
+        var root = $("#change-options");
+        var select3 = root.find(".vue-select3");
+        var select3Text = select3.next(".select2").find(".select2-selection__rendered");
+        assert.equal(select3Text.text(), "name6");
+        assert.equal(vm.result3, "value6");
+        var demo = vm.$refs.demo;
+        demo.options3.push({
+          label: "group3",
+          options: [{
+            text: "name7",
+            value: "value7"
+          }, {
+            text: "name8",
+            value: "value8"
+          }]
+        });
+        vm.$nextTick(function() {
+          var optgroups3 = select3.find("optgroup");
+          assert.equal(optgroups3.length, 3);
+          var options3_1 = $(optgroups3[0]).find("option");
+          assert.equal(options3_1.length, 3);
+          assert.equal(options3_1[0].text, "name1");
+          assert.equal(options3_1[0].value, "value1");
+          assert.equal(options3_1[1].text, "name2");
+          assert.equal(options3_1[1].value, "value2");
+          assert.equal(options3_1[2].text, "name3");
+          assert.equal(options3_1[2].value, "value3");
+          var options3_2 = $(optgroups3[1]).find("option");
+          assert.equal(options3_2.length, 3);
+          assert.equal(options3_2[0].text, "name4");
+          assert.equal(options3_2[0].value, "value4");
+          assert.equal(options3_2[1].text, "name5");
+          assert.equal(options3_2[1].value, "value5");
+          assert.equal(options3_2[2].text, "name6");
+          assert.equal(options3_2[2].value, "value6");
+          var options3_3 = $(optgroups3[2]).find("option");
+          assert.equal(options3_3.length, 2);
+          assert.equal(options3_3[0].text, "name7");
+          assert.equal(options3_3[0].value, "value7");
+          assert.equal(options3_3[1].text, "name8");
+          assert.equal(options3_3[1].value, "value8");
+          assert.equal(select3Text.text(), "name6");
+          assert.equal(vm.result3, "value6");
+          done();
+        });
+      });
+    });
+  });
+
+  // FIXME: I don't know how to get the options of a select2 control,
+  // so the following test cannot be performed.
+
+  // describe("test the i18n plugin", function() {
+  //   before(function() {
+  //     Vue.use(VueI18n, {
+  //       baseUrl: "/base/test/specs/i18n"
+  //     });
+  //   });
+  //   var VM = Vue.extend({
+  //     template: "<div><vue-select v-ref='select' options='{{options}}' model='{{@ result}}'></vue-select></div>",
+  //     el: function() {
+  //       var el = document.createElement("div");
+  //       el.id = "test-i18n";
+  //       document.body.appendChild(el);
+  //       return el;
+  //     },
+  //     components: {
+  //       "vue-select": VueSelect
+  //     },
+  //     data: function() {
+  //       return {
+  //         options: ["value1", "value2", "value3"],
+  //         result: null
+  //       };
+  //     },
+  //     beforeCompile: function() {
+  //       this.$setLanguage("zh-CN");
+  //     }
+  //   });
+  //   it.only("test language", function(done) {
+  //     var vm = new VM();
+  //     vm.$nextTick(function() {
+  //       var select = vm.$refs.select.control;
+  //       assert.equal(select.options.get("language"), "zh-CN");
+  //       done();
+  //     });
+  //   });
+  // });
+});
\ No newline at end of file
Index: public/node_modules/vue/src/platforms/web/util/style.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/util/style.js	(revision )
+++ public/node_modules/vue/src/platforms/web/util/style.js	(revision )
@@ -0,0 +1,69 @@
+/* @flow */
+
+import { cached, extend, toObject } from 'shared/util'
+
+export const parseStyleText = cached(function (cssText) {
+  const res = {}
+  const listDelimiter = /;(?![^(]*\))/g
+  const propertyDelimiter = /:(.+)/
+  cssText.split(listDelimiter).forEach(function (item) {
+    if (item) {
+      var tmp = item.split(propertyDelimiter)
+      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim())
+    }
+  })
+  return res
+})
+
+// merge static and dynamic style data on the same vnode
+function normalizeStyleData (data: VNodeData): ?Object {
+  const style = normalizeStyleBinding(data.style)
+  // static style is pre-processed into an object during compilation
+  // and is always a fresh object, so it's safe to merge into it
+  return data.staticStyle
+    ? extend(data.staticStyle, style)
+    : style
+}
+
+// normalize possible array / string values into Object
+export function normalizeStyleBinding (bindingStyle: any): ?Object {
+  if (Array.isArray(bindingStyle)) {
+    return toObject(bindingStyle)
+  }
+  if (typeof bindingStyle === 'string') {
+    return parseStyleText(bindingStyle)
+  }
+  return bindingStyle
+}
+
+/**
+ * parent component style should be after child's
+ * so that parent component's style could override it
+ */
+export function getStyle (vnode: VNode, checkChild: boolean): Object {
+  const res = {}
+  let styleData
+
+  if (checkChild) {
+    let childNode = vnode
+    while (childNode.componentInstance) {
+      childNode = childNode.componentInstance._vnode
+      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
+        extend(res, styleData)
+      }
+    }
+  }
+
+  if ((styleData = normalizeStyleData(vnode.data))) {
+    extend(res, styleData)
+  }
+
+  let parentNode = vnode
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
+      extend(res, styleData)
+    }
+  }
+  return res
+}
+
Index: public/node_modules/vue/src/server/create-bundle-renderer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/create-bundle-renderer.js	(revision )
+++ public/node_modules/vue/src/server/create-bundle-renderer.js	(revision )
@@ -0,0 +1,134 @@
+/* @flow */
+
+import { createBundleRunner } from './create-bundle-runner'
+import type { Renderer, RenderOptions } from './create-renderer'
+import { createSourceMapConsumers, rewriteErrorTrace } from './source-map-support'
+
+const fs = require('fs')
+const path = require('path')
+const PassThrough = require('stream').PassThrough
+
+const INVALID_MSG =
+  'Invalid server-rendering bundle format. Should be a string ' +
+  'or a bundle Object of type:\n\n' +
+`{
+  entry: string;
+  files: { [filename: string]: string; };
+  maps: { [filename: string]: string; };
+}\n`
+
+// The render bundle can either be a string (single bundled file)
+// or a bundle manifest object generated by vue-ssr-webpack-plugin.
+type RenderBundle = {
+  basedir?: string;
+  entry: string;
+  files: { [filename: string]: string; };
+  maps: { [filename: string]: string; };
+};
+
+export function createBundleRendererCreator (createRenderer: () => Renderer) {
+  return function createBundleRenderer (
+    bundle: string | RenderBundle,
+    rendererOptions?: RenderOptions
+  ) {
+    const renderer = createRenderer(rendererOptions)
+
+    let files, entry, maps
+    let basedir = rendererOptions && rendererOptions.basedir
+
+    // load bundle if given filepath
+    if (
+      typeof bundle === 'string' &&
+      /\.js(on)?$/.test(bundle) &&
+      path.isAbsolute(bundle)
+    ) {
+      if (fs.existsSync(bundle)) {
+        const isJSON = /\.json$/.test(bundle)
+        basedir = basedir || path.dirname(bundle)
+        bundle = fs.readFileSync(bundle, 'utf-8')
+        if (isJSON) {
+          try {
+            bundle = JSON.parse(bundle)
+          } catch (e) {
+            throw new Error(`Invalid JSON bundle file: ${bundle}`)
+          }
+        }
+      } else {
+        throw new Error(`Cannot locate bundle file: ${bundle}`)
+      }
+    }
+
+    if (typeof bundle === 'object') {
+      entry = bundle.entry
+      files = bundle.files
+      basedir = basedir || bundle.basedir
+      maps = createSourceMapConsumers(bundle.maps)
+      if (typeof entry !== 'string' || typeof files !== 'object') {
+        throw new Error(INVALID_MSG)
+      }
+    } else if (typeof bundle === 'string') {
+      entry = '__vue_ssr_bundle__'
+      files = { '__vue_ssr_bundle__': bundle }
+      maps = {}
+    } else {
+      throw new Error(INVALID_MSG)
+    }
+
+    const run = createBundleRunner(entry, files, basedir)
+
+    return {
+      renderToString: (context?: Object, cb: (err: ?Error, res: ?string) => void) => {
+        if (typeof context === 'function') {
+          cb = context
+          context = {}
+        }
+        run(context).catch(err => {
+          rewriteErrorTrace(err, maps)
+          cb(err)
+        }).then(app => {
+          if (app) {
+            renderer.renderToString(app, (err, res) => {
+              rewriteErrorTrace(err, maps)
+              cb(err, res)
+            }, context)
+          }
+        })
+      },
+
+      renderToStream: (context?: Object) => {
+        const res = new PassThrough()
+        run(context).catch(err => {
+          rewriteErrorTrace(err, maps)
+          // avoid emitting synchronously before user can
+          // attach error listener
+          process.nextTick(() => {
+            res.emit('error', err)
+          })
+        }).then(app => {
+          if (app) {
+            const renderStream = renderer.renderToStream(app, context)
+
+            renderStream.on('error', err => {
+              rewriteErrorTrace(err, maps)
+              res.emit('error', err)
+            })
+
+            // relay HTMLStream special events
+            if (rendererOptions && rendererOptions.template) {
+              renderStream.on('beforeStart', () => {
+                res.emit('beforeStart')
+              })
+              renderStream.on('beforeEnd', () => {
+                res.emit('beforeEnd')
+              })
+            }
+
+            renderStream.pipe(res)
+          }
+        })
+
+        return res
+      }
+    }
+  }
+}
Index: public/node_modules/vue-resource/src/http/interceptor/jsonp.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/interceptor/jsonp.js	(revision )
+++ public/node_modules/vue-resource/src/http/interceptor/jsonp.js	(revision )
@@ -0,0 +1,14 @@
+/**
+ * JSONP Interceptor.
+ */
+
+import jsonpClient from '../client/jsonp';
+
+export default function (request, next) {
+
+    if (request.method == 'JSONP') {
+        request.client = jsonpClient;
+    }
+
+    next();
+}
Index: public/node_modules/vue/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/README.md	(revision )
+++ public/node_modules/vue/README.md	(revision )
@@ -0,0 +1,105 @@
+<p align="center"><a href="https://vuejs.org" target="_blank"><img width="100"src="https://vuejs.org/images/logo.png"></a></p>
+
+<p align="center">
+  <a href="https://circleci.com/gh/vuejs/vue/tree/dev"><img src="https://img.shields.io/circleci/project/vuejs/vue/dev.svg" alt="Build Status"></a>
+  <a href="https://codecov.io/github/vuejs/vue?branch=dev"><img src="https://img.shields.io/codecov/c/github/vuejs/vue/dev.svg" alt="Coverage Status"></a>
+  <a href="https://www.npmjs.com/package/vue"><img src="https://img.shields.io/npm/dt/vue.svg" alt="Downloads"></a>
+  <a href="https://www.npmjs.com/package/vue"><img src="https://img.shields.io/npm/v/vue.svg" alt="Version"></a>
+  <a href="https://www.npmjs.com/package/vue"><img src="https://img.shields.io/npm/l/vue.svg" alt="License"></a>
+  <br>
+  <a href="https://saucelabs.com/u/vuejs"><img src="https://saucelabs.com/browser-matrix/vuejs.svg" alt="Sauce Test Status"></a>
+</p>
+
+## Supporting Vue.js
+
+Vue.js is an MIT-licensed open source project. Its ongoing development is made possible thanks to the support by these awesome [backers](https://github.com/vuejs/vue/blob/dev/BACKERS.md). If you'd like to join them, check out [Vue.js' Patreon campaign](https://www.patreon.com/evanyou).
+
+<p align="center">
+  <b>Special thanks to the generous sponsorship by:</b>
+  <br><br>
+  <a href="http://www.thedifferenceengine.io/">
+    <img width="300px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/tde.png">
+  </a>
+  <br><br>
+  <a href="https://jsfiddle.net/">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/jsfiddle.png">
+  </a>
+  <br><br>
+  <a href="https://laravel.com/">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/laravel.png">
+  </a>
+  <br><br>
+  <a href="https://chaitin.cn/">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/chaitin.png">
+  </a>
+  <br><br>
+  <a href="https://htmlburger.com/">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/htmlburger.png">
+  </a>
+  <br><br>
+  <a href="https://starter.someline.com/">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/someline.png">
+  </a>
+  <br><br>
+  <a href="http://monterail.com/" target="_blank">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/monterail.png">
+  </a>
+  <br><br>
+  <a href="https://www.trisoft.ro/" target="_blank">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/trisoft.png">
+  </a>
+  <br><br>
+  <a href="https://www.2mhost.com/" target="_blank">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/2mhost.png">
+  </a>
+  <br><br>
+  <a href="https://vuejsjob.com/?ref=vuejs" target="_blank">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/vuejobs.png">
+  </a>
+  <br><br>
+  <a href="https://leanpub.com/vuejs2" target="_blank">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/tmvuejs2.png">
+  </a>
+  <br><br>
+  <a href="https://stdlib.com/" target="_blank">
+    <img width="120px" src="https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/stdlib.png">
+  </a>
+</p>
+
+## Intro
+
+Vue.js is a library for building interactive web interfaces. It provides data-reactive components with a simple and flexible API. Core features include:
+
+- [Declarative rendering with a plain JavaScript object based reactivity system.](https://vuejs.org/guide/index.html#Declarative-Rendering)
+- [Component-oriented development style with tooling support](https://vuejs.org/guide/index.html#Composing-with-Components)
+- Lean and extensible core
+- [Flexible transition effect system](https://vuejs.org/guide/transitions.html)
+- Fast without the need for complex optimization
+
+Note that Vue.js only supports [ES5-compliant browsers](http://kangax.github.io/compat-table/es5/) (IE8 and below are not supported). To check out live examples and docs, visit [vuejs.org](https://vuejs.org).
+
+## Questions
+
+For questions and support please use the [Gitter chat room](https://gitter.im/vuejs/vue) or [the official forum](http://forum.vuejs.org). The issue list of this repo is **exclusively** for bug reports and feature requests.
+
+## Issues
+
+Please make sure to read the [Issue Reporting Checklist](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#issue-reporting-guidelines) before opening an issue. Issues not conforming to the guidelines may be closed immediately.
+
+## Contribution
+
+Please make sure to read the [Contributing Guide](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md) before making a pull request. If you have a Vue-related project/component/tool, add it with a pull-request to [this curated list](https://github.com/vuejs/awesome-vue)!
+
+## Changelog
+
+Details changes for each release are documented in the [release notes](https://github.com/vuejs/vue/releases).
+
+## Stay In Touch
+
+- For latest releases and announcements, follow on Twitter: [@vuejs](https://twitter.com/vuejs)
+
+## License
+
+[MIT](http://opensource.org/licenses/MIT)
+
+Copyright (c) 2013-present, Yuxi (Evan) You
Index: public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/test.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/test.js	(revision )
@@ -0,0 +1,99 @@
+var test = require('tape')
+var SafeBuffer = require('./').Buffer
+
+test('new SafeBuffer(value) works just like Buffer', function (t) {
+  t.deepEqual(new SafeBuffer('hey'), new Buffer('hey'))
+  t.deepEqual(new SafeBuffer('hey', 'utf8'), new Buffer('hey', 'utf8'))
+  t.deepEqual(new SafeBuffer('686579', 'hex'), new Buffer('686579', 'hex'))
+  t.deepEqual(new SafeBuffer([1, 2, 3]), new Buffer([1, 2, 3]))
+  t.deepEqual(new SafeBuffer(new Uint8Array([1, 2, 3])), new Buffer(new Uint8Array([1, 2, 3])))
+
+  t.equal(typeof SafeBuffer.isBuffer, 'function')
+  t.equal(SafeBuffer.isBuffer(new SafeBuffer('hey')), true)
+  t.equal(Buffer.isBuffer(new SafeBuffer('hey')), true)
+  t.notOk(SafeBuffer.isBuffer({}))
+
+  t.end()
+})
+
+test('SafeBuffer.from(value) converts to a Buffer', function (t) {
+  t.deepEqual(SafeBuffer.from('hey'), new Buffer('hey'))
+  t.deepEqual(SafeBuffer.from('hey', 'utf8'), new Buffer('hey', 'utf8'))
+  t.deepEqual(SafeBuffer.from('686579', 'hex'), new Buffer('686579', 'hex'))
+  t.deepEqual(SafeBuffer.from([1, 2, 3]), new Buffer([1, 2, 3]))
+  t.deepEqual(SafeBuffer.from(new Uint8Array([1, 2, 3])), new Buffer(new Uint8Array([1, 2, 3])))
+
+  t.end()
+})
+
+test('SafeBuffer.alloc(number) returns zeroed-out memory', function (t) {
+  for (var i = 0; i < 10; i++) {
+    var expected1 = new Buffer(1000)
+    expected1.fill(0)
+    t.deepEqual(SafeBuffer.alloc(1000), expected1)
+
+    var expected2 = new Buffer(1000 * 1000)
+    expected2.fill(0)
+    t.deepEqual(SafeBuffer.alloc(1000 * 1000), expected2)
+  }
+  t.end()
+})
+
+test('SafeBuffer.allocUnsafe(number)', function (t) {
+  var buf = SafeBuffer.allocUnsafe(100) // unitialized memory
+  t.equal(buf.length, 100)
+  t.equal(SafeBuffer.isBuffer(buf), true)
+  t.equal(Buffer.isBuffer(buf), true)
+  t.end()
+})
+
+test('SafeBuffer.from() throws with number types', function (t) {
+  t.plan(5)
+  t.throws(function () {
+    SafeBuffer.from(0)
+  })
+  t.throws(function () {
+    SafeBuffer.from(-1)
+  })
+  t.throws(function () {
+    SafeBuffer.from(NaN)
+  })
+  t.throws(function () {
+    SafeBuffer.from(Infinity)
+  })
+  t.throws(function () {
+    SafeBuffer.from(99)
+  })
+})
+
+test('SafeBuffer.allocUnsafe() throws with non-number types', function (t) {
+  t.plan(4)
+  t.throws(function () {
+    SafeBuffer.allocUnsafe('hey')
+  })
+  t.throws(function () {
+    SafeBuffer.allocUnsafe('hey', 'utf8')
+  })
+  t.throws(function () {
+    SafeBuffer.allocUnsafe([1, 2, 3])
+  })
+  t.throws(function () {
+    SafeBuffer.allocUnsafe({})
+  })
+})
+
+test('SafeBuffer.alloc() throws with non-number types', function (t) {
+  t.plan(4)
+  t.throws(function () {
+    SafeBuffer.alloc('hey')
+  })
+  t.throws(function () {
+    SafeBuffer.alloc('hey', 'utf8')
+  })
+  t.throws(function () {
+    SafeBuffer.alloc([1, 2, 3])
+  })
+  t.throws(function () {
+    SafeBuffer.alloc({})
+  })
+})
Index: public/node_modules/vue/src/platforms/web/runtime/transition-util.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/transition-util.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/transition-util.js	(revision )
@@ -0,0 +1,178 @@
+/* @flow */
+
+import { inBrowser, isIE9 } from 'core/util/index'
+import { addClass, removeClass } from './class-util'
+import { remove, extend, cached } from 'shared/util'
+
+export function resolveTransition (def?: string | Object): ?Object {
+  if (!def) {
+    return
+  }
+  /* istanbul ignore else */
+  if (typeof def === 'object') {
+    const res = {}
+    if (def.css !== false) {
+      extend(res, autoCssTransition(def.name || 'v'))
+    }
+    extend(res, def)
+    return res
+  } else if (typeof def === 'string') {
+    return autoCssTransition(def)
+  }
+}
+
+const autoCssTransition: (name: string) => Object = cached(name => {
+  return {
+    enterClass: `${name}-enter`,
+    enterToClass: `${name}-enter-to`,
+    enterActiveClass: `${name}-enter-active`,
+    leaveClass: `${name}-leave`,
+    leaveToClass: `${name}-leave-to`,
+    leaveActiveClass: `${name}-leave-active`
+  }
+})
+
+export const hasTransition = inBrowser && !isIE9
+const TRANSITION = 'transition'
+const ANIMATION = 'animation'
+
+// Transition property/event sniffing
+export let transitionProp = 'transition'
+export let transitionEndEvent = 'transitionend'
+export let animationProp = 'animation'
+export let animationEndEvent = 'animationend'
+if (hasTransition) {
+  /* istanbul ignore if */
+  if (window.ontransitionend === undefined &&
+    window.onwebkittransitionend !== undefined) {
+    transitionProp = 'WebkitTransition'
+    transitionEndEvent = 'webkitTransitionEnd'
+  }
+  if (window.onanimationend === undefined &&
+    window.onwebkitanimationend !== undefined) {
+    animationProp = 'WebkitAnimation'
+    animationEndEvent = 'webkitAnimationEnd'
+  }
+}
+
+// binding to window is necessary to make hot reload work in IE in strict mode
+const raf = inBrowser && window.requestAnimationFrame
+  ? window.requestAnimationFrame.bind(window)
+  : setTimeout
+
+export function nextFrame (fn: Function) {
+  raf(() => {
+    raf(fn)
+  })
+}
+
+export function addTransitionClass (el: any, cls: string) {
+  (el._transitionClasses || (el._transitionClasses = [])).push(cls)
+  addClass(el, cls)
+}
+
+export function removeTransitionClass (el: any, cls: string) {
+  if (el._transitionClasses) {
+    remove(el._transitionClasses, cls)
+  }
+  removeClass(el, cls)
+}
+
+export function whenTransitionEnds (
+  el: Element,
+  expectedType: ?string,
+  cb: Function
+) {
+  const { type, timeout, propCount } = getTransitionInfo(el, expectedType)
+  if (!type) return cb()
+  const event: string = type === TRANSITION ? transitionEndEvent : animationEndEvent
+  let ended = 0
+  const end = () => {
+    el.removeEventListener(event, onEnd)
+    cb()
+  }
+  const onEnd = e => {
+    if (e.target === el) {
+      if (++ended >= propCount) {
+        end()
+      }
+    }
+  }
+  setTimeout(() => {
+    if (ended < propCount) {
+      end()
+    }
+  }, timeout + 1)
+  el.addEventListener(event, onEnd)
+}
+
+const transformRE = /\b(transform|all)(,|$)/
+
+export function getTransitionInfo (el: Element, expectedType?: ?string): {
+  type: ?string;
+  propCount: number;
+  timeout: number;
+  hasTransform: boolean;
+} {
+  const styles: any = window.getComputedStyle(el)
+  const transitionDelays: Array<string> = styles[transitionProp + 'Delay'].split(', ')
+  const transitionDurations: Array<string> = styles[transitionProp + 'Duration'].split(', ')
+  const transitionTimeout: number = getTimeout(transitionDelays, transitionDurations)
+  const animationDelays: Array<string> = styles[animationProp + 'Delay'].split(', ')
+  const animationDurations: Array<string> = styles[animationProp + 'Duration'].split(', ')
+  const animationTimeout: number = getTimeout(animationDelays, animationDurations)
+
+  let type: ?string
+  let timeout = 0
+  let propCount = 0
+  /* istanbul ignore if */
+  if (expectedType === TRANSITION) {
+    if (transitionTimeout > 0) {
+      type = TRANSITION
+      timeout = transitionTimeout
+      propCount = transitionDurations.length
+    }
+  } else if (expectedType === ANIMATION) {
+    if (animationTimeout > 0) {
+      type = ANIMATION
+      timeout = animationTimeout
+      propCount = animationDurations.length
+    }
+  } else {
+    timeout = Math.max(transitionTimeout, animationTimeout)
+    type = timeout > 0
+      ? transitionTimeout > animationTimeout
+        ? TRANSITION
+        : ANIMATION
+      : null
+    propCount = type
+      ? type === TRANSITION
+        ? transitionDurations.length
+        : animationDurations.length
+      : 0
+  }
+  const hasTransform: boolean =
+    type === TRANSITION &&
+    transformRE.test(styles[transitionProp + 'Property'])
+  return {
+    type,
+    timeout,
+    propCount,
+    hasTransform
+  }
+}
+
+function getTimeout (delays: Array<string>, durations: Array<string>): number {
+  /* istanbul ignore next */
+  while (delays.length < durations.length) {
+    delays = delays.concat(delays)
+  }
+
+  return Math.max.apply(null, durations.map((d, i) => {
+    return toMs(d) + toMs(delays[i])
+  }))
+}
+
+function toMs (s: string): number {
+  return Number(s.slice(0, -1)) * 1000
+}
Index: public/node_modules/vue/src/core/global-api/extend.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/global-api/extend.js	(revision )
+++ public/node_modules/vue/src/core/global-api/extend.js	(revision )
@@ -0,0 +1,101 @@
+/* @flow */
+
+import config from '../config'
+import { warn, extend, mergeOptions } from '../util/index'
+import { defineComputed, proxy } from '../instance/state'
+
+export function initExtend (Vue: GlobalAPI) {
+  /**
+   * Each instance constructor, including Vue, has a unique
+   * cid. This enables us to create wrapped "child
+   * constructors" for prototypal inheritance and cache them.
+   */
+  Vue.cid = 0
+  let cid = 1
+
+  /**
+   * Class inheritance
+   */
+  Vue.extend = function (extendOptions: Object): Function {
+    extendOptions = extendOptions || {}
+    const Super = this
+    const SuperId = Super.cid
+    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
+    if (cachedCtors[SuperId]) {
+      return cachedCtors[SuperId]
+    }
+
+    const name = extendOptions.name || Super.options.name
+    if (process.env.NODE_ENV !== 'production') {
+      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+        warn(
+          'Invalid component name: "' + name + '". Component names ' +
+          'can only contain alphanumeric characters and the hyphen, ' +
+          'and must start with a letter.'
+        )
+      }
+    }
+
+    const Sub = function VueComponent (options) {
+      this._init(options)
+    }
+    Sub.prototype = Object.create(Super.prototype)
+    Sub.prototype.constructor = Sub
+    Sub.cid = cid++
+    Sub.options = mergeOptions(
+      Super.options,
+      extendOptions
+    )
+    Sub['super'] = Super
+
+    // For props and computed properties, we define the proxy getters on
+    // the Vue instances at extension time, on the extended prototype. This
+    // avoids Object.defineProperty calls for each instance created.
+    if (Sub.options.props) {
+      initProps(Sub)
+    }
+    if (Sub.options.computed) {
+      initComputed(Sub)
+    }
+
+    // allow further extension/mixin/plugin usage
+    Sub.extend = Super.extend
+    Sub.mixin = Super.mixin
+    Sub.use = Super.use
+
+    // create asset registers, so extended classes
+    // can have their private assets too.
+    config._assetTypes.forEach(function (type) {
+      Sub[type] = Super[type]
+    })
+    // enable recursive self-lookup
+    if (name) {
+      Sub.options.components[name] = Sub
+    }
+
+    // keep a reference to the super options at extension time.
+    // later at instantiation we can check if Super's options have
+    // been updated.
+    Sub.superOptions = Super.options
+    Sub.extendOptions = extendOptions
+    Sub.sealedOptions = extend({}, Sub.options)
+
+    // cache constructor
+    cachedCtors[SuperId] = Sub
+    return Sub
+  }
+}
+
+function initProps (Comp) {
+  const props = Comp.options.props
+  for (const key in props) {
+    proxy(Comp.prototype, `_props`, key)
+  }
+}
+
+function initComputed (Comp) {
+  const computed = Comp.options.computed
+  for (const key in computed) {
+    defineComputed(Comp.prototype, key, computed[key])
+  }
+}
Index: public/node_modules/vue-select2/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/package.json	(revision )
+++ public/node_modules/vue-select2/package.json	(revision )
@@ -0,0 +1,86 @@
+{
+  "name": "vue-select2",
+  "description": "A Vue.js component implementing the select control with the jQuery select2 plugin.",
+  "version": "0.2.6",
+  "author": {
+    "name": "Haixing Hu",
+    "email": "starfish.hu@gmail.com"
+  },
+  "homepage": "https://github.com/Haixing-Hu/vue-select",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git@github.com:Haixing-Hu/vue-select.git"
+  },
+  "bugs": {
+    "url": "https://github.com/Haixing-Hu/vue-select/issues"
+  },
+  "main": "dist/vue-select.min.js",
+  "configs": {
+    "directories": {
+      "dist": "dist",
+      "src": "src",
+      "test": "test",
+      "coverage": "coverage"
+    }
+  },
+  "scripts": {
+    "build": "bower install && gulp build",
+    "test": "bower install && gulp test:coveralls",
+    "coverage": "bower install && gulp test:coverage",
+    "coveralls": "bower install && gulp test:coveralls",
+    "ci": "bower install && gulp test:coveralls && gulp build"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "devDependencies": {
+    "bower": "^1.7.9",
+    "bower-update-all": "^0.1.2",
+    "del": "^2.2.0",
+    "run-sequence": "^1.2.1",
+    "bower-webpack-plugin": "^0.1.9",
+    "gulp": "^3.9.1",
+    "gulp-util": "^3.0.7",
+    "webpack": "^1.13.1",
+    "mocha": "^2.5.3",
+    "karma": "^0.13.22",
+    "karma-chrome-launcher": "^1.0.1",
+    "karma-safari-launcher": "^1.0.0",
+    "karma-firefox-launcher": "^1.0.0",
+    "karma-phantomjs-launcher": "^1.0.0",
+    "karma-sauce-launcher": "^1.0.0",
+    "karma-mocha": "^1.0.1",
+    "karma-mocha-reporter": "^2.0.4",
+    "karma-coverage": "^1.0.0",
+    "karma-coveralls": "^1.1.2",
+    "karma-sourcemap-loader": "^0.3.7",
+    "karma-webpack": "^1.7.0",
+    "phantomjs-prebuilt": "^2.1.7",
+    "istanbul": "^0.4.3",
+    "istanbul-instrumenter-loader": "^0.2.0",
+    "vue": "^1.0.24",
+    "vue-loader": "^8.5.2",
+    "vue-html-loader": "^1.2.2",
+    "vue-style-loader": "^1.0.0",
+    "vue-hot-reload-api": "^1.2.0",
+    "raw-loader": "^0.5.1",
+    "html-loader": "^0.4.3",
+    "css-loader": "^0.23.1",
+    "file-loader": "^0.8.5",
+    "babel-loader": "^6.2.4",
+    "babel-core": "^6.8.0",
+    "babel-plugin-transform-runtime": "^6.8.0",
+    "babel-runtime": "^6.0.0",
+    "babel-preset-es2015": "^6.6.0",
+    "jquery": "^2.2.4"
+  },
+  "readme": "# vue-select\n\n[![Build Status](https://circleci.com/gh/Haixing-Hu/vue-select/tree/master.svg?style=shield)](https://circleci.com/gh/Haixing-Hu/vue-select/tree/master)\n[![Coverage Status](https://coveralls.io/repos/Haixing-Hu/vue-select/badge.svg?branch=master&service=github)](https://coveralls.io/github/Haixing-Hu/vue-select?branch=master)\n[![bitHound Score](https://www.bithound.io/github/Haixing-Hu/vue-select/badges/score.svg)](https://www.bithound.io/github/Haixing-Hu/vue-select)\n[![Dependency Status](https://david-dm.org/Haixing-Hu/vue-select.svg)](https://david-dm.org/Haixing-Hu/vue-select)\n[![devDependency Status](https://david-dm.org/Haixing-Hu/vue-select/dev-status.svg)](https://david-dm.org/Haixing-Hu/vue-select#info=devDependencies)\n\nA Vue.js component implementing the select control with the [jQuery select2 plugin](https://github.com/select2/select2).\n\n# Demo\n\nThe demo page is [HERE](http://haixing-hu.github.io/vue-select/demo.html).\n\n![Screenshot](screenshot.png)\n\n# Requirements\n\n- [Vue.js](https://github.com/yyx990803/vue) `^1.0.24`\n- [JQuery](https://github.com/jquery/jquery) `^2.2.4`\n- [Select2](https://github.com/select2/select2) `^4.0.3`\n\n# Instllation\n\n## npm\n\n```shell\n$ npm install vue-select2\n```\n\n## bower\n\n```shell\n$ bower install vue-select\n```\n\n# Usage\n\nThe HTML snippets are as follows:\n\n```html\n<div id=\"app\">\n  <div class=\"form-horizontal\">\n    <div class=\"form-group\">\n      <label for=\"select1\" class=\"col-sm-3 control-label\">\n        A simple select:\n      </label>\n      <div class=\"col-sm-5\">\n        <vue-select class=\"vue-select1\" name=\"select1\" :options=\"options1\" :model.sync=\"result1\">\n        </vue-select>\n      </div>\n      <div class=\"col-sm-4\">\n        <p class=\"form-control-static\">\n          Selected Result: <span class=\"vue-result1\">{{result1}}</span>\n        </p>\n      </div>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"select2\" class=\"col-sm-3 control-label\">\n        A searchable select with names and localized in en-US:\n      </label>\n      <div class=\"col-sm-5\">\n        <vue-select class=\"vue-select2\" name=\"select2\"\n                :options=\"options2\" :model.sync=\"result2\"\n                :searchable=\"true\" language=\"en-US\">\n        </vue-select>\n      </div>\n      <div class=\"col-sm-4\">\n        <p class=\"form-control-static\">\n          Selected Result: <span class=\"vue-result2\">{{result2}}</span>\n        </p>\n      </div>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"select3\" class=\"col-sm-3 control-label\">\n        A searchable select with groups and localized in zh-CN:\n      </label>\n      <div class=\"col-sm-5\">\n        <vue-select class=\"vue-select3\" name=\"select3\"\n                    :options=\"options3\" :model.sync=\"result3\"\n                    :searchable=\"true\" language=\"zh-CN\">\n        </vue-select>\n      </div>\n      <div class=\"col-sm-4\">\n        <p class=\"form-control-static\">\n          Selected Result: <span class=\"vue-result3\">{{result3}}</span>\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n```\n\nThe Javascript snippets are as follows:\n\n```javascript\nvar vm = new Vue({\n  el: \"#app\",\n  components: {\n    \"vue-select\": require(\"vue-select\")\n  },\n  data: {\n    options1: [\n      \"value1\",\n      \"value2\",\n      \"value3\"\n    ],\n    options2: [{\n      text: \"name1\",\n      value: \"value1\"\n    }, {\n      text: \"name2\",\n      value: \"value2\"\n    }, {\n      text: \"name3\",\n      value: \"value3\"\n    }],\n    options3: [{\n      label: \"group1\",\n      options: [{\n        text: \"name1\",\n        value: \"value1\"\n      }, {\n        text: \"name2\",\n        value: \"value2\"\n      }, {\n        text: \"name3\",\n        value: \"value3\"\n      }]\n    }, {\n      label: \"group2\",\n      options: [{\n        text: \"name4\",\n        value: \"value4\"\n      }, {\n        text: \"name5\",\n        value: \"value5\"\n      }, {\n        text: \"name6\",\n        value: \"value6\"\n      }]\n    }],\n    result1: \"\",\n    result2: \"\",\n    result3: \"\"\n  }\n});\n```\n\n# Component Properties\n\n## `options`\n\nThe array of options of the selection control. It could be\n\n- an array of strings, e.g., `['opt1', 'opt2']`; or\n- an array of objects specifying the text and value of each option, e.g.,\n  `[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]`; or\n- an array of objects specifying the option group, e.g.\n  ```\n  [{\n    label: 'group1',\n    options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]\n  }, {\n    label: 'group2',\n    options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]\n  }]\n  ```\n\n## `model`\n\nThe model bind to the control, which must be a two way binding variable.\n\nNote that the value of model could be set to `null`, and in that case the\nselection will be set to nothing. Also, if the selection is set to nothing\n(that is, the user delete the text in the input box of the selector), the\nvalue of the model will be set to `null` instead of an empty string.\n\n## `searchable`\n\nThe optional flag indicates whether to show the search box.\n\n## `language`\n\nThe optional code of language used by the\n[select2](https://github.com/select2/select2) plugin.\n\nThe supported languages are exactly the same as the supported languages of the\n[select2](https://github.com/select2/select2) plugin. In order to use the\nsupported language, you must also include the corresponding \"i18n\" js file of\nthe [select2](https://github.com/select2/select2) plugin in your HTML file.\n\nNote that the language code passed to this property could be a locale code\nconsists of a language code and a country code, e.g., `\"en-US\"`. The component\nwill automatically convert the locale code to the language code supported by\nthe [select2](https://github.com/select2/select2) plugin. Since some languages\nhave different variants in different country or region, e.g., `\"zh-CN\"` for the\nsimplified Chinese and `\"zh-TW\"` for the traditional Chinese, it's recommended\nto use the locale code in the form of `\"[language]-[country]\"`.\n\nIf this property is not set, and the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n)\nplugin is used, the component will use the language code `$language` provided\nby the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin; otherwise, the\ncomponent will use the default value `\"en-US\"`.\n\n## `theme`\n\nThe optional name of the theme of the [select2](https://github.com/select2/select2)\nplugin. Default value is `'bootstrap'`.\n\nNote that in order to use the bootstrap theme, you must include the CSS file\nfrom the [select2-bootstrap-theme](https://github.com/select2/select2-bootstrap-theme/) project.\nAnd it's very important that the above CSS file must be included AFTER the\nCSS file of the bootstrap.\n\nThe following is the correct order for including CSS files:\n\n```html\n<link rel=\"stylesheet\" type=\"text/css\" href=\"http://cdn.bootcss.com/select2/4.0.0/css/select2.css\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.css\">\n<link rel=\"stylesheet\" type=\"text/css\" href=\"https://select2.github.io/select2-bootstrap-theme/css/select2-bootstrap.css\">\n```\n\nCheck the [demo page](http://haixing-hu.github.io/vue-select/demo.html) for details.\n\n## `name`\n\nThe optional name of the selection control.\n\n# API\n\n## `control`\n\nThis property is a reference to the JQuery selection of the base select\ncontrol. It could be used to call the APIs of\n[select2](https://github.com/select2/select2) plugin. For example,\n`select.control.val(val)` will set the value of the select to the\nspecified value, where `select` is the reference to the `vue-select`\ncomponent.\n\n# Contributing\n\n- Fork it !\n- Create your top branch from `dev`: `git branch my-new-topic origin/dev`\n- Commit your changes: `git commit -am 'Add some topic'`\n- Push to the branch: `git push origin my-new-topic`\n- Submit a pull request to `dev` branch of `Haixing-Hu/vue-select` repository !\n\n# Building and Testing\n\nFirst you should install all depended NPM packages. The NPM packages are used\nfor building and testing this package.\n\n```shell\n$ npm install\n```\n\nThen install all depended bower packages. The bower packages are depended by\nthis packages.\n\n```shell\n$ bower install\n```\n\nNow you can build the project.\n```shell\n$ gulp build\n```\n\nThe following command will test the project.\n```shell\n$ gulp test\n```\n\nThe following command will perform the test and generate a coverage report.\n```shell\n$ gulp test:coverage\n```\n\nThe following command will perform the test, generate a coverage report, and\nupload the coverage report to [coveralls.io](https://coveralls.io/).\n```shell\n$ gulp test:coveralls\n```\n\nYou can also run `bower install` and `gulp build` together with the following\ncommand:\n```shell\nnpm run build\n```\n\nOr run `bower install` and `gulp test:coveralls` together with the following\ncommand:\n```shell\nnpm run test\n```\n\n# License\n\n[The MIT License](http://opensource.org/licenses/MIT)\n",
+  "readmeFilename": "README.md",
+  "_id": "vue-select2@0.2.6",
+  "dist": {
+    "shasum": "24b63dd590a6b134f71b883a0742ee8549a1142c"
+  },
+  "_from": "vue-select2@",
+  "_resolved": "https://registry.npmjs.org/vue-select2/-/vue-select2-0.2.6.tgz"
+}
Index: public/node_modules/vue/src/compiler/directives/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/directives/index.js	(revision )
+++ public/node_modules/vue/src/compiler/directives/index.js	(revision )
@@ -0,0 +1,9 @@
+/* @flow */
+
+import bind from './bind'
+import { noop } from 'shared/util'
+
+export default {
+  bind,
+  cloak: noop
+}
Index: public/node_modules/vue-select2/.bowerrc
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/.bowerrc	(revision )
+++ public/node_modules/vue-select2/.bowerrc	(revision )
@@ -0,0 +1,3 @@
+{
+    "directory": "lib"
+}
Index: public/node_modules/vue-resource/src/http/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/index.js	(revision )
+++ public/node_modules/vue-resource/src/http/index.js	(revision )
@@ -0,0 +1,70 @@
+/**
+ * Service for sending network requests.
+ */
+
+const COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
+const JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};
+
+import cors from './interceptor/cors';
+import body from './interceptor/body';
+import jsonp from './interceptor/jsonp';
+import before from './interceptor/before';
+import method from './interceptor/method';
+import header from './interceptor/header';
+import Client from './client/index';
+import Request from './request';
+import Promise from '../promise';
+import { assign, defaults, error } from '../util';
+
+export default function Http(options) {
+
+    var self = this || {}, client = Client(self.$vm);
+
+    defaults(options || {}, self.$options, Http.options);
+
+    Http.interceptors.forEach(handler => {
+        client.use(handler);
+    });
+
+    return client(new Request(options)).then(response => {
+
+        return response.ok ? response : Promise.reject(response);
+
+    }, response => {
+
+        if (response instanceof Error) {
+            error(response);
+        }
+
+        return Promise.reject(response);
+    });
+}
+
+Http.options = {};
+
+Http.headers = {
+    put: JSON_CONTENT_TYPE,
+    post: JSON_CONTENT_TYPE,
+    patch: JSON_CONTENT_TYPE,
+    delete: JSON_CONTENT_TYPE,
+    common: COMMON_HEADERS,
+    custom: {}
+};
+
+Http.interceptors = [before, method, body, jsonp, header, cors];
+
+['get', 'delete', 'head', 'jsonp'].forEach(method => {
+
+    Http[method] = function (url, options) {
+        return this(assign(options || {}, {url, method}));
+    };
+
+});
+
+['post', 'put', 'patch'].forEach(method => {
+
+    Http[method] = function (url, body, options) {
+        return this(assign(options || {}, {url, method, body}));
+    };
+
+});
Index: public/node_modules/vue/src/platforms/web/server/util.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/util.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/util.js	(revision )
@@ -0,0 +1,36 @@
+/* @flow */
+
+import { makeMap } from 'shared/util'
+
+const isAttr = makeMap(
+  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +
+  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +
+  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +
+  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +
+  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +
+  'form,formaction,headers,height,hidden,high,href,hreflang,http-equiv,' +
+  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +
+  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +
+  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +
+  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +
+  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +
+  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +
+  'target,title,type,usemap,value,width,wrap'
+)
+
+/* istanbul ignore next */
+const isRenderableAttr = (name: string): boolean => {
+  return (
+    isAttr(name) ||
+    name.indexOf('data-') === 0 ||
+    name.indexOf('aria-') === 0
+  )
+}
+export { isRenderableAttr }
+
+export const propsToAttrMap = {
+  acceptCharset: 'accept-charset',
+  className: 'class',
+  htmlFor: 'for',
+  httpEquiv: 'http-equiv'
+}
Index: public/node_modules/vue/src/core/util/lang.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/lang.js	(revision )
+++ public/node_modules/vue/src/core/util/lang.js	(revision )
@@ -0,0 +1,41 @@
+/* @flow */
+
+export const emptyObject = Object.freeze({})
+
+/**
+ * Check if a string starts with $ or _
+ */
+export function isReserved (str: string): boolean {
+  const c = (str + '').charCodeAt(0)
+  return c === 0x24 || c === 0x5F
+}
+
+/**
+ * Define a property.
+ */
+export function def (obj: Object, key: string, val: any, enumerable?: boolean) {
+  Object.defineProperty(obj, key, {
+    value: val,
+    enumerable: !!enumerable,
+    writable: true,
+    configurable: true
+  })
+}
+
+/**
+ * Parse simple path.
+ */
+const bailRE = /[^\w.$]/
+export function parsePath (path: string): any {
+  if (bailRE.test(path)) {
+    return
+  }
+  const segments = path.split('.')
+  return function (obj) {
+    for (let i = 0; i < segments.length; i++) {
+      if (!obj) return
+      obj = obj[segments[i]]
+    }
+    return obj
+  }
+}
Index: public/node_modules/vue-resource/src/url/query.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/url/query.js	(revision )
+++ public/node_modules/vue-resource/src/url/query.js	(revision )
@@ -0,0 +1,25 @@
+/**
+ * Query Parameter Transform.
+ */
+
+import Url from './index';
+import { each } from '../util';
+
+export default function (options, next) {
+
+    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options);
+
+    each(options.params, (value, key) => {
+        if (urlParams.indexOf(key) === -1) {
+            query[key] = value;
+        }
+    });
+
+    query = Url.params(query);
+
+    if (query) {
+        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
+    }
+
+    return url;
+}
Index: public/node_modules/vue-resource/src/http/interceptor/body.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/interceptor/body.js	(revision )
+++ public/node_modules/vue-resource/src/http/interceptor/body.js	(revision )
@@ -0,0 +1,66 @@
+/**
+ * Body Interceptor.
+ */
+
+import Url from '../../url/index';
+import { when, isArray, isObject, isFormData } from '../../util';
+
+export default function (request, next) {
+
+    if (isFormData(request.body)) {
+
+        request.headers.delete('Content-Type');
+
+    } else if (isObject(request.body) || isArray(request.body)) {
+
+        if (request.emulateJSON) {
+            request.body = Url.params(request.body);
+            request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
+        } else {
+            request.body = JSON.stringify(request.body);
+        }
+    }
+
+    next(response => {
+
+        Object.defineProperty(response, 'data', {
+
+            get() {
+                return this.body;
+            },
+
+            set(body) {
+                this.body = body;
+            }
+
+        });
+
+        return response.bodyText ? when(response.text(), text => {
+
+            var type = response.headers.get('Content-Type') || '';
+
+            if (type.indexOf('application/json') === 0 || isJson(text)) {
+
+                try {
+                    response.body = JSON.parse(text);
+                } catch (e) {
+                    response.body = null;
+                }
+
+            } else {
+                response.body = text;
+            }
+
+            return response;
+
+        }) : response;
+
+    });
+}
+
+function isJson(str) {
+
+    var start = str.match(/^\[|^\{(?!\{)/), end = {'[': /]$/, '{': /}$/};
+
+    return start && end[start[0]].test(str);
+}
Index: public/node_modules/vue/src/compiler/directives/bind.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/directives/bind.js	(revision )
+++ public/node_modules/vue/src/compiler/directives/bind.js	(revision )
@@ -0,0 +1,9 @@
+/* @flow */
+
+export default function bind (el: ASTElement, dir: ASTDirective) {
+  el.wrapData = (code: string) => {
+    return `_b(${code},'${el.tag}',${dir.value}${
+      dir.modifiers && dir.modifiers.prop ? ',true' : ''
+    })`
+  }
+}
Index: public/node_modules/vue-resource/src/http/interceptor/method.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/interceptor/method.js	(revision )
+++ public/node_modules/vue-resource/src/http/interceptor/method.js	(revision )
@@ -0,0 +1,13 @@
+/**
+ * HTTP method override Interceptor.
+ */
+
+export default function (request, next) {
+
+    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
+        request.headers.set('X-HTTP-Method-Override', request.method);
+        request.method = 'POST';
+    }
+
+    next();
+}
Index: public/node_modules/vue/src/platforms/web/compiler/modules/style.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/modules/style.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/modules/style.js	(revision )
@@ -0,0 +1,51 @@
+/* @flow */
+
+import { parseText } from 'compiler/parser/text-parser'
+import { parseStyleText } from 'web/util/style'
+import {
+  getAndRemoveAttr,
+  getBindingAttr,
+  baseWarn
+} from 'compiler/helpers'
+
+function transformNode (el: ASTElement, options: CompilerOptions) {
+  const warn = options.warn || baseWarn
+  const staticStyle = getAndRemoveAttr(el, 'style')
+  if (staticStyle) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      const expression = parseText(staticStyle, options.delimiters)
+      if (expression) {
+        warn(
+          `style="${staticStyle}": ` +
+          'Interpolation inside attributes has been removed. ' +
+          'Use v-bind or the colon shorthand instead. For example, ' +
+          'instead of <div style="{{ val }}">, use <div :style="val">.'
+        )
+      }
+    }
+    el.staticStyle = JSON.stringify(parseStyleText(staticStyle))
+  }
+
+  const styleBinding = getBindingAttr(el, 'style', false /* getStatic */)
+  if (styleBinding) {
+    el.styleBinding = styleBinding
+  }
+}
+
+function genData (el: ASTElement): string {
+  let data = ''
+  if (el.staticStyle) {
+    data += `staticStyle:${el.staticStyle},`
+  }
+  if (el.styleBinding) {
+    data += `style:(${el.styleBinding}),`
+  }
+  return data
+}
+
+export default {
+  staticKeys: ['staticStyle'],
+  transformNode,
+  genData
+}
Index: public/node_modules/vue/src/server/create-renderer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/create-renderer.js	(revision )
+++ public/node_modules/vue/src/server/create-renderer.js	(revision )
@@ -0,0 +1,83 @@
+/* @flow */
+
+const HTMLStream = require('vue-ssr-html-stream')
+
+import RenderStream from './render-stream'
+import { createWriteFunction } from './write'
+import { createRenderFunction } from './render'
+
+export type Renderer = {
+  renderToString: (component: Component, cb: (err: ?Error, res: ?string) => void) => void;
+  renderToStream: (component: Component) => stream$Readable;
+};
+
+type RenderCache = {
+  get: (key: string, cb?: Function) => string | void;
+  set: (key: string, val: string) => void;
+  has?: (key: string, cb?: Function) => boolean | void;
+};
+
+export type RenderOptions = {
+  modules?: Array<(vnode: VNode) => string>;
+  directives?: Object;
+  isUnaryTag?: Function;
+  cache?: RenderCache;
+  template?: string;
+  basedir?: string;
+};
+
+export function createRenderer ({
+  modules = [],
+  directives = {},
+  isUnaryTag = (() => false),
+  template,
+  cache
+}: RenderOptions = {}): Renderer {
+  const render = createRenderFunction(modules, directives, isUnaryTag, cache)
+  const parsedTemplate = template && HTMLStream.parseTemplate(template)
+
+  return {
+    renderToString (
+      component: Component,
+      done: (err: ?Error, res: ?string) => any,
+      context?: ?Object
+    ): void {
+      let result = ''
+      const write = createWriteFunction(text => {
+        result += text
+      }, done)
+      try {
+        render(component, write, () => {
+          if (parsedTemplate) {
+            result = HTMLStream.renderTemplate(parsedTemplate, result, context)
+          }
+          done(null, result)
+        })
+      } catch (e) {
+        done(e)
+      }
+    },
+
+    renderToStream (
+      component: Component,
+      context?: ?Object
+    ): stream$Readable {
+      const renderStream = new RenderStream((write, done) => {
+        render(component, write, done)
+      })
+      if (!parsedTemplate) {
+        return renderStream
+      } else {
+        const htmlStream = new HTMLStream({
+          template: parsedTemplate,
+          context
+        })
+        renderStream.on('error', err => {
+          htmlStream.emit('error', err)
+        })
+        renderStream.pipe(htmlStream)
+        return htmlStream
+      }
+    }
+  }
+}
Index: public/node_modules/vue/src/platforms/web/runtime/modules/attrs.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/modules/attrs.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/modules/attrs.js	(revision )
@@ -0,0 +1,79 @@
+/* @flow */
+
+import { extend } from 'shared/util'
+import { isIE9 } from 'core/util/env'
+import {
+  isBooleanAttr,
+  isEnumeratedAttr,
+  isXlink,
+  xlinkNS,
+  getXlinkProp,
+  isFalsyAttrValue
+} from 'web/util/index'
+
+function updateAttrs (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  let key, cur, old
+  const elm = vnode.elm
+  const oldAttrs = oldVnode.data.attrs || {}
+  let attrs: any = vnode.data.attrs || {}
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs)
+  }
+
+  for (key in attrs) {
+    cur = attrs[key]
+    old = oldAttrs[key]
+    if (old !== cur) {
+      setAttr(elm, key, cur)
+    }
+  }
+  // #4391: in IE9, setting type can reset value for input[type=radio]
+  /* istanbul ignore if */
+  if (isIE9 && attrs.value !== oldAttrs.value) {
+    setAttr(elm, 'value', attrs.value)
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      if (isXlink(key)) {
+        elm.removeAttributeNS(xlinkNS, getXlinkProp(key))
+      } else if (!isEnumeratedAttr(key)) {
+        elm.removeAttribute(key)
+      }
+    }
+  }
+}
+
+function setAttr (el: Element, key: string, value: any) {
+  if (isBooleanAttr(key)) {
+    // set attribute for blank value
+    // e.g. <option disabled>Select one</option>
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key)
+    } else {
+      el.setAttribute(key, key)
+    }
+  } else if (isEnumeratedAttr(key)) {
+    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true')
+  } else if (isXlink(key)) {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttributeNS(xlinkNS, getXlinkProp(key))
+    } else {
+      el.setAttributeNS(xlinkNS, key, value)
+    }
+  } else {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key)
+    } else {
+      el.setAttribute(key, value)
+    }
+  }
+}
+
+export default {
+  create: updateAttrs,
+  update: updateAttrs
+}
Index: public/node_modules/vue-select2/demo/webpack.config.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/demo/webpack.config.js	(revision )
+++ public/node_modules/vue-select2/demo/webpack.config.js	(revision )
@@ -0,0 +1,48 @@
+//  Configuration file of webpack
+var path = require("path");
+var webpack = require("webpack");
+var BowerWebpackPlugin = require("bower-webpack-plugin");
+var pkg = require("../package.json");
+var dirs = pkg.configs.directories;
+var version = process.env.VERSION || pkg.version;
+var banner = pkg.name + " v" + version + "\n" +
+  "(c) " + new Date().getFullYear() +
+  " " + pkg.author.name + "\n" +
+  "Released under the " + pkg.license + " License.";
+var VueLoader = require('vue-loader');
+
+module.exports = {
+  entry: {
+    "demo": path.join(__dirname, "demo.js")
+  },
+  module: {
+    loaders: [
+      { test: /\.vue$/, loader: "vue" }
+    ]
+  },
+  vue: {
+    loaders: {
+      html: "raw"    // use raw-loader to process HTML
+    }
+  },
+  resolve: {
+    root: [__dirname],
+    modulesDirectories: [ "lib" ]
+  },
+  plugins: [
+    // new webpack.optimize.DedupePlugin(),
+    new BowerWebpackPlugin({
+      modulesDirectories: [ "lib" ],
+      manifestFiles:      "bower.json",
+      includes:           /.*/,
+      excludes:           [],
+      searchResolveModulesDirectories: true
+    }),
+    new webpack.BannerPlugin(banner)
+  ],
+  output: {
+    path: __dirname,
+    filename: "[name].all.js",
+    sourceMapFilename: "[file].map"
+  },
+};
Index: public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/readme.md	(revision )
@@ -0,0 +1,100 @@
+# url-parse-lax [![Build Status](https://travis-ci.org/sindresorhus/url-parse-lax.svg?branch=master)](https://travis-ci.org/sindresorhus/url-parse-lax)
+
+> [`url.parse()`](https://nodejs.org/docs/latest/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost) with support for protocol-less URLs & IPs
+
+
+## Install
+
+```
+$ npm install --save url-parse-lax
+```
+
+
+## Usage
+
+```js
+var urlParseLax = require('url-parse-lax');
+
+urlParseLax('sindresorhus.com');
+/*
+{
+	protocol: null,
+	slashes: true,
+	auth: null,
+	host: 'sindresorhus.com',
+	port: null,
+	hostname: 'sindresorhus.com',
+	hash: null,
+	search: null,
+	query: null,
+	pathname: '/',
+	path: '/',
+	href: 'http://sindresorhus.com/'
+}
+*/
+
+urlParseLax('[2001:db8::]:8000');
+/*
+{
+	protocol: null,
+	slashes: true,
+	auth: null,
+	host: '[2001:db8::]:8000',
+	port: '8000',
+	hostname: '2001:db8::',
+	hash: null,
+	search: null,
+	query: null,
+	pathname: '/',
+	path: '/',
+	href: 'http://[2001:db8::]:8000/'
+}
+*/
+```
+
+And with the built-in `url.parse()`:
+
+```js
+var url = require('url');
+
+url.parse('sindresorhus.com');
+/*
+{
+	protocol: null,
+	slashes: null,
+	auth: null,
+	host: null,
+	port: null,
+	hostname: null,
+	hash: null,
+	search: null,
+	query: null,
+	pathname: 'sindresorhus',
+	path: 'sindresorhus',
+	href: 'sindresorhus'
+}
+*/
+
+url.parse('[2001:db8::]:8000');
+/*
+{
+	protocol: null,
+	slashes: null,
+	auth: null,
+	host: null,
+	port: null,
+	hostname: null,
+	hash: null,
+	search: null,
+	query: null,
+	pathname: '[2001:db8::]:8000',
+	path: '[2001:db8::]:8000',
+	href: '[2001:db8::]:8000'
+}
+*/
+```
+
+
+## License
+
+MIT  [Sindre Sorhus](http://sindresorhus.com)
Index: public/node_modules/vue/src/core/global-api/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/global-api/index.js	(revision )
+++ public/node_modules/vue/src/core/global-api/index.js	(revision )
@@ -0,0 +1,61 @@
+/* @flow */
+
+import config from '../config'
+import { initUse } from './use'
+import { initMixin } from './mixin'
+import { initExtend } from './extend'
+import { initAssetRegisters } from './assets'
+import { set, del } from '../observer/index'
+import builtInComponents from '../components/index'
+
+import {
+  warn,
+  extend,
+  nextTick,
+  mergeOptions,
+  defineReactive
+} from '../util/index'
+
+export function initGlobalAPI (Vue: GlobalAPI) {
+  // config
+  const configDef = {}
+  configDef.get = () => config
+  if (process.env.NODE_ENV !== 'production') {
+    configDef.set = () => {
+      warn(
+        'Do not replace the Vue.config object, set individual fields instead.'
+      )
+    }
+  }
+  Object.defineProperty(Vue, 'config', configDef)
+
+  // exposed util methods.
+  // NOTE: these are not considered part of the public API - avoid relying on
+  // them unless you are aware of the risk.
+  Vue.util = {
+    warn,
+    extend,
+    mergeOptions,
+    defineReactive
+  }
+
+  Vue.set = set
+  Vue.delete = del
+  Vue.nextTick = nextTick
+
+  Vue.options = Object.create(null)
+  config._assetTypes.forEach(type => {
+    Vue.options[type + 's'] = Object.create(null)
+  })
+
+  // this is used to identify the "base" constructor to extend all plain-object
+  // components with in Weex's multi-instance scenarios.
+  Vue.options._base = Vue
+
+  extend(Vue.options.components, builtInComponents)
+
+  initUse(Vue)
+  initMixin(Vue)
+  initExtend(Vue)
+  initAssetRegisters(Vue)
+}
Index: public/node_modules/vue-select2/demo/demo.vue
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/demo/demo.vue	(revision )
+++ public/node_modules/vue-select2/demo/demo.vue	(revision )
@@ -0,0 +1,118 @@
+<template>
+  <div class="form-horizontal">
+    <div class="form-group">
+      <label for="select1" class="col-sm-3 control-label">
+        A simple select:
+      </label>
+      <div class="col-sm-5">
+        <vue-select class="vue-select1" name="select1"
+                    :options="options1" :model.sync="result1"
+                    language="">
+        </vue-select>
+      </div>
+      <div class="col-sm-4">
+        <p class="form-control-static">
+          Selected Result: <span class="vue-result1">{{result1}}</span>
+        </p>
+      </div>
+    </div>
+    <div class="form-group">
+      <label for="select2" class="col-sm-3 control-label">
+        A searchable select with names and localized in en-US:
+      </label>
+      <div class="col-sm-5">
+        <vue-select class="vue-select2" name="select2"
+                :options="options2" :model.sync="result2"
+                :searchable="true" language="en-US">
+        </vue-select>
+      </div>
+      <div class="col-sm-4">
+        <p class="form-control-static">
+          Selected Result: <span class="vue-result2">{{result2}}</span>
+        </p>
+      </div>
+    </div>
+    <div class="form-group">
+      <label for="select3" class="col-sm-3 control-label">
+        A searchable select with groups and localized in zh-CN:
+      </label>
+      <div class="col-sm-5">
+        <vue-select class="vue-select3" name="select3"
+                    :options="options3" :model.sync="result3"
+                    :searchable="true" language="zh-CN">
+        </vue-select>
+      </div>
+      <div class="col-sm-4">
+        <p class="form-control-static">
+          Selected Result: <span class="vue-result3">{{result3}}</span>
+        </p>
+      </div>
+    </div>
+  </div>
+</template>
+
+<script>
+module.exports = {
+  components: {
+    "vue-select": require("../src/vue-select.js")
+  },
+  data: function() {
+    return {
+      options1: [
+        "value1",
+        "value2",
+        "value3"
+      ],
+      options2: [{
+        text: "name1",
+        value: "value1"
+      }, {
+        text: "name2",
+        value: "value2"
+      }, {
+        text: "name3",
+        value: "value3"
+      }],
+      options3: [{
+        label: "group1",
+        options: [{
+          text: "name1",
+          value: "value1"
+        }, {
+          text: "name2",
+          value: "value2"
+        }, {
+          text: "name3",
+          value: "value3"
+        }]
+      }, {
+        label: "group2",
+        options: [{
+          text: "name4",
+          value: "value4"
+        }, {
+          text: "name5",
+          value: "value5"
+        }, {
+          text: "name6",
+          value: "value6"
+        }]
+      }]
+    };
+  },
+  props: {
+    result1: {
+      required: true,
+      twoWay: true
+    },
+    result2: {
+      required: true,
+      twoWay: true
+    },
+    result3: {
+      required: true,
+      twoWay: true
+    }
+  }
+};
+</script>
\ No newline at end of file
Index: public/node_modules/vue/src/core/instance/inject.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/inject.js	(revision )
+++ public/node_modules/vue/src/core/instance/inject.js	(revision )
@@ -0,0 +1,39 @@
+/* @flow */
+
+import { hasSymbol } from 'core/util/env'
+
+export function initProvide (vm: Component) {
+  const provide = vm.$options.provide
+  if (provide) {
+    vm._provided = typeof provide === 'function'
+      ? provide.call(vm)
+      : provide
+  }
+}
+
+export function initInjections (vm: Component) {
+  const inject: any = vm.$options.inject
+  if (inject) {
+    // inject is :any because flow is not smart enough to figure out cached
+    // isArray here
+    const isArray = Array.isArray(inject)
+    const keys = isArray
+      ? inject
+      : hasSymbol
+        ? Reflect.ownKeys(inject)
+        : Object.keys(inject)
+
+    for (let i = 0; i < keys.length; i++) {
+      const key = keys[i]
+      const provideKey = isArray ? key : inject[key]
+      let source = vm
+      while (source) {
+        if (source._provided && provideKey in source._provided) {
+          vm[key] = source._provided[provideKey]
+          break
+        }
+        source = source.$parent
+      }
+    }
+  }
+}
Index: public/node_modules/vue-select2/karma.conf.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/karma.conf.js	(revision )
+++ public/node_modules/vue-select2/karma.conf.js	(revision )
@@ -0,0 +1,142 @@
+// Karma configuration
+var VueLoader = require('vue-loader');
+
+module.exports = function (config) {
+  var settings = {
+    // base path that will be used to resolve all patterns (eg. files, exclude)
+    basePath: '',
+
+    // frameworks to use
+    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter
+    frameworks: ['mocha'],
+
+    // list of files / patterns to load in the browser
+    files: [
+      "./lib/jquery/dist/jquery.min.js",
+      "./lib/select2/dist/js/select2.min.js",
+      "./test/specs/**/*.js",
+      {
+        pattern: "./test/specs/i18n/*.json",
+        watched: false,
+        included: false,
+        served: true
+      }
+    ],
+
+    // list of files to exclude
+    exclude: [
+    ],
+
+    // preprocess matching files before serving them to the browser
+    // available preprocessors: https://npmjs.org/browse/keyword/karma-preprocessor
+    preprocessors: {
+      "./test/**/*.js": ['webpack', 'sourcemap'],
+      "./demo/**/*.vue": ['webpack', 'sourcemap'],
+      "./src/**/*.js": ['webpack', 'sourcemap']
+    },
+
+    webpack: {
+      devtool: 'inline-source-map',
+      module: {
+        loaders: [{
+          test: /\.vue$/, loader: "vue"
+        }],
+        postLoaders: [{
+          test: /\.js$/,
+          exclude: /test|node_modules|lib|value-text-matcher.js/,
+          loader: 'istanbul-instrumenter'
+        }]
+      },
+      vue: {
+        loaders: {
+          html: "raw"    // use raw-loader to process HTML
+        }
+      }
+    },
+
+    webpackMiddleware: {
+      noInfo: true
+    },
+
+    // test results reporter to use
+    // possible values: 'dots', 'progress'
+    // available reporters: https://npmjs.org/browse/keyword/karma-reporter
+    /*
+    reporters: [
+      'mocha', 'coverage'
+    ],
+
+    coverageReporter: {
+      reporters: [{
+        type: 'html', dir: '../coverage'
+      }, {
+        type: 'lcov', dir: '../coverage'
+      }, {
+        type: 'text-summary', dir: '../coverage'
+      }]
+    },
+    */
+
+    // web server port
+    port: 9876,
+
+    // enable / disable colors in the output (reporters and logs)
+    colors: true,
+
+    // level of logging
+    // possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
+    logLevel: config.LOG_INFO,
+
+    // enable / disable watching file and executing tests whenever any file changes
+    autoWatch: true,
+
+    // Continuous Integration mode
+    // if true, Karma captures browsers, runs the tests and exits
+    singleRun: true
+  };
+
+  switch (process.env.TEST_TYPE) {
+    case 'coverage':
+      settings.browsers = ['PhantomJS'];
+      settings.reporters = ['coverage'];
+      settings.coverageReporter = {
+        reporters: [{
+          type: 'text-summary', dir: "./coverage"
+        }, {
+          type: 'html', dir: "./coverage"
+        }]
+      };
+      break;
+    case 'coveralls':
+      settings.browsers = ['PhantomJS'];
+      settings.reporters = ['coverage', 'coveralls'];
+      settings.coverageReporter = {
+        reporters: [{
+          type: 'text-summary', dir: "./coverage"
+        }, {
+          type: 'lcov',
+          dir: "./coverage"
+        }]
+      };
+      break;
+    case 'sauce':
+      var batch = process.env.SAUCE || 'batch1';
+      var sauce = require('./sauce')[batch];
+      settings.sauceLabs = sauce.sauceLabs;
+      settings.captureTimeout = sauce.captureTimeout;
+      settings.customLaunchers = sauce.customLaunchers;
+      settings.browsers = sauce.browsers;
+      settings.reporters = sauce.reporters;
+      break;
+    case 'browser':
+      settings.browsers = ['Chrome', 'Safari', 'Firefox'];
+      settings.reporters = ['progress'];
+      break;
+    default:
+      settings.browsers = ['PhantomJS'];
+      settings.reporters = ['mocha'];
+      break;
+  }
+
+  config.set(settings);
+};
Index: public/node_modules/vue-resource/dist/vue-resource.min.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/dist/vue-resource.min.js	(revision )
+++ public/node_modules/vue-resource/dist/vue-resource.min.js	(revision )
@@ -0,0 +1,7 @@
+/*!
+ * vue-resource v1.2.1
+ * https://github.com/pagekit/vue-resource
+ * Released under the MIT License.
+ */
+
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.VueResource=e()}(this,function(){"use strict";function t(t){this.state=J,this.value=void 0,this.deferred=[];var e=this;try{t(function(t){e.resolve(t)},function(t){e.reject(t)})}catch(t){e.reject(t)}}function e(t,e){t instanceof Promise?this.promise=t:this.promise=new Promise(t.bind(e)),this.context=e}function n(t){"undefined"!=typeof console&&Q&&console.warn("[VueResource warn]: "+t)}function o(t){"undefined"!=typeof console&&console.error(t)}function r(t,e){return G(t,e)}function i(t){return t?t.replace(/^\s*|\s*$/g,""):""}function u(t){return t?t.toLowerCase():""}function s(t){return t?t.toUpperCase():""}function a(t){return"string"==typeof t}function c(t){return"function"==typeof t}function f(t){return null!==t&&"object"==typeof t}function h(t){return f(t)&&Object.getPrototypeOf(t)==Object.prototype}function p(t){return"undefined"!=typeof Blob&&t instanceof Blob}function d(t){return"undefined"!=typeof FormData&&t instanceof FormData}function l(t,n,o){var r=e.resolve(t);return arguments.length<2?r:r.then(n,o)}function m(t,e,n){return n=n||{},c(n)&&(n=n.call(e)),v(t.bind({$vm:e,$options:n}),t,{$options:n})}function y(t,e){var n,o;if(tt(t))for(n=0;n<t.length;n++)e.call(t[n],t[n],n);else if(f(t))for(o in t)_.call(t,o)&&e.call(t[o],t[o],o);return t}function v(t){var e=K.call(arguments,1);return e.forEach(function(e){w(t,e,!0)}),t}function b(t){var e=K.call(arguments,1);return e.forEach(function(e){for(var n in e)void 0===t[n]&&(t[n]=e[n])}),t}function g(t){var e=K.call(arguments,1);return e.forEach(function(e){w(t,e)}),t}function w(t,e,n){for(var o in e)n&&(h(e[o])||tt(e[o]))?(h(e[o])&&!h(t[o])&&(t[o]={}),tt(e[o])&&!tt(t[o])&&(t[o]=[]),w(t[o],e[o],n)):void 0!==e[o]&&(t[o]=e[o])}function T(t,e,n){var o=x(t),r=o.expand(e);return n&&n.push.apply(n,o.vars),r}function x(t){var e=["+","#",".","/",";","?","&"],n=[];return{vars:n,expand:function(o){return t.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g,function(t,r,i){if(r){var u=null,s=[];if(e.indexOf(r.charAt(0))!==-1&&(u=r.charAt(0),r=r.substr(1)),r.split(/,/g).forEach(function(t){var e=/([^:\*]*)(?::(\d+)|(\*))?/.exec(t);s.push.apply(s,j(o,u,e[1],e[2]||e[3])),n.push(e[1])}),u&&"+"!==u){var a=",";return"?"===u?a="&":"#"!==u&&(a=u),(0!==s.length?u:"")+s.join(a)}return s.join(",")}return C(i)})}}}function j(t,e,n,o){var r=t[n],i=[];if(E(r)&&""!==r)if("string"==typeof r||"number"==typeof r||"boolean"==typeof r)r=r.toString(),o&&"*"!==o&&(r=r.substring(0,parseInt(o,10))),i.push(P(e,r,O(e)?n:null));else if("*"===o)Array.isArray(r)?r.filter(E).forEach(function(t){i.push(P(e,t,O(e)?n:null))}):Object.keys(r).forEach(function(t){E(r[t])&&i.push(P(e,r[t],t))});else{var u=[];Array.isArray(r)?r.filter(E).forEach(function(t){u.push(P(e,t))}):Object.keys(r).forEach(function(t){E(r[t])&&(u.push(encodeURIComponent(t)),u.push(P(e,r[t].toString())))}),O(e)?i.push(encodeURIComponent(n)+"="+u.join(",")):0!==u.length&&i.push(u.join(","))}else";"===e?i.push(encodeURIComponent(n)):""!==r||"&"!==e&&"?"!==e?""===r&&i.push(""):i.push(encodeURIComponent(n)+"=");return i}function E(t){return void 0!==t&&null!==t}function O(t){return";"===t||"&"===t||"?"===t}function P(t,e,n){return e="+"===t||"#"===t?C(e):encodeURIComponent(e),n?encodeURIComponent(n)+"="+e:e}function C(t){return t.split(/(%[0-9A-Fa-f]{2})/g).map(function(t){return/%[0-9A-Fa-f]/.test(t)||(t=encodeURI(t)),t}).join("")}function $(t,e){var n,o=this||{},r=t;return a(t)&&(r={url:t,params:e}),r=v({},$.options,o.$options,r),$.transforms.forEach(function(t){n=U(t,n,o.$vm)}),n(r)}function U(t,e,n){return function(o){return t.call(n,o,e)}}function R(t,e,n){var o,r=tt(e),i=h(e);y(e,function(e,u){o=f(e)||tt(e),n&&(u=n+"["+(i||o?u:"")+"]"),!n&&r?t.add(e.name,e.value):o?R(t,e,u):t.add(u,e)})}function A(t){var e=t.match(/^\[|^\{(?!\{)/),n={"[":/]$/,"{":/}$/};return e&&n[e[0]].test(t)}function S(t,e){var n=t.client||(Y?mt:yt);e(n(t))}function k(t,e){return Object.keys(t).reduce(function(t,n){return u(e)===u(n)?n:t},null)}function I(t){if(/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(t))throw new TypeError("Invalid character in header field name");return i(t)}function H(t){return new e(function(e){var n=new FileReader;n.readAsText(t),n.onload=function(){e(n.result)}})}function B(t){return 0===t.type.indexOf("text")||t.type.indexOf("json")!==-1}function L(t){var n=this||{},r=vt(n.$vm);return b(t||{},n.$options,L.options),L.interceptors.forEach(function(t){r.use(t)}),r(new wt(t)).then(function(t){return t.ok?t:e.reject(t)},function(t){return t instanceof Error&&o(t),e.reject(t)})}function q(t,e,n,o){var r=this||{},i={};return n=et({},q.actions,n),y(n,function(n,u){n=v({url:t,params:et({},e)},o,n),i[u]=function(){return(r.$http||L)(M(n,arguments))}}),i}function M(t,e){var n,o=et({},t),r={};switch(e.length){case 2:r=e[0],n=e[1];break;case 1:/^(POST|PUT|PATCH)$/i.test(o.method)?n=e[0]:r=e[0];break;case 0:break;default:throw"Expected up to 2 arguments [params, body], got "+e.length+" arguments"}return o.body=n,o.params=et({},o.params,r),o}function N(t){N.installed||(Z(t),t.url=$,t.http=L,t.resource=q,t.Promise=e,Object.defineProperties(t.prototype,{$url:{get:function(){return m(t.url,this,this.$options.url)}},$http:{get:function(){return m(t.http,this,this.$options.http)}},$resource:{get:function(){return t.resource.bind(this)}},$promise:{get:function(){var e=this;return function(n){return new t.Promise(n,e)}}}}))}var D=0,F=1,J=2;t.reject=function(e){return new t(function(t,n){n(e)})},t.resolve=function(e){return new t(function(t,n){t(e)})},t.all=function(e){return new t(function(n,o){function r(t){return function(o){u[t]=o,i+=1,i===e.length&&n(u)}}var i=0,u=[];0===e.length&&n(u);for(var s=0;s<e.length;s+=1)t.resolve(e[s]).then(r(s),o)})},t.race=function(e){return new t(function(n,o){for(var r=0;r<e.length;r+=1)t.resolve(e[r]).then(n,o)})};var W=t.prototype;W.resolve=function(t){var e=this;if(e.state===J){if(t===e)throw new TypeError("Promise settled with itself.");var n=!1;try{var o=t&&t.then;if(null!==t&&"object"==typeof t&&"function"==typeof o)return void o.call(t,function(t){n||e.resolve(t),n=!0},function(t){n||e.reject(t),n=!0})}catch(t){return void(n||e.reject(t))}e.state=D,e.value=t,e.notify()}},W.reject=function(t){var e=this;if(e.state===J){if(t===e)throw new TypeError("Promise settled with itself.");e.state=F,e.value=t,e.notify()}},W.notify=function(){var t=this;r(function(){if(t.state!==J)for(;t.deferred.length;){var e=t.deferred.shift(),n=e[0],o=e[1],r=e[2],i=e[3];try{t.state===D?r("function"==typeof n?n.call(void 0,t.value):t.value):t.state===F&&("function"==typeof o?r(o.call(void 0,t.value)):i(t.value))}catch(t){i(t)}}})},W.then=function(e,n){var o=this;return new t(function(t,r){o.deferred.push([e,n,t,r]),o.notify()})},W.catch=function(t){return this.then(void 0,t)},"undefined"==typeof Promise&&(window.Promise=t),e.all=function(t,n){return new e(Promise.all(t),n)},e.resolve=function(t,n){return new e(Promise.resolve(t),n)},e.reject=function(t,n){return new e(Promise.reject(t),n)},e.race=function(t,n){return new e(Promise.race(t),n)};var X=e.prototype;X.bind=function(t){return this.context=t,this},X.then=function(t,n){return t&&t.bind&&this.context&&(t=t.bind(this.context)),n&&n.bind&&this.context&&(n=n.bind(this.context)),new e(this.promise.then(t,n),this.context)},X.catch=function(t){return t&&t.bind&&this.context&&(t=t.bind(this.context)),new e(this.promise.catch(t),this.context)},X.finally=function(t){return this.then(function(e){return t.call(this),e},function(e){return t.call(this),Promise.reject(e)})};var G,V={},_=V.hasOwnProperty,z=[],K=z.slice,Q=!1,Y="undefined"!=typeof window,Z=function(t){var e=t.config,n=t.nextTick;G=n,Q=e.debug||!e.silent},tt=Array.isArray,et=Object.assign||g,nt=function(t,e){var n=e(t);return a(t.root)&&!n.match(/^(https?:)?\//)&&(n=t.root+"/"+n),n},ot=function(t,e){var n=Object.keys($.options.params),o={},r=e(t);return y(t.params,function(t,e){n.indexOf(e)===-1&&(o[e]=t)}),o=$.params(o),o&&(r+=(r.indexOf("?")==-1?"?":"&")+o),r},rt=function(t){var e=[],n=T(t.url,t.params,e);return e.forEach(function(e){delete t.params[e]}),n};$.options={url:"",root:null,params:{}},$.transforms=[rt,ot,nt],$.params=function(t){var e=[],n=encodeURIComponent;return e.add=function(t,e){c(e)&&(e=e()),null===e&&(e=""),this.push(n(t)+"="+n(e))},R(e,t),e.join("&").replace(/%20/g,"+")},$.parse=function(t){var e=document.createElement("a");return document.documentMode&&(e.href=t,t=e.href),e.href=t,{href:e.href,protocol:e.protocol?e.protocol.replace(/:$/,""):"",port:e.port,host:e.host,hostname:e.hostname,pathname:"/"===e.pathname.charAt(0)?e.pathname:"/"+e.pathname,search:e.search?e.search.replace(/^\?/,""):"",hash:e.hash?e.hash.replace(/^#/,""):""}};var it=function(t){return new e(function(e){var n=new XDomainRequest,o=function(o){var r=o.type,i=0;"load"===r?i=200:"error"===r&&(i=500),e(t.respondWith(n.responseText,{status:i}))};t.abort=function(){return n.abort()},n.open(t.method,t.getUrl()),t.timeout&&(n.timeout=t.timeout),n.onload=o,n.onabort=o,n.onerror=o,n.ontimeout=o,n.onprogress=function(){},n.send(t.getBody())})},ut=Y&&"withCredentials"in new XMLHttpRequest,st=function(t,e){if(Y){var n=$.parse(location.href),o=$.parse(t.getUrl());o.protocol===n.protocol&&o.host===n.host||(t.crossOrigin=!0,t.emulateHTTP=!1,ut||(t.client=it))}e()},at=function(t,e){d(t.body)?t.headers.delete("Content-Type"):(f(t.body)||tt(t.body))&&(t.emulateJSON?(t.body=$.params(t.body),t.headers.set("Content-Type","application/x-www-form-urlencoded")):t.body=JSON.stringify(t.body)),e(function(t){return Object.defineProperty(t,"data",{get:function(){return this.body},set:function(t){this.body=t}}),t.bodyText?l(t.text(),function(e){var n=t.headers.get("Content-Type")||"";if(0===n.indexOf("application/json")||A(e))try{t.body=JSON.parse(e)}catch(e){t.body=null}else t.body=e;return t}):t})},ct=function(t){return new e(function(e){var n,o,r=t.jsonp||"callback",i=t.jsonpCallback||"_jsonp"+Math.random().toString(36).substr(2),u=null;n=function(n){var r=n.type,s=0;"load"===r&&null!==u?s=200:"error"===r&&(s=500),s&&window[i]&&(delete window[i],document.body.removeChild(o)),e(t.respondWith(u,{status:s}))},window[i]=function(t){u=JSON.stringify(t)},t.abort=function(){n({type:"abort"})},t.params[r]=i,t.timeout&&setTimeout(t.abort,t.timeout),o=document.createElement("script"),o.src=t.getUrl(),o.type="text/javascript",o.async=!0,o.onload=n,o.onerror=n,document.body.appendChild(o)})},ft=function(t,e){"JSONP"==t.method&&(t.client=ct),e()},ht=function(t,e){c(t.before)&&t.before.call(this,t),e()},pt=function(t,e){t.emulateHTTP&&/^(PUT|PATCH|DELETE)$/i.test(t.method)&&(t.headers.set("X-HTTP-Method-Override",t.method),t.method="POST"),e()},dt=function(t,e){var n=et({},L.headers.common,t.crossOrigin?{}:L.headers.custom,L.headers[u(t.method)]);y(n,function(e,n){t.headers.has(n)||t.headers.set(n,e)}),e()},lt="undefined"!=typeof Blob&&"undefined"!=typeof FileReader,mt=function(t){return new e(function(e){var n=new XMLHttpRequest,o=function(o){var r=t.respondWith("response"in n?n.response:n.responseText,{status:1223===n.status?204:n.status,statusText:1223===n.status?"No Content":i(n.statusText)});y(i(n.getAllResponseHeaders()).split("\n"),function(t){r.headers.append(t.slice(0,t.indexOf(":")),t.slice(t.indexOf(":")+1))}),e(r)};t.abort=function(){return n.abort()},t.progress&&("GET"===t.method?n.addEventListener("progress",t.progress):/^(POST|PUT)$/i.test(t.method)&&n.upload.addEventListener("progress",t.progress)),n.open(t.method,t.getUrl(),!0),t.timeout&&(n.timeout=t.timeout),t.credentials===!0&&(n.withCredentials=!0),t.crossOrigin||t.headers.set("X-Requested-With","XMLHttpRequest"),"responseType"in n&&lt&&(n.responseType="blob"),t.headers.forEach(function(t,e){n.setRequestHeader(e,t)}),n.onload=o,n.onabort=o,n.onerror=o,n.ontimeout=o,n.send(t.getBody())})},yt=function(t){var n=require("got");return new e(function(e){var o,r=t.getUrl(),u=t.getBody(),s=t.method,a={};t.headers.forEach(function(t,e){a[e]=t}),n(r,{body:u,method:s,headers:a}).then(o=function(n){var o=t.respondWith(n.body,{status:n.statusCode,statusText:i(n.statusMessage)});y(n.headers,function(t,e){o.headers.set(e,t)}),e(o)},function(t){return o(t.response)})})},vt=function(t){function o(o){return new e(function(e){function s(){r=i.pop(),c(r)?r.call(t,o,a):(n("Invalid interceptor of type "+typeof r+", must be a function"),a())}function a(n){if(c(n))u.unshift(n);else if(f(n))return u.forEach(function(e){n=l(n,function(n){return e.call(t,n)||n})}),void l(n,e);s()}s()},t)}var r,i=[S],u=[];return f(t)||(t=null),o.use=function(t){i.push(t)},o},bt=function(t){var e=this;this.map={},y(t,function(t,n){return e.append(n,t)})};bt.prototype.has=function(t){return null!==k(this.map,t)},bt.prototype.get=function(t){var e=this.map[k(this.map,t)];return e?e.join():null},bt.prototype.getAll=function(t){return this.map[k(this.map,t)]||[]},bt.prototype.set=function(t,e){this.map[I(k(this.map,t)||t)]=[i(e)]},bt.prototype.append=function(t,e){var n=this.map[k(this.map,t)];n?n.push(i(e)):this.set(t,e)},bt.prototype.delete=function(t){delete this.map[k(this.map,t)]},bt.prototype.deleteAll=function(){this.map={}},bt.prototype.forEach=function(t,e){var n=this;y(this.map,function(o,r){y(o,function(o){return t.call(e,o,r,n)})})};var gt=function(t,e){var n=e.url,o=e.headers,r=e.status,i=e.statusText;this.url=n,this.ok=r>=200&&r<300,this.status=r||0,this.statusText=i||"",this.headers=new bt(o),this.body=t,a(t)?this.bodyText=t:p(t)&&(this.bodyBlob=t,B(t)&&(this.bodyText=H(t)))};gt.prototype.blob=function(){return l(this.bodyBlob)},gt.prototype.text=function(){return l(this.bodyText)},gt.prototype.json=function(){return l(this.text(),function(t){return JSON.parse(t)})};var wt=function(t){this.body=null,this.params={},et(this,t,{method:s(t.method||"GET")}),this.headers instanceof bt||(this.headers=new bt(this.headers))};wt.prototype.getUrl=function(){return $(this)},wt.prototype.getBody=function(){return this.body},wt.prototype.respondWith=function(t,e){return new gt(t,et(e||{},{url:this.getUrl()}))};var Tt={Accept:"application/json, text/plain, */*"},xt={"Content-Type":"application/json;charset=utf-8"};return L.options={},L.headers={put:xt,post:xt,patch:xt,delete:xt,common:Tt,custom:{}},L.interceptors=[ht,pt,at,ft,dt,st],["get","delete","head","jsonp"].forEach(function(t){L[t]=function(e,n){return this(et(n||{},{url:e,method:t}))}}),["post","put","patch"].forEach(function(t){L[t]=function(e,n,o){return this(et(o||{},{url:e,method:t,body:n}))}}),q.actions={get:{method:"GET"},save:{method:"POST"},query:{method:"GET"},update:{method:"PUT"},remove:{method:"DELETE"},delete:{method:"DELETE"}},"undefined"!=typeof window&&window.Vue&&window.Vue.use(N),N});
\ No newline at end of file
Index: public/node_modules/vue-select2/demo/demo.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/demo/demo.js	(revision )
+++ public/node_modules/vue-select2/demo/demo.js	(revision )
@@ -0,0 +1,14 @@
+var Vue = require("vue");
+
+var vm = new Vue({
+  components: {
+    "demo": require("./demo.vue")
+  },
+  data: {
+    result1: null,
+    result2: "value2",
+    result3: "value6"
+  }
+});
+
+vm.$mount("#app");
Index: public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/LICENSE	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/LICENSE	(revision )
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) Feross Aboukhadijeh
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
Index: public/node_modules/vue/src/core/components/keep-alive.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/components/keep-alive.js	(revision )
+++ public/node_modules/vue/src/core/components/keep-alive.js	(revision )
@@ -0,0 +1,100 @@
+/* @flow */
+
+import { callHook } from 'core/instance/lifecycle'
+import { getFirstComponentChild } from 'core/vdom/helpers/index'
+
+type VNodeCache = { [key: string]: ?VNode };
+
+const patternTypes: Array<Function> = [String, RegExp]
+
+function getComponentName (opts: ?VNodeComponentOptions): ?string {
+  return opts && (opts.Ctor.options.name || opts.tag)
+}
+
+function matches (pattern: string | RegExp, name: string): boolean {
+  if (typeof pattern === 'string') {
+    return pattern.split(',').indexOf(name) > -1
+  } else if (pattern instanceof RegExp) {
+    return pattern.test(name)
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function pruneCache (cache: VNodeCache, filter: Function) {
+  for (const key in cache) {
+    const cachedNode: ?VNode = cache[key]
+    if (cachedNode) {
+      const name: ?string = getComponentName(cachedNode.componentOptions)
+      if (name && !filter(name)) {
+        pruneCacheEntry(cachedNode)
+        cache[key] = null
+      }
+    }
+  }
+}
+
+function pruneCacheEntry (vnode: ?VNode) {
+  if (vnode) {
+    if (!vnode.componentInstance._inactive) {
+      callHook(vnode.componentInstance, 'deactivated')
+    }
+    vnode.componentInstance.$destroy()
+  }
+}
+
+export default {
+  name: 'keep-alive',
+  abstract: true,
+
+  props: {
+    include: patternTypes,
+    exclude: patternTypes
+  },
+
+  created () {
+    this.cache = Object.create(null)
+  },
+
+  destroyed () {
+    for (const key in this.cache) {
+      pruneCacheEntry(this.cache[key])
+    }
+  },
+
+  watch: {
+    include (val: string | RegExp) {
+      pruneCache(this.cache, name => matches(val, name))
+    },
+    exclude (val: string | RegExp) {
+      pruneCache(this.cache, name => !matches(val, name))
+    }
+  },
+
+  render () {
+    const vnode: VNode = getFirstComponentChild(this.$slots.default)
+    const componentOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions
+    if (componentOptions) {
+      // check pattern
+      const name: ?string = getComponentName(componentOptions)
+      if (name && (
+        (this.include && !matches(this.include, name)) ||
+        (this.exclude && matches(this.exclude, name))
+      )) {
+        return vnode
+      }
+      const key: ?string = vnode.key == null
+        // same constructor may get registered as different local components
+        // so cid alone is not enough (#3269)
+        ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : '')
+        : vnode.key
+      if (this.cache[key]) {
+        vnode.componentInstance = this.cache[key].componentInstance
+      } else {
+        this.cache[key] = vnode
+      }
+      vnode.data.keepAlive = true
+    }
+    return vnode
+  }
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/readme.md	(revision )
@@ -0,0 +1,54 @@
+# create-error-class [![Build Status](https://travis-ci.org/floatdrop/create-error-class.svg?branch=master)](https://travis-ci.org/floatdrop/create-error-class)
+
+> Create error class
+
+
+## Install
+
+```
+$ npm install --save create-error-class
+```
+
+
+## Usage
+
+```js
+var createErrorClass = require('create-error-class');
+
+var HTTPError = createErrorClass('HTTPError', function (props) {
+	this.message = 'Status code is ' + props.statusCode;
+});
+
+throw new HTTPError({statusCode: 404});
+```
+
+
+## API
+
+### createErrorClass(className, [setup])
+
+Return constructor of Errors with `className`.
+
+#### className
+
+*Required*  
+Type: `string`
+
+Class name of Error Object. Should contain characters from `[0-9a-zA-Z_$]` range.
+
+#### setup
+Type: `function`
+
+Setup function, that will be called after each Error object is created from constructor with context of Error object.
+
+By default `setup` function sets `this.message` as first argument:
+
+```js
+var MyError = createErrorClass('MyError');
+
+new MyError('Something gone wrong!').message; // => 'Something gone wrong!'
+```
+
+## License
+
+MIT  [Vsevolod Strukchinsky](http://github.com/floatdrop)
Index: public/node_modules/vue/src/server/source-map-support.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/source-map-support.js	(revision )
+++ public/node_modules/vue/src/server/source-map-support.js	(revision )
@@ -0,0 +1,45 @@
+/* @flow */
+
+const SourceMapConsumer = require('source-map').SourceMapConsumer
+
+const filenameRE = /\(([^)]+\.js):(\d+):(\d+)\)$/
+
+export function createSourceMapConsumers (rawMaps: Object) {
+  const maps = {}
+  Object.keys(rawMaps).forEach(file => {
+    maps[file] = new SourceMapConsumer(rawMaps[file])
+  })
+  return maps
+}
+
+export function rewriteErrorTrace (e: any, mapConsumers: {
+  [key: string]: SourceMapConsumer
+}) {
+  if (e && typeof e.stack === 'string') {
+    e.stack = e.stack.split('\n').map(line => {
+      return rewriteTraceLine(line, mapConsumers)
+    }).join('\n')
+  }
+}
+
+function rewriteTraceLine (trace: string, mapConsumers: {
+  [key: string]: SourceMapConsumer
+}) {
+  const m = trace.match(filenameRE)
+  const map = m && mapConsumers[m[1]]
+  if (m != null && map) {
+    const originalPosition = map.originalPositionFor({
+      line: Number(m[2]),
+      column: Number(m[3])
+    })
+    if (originalPosition.source != null) {
+      const { source, line, column } = originalPosition
+      const mappedPosition = `(${source.replace(/^webpack:\/\/\//, '')}:${String(line)}:${String(column)})`
+      return trace.replace(filenameRE, mappedPosition)
+    } else {
+      return trace
+    }
+  } else {
+    return trace
+  }
+}
Index: public/node_modules/vue/src/platforms/weex/compiler/modules/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/modules/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/modules/index.js	(revision )
@@ -0,0 +1,11 @@
+import klass from './class'
+import style from './style'
+import props from './props'
+import append from './append'
+
+export default [
+  klass,
+  style,
+  props,
+  append
+]
Index: public/node_modules/vue/src/core/util/perf.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/perf.js	(revision )
+++ public/node_modules/vue/src/core/util/perf.js	(revision )
@@ -0,0 +1,10 @@
+import { inBrowser } from './env'
+
+export let perf
+
+if (process.env.NODE_ENV !== 'production') {
+  perf = inBrowser && window.performance
+  if (perf && (!perf.mark || !perf.measure)) {
+    perf = undefined
+  }
+}
Index: public/node_modules/vue/src/platforms/web/server/modules/dom-props.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/modules/dom-props.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/modules/dom-props.js	(revision )
@@ -0,0 +1,45 @@
+/* @flow */
+
+import VNode from 'core/vdom/vnode'
+import { renderAttr } from './attrs'
+import { propsToAttrMap, isRenderableAttr } from '../util'
+
+export default function renderDOMProps (node: VNodeWithData): string {
+  let props = node.data.domProps
+  let res = ''
+
+  let parent = node.parent
+  while (parent) {
+    if (parent.data && parent.data.domProps) {
+      props = Object.assign({}, props, parent.data.domProps)
+    }
+    parent = parent.parent
+  }
+
+  if (!props) {
+    return res
+  }
+
+  const attrs = node.data.attrs
+  for (const key in props) {
+    if (key === 'innerHTML') {
+      setText(node, props[key], true)
+    } else if (key === 'textContent') {
+      setText(node, props[key], false)
+    } else {
+      const attr = propsToAttrMap[key] || key.toLowerCase()
+      if (isRenderableAttr(attr) &&
+          // avoid rendering double-bound props/attrs twice
+          !(attrs && attrs[attr])) {
+        res += renderAttr(attr, props[key])
+      }
+    }
+  }
+  return res
+}
+
+function setText (node, text, raw) {
+  const child = new VNode(undefined, undefined, undefined, text)
+  child.raw = raw
+  node.children = [child]
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/readme.md	(revision )
@@ -0,0 +1,42 @@
+# is-retry-allowed [![Build Status](https://travis-ci.org/floatdrop/is-retry-allowed.svg?branch=master)](https://travis-ci.org/floatdrop/is-retry-allowed)
+
+Is retry allowed for Error?
+
+
+## Install
+
+```
+$ npm install --save is-retry-allowed
+```
+
+
+## Usage
+
+```js
+const isRetryAllowed = require('is-retry-allowed');
+
+isRetryAllowed({code: 'ETIMEDOUT'});
+//=> true
+
+isRetryAllowed({code: 'ENOTFOUND'});
+//=> false
+
+isRetryAllowed({});
+//=> true
+```
+
+
+## API
+
+### isRetryAllowed(error)
+
+#### error
+
+Type: `object`
+
+Object with `code` property, which will be used to determine retry.
+
+
+## License
+
+MIT  [Vsevolod Strukchinsky](http://github.com/floatdrop)
Index: public/node_modules/vue/src/server/write.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/write.js	(revision )
+++ public/node_modules/vue/src/server/write.js	(revision )
@@ -0,0 +1,32 @@
+/* @flow */
+
+const MAX_STACK_DEPTH = 1000
+
+export function createWriteFunction (
+  write: (text: string, next: Function) => ?boolean,
+  onError: Function
+): Function {
+  let stackDepth = 0
+  const cachedWrite = (text, next) => {
+    if (text && cachedWrite.caching) {
+      cachedWrite.cacheBuffer[cachedWrite.cacheBuffer.length - 1] += text
+    }
+    const waitForNext = write(text, next)
+    if (!waitForNext) {
+      if (stackDepth >= MAX_STACK_DEPTH) {
+        process.nextTick(() => {
+          try { next() } catch (e) {
+            onError(e)
+          }
+        })
+      } else {
+        stackDepth++
+        next()
+        stackDepth--
+      }
+    }
+  }
+  cachedWrite.caching = false
+  cachedWrite.cacheBuffer = []
+  return cachedWrite
+}
Index: public/node_modules/vue/src/platforms/web/compiler/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/index.js	(revision )
@@ -0,0 +1,30 @@
+/* @flow */
+
+import { isUnaryTag } from './util'
+import { genStaticKeys } from 'shared/util'
+import { createCompiler } from 'compiler/index'
+
+import modules from './modules/index'
+import directives from './directives/index'
+
+import {
+  isPreTag,
+  mustUseProp,
+  isReservedTag,
+  getTagNamespace
+} from '../util/index'
+
+export const baseOptions: CompilerOptions = {
+  expectHTML: true,
+  modules,
+  directives,
+  isPreTag,
+  isUnaryTag,
+  mustUseProp,
+  isReservedTag,
+  getTagNamespace,
+  staticKeys: genStaticKeys(modules)
+}
+
+const { compile, compileToFunctions } = createCompiler(baseOptions)
+export { compile, compileToFunctions }
Index: public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/index.js	(revision )
@@ -0,0 +1,76 @@
+"use strict";
+
+var stream = require("stream");
+
+function DuplexWrapper(options, writable, readable) {
+  if (typeof readable === "undefined") {
+    readable = writable;
+    writable = options;
+    options = null;
+  }
+
+  stream.Duplex.call(this, options);
+
+  if (typeof readable.read !== "function") {
+    readable = (new stream.Readable(options)).wrap(readable);
+  }
+
+  this._writable = writable;
+  this._readable = readable;
+  this._waiting = false;
+
+  var self = this;
+
+  writable.once("finish", function() {
+    self.end();
+  });
+
+  this.once("finish", function() {
+    writable.end();
+  });
+
+  readable.on("readable", function() {
+    if (self._waiting) {
+      self._waiting = false;
+      self._read();
+    }
+  });
+
+  readable.once("end", function() {
+    self.push(null);
+  });
+
+  if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
+    writable.on("error", function(err) {
+      self.emit("error", err);
+    });
+
+    readable.on("error", function(err) {
+      self.emit("error", err);
+    });
+  }
+}
+
+DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});
+
+DuplexWrapper.prototype._write = function _write(input, encoding, done) {
+  this._writable.write(input, encoding, done);
+};
+
+DuplexWrapper.prototype._read = function _read() {
+  var buf;
+  var reads = 0;
+  while ((buf = this._readable.read()) !== null) {
+    this.push(buf);
+    reads++;
+  }
+  if (reads === 0) {
+    this._waiting = true;
+  }
+};
+
+module.exports = function duplex2(options, writable, readable) {
+  return new DuplexWrapper(options, writable, readable);
+};
+
+module.exports.DuplexWrapper = DuplexWrapper;
Index: public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/readme.md	(revision )
@@ -0,0 +1,117 @@
+# get-stream [![Build Status](https://travis-ci.org/sindresorhus/get-stream.svg?branch=master)](https://travis-ci.org/sindresorhus/get-stream)
+
+> Get a stream as a string, buffer, or array
+
+
+## Install
+
+```
+$ npm install --save get-stream
+```
+
+
+## Usage
+
+```js
+const fs = require('fs');
+const getStream = require('get-stream');
+const stream = fs.createReadStream('unicorn.txt');
+
+getStream(stream).then(str => {
+	console.log(str);
+	/*
+	              ,,))))))));,
+	           __)))))))))))))),
+	\|/       -\(((((''''((((((((.
+	-*-==//////((''  .     `)))))),
+	/|\      ))| o    ;-.    '(((((                                  ,(,
+	         ( `|    /  )    ;))))'                               ,_))^;(~
+	            |   |   |   ,))((((_     _____------~~~-.        %,;(;(>';'~
+	            o_);   ;    )))(((` ~---~  `::           \      %%~~)(v;(`('~
+	                  ;    ''''````         `:       `:::|\,__,%%    );`'; ~
+	                 |   _                )     /      `:|`----'     `-'
+	           ______/\/~    |                 /        /
+	         /~;;.____/;;'  /          ___--,-(   `;;;/
+	        / //  _;______;'------~~~~~    /;;/\    /
+	       //  | |                        / ;   \;;,\
+	      (<_  | ;                      /',/-----'  _>
+	       \_| ||_                     //~;~~~~~~~~~
+	           `\_|                   (,~~
+	                                   \~\
+	                                    ~~
+	*/
+});
+```
+
+
+## API
+
+The methods returns a promise that resolves when the `end` event fires on the stream, indicating that there is no more data to be read. The stream is switched to flowing mode.
+
+### getStream(stream, [options])
+
+Get the `stream` as a string.
+
+#### options
+
+##### encoding
+
+Type: `string`<br>
+Default: `utf8`
+
+[Encoding](https://nodejs.org/api/buffer.html#buffer_buffer) of the incoming stream.
+
+##### maxBuffer
+
+Type: `number`<br>
+Default: `Infinity`
+
+Maximum length of the returned string. If it exceeds this value before the stream ends, the promise will be rejected.
+
+### getStream.buffer(stream, [options])
+
+Get the `stream` as a buffer.
+
+It honors the `maxBuffer` option as above, but it refers to byte length rather than string length.
+
+### getStream.array(stream, [options])
+
+Get the `stream` as an array of values.
+
+It honors both the `maxBuffer` and `encoding` options. The behavior changes slightly based on the encoding chosen:
+
+- When `encoding` is unset, it assumes an [object mode stream](https://nodesource.com/blog/understanding-object-streams/) and collects values emitted from `stream` unmodified. In this case `maxBuffer` refers to the number of items in the array (not the sum of their sizes).
+
+- When `encoding` is set to `buffer`, it collects an array of buffers. `maxBuffer` refers to the summed byte lengths of every buffer in the array.
+
+- When `encoding` is set to anything else, it collects an array of strings. `maxBuffer` refers to the summed character lengths of every string in the array.
+
+
+## Errors
+
+If the input stream emits an `error` event, the promise will be rejected with the error. The buffered data will be attached to the `bufferedData` property of the error.
+
+```js
+getStream(streamThatErrorsAtTheEnd('unicorn'))
+	.catch(err => {
+		console.log(err.bufferedData);
+		//=> 'unicorn'
+	});
+```
+
+
+## FAQ
+
+### How is this different from [`concat-stream`](https://github.com/maxogden/concat-stream)?
+
+This module accepts a stream instead of being one and returns a promise instead of using a callback. The API is simpler and it only supports returning a string, buffer, or array. It doesn't have a fragile type inference. You explicitly choose what you want. And it doesn't depend on the huge `readable-stream` package.
+
+
+## Related
+
+- [get-stdin](https://github.com/sindresorhus/get-stdin) - Get stdin as a string or buffer
+
+
+## License
+
+MIT  [Sindre Sorhus](https://sindresorhus.com)
Index: public/node_modules/vue/src/core/vdom/create-element.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/create-element.js	(revision )
+++ public/node_modules/vue/src/core/vdom/create-element.js	(revision )
@@ -0,0 +1,110 @@
+/* @flow */
+
+import VNode, { createEmptyVNode } from './vnode'
+import config from '../config'
+import { createComponent } from './create-component'
+import { normalizeChildren, simpleNormalizeChildren } from './helpers/index'
+import { warn, resolveAsset, isPrimitive } from '../util/index'
+
+const SIMPLE_NORMALIZE = 1
+const ALWAYS_NORMALIZE = 2
+
+// wrapper function for providing a more flexible interface
+// without getting yelled at by flow
+export function createElement (
+  context: Component,
+  tag: any,
+  data: any,
+  children: any,
+  normalizationType: any,
+  alwaysNormalize: boolean
+): VNode {
+  if (Array.isArray(data) || isPrimitive(data)) {
+    normalizationType = children
+    children = data
+    data = undefined
+  }
+  if (alwaysNormalize) normalizationType = ALWAYS_NORMALIZE
+  return _createElement(context, tag, data, children, normalizationType)
+}
+
+export function _createElement (
+  context: Component,
+  tag?: string | Class<Component> | Function | Object,
+  data?: VNodeData,
+  children?: any,
+  normalizationType?: number
+): VNode {
+  if (data && data.__ob__) {
+    process.env.NODE_ENV !== 'production' && warn(
+      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
+      'Always create fresh vnode data objects in each render!',
+      context
+    )
+    return createEmptyVNode()
+  }
+  if (!tag) {
+    // in case of component :is set to falsy value
+    return createEmptyVNode()
+  }
+  // support single function children as default scoped slot
+  if (Array.isArray(children) &&
+      typeof children[0] === 'function') {
+    data = data || {}
+    data.scopedSlots = { default: children[0] }
+    children.length = 0
+  }
+  if (normalizationType === ALWAYS_NORMALIZE) {
+    children = normalizeChildren(children)
+  } else if (normalizationType === SIMPLE_NORMALIZE) {
+    children = simpleNormalizeChildren(children)
+  }
+  let vnode, ns
+  if (typeof tag === 'string') {
+    let Ctor
+    ns = config.getTagNamespace(tag)
+    if (config.isReservedTag(tag)) {
+      // platform built-in elements
+      vnode = new VNode(
+        config.parsePlatformTagName(tag), data, children,
+        undefined, undefined, context
+      )
+    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
+      // component
+      vnode = createComponent(Ctor, data, context, children, tag)
+    } else {
+      // unknown or unlisted namespaced elements
+      // check at runtime because it may get assigned a namespace when its
+      // parent normalizes children
+      vnode = new VNode(
+        tag, data, children,
+        undefined, undefined, context
+      )
+    }
+  } else {
+    // direct component options / constructor
+    vnode = createComponent(tag, data, context, children)
+  }
+  if (vnode) {
+    if (ns) applyNS(vnode, ns)
+    return vnode
+  } else {
+    return createEmptyVNode()
+  }
+}
+
+function applyNS (vnode, ns) {
+  vnode.ns = ns
+  if (vnode.tag === 'foreignObject') {
+    // use default namespace inside foreignObject
+    return
+  }
+  if (vnode.children) {
+    for (let i = 0, l = vnode.children.length; i < l; i++) {
+      const child = vnode.children[i]
+      if (child.tag && !child.ns) {
+        applyNS(child, ns)
+      }
+    }
+  }
+}
Index: public/node_modules/vue-resource/LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/LICENSE	(revision )
+++ public/node_modules/vue-resource/LICENSE	(revision )
@@ -0,0 +1,21 @@
+The MIT License (MIT)
+
+Copyright (c) 2015-2016 steffans
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
Index: public/node_modules/vue/src/core/vdom/helpers/normalize-children.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/helpers/normalize-children.js	(revision )
+++ public/node_modules/vue/src/core/vdom/helpers/normalize-children.js	(revision )
@@ -0,0 +1,69 @@
+/* @flow */
+
+import { isPrimitive } from 'core/util/index'
+import VNode, { createTextVNode } from 'core/vdom/vnode'
+
+// The template compiler attempts to minimize the need for normalization by
+// statically analyzing the template at compile time.
+//
+// For plain HTML markup, normalization can be completely skipped because the
+// generated render function is guaranteed to return Array<VNode>. There are
+// two cases where extra normalization is needed:
+
+// 1. When the children contains components - because a functional component
+// may return an Array instead of a single root. In this case, just a simple
+// normalization is needed - if any child is an Array, we flatten the whole
+// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
+// because functional components already normalize their own children.
+export function simpleNormalizeChildren (children: any) {
+  for (let i = 0; i < children.length; i++) {
+    if (Array.isArray(children[i])) {
+      return Array.prototype.concat.apply([], children)
+    }
+  }
+  return children
+}
+
+// 2. When the children contains constructs that always generated nested Arrays,
+// e.g. <template>, <slot>, v-for, or when the children is provided by user
+// with hand-written render functions / JSX. In such cases a full normalization
+// is needed to cater to all possible types of children values.
+export function normalizeChildren (children: any): ?Array<VNode> {
+  return isPrimitive(children)
+    ? [createTextVNode(children)]
+    : Array.isArray(children)
+      ? normalizeArrayChildren(children)
+      : undefined
+}
+
+function normalizeArrayChildren (children: any, nestedIndex?: string): Array<VNode> {
+  const res = []
+  let i, c, last
+  for (i = 0; i < children.length; i++) {
+    c = children[i]
+    if (c == null || typeof c === 'boolean') continue
+    last = res[res.length - 1]
+    //  nested
+    if (Array.isArray(c)) {
+      res.push.apply(res, normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`))
+    } else if (isPrimitive(c)) {
+      if (last && last.text) {
+        last.text += String(c)
+      } else if (c !== '') {
+        // convert primitive to vnode
+        res.push(createTextVNode(c))
+      }
+    } else {
+      if (c.text && last && last.text) {
+        res[res.length - 1] = createTextVNode(last.text + c.text)
+      } else {
+        // default key for nested array children (likely generated by v-for)
+        if (c.tag && c.key == null && nestedIndex != null) {
+          c.key = `__vlist${nestedIndex}_${i}__`
+        }
+        res.push(c)
+      }
+    }
+  }
+  return res
+}
Index: public/node_modules/vue/src/core/components/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/components/index.js	(revision )
+++ public/node_modules/vue/src/core/components/index.js	(revision )
@@ -0,0 +1,5 @@
+import KeepAlive from './keep-alive'
+
+export default {
+  KeepAlive
+}
Index: public/node_modules/vue/src/platforms/weex/compiler/modules/class.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/modules/class.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/modules/class.js	(revision )
@@ -0,0 +1,73 @@
+/* @flow */
+
+import { parseText } from 'compiler/parser/text-parser'
+import {
+  getAndRemoveAttr,
+  getBindingAttr,
+  baseWarn
+} from 'compiler/helpers'
+
+type StaticClassResult = {
+  dynamic: boolean,
+  classResult: string
+};
+
+function transformNode (el: ASTElement, options: CompilerOptions) {
+  const warn = options.warn || baseWarn
+  const staticClass = getAndRemoveAttr(el, 'class')
+  const { dynamic, classResult } = parseStaticClass(staticClass, options)
+  if (process.env.NODE_ENV !== 'production' && dynamic && staticClass) {
+    warn(
+      `class="${staticClass}": ` +
+      'Interpolation inside attributes has been deprecated. ' +
+      'Use v-bind or the colon shorthand instead.'
+    )
+  }
+  if (!dynamic && classResult) {
+    el.staticClass = classResult
+  }
+  const classBinding = getBindingAttr(el, 'class', false /* getStatic */)
+  if (classBinding) {
+    el.classBinding = classBinding
+  } else if (dynamic) {
+    el.classBinding = classResult
+  }
+}
+
+function genData (el: ASTElement): string {
+  let data = ''
+  if (el.staticClass) {
+    data += `staticClass:${el.staticClass},`
+  }
+  if (el.classBinding) {
+    data += `class:${el.classBinding},`
+  }
+  return data
+}
+
+function parseStaticClass (staticClass: ?string, options: CompilerOptions): StaticClassResult {
+  // "a b c" -> ["a", "b", "c"] => staticClass: ["a", "b", "c"]
+  // "a {{x}} c" -> ["a", x, "c"] => classBinding: '["a", x, "c"]'
+  let dynamic = false
+  let classResult = ''
+  if (staticClass) {
+    const classList = staticClass.trim().split(' ').map(name => {
+      const result = parseText(name, options.delimiters)
+      if (result) {
+        dynamic = true
+        return result
+      }
+      return JSON.stringify(name)
+    })
+    if (classList.length) {
+      classResult = '[' + classList.join(',') + ']'
+    }
+  }
+  return { dynamic, classResult }
+}
+
+export default {
+  staticKeys: ['staticClass'],
+  transformNode,
+  genData
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/.travis.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/.travis.yml	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/.travis.yml	(revision )
@@ -0,0 +1,7 @@
+language: node_js
+node_js:
+  - 'node'
+  - '5'
+  - '4'
+  - '0.12'
+  - '0.10'
Index: public/node_modules/vue/src/platforms/web/server/modules/class.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/modules/class.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/modules/class.js	(revision )
@@ -0,0 +1,10 @@
+/* @flow */
+
+import { genClassForVnode } from 'web/util/index'
+
+export default function renderClass (node: VNodeWithData): ?string {
+  const classList = genClassForVnode(node)
+  if (classList) {
+    return ` class="${classList}"`
+  }
+}
Index: public/node_modules/vue/types/vue.d.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/types/vue.d.ts	(revision )
+++ public/node_modules/vue/types/vue.d.ts	(revision )
@@ -0,0 +1,101 @@
+import {
+  Component,
+  AsyncComponent,
+  ComponentOptions,
+  FunctionalComponentOptions,
+  WatchOptions,
+  WatchHandler,
+  DirectiveOptions,
+  DirectiveFunction
+} from "./options";
+import { VNode, VNodeData, VNodeChildren, ScopedSlot } from "./vnode";
+import { PluginFunction, PluginObject } from "./plugin";
+
+export type CreateElement = {
+  // empty node
+  (): VNode;
+
+  // element or component name
+  (tag: string, children: VNodeChildren): VNode;
+  (tag: string, data?: VNodeData, children?: VNodeChildren): VNode;
+
+  // component constructor or options
+  (tag: Component, children: VNodeChildren): VNode;
+  (tag: Component, data?: VNodeData, children?: VNodeChildren): VNode;
+
+  // async component
+  (tag: AsyncComponent, children: VNodeChildren): VNode;
+  (tag: AsyncComponent, data?: VNodeData, children?: VNodeChildren): VNode;
+}
+
+export declare class Vue {
+
+  constructor(options?: ComponentOptions<Vue>);
+
+  $data: Object;
+  readonly $el: HTMLElement;
+  readonly $options: ComponentOptions<this>;
+  readonly $parent: Vue;
+  readonly $root: Vue;
+  readonly $children: Vue[];
+  readonly $refs: { [key: string]: Vue | Element | Vue[] | Element[]};
+  readonly $slots: { [key: string]: VNode[] };
+  readonly $scopedSlots: { [key: string]: ScopedSlot };
+  readonly $isServer: boolean;
+  readonly $props: any;
+
+  $mount(elementOrSelector?: Element | String, hydrating?: boolean): this;
+  $forceUpdate(): void;
+  $destroy(): void;
+  $set: typeof Vue.set;
+  $delete: typeof Vue.delete;
+  $watch(
+    expOrFn: string,
+    callback: WatchHandler<this, any>,
+    options?: WatchOptions
+  ): (() => void);
+  $watch<T>(
+    expOrFn: (this: this) => T,
+    callback: WatchHandler<this, T>,
+    options?: WatchOptions
+  ): (() => void);
+  $on(event: string | string[], callback: Function): this;
+  $once(event: string, callback: Function): this;
+  $off(event?: string | string[], callback?: Function): this;
+  $emit(event: string, ...args: any[]): this;
+  $nextTick(callback: (this: this) => void): void;
+  $nextTick(): Promise<void>;
+  $createElement: CreateElement;
+
+  static config: {
+    silent: boolean;
+    optionMergeStrategies: any;
+    devtools: boolean;
+    productionTip: boolean;
+    performance: boolean;
+    errorHandler(err: Error, vm: Vue, info: string): void;
+    ignoredElements: string[];
+    keyCodes: { [key: string]: number };
+  }
+
+  static extend(options: ComponentOptions<Vue> | FunctionalComponentOptions): typeof Vue;
+  static nextTick(callback: () => void, context?: any[]): void;
+  static nextTick(): Promise<void>
+  static set<T>(object: Object, key: string, value: T): T;
+  static set<T>(array: T[], key: number, value: T): T;
+  static delete(object: Object, key: string): void;
+
+  static directive(
+    id: string,
+    definition?: DirectiveOptions | DirectiveFunction
+  ): DirectiveOptions;
+  static filter(id: string, definition?: Function): Function;
+  static component(id: string, definition?: Component | AsyncComponent): typeof Vue;
+
+  static use<T>(plugin: PluginObject<T> | PluginFunction<T>, options?: T): void;
+  static mixin(mixin: typeof Vue | ComponentOptions<Vue>): void;
+  static compile(template: string): {
+    render(createElement: typeof Vue.prototype.$createElement): VNode;
+    staticRenderFns: (() => VNode)[];
+  };
+}
Index: public/node_modules/vue/src/platforms/web/compiler/directives/html.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/directives/html.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/directives/html.js	(revision )
@@ -0,0 +1,9 @@
+/* @flow */
+
+import { addProp } from 'compiler/helpers'
+
+export default function html (el: ASTElement, dir: ASTDirective) {
+  if (dir.value) {
+    addProp(el, 'innerHTML', `_s(${dir.value})`)
+  }
+}
Index: public/node_modules/vue/src/entries/weex-framework.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/entries/weex-framework.js	(revision )
+++ public/node_modules/vue/src/entries/weex-framework.js	(revision )
@@ -0,0 +1,1 @@
+export * from 'weex/framework'
Index: public/node_modules/vue/src/platforms/weex/runtime/components/transition.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/components/transition.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/components/transition.js	(revision )
@@ -0,0 +1,9 @@
+// reuse same transition component logic from web
+export {
+  transitionProps,
+  extractTransitionData
+} from 'web/runtime/components/transition'
+
+import Transition from 'web/runtime/components/transition'
+
+export default Transition
Index: public/node_modules/vue/src/compiler/parser/text-parser.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/parser/text-parser.js	(revision )
+++ public/node_modules/vue/src/compiler/parser/text-parser.js	(revision )
@@ -0,0 +1,41 @@
+/* @flow */
+
+import { cached } from 'shared/util'
+import { parseFilters } from './filter-parser'
+
+const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
+const regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g
+
+const buildRegex = cached(delimiters => {
+  const open = delimiters[0].replace(regexEscapeRE, '\\$&')
+  const close = delimiters[1].replace(regexEscapeRE, '\\$&')
+  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
+})
+
+export function parseText (
+  text: string,
+  delimiters?: [string, string]
+): string | void {
+  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
+  if (!tagRE.test(text)) {
+    return
+  }
+  const tokens = []
+  let lastIndex = tagRE.lastIndex = 0
+  let match, index
+  while ((match = tagRE.exec(text))) {
+    index = match.index
+    // push text token
+    if (index > lastIndex) {
+      tokens.push(JSON.stringify(text.slice(lastIndex, index)))
+    }
+    // tag token
+    const exp = parseFilters(match[1].trim())
+    tokens.push(`_s(${exp})`)
+    lastIndex = index + match[0].length
+  }
+  if (lastIndex < text.length) {
+    tokens.push(JSON.stringify(text.slice(lastIndex)))
+  }
+  return tokens.join('+')
+}
Index: public/node_modules/vue/src/platforms/web/util/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/util/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/util/index.js	(revision )
@@ -0,0 +1,25 @@
+/* @flow */
+
+import { warn } from 'core/util/index'
+
+export * from './attrs'
+export * from './class'
+export * from './element'
+
+/**
+ * Query an element selector if it's not an element already.
+ */
+export function query (el: string | Element): Element {
+  if (typeof el === 'string') {
+    const selected = document.querySelector(el)
+    if (!selected) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'Cannot find element: ' + el
+      )
+      return document.createElement('div')
+    }
+    return selected
+  } else {
+    return el
+  }
+}
Index: public/node_modules/vue/src/platforms/web/server/modules/attrs.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/modules/attrs.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/modules/attrs.js	(revision )
@@ -0,0 +1,46 @@
+/* @flow */
+
+import {
+  isBooleanAttr,
+  isEnumeratedAttr,
+  isFalsyAttrValue
+} from 'web/util/attrs'
+
+export default function renderAttrs (node: VNodeWithData): string {
+  let attrs = node.data.attrs
+  let res = ''
+
+  let parent = node.parent
+  while (parent) {
+    if (parent.data && parent.data.attrs) {
+      attrs = Object.assign({}, attrs, parent.data.attrs)
+    }
+    parent = parent.parent
+  }
+
+  if (!attrs) {
+    return res
+  }
+
+  for (const key in attrs) {
+    if (key === 'style') {
+      // leave it to the style module
+      continue
+    }
+    res += renderAttr(key, attrs[key])
+  }
+  return res
+}
+
+export function renderAttr (key: string, value: string): string {
+  if (isBooleanAttr(key)) {
+    if (!isFalsyAttrValue(value)) {
+      return ` ${key}="${key}"`
+    }
+  } else if (isEnumeratedAttr(key)) {
+    return ` ${key}="${isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true'}"`
+  } else if (!isFalsyAttrValue(value)) {
+    return ` ${key}="${value}"`
+  }
+  return ''
+}
Index: public/node_modules/vue-resource/src/lib/url-template.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/lib/url-template.js	(revision )
+++ public/node_modules/vue-resource/src/lib/url-template.js	(revision )
@@ -0,0 +1,150 @@
+/**
+ * URL Template v2.0.6 (https://github.com/bramstein/url-template)
+ */
+
+export function expand(url, params, variables) {
+
+    var tmpl = parse(url), expanded = tmpl.expand(params);
+
+    if (variables) {
+        variables.push.apply(variables, tmpl.vars);
+    }
+
+    return expanded;
+}
+
+export function parse(template) {
+
+    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];
+
+    return {
+        vars: variables,
+        expand(context) {
+            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, (_, expression, literal) => {
+                if (expression) {
+
+                    var operator = null, values = [];
+
+                    if (operators.indexOf(expression.charAt(0)) !== -1) {
+                        operator = expression.charAt(0);
+                        expression = expression.substr(1);
+                    }
+
+                    expression.split(/,/g).forEach((variable) => {
+                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
+                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
+                        variables.push(tmp[1]);
+                    });
+
+                    if (operator && operator !== '+') {
+
+                        var separator = ',';
+
+                        if (operator === '?') {
+                            separator = '&';
+                        } else if (operator !== '#') {
+                            separator = operator;
+                        }
+
+                        return (values.length !== 0 ? operator : '') + values.join(separator);
+                    } else {
+                        return values.join(',');
+                    }
+
+                } else {
+                    return encodeReserved(literal);
+                }
+            });
+        }
+    };
+}
+
+function getValues(context, operator, key, modifier) {
+
+    var value = context[key], result = [];
+
+    if (isDefined(value) && value !== '') {
+        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
+            value = value.toString();
+
+            if (modifier && modifier !== '*') {
+                value = value.substring(0, parseInt(modifier, 10));
+            }
+
+            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+        } else {
+            if (modifier === '*') {
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach((value) => {
+                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+                    });
+                } else {
+                    Object.keys(value).forEach((k) => {
+                        if (isDefined(value[k])) {
+                            result.push(encodeValue(operator, value[k], k));
+                        }
+                    });
+                }
+            } else {
+                var tmp = [];
+
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach((value) => {
+                        tmp.push(encodeValue(operator, value));
+                    });
+                } else {
+                    Object.keys(value).forEach((k) => {
+                        if (isDefined(value[k])) {
+                            tmp.push(encodeURIComponent(k));
+                            tmp.push(encodeValue(operator, value[k].toString()));
+                        }
+                    });
+                }
+
+                if (isKeyOperator(operator)) {
+                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
+                } else if (tmp.length !== 0) {
+                    result.push(tmp.join(','));
+                }
+            }
+        }
+    } else {
+        if (operator === ';') {
+            result.push(encodeURIComponent(key));
+        } else if (value === '' && (operator === '&' || operator === '?')) {
+            result.push(encodeURIComponent(key) + '=');
+        } else if (value === '') {
+            result.push('');
+        }
+    }
+
+    return result;
+}
+
+function isDefined(value) {
+    return value !== undefined && value !== null;
+}
+
+function isKeyOperator(operator) {
+    return operator === ';' || operator === '&' || operator === '?';
+}
+
+function encodeValue(operator, value, key) {
+
+    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);
+
+    if (key) {
+        return encodeURIComponent(key) + '=' + value;
+    } else {
+        return value;
+    }
+}
+
+function encodeReserved(str) {
+    return str.split(/(%[0-9A-Fa-f]{2})/g).map((part) => {
+        if (!/%[0-9A-Fa-f]/.test(part)) {
+            part = encodeURI(part);
+        }
+        return part;
+    }).join('');
+}
Index: public/node_modules/vue/src/compiler/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/index.js	(revision )
+++ public/node_modules/vue/src/compiler/index.js	(revision )
@@ -0,0 +1,159 @@
+/* @flow */
+
+import { parse } from './parser/index'
+import { optimize } from './optimizer'
+import { generate } from './codegen/index'
+import { detectErrors } from './error-detector'
+import { extend, noop } from 'shared/util'
+import { warn, tip } from 'core/util/debug'
+
+function baseCompile (
+  template: string,
+  options: CompilerOptions
+): CompiledResult {
+  const ast = parse(template.trim(), options)
+  optimize(ast, options)
+  const code = generate(ast, options)
+  return {
+    ast,
+    render: code.render,
+    staticRenderFns: code.staticRenderFns
+  }
+}
+
+function makeFunction (code, errors) {
+  try {
+    return new Function(code)
+  } catch (err) {
+    errors.push({ err, code })
+    return noop
+  }
+}
+
+export function createCompiler (baseOptions: CompilerOptions) {
+  const functionCompileCache: {
+    [key: string]: CompiledFunctionResult;
+  } = Object.create(null)
+
+  function compile (
+    template: string,
+    options?: CompilerOptions
+  ): CompiledResult {
+    const finalOptions = Object.create(baseOptions)
+    const errors = []
+    const tips = []
+    finalOptions.warn = (msg, tip) => {
+      (tip ? tips : errors).push(msg)
+    }
+
+    if (options) {
+      // merge custom modules
+      if (options.modules) {
+        finalOptions.modules = (baseOptions.modules || []).concat(options.modules)
+      }
+      // merge custom directives
+      if (options.directives) {
+        finalOptions.directives = extend(
+          Object.create(baseOptions.directives),
+          options.directives
+        )
+      }
+      // copy other options
+      for (const key in options) {
+        if (key !== 'modules' && key !== 'directives') {
+          finalOptions[key] = options[key]
+        }
+      }
+    }
+
+    const compiled = baseCompile(template, finalOptions)
+    if (process.env.NODE_ENV !== 'production') {
+      errors.push.apply(errors, detectErrors(compiled.ast))
+    }
+    compiled.errors = errors
+    compiled.tips = tips
+    return compiled
+  }
+
+  function compileToFunctions (
+    template: string,
+    options?: CompilerOptions,
+    vm?: Component
+  ): CompiledFunctionResult {
+    options = options || {}
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      // detect possible CSP restriction
+      try {
+        new Function('return 1')
+      } catch (e) {
+        if (e.toString().match(/unsafe-eval|CSP/)) {
+          warn(
+            'It seems you are using the standalone build of Vue.js in an ' +
+            'environment with Content Security Policy that prohibits unsafe-eval. ' +
+            'The template compiler cannot work in this environment. Consider ' +
+            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
+            'templates into render functions.'
+          )
+        }
+      }
+    }
+
+    // check cache
+    const key = options.delimiters
+      ? String(options.delimiters) + template
+      : template
+    if (functionCompileCache[key]) {
+      return functionCompileCache[key]
+    }
+
+    // compile
+    const compiled = compile(template, options)
+
+    // check compilation errors/tips
+    if (process.env.NODE_ENV !== 'production') {
+      if (compiled.errors && compiled.errors.length) {
+        warn(
+          `Error compiling template:\n\n${template}\n\n` +
+          compiled.errors.map(e => `- ${e}`).join('\n') + '\n',
+          vm
+        )
+      }
+      if (compiled.tips && compiled.tips.length) {
+        compiled.tips.forEach(msg => tip(msg, vm))
+      }
+    }
+
+    // turn code into functions
+    const res = {}
+    const fnGenErrors = []
+    res.render = makeFunction(compiled.render, fnGenErrors)
+    const l = compiled.staticRenderFns.length
+    res.staticRenderFns = new Array(l)
+    for (let i = 0; i < l; i++) {
+      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors)
+    }
+
+    // check function generation errors.
+    // this should only happen if there is a bug in the compiler itself.
+    // mostly for codegen development use
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
+        warn(
+          `Failed to generate render function:\n\n` +
+          fnGenErrors.map(({ err, code }) => `${err.toString()} in\n\n${code}\n`).join('\n'),
+          vm
+        )
+      }
+    }
+
+    return (functionCompileCache[key] = res)
+  }
+
+  return {
+    compile,
+    compileToFunctions
+  }
+}
Index: public/node_modules/vue/src/compiler/codegen/events.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/codegen/events.js	(revision )
+++ public/node_modules/vue/src/compiler/codegen/events.js	(revision )
@@ -0,0 +1,101 @@
+/* @flow */
+
+const fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/
+const simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/
+
+// keyCode aliases
+const keyCodes: { [key: string]: number | Array<number> } = {
+  esc: 27,
+  tab: 9,
+  enter: 13,
+  space: 32,
+  up: 38,
+  left: 37,
+  right: 39,
+  down: 40,
+  'delete': [8, 46]
+}
+
+// #4868: modifiers that prevent the execution of the listener
+// need to explicitly return null so that we can determine whether to remove
+// the listener for .once
+const genGuard = condition => `if(${condition})return null;`
+
+const modifierCode: { [key: string]: string } = {
+  stop: '$event.stopPropagation();',
+  prevent: '$event.preventDefault();',
+  self: genGuard(`$event.target !== $event.currentTarget`),
+  ctrl: genGuard(`!$event.ctrlKey`),
+  shift: genGuard(`!$event.shiftKey`),
+  alt: genGuard(`!$event.altKey`),
+  meta: genGuard(`!$event.metaKey`),
+  left: genGuard(`'button' in $event && $event.button !== 0`),
+  middle: genGuard(`'button' in $event && $event.button !== 1`),
+  right: genGuard(`'button' in $event && $event.button !== 2`)
+}
+
+export function genHandlers (events: ASTElementHandlers, native?: boolean): string {
+  let res = native ? 'nativeOn:{' : 'on:{'
+  for (const name in events) {
+    res += `"${name}":${genHandler(name, events[name])},`
+  }
+  return res.slice(0, -1) + '}'
+}
+
+function genHandler (
+  name: string,
+  handler: ASTElementHandler | Array<ASTElementHandler>
+): string {
+  if (!handler) {
+    return 'function(){}'
+  }
+
+  if (Array.isArray(handler)) {
+    return `[${handler.map(handler => genHandler(name, handler)).join(',')}]`
+  }
+
+  const isMethodPath = simplePathRE.test(handler.value)
+  const isFunctionExpression = fnExpRE.test(handler.value)
+
+  if (!handler.modifiers) {
+    return isMethodPath || isFunctionExpression
+      ? handler.value
+      : `function($event){${handler.value}}` // inline statement
+  } else {
+    let code = ''
+    const keys = []
+    for (const key in handler.modifiers) {
+      if (modifierCode[key]) {
+        code += modifierCode[key]
+        // left/right
+        if (keyCodes[key]) {
+          keys.push(key)
+        }
+      } else {
+        keys.push(key)
+      }
+    }
+    if (keys.length) {
+      code += genKeyFilter(keys)
+    }
+    const handlerCode = isMethodPath
+      ? handler.value + '($event)'
+      : isFunctionExpression
+        ? `(${handler.value})($event)`
+        : handler.value
+    return `function($event){${code}${handlerCode}}`
+  }
+}
+
+function genKeyFilter (keys: Array<string>): string {
+  return `if(!('button' in $event)&&${keys.map(genFilterCode).join('&&')})return null;`
+}
+
+function genFilterCode (key: string): string {
+  const keyVal = parseInt(key, 10)
+  if (keyVal) {
+    return `$event.keyCode!==${keyVal}`
+  }
+  const alias = keyCodes[key]
+  return `_k($event.keyCode,${JSON.stringify(key)}${alias ? ',' + JSON.stringify(alias) : ''})`
+}
Index: public/node_modules/vue/src/platforms/web/util/element.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/util/element.js	(revision )
+++ public/node_modules/vue/src/platforms/web/util/element.js	(revision )
@@ -0,0 +1,75 @@
+/* @flow */
+
+import { inBrowser } from 'core/util/env'
+import { makeMap } from 'shared/util'
+
+export const namespaceMap = {
+  svg: 'http://www.w3.org/2000/svg',
+  math: 'http://www.w3.org/1998/Math/MathML'
+}
+
+export const isHTMLTag = makeMap(
+  'html,body,base,head,link,meta,style,title,' +
+  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
+  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
+  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
+  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
+  'embed,object,param,source,canvas,script,noscript,del,ins,' +
+  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
+  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
+  'output,progress,select,textarea,' +
+  'details,dialog,menu,menuitem,summary,' +
+  'content,element,shadow,template'
+)
+
+// this map is intentionally selective, only covering SVG elements that may
+// contain child elements.
+export const isSVG = makeMap(
+  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
+  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
+  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
+  true
+)
+
+export const isPreTag = (tag: ?string): boolean => tag === 'pre'
+
+export const isReservedTag = (tag: string): ?boolean => {
+  return isHTMLTag(tag) || isSVG(tag)
+}
+
+export function getTagNamespace (tag: string): ?string {
+  if (isSVG(tag)) {
+    return 'svg'
+  }
+  // basic support for MathML
+  // note it doesn't support other MathML elements being component roots
+  if (tag === 'math') {
+    return 'math'
+  }
+}
+
+const unknownElementCache = Object.create(null)
+export function isUnknownElement (tag: string): boolean {
+  /* istanbul ignore if */
+  if (!inBrowser) {
+    return true
+  }
+  if (isReservedTag(tag)) {
+    return false
+  }
+  tag = tag.toLowerCase()
+  /* istanbul ignore if */
+  if (unknownElementCache[tag] != null) {
+    return unknownElementCache[tag]
+  }
+  const el = document.createElement(tag)
+  if (tag.indexOf('-') > -1) {
+    // http://stackoverflow.com/a/28210364/1070244
+    return (unknownElementCache[tag] = (
+      el.constructor === window.HTMLUnknownElement ||
+      el.constructor === window.HTMLElement
+    ))
+  } else {
+    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
+  }
+}
Index: public/node_modules/vue/src/platforms/web/runtime/modules/events.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/modules/events.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/modules/events.js	(revision )
@@ -0,0 +1,74 @@
+/* @flow */
+
+import { isChrome, isIE } from 'core/util/env'
+import { updateListeners } from 'core/vdom/helpers/index'
+import { RANGE_TOKEN, CHECKBOX_RADIO_TOKEN } from 'web/compiler/directives/model'
+
+// normalize v-model event tokens that can only be determined at runtime.
+// it's important to place the event as the first in the array because
+// the whole point is ensuring the v-model callback gets called before
+// user-attached handlers.
+function normalizeEvents (on) {
+  let event
+  /* istanbul ignore if */
+  if (on[RANGE_TOKEN]) {
+    // IE input[type=range] only supports `change` event
+    event = isIE ? 'change' : 'input'
+    on[event] = [].concat(on[RANGE_TOKEN], on[event] || [])
+    delete on[RANGE_TOKEN]
+  }
+  if (on[CHECKBOX_RADIO_TOKEN]) {
+    // Chrome fires microtasks in between click/change, leads to #4521
+    event = isChrome ? 'click' : 'change'
+    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || [])
+    delete on[CHECKBOX_RADIO_TOKEN]
+  }
+}
+
+let target: HTMLElement
+
+function add (
+  event: string,
+  handler: Function,
+  once: boolean,
+  capture: boolean
+) {
+  if (once) {
+    const oldHandler = handler
+    const _target = target // save current target element in closure
+    handler = function (ev) {
+      const res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments)
+      if (res !== null) {
+        remove(event, handler, capture, _target)
+      }
+    }
+  }
+  target.addEventListener(event, handler, capture)
+}
+
+function remove (
+  event: string,
+  handler: Function,
+  capture: boolean,
+  _target?: HTMLElement
+) {
+  (_target || target).removeEventListener(event, handler, capture)
+}
+
+function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  const on = vnode.data.on || {}
+  const oldOn = oldVnode.data.on || {}
+  target = vnode.elm
+  normalizeEvents(on)
+  updateListeners(on, oldOn, add, remove, vnode.context)
+}
+
+export default {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+}
Index: public/node_modules/vue-resource/dist/vue-resource.common.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/dist/vue-resource.common.js	(revision )
+++ public/node_modules/vue-resource/dist/vue-resource.common.js	(revision )
@@ -0,0 +1,1528 @@
+/*!
+ * vue-resource v1.2.1
+ * https://github.com/pagekit/vue-resource
+ * Released under the MIT License.
+ */
+
+'use strict';
+
+/**
+ * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
+ */
+
+var RESOLVED = 0;
+var REJECTED = 1;
+var PENDING  = 2;
+
+function Promise$1(executor) {
+
+    this.state = PENDING;
+    this.value = undefined;
+    this.deferred = [];
+
+    var promise = this;
+
+    try {
+        executor(function (x) {
+            promise.resolve(x);
+        }, function (r) {
+            promise.reject(r);
+        });
+    } catch (e) {
+        promise.reject(e);
+    }
+}
+
+Promise$1.reject = function (r) {
+    return new Promise$1(function (resolve, reject) {
+        reject(r);
+    });
+};
+
+Promise$1.resolve = function (x) {
+    return new Promise$1(function (resolve, reject) {
+        resolve(x);
+    });
+};
+
+Promise$1.all = function all(iterable) {
+    return new Promise$1(function (resolve, reject) {
+        var count = 0, result = [];
+
+        if (iterable.length === 0) {
+            resolve(result);
+        }
+
+        function resolver(i) {
+            return function (x) {
+                result[i] = x;
+                count += 1;
+
+                if (count === iterable.length) {
+                    resolve(result);
+                }
+            };
+        }
+
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise$1.resolve(iterable[i]).then(resolver(i), reject);
+        }
+    });
+};
+
+Promise$1.race = function race(iterable) {
+    return new Promise$1(function (resolve, reject) {
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise$1.resolve(iterable[i]).then(resolve, reject);
+        }
+    });
+};
+
+var p$1 = Promise$1.prototype;
+
+p$1.resolve = function resolve(x) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (x === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        var called = false;
+
+        try {
+            var then = x && x['then'];
+
+            if (x !== null && typeof x === 'object' && typeof then === 'function') {
+                then.call(x, function (x) {
+                    if (!called) {
+                        promise.resolve(x);
+                    }
+                    called = true;
+
+                }, function (r) {
+                    if (!called) {
+                        promise.reject(r);
+                    }
+                    called = true;
+                });
+                return;
+            }
+        } catch (e) {
+            if (!called) {
+                promise.reject(e);
+            }
+            return;
+        }
+
+        promise.state = RESOLVED;
+        promise.value = x;
+        promise.notify();
+    }
+};
+
+p$1.reject = function reject(reason) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (reason === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        promise.state = REJECTED;
+        promise.value = reason;
+        promise.notify();
+    }
+};
+
+p$1.notify = function notify() {
+    var promise = this;
+
+    nextTick(function () {
+        if (promise.state !== PENDING) {
+            while (promise.deferred.length) {
+                var deferred = promise.deferred.shift(),
+                    onResolved = deferred[0],
+                    onRejected = deferred[1],
+                    resolve = deferred[2],
+                    reject = deferred[3];
+
+                try {
+                    if (promise.state === RESOLVED) {
+                        if (typeof onResolved === 'function') {
+                            resolve(onResolved.call(undefined, promise.value));
+                        } else {
+                            resolve(promise.value);
+                        }
+                    } else if (promise.state === REJECTED) {
+                        if (typeof onRejected === 'function') {
+                            resolve(onRejected.call(undefined, promise.value));
+                        } else {
+                            reject(promise.value);
+                        }
+                    }
+                } catch (e) {
+                    reject(e);
+                }
+            }
+        }
+    });
+};
+
+p$1.then = function then(onResolved, onRejected) {
+    var promise = this;
+
+    return new Promise$1(function (resolve, reject) {
+        promise.deferred.push([onResolved, onRejected, resolve, reject]);
+        promise.notify();
+    });
+};
+
+p$1.catch = function (onRejected) {
+    return this.then(undefined, onRejected);
+};
+
+/**
+ * Promise adapter.
+ */
+
+if (typeof Promise === 'undefined') {
+    window.Promise = Promise$1;
+}
+
+function PromiseObj(executor, context) {
+
+    if (executor instanceof Promise) {
+        this.promise = executor;
+    } else {
+        this.promise = new Promise(executor.bind(context));
+    }
+
+    this.context = context;
+}
+
+PromiseObj.all = function (iterable, context) {
+    return new PromiseObj(Promise.all(iterable), context);
+};
+
+PromiseObj.resolve = function (value, context) {
+    return new PromiseObj(Promise.resolve(value), context);
+};
+
+PromiseObj.reject = function (reason, context) {
+    return new PromiseObj(Promise.reject(reason), context);
+};
+
+PromiseObj.race = function (iterable, context) {
+    return new PromiseObj(Promise.race(iterable), context);
+};
+
+var p = PromiseObj.prototype;
+
+p.bind = function (context) {
+    this.context = context;
+    return this;
+};
+
+p.then = function (fulfilled, rejected) {
+
+    if (fulfilled && fulfilled.bind && this.context) {
+        fulfilled = fulfilled.bind(this.context);
+    }
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
+};
+
+p.catch = function (rejected) {
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.catch(rejected), this.context);
+};
+
+p.finally = function (callback) {
+
+    return this.then(function (value) {
+            callback.call(this);
+            return value;
+        }, function (reason) {
+            callback.call(this);
+            return Promise.reject(reason);
+        }
+    );
+};
+
+/**
+ * Utility functions.
+ */
+
+var ref = {};
+var hasOwnProperty = ref.hasOwnProperty;
+
+var ref$1 = [];
+var slice = ref$1.slice;
+var debug = false;
+var ntick;
+
+var inBrowser = typeof window !== 'undefined';
+
+var Util = function (ref) {
+    var config = ref.config;
+    var nextTick = ref.nextTick;
+
+    ntick = nextTick;
+    debug = config.debug || !config.silent;
+};
+
+function warn(msg) {
+    if (typeof console !== 'undefined' && debug) {
+        console.warn('[VueResource warn]: ' + msg);
+    }
+}
+
+function error(msg) {
+    if (typeof console !== 'undefined') {
+        console.error(msg);
+    }
+}
+
+function nextTick(cb, ctx) {
+    return ntick(cb, ctx);
+}
+
+function trim(str) {
+    return str ? str.replace(/^\s*|\s*$/g, '') : '';
+}
+
+function toLower(str) {
+    return str ? str.toLowerCase() : '';
+}
+
+function toUpper(str) {
+    return str ? str.toUpperCase() : '';
+}
+
+var isArray = Array.isArray;
+
+function isString(val) {
+    return typeof val === 'string';
+}
+
+
+
+function isFunction(val) {
+    return typeof val === 'function';
+}
+
+function isObject(obj) {
+    return obj !== null && typeof obj === 'object';
+}
+
+function isPlainObject(obj) {
+    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
+}
+
+function isBlob(obj) {
+    return typeof Blob !== 'undefined' && obj instanceof Blob;
+}
+
+function isFormData(obj) {
+    return typeof FormData !== 'undefined' && obj instanceof FormData;
+}
+
+function when(value, fulfilled, rejected) {
+
+    var promise = PromiseObj.resolve(value);
+
+    if (arguments.length < 2) {
+        return promise;
+    }
+
+    return promise.then(fulfilled, rejected);
+}
+
+function options(fn, obj, opts) {
+
+    opts = opts || {};
+
+    if (isFunction(opts)) {
+        opts = opts.call(obj);
+    }
+
+    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
+}
+
+function each(obj, iterator) {
+
+    var i, key;
+
+    if (isArray(obj)) {
+        for (i = 0; i < obj.length; i++) {
+            iterator.call(obj[i], obj[i], i);
+        }
+    } else if (isObject(obj)) {
+        for (key in obj) {
+            if (hasOwnProperty.call(obj, key)) {
+                iterator.call(obj[key], obj[key], key);
+            }
+        }
+    }
+
+    return obj;
+}
+
+var assign = Object.assign || _assign;
+
+function merge(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+        _merge(target, source, true);
+    });
+
+    return target;
+}
+
+function defaults(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+
+        for (var key in source) {
+            if (target[key] === undefined) {
+                target[key] = source[key];
+            }
+        }
+
+    });
+
+    return target;
+}
+
+function _assign(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+        _merge(target, source);
+    });
+
+    return target;
+}
+
+function _merge(target, source, deep) {
+    for (var key in source) {
+        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
+            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
+                target[key] = {};
+            }
+            if (isArray(source[key]) && !isArray(target[key])) {
+                target[key] = [];
+            }
+            _merge(target[key], source[key], deep);
+        } else if (source[key] !== undefined) {
+            target[key] = source[key];
+        }
+    }
+}
+
+/**
+ * Root Prefix Transform.
+ */
+
+var root = function (options$$1, next) {
+
+    var url = next(options$$1);
+
+    if (isString(options$$1.root) && !url.match(/^(https?:)?\//)) {
+        url = options$$1.root + '/' + url;
+    }
+
+    return url;
+};
+
+/**
+ * Query Parameter Transform.
+ */
+
+var query = function (options$$1, next) {
+
+    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);
+
+    each(options$$1.params, function (value, key) {
+        if (urlParams.indexOf(key) === -1) {
+            query[key] = value;
+        }
+    });
+
+    query = Url.params(query);
+
+    if (query) {
+        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
+    }
+
+    return url;
+};
+
+/**
+ * URL Template v2.0.6 (https://github.com/bramstein/url-template)
+ */
+
+function expand(url, params, variables) {
+
+    var tmpl = parse(url), expanded = tmpl.expand(params);
+
+    if (variables) {
+        variables.push.apply(variables, tmpl.vars);
+    }
+
+    return expanded;
+}
+
+function parse(template) {
+
+    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];
+
+    return {
+        vars: variables,
+        expand: function expand(context) {
+            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
+                if (expression) {
+
+                    var operator = null, values = [];
+
+                    if (operators.indexOf(expression.charAt(0)) !== -1) {
+                        operator = expression.charAt(0);
+                        expression = expression.substr(1);
+                    }
+
+                    expression.split(/,/g).forEach(function (variable) {
+                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
+                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
+                        variables.push(tmp[1]);
+                    });
+
+                    if (operator && operator !== '+') {
+
+                        var separator = ',';
+
+                        if (operator === '?') {
+                            separator = '&';
+                        } else if (operator !== '#') {
+                            separator = operator;
+                        }
+
+                        return (values.length !== 0 ? operator : '') + values.join(separator);
+                    } else {
+                        return values.join(',');
+                    }
+
+                } else {
+                    return encodeReserved(literal);
+                }
+            });
+        }
+    };
+}
+
+function getValues(context, operator, key, modifier) {
+
+    var value = context[key], result = [];
+
+    if (isDefined(value) && value !== '') {
+        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
+            value = value.toString();
+
+            if (modifier && modifier !== '*') {
+                value = value.substring(0, parseInt(modifier, 10));
+            }
+
+            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+        } else {
+            if (modifier === '*') {
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach(function (value) {
+                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+                    });
+                } else {
+                    Object.keys(value).forEach(function (k) {
+                        if (isDefined(value[k])) {
+                            result.push(encodeValue(operator, value[k], k));
+                        }
+                    });
+                }
+            } else {
+                var tmp = [];
+
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach(function (value) {
+                        tmp.push(encodeValue(operator, value));
+                    });
+                } else {
+                    Object.keys(value).forEach(function (k) {
+                        if (isDefined(value[k])) {
+                            tmp.push(encodeURIComponent(k));
+                            tmp.push(encodeValue(operator, value[k].toString()));
+                        }
+                    });
+                }
+
+                if (isKeyOperator(operator)) {
+                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
+                } else if (tmp.length !== 0) {
+                    result.push(tmp.join(','));
+                }
+            }
+        }
+    } else {
+        if (operator === ';') {
+            result.push(encodeURIComponent(key));
+        } else if (value === '' && (operator === '&' || operator === '?')) {
+            result.push(encodeURIComponent(key) + '=');
+        } else if (value === '') {
+            result.push('');
+        }
+    }
+
+    return result;
+}
+
+function isDefined(value) {
+    return value !== undefined && value !== null;
+}
+
+function isKeyOperator(operator) {
+    return operator === ';' || operator === '&' || operator === '?';
+}
+
+function encodeValue(operator, value, key) {
+
+    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);
+
+    if (key) {
+        return encodeURIComponent(key) + '=' + value;
+    } else {
+        return value;
+    }
+}
+
+function encodeReserved(str) {
+    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
+        if (!/%[0-9A-Fa-f]/.test(part)) {
+            part = encodeURI(part);
+        }
+        return part;
+    }).join('');
+}
+
+/**
+ * URL Template (RFC 6570) Transform.
+ */
+
+var template = function (options) {
+
+    var variables = [], url = expand(options.url, options.params, variables);
+
+    variables.forEach(function (key) {
+        delete options.params[key];
+    });
+
+    return url;
+};
+
+/**
+ * Service for URL templating.
+ */
+
+function Url(url, params) {
+
+    var self = this || {}, options$$1 = url, transform;
+
+    if (isString(url)) {
+        options$$1 = {url: url, params: params};
+    }
+
+    options$$1 = merge({}, Url.options, self.$options, options$$1);
+
+    Url.transforms.forEach(function (handler) {
+        transform = factory(handler, transform, self.$vm);
+    });
+
+    return transform(options$$1);
+}
+
+/**
+ * Url options.
+ */
+
+Url.options = {
+    url: '',
+    root: null,
+    params: {}
+};
+
+/**
+ * Url transforms.
+ */
+
+Url.transforms = [template, query, root];
+
+/**
+ * Encodes a Url parameter string.
+ *
+ * @param {Object} obj
+ */
+
+Url.params = function (obj) {
+
+    var params = [], escape = encodeURIComponent;
+
+    params.add = function (key, value) {
+
+        if (isFunction(value)) {
+            value = value();
+        }
+
+        if (value === null) {
+            value = '';
+        }
+
+        this.push(escape(key) + '=' + escape(value));
+    };
+
+    serialize(params, obj);
+
+    return params.join('&').replace(/%20/g, '+');
+};
+
+/**
+ * Parse a URL and return its components.
+ *
+ * @param {String} url
+ */
+
+Url.parse = function (url) {
+
+    var el = document.createElement('a');
+
+    if (document.documentMode) {
+        el.href = url;
+        url = el.href;
+    }
+
+    el.href = url;
+
+    return {
+        href: el.href,
+        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
+        port: el.port,
+        host: el.host,
+        hostname: el.hostname,
+        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
+        search: el.search ? el.search.replace(/^\?/, '') : '',
+        hash: el.hash ? el.hash.replace(/^#/, '') : ''
+    };
+};
+
+function factory(handler, next, vm) {
+    return function (options$$1) {
+        return handler.call(vm, options$$1, next);
+    };
+}
+
+function serialize(params, obj, scope) {
+
+    var array = isArray(obj), plain = isPlainObject(obj), hash;
+
+    each(obj, function (value, key) {
+
+        hash = isObject(value) || isArray(value);
+
+        if (scope) {
+            key = scope + '[' + (plain || hash ? key : '') + ']';
+        }
+
+        if (!scope && array) {
+            params.add(value.name, value.value);
+        } else if (hash) {
+            serialize(params, value, key);
+        } else {
+            params.add(key, value);
+        }
+    });
+}
+
+/**
+ * XDomain client (Internet Explorer).
+ */
+
+var xdrClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var xdr = new XDomainRequest(), handler = function (ref) {
+            var type = ref.type;
+
+
+            var status = 0;
+
+            if (type === 'load') {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            resolve(request.respondWith(xdr.responseText, {status: status}));
+        };
+
+        request.abort = function () { return xdr.abort(); };
+
+        xdr.open(request.method, request.getUrl());
+
+        if (request.timeout) {
+            xdr.timeout = request.timeout;
+        }
+
+        xdr.onload = handler;
+        xdr.onabort = handler;
+        xdr.onerror = handler;
+        xdr.ontimeout = handler;
+        xdr.onprogress = function () {};
+        xdr.send(request.getBody());
+    });
+};
+
+/**
+ * CORS Interceptor.
+ */
+
+var SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();
+
+var cors = function (request, next) {
+
+    if (inBrowser) {
+
+        var orgUrl = Url.parse(location.href);
+        var reqUrl = Url.parse(request.getUrl());
+
+        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {
+
+            request.crossOrigin = true;
+            request.emulateHTTP = false;
+
+            if (!SUPPORTS_CORS) {
+                request.client = xdrClient;
+            }
+        }
+    }
+
+    next();
+};
+
+/**
+ * Body Interceptor.
+ */
+
+var body = function (request, next) {
+
+    if (isFormData(request.body)) {
+
+        request.headers.delete('Content-Type');
+
+    } else if (isObject(request.body) || isArray(request.body)) {
+
+        if (request.emulateJSON) {
+            request.body = Url.params(request.body);
+            request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
+        } else {
+            request.body = JSON.stringify(request.body);
+        }
+    }
+
+    next(function (response) {
+
+        Object.defineProperty(response, 'data', {
+
+            get: function get() {
+                return this.body;
+            },
+
+            set: function set(body) {
+                this.body = body;
+            }
+
+        });
+
+        return response.bodyText ? when(response.text(), function (text) {
+
+            var type = response.headers.get('Content-Type') || '';
+
+            if (type.indexOf('application/json') === 0 || isJson(text)) {
+
+                try {
+                    response.body = JSON.parse(text);
+                } catch (e) {
+                    response.body = null;
+                }
+
+            } else {
+                response.body = text;
+            }
+
+            return response;
+
+        }) : response;
+
+    });
+};
+
+function isJson(str) {
+
+    var start = str.match(/^\[|^\{(?!\{)/), end = {'[': /]$/, '{': /}$/};
+
+    return start && end[start[0]].test(str);
+}
+
+/**
+ * JSONP client (Browser).
+ */
+
+var jsonpClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;
+
+        handler = function (ref) {
+            var type = ref.type;
+
+
+            var status = 0;
+
+            if (type === 'load' && body !== null) {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            if (status && window[callback]) {
+                delete window[callback];
+                document.body.removeChild(script);
+            }
+
+            resolve(request.respondWith(body, {status: status}));
+        };
+
+        window[callback] = function (result) {
+            body = JSON.stringify(result);
+        };
+
+        request.abort = function () {
+            handler({type: 'abort'});
+        };
+
+        request.params[name] = callback;
+
+        if (request.timeout) {
+            setTimeout(request.abort, request.timeout);
+        }
+
+        script = document.createElement('script');
+        script.src = request.getUrl();
+        script.type = 'text/javascript';
+        script.async = true;
+        script.onload = handler;
+        script.onerror = handler;
+
+        document.body.appendChild(script);
+    });
+};
+
+/**
+ * JSONP Interceptor.
+ */
+
+var jsonp = function (request, next) {
+
+    if (request.method == 'JSONP') {
+        request.client = jsonpClient;
+    }
+
+    next();
+};
+
+/**
+ * Before Interceptor.
+ */
+
+var before = function (request, next) {
+
+    if (isFunction(request.before)) {
+        request.before.call(this, request);
+    }
+
+    next();
+};
+
+/**
+ * HTTP method override Interceptor.
+ */
+
+var method = function (request, next) {
+
+    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
+        request.headers.set('X-HTTP-Method-Override', request.method);
+        request.method = 'POST';
+    }
+
+    next();
+};
+
+/**
+ * Header Interceptor.
+ */
+
+var header = function (request, next) {
+
+    var headers = assign({}, Http.headers.common,
+        !request.crossOrigin ? Http.headers.custom : {},
+        Http.headers[toLower(request.method)]
+    );
+
+    each(headers, function (value, name) {
+        if (!request.headers.has(name)) {
+            request.headers.set(name, value);
+        }
+    });
+
+    next();
+};
+
+/**
+ * XMLHttp client (Browser).
+ */
+
+var SUPPORTS_BLOB = typeof Blob !== 'undefined' && typeof FileReader !== 'undefined';
+
+var xhrClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var xhr = new XMLHttpRequest(), handler = function (event) {
+
+            var response = request.respondWith(
+                'response' in xhr ? xhr.response : xhr.responseText, {
+                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
+                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
+                }
+            );
+
+            each(trim(xhr.getAllResponseHeaders()).split('\n'), function (row) {
+                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
+            });
+
+            resolve(response);
+        };
+
+        request.abort = function () { return xhr.abort(); };
+
+        if (request.progress) {
+            if (request.method === 'GET') {
+                xhr.addEventListener('progress', request.progress);
+            } else if (/^(POST|PUT)$/i.test(request.method)) {
+                xhr.upload.addEventListener('progress', request.progress);
+            }
+        }
+
+        xhr.open(request.method, request.getUrl(), true);
+
+        if (request.timeout) {
+            xhr.timeout = request.timeout;
+        }
+
+        if (request.credentials === true) {
+            xhr.withCredentials = true;
+        }
+
+        if (!request.crossOrigin) {
+            request.headers.set('X-Requested-With', 'XMLHttpRequest');
+        }
+
+        if ('responseType' in xhr && SUPPORTS_BLOB) {
+            xhr.responseType = 'blob';
+        }
+
+        request.headers.forEach(function (value, name) {
+            xhr.setRequestHeader(name, value);
+        });
+
+        xhr.onload = handler;
+        xhr.onabort = handler;
+        xhr.onerror = handler;
+        xhr.ontimeout = handler;
+        xhr.send(request.getBody());
+    });
+};
+
+/**
+ * Http client (Node).
+ */
+
+var nodeClient = function (request) {
+
+    var client = require('got');
+
+    return new PromiseObj(function (resolve) {
+
+        var url = request.getUrl();
+        var body = request.getBody();
+        var method = request.method;
+        var headers = {}, handler;
+
+        request.headers.forEach(function (value, name) {
+            headers[name] = value;
+        });
+
+        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {
+
+            var response = request.respondWith(resp.body, {
+                    status: resp.statusCode,
+                    statusText: trim(resp.statusMessage)
+                }
+            );
+
+            each(resp.headers, function (value, name) {
+                response.headers.set(name, value);
+            });
+
+            resolve(response);
+
+        }, function (error$$1) { return handler(error$$1.response); });
+    });
+};
+
+/**
+ * Base client.
+ */
+
+var Client = function (context) {
+
+    var reqHandlers = [sendRequest], resHandlers = [], handler;
+
+    if (!isObject(context)) {
+        context = null;
+    }
+
+    function Client(request) {
+        return new PromiseObj(function (resolve) {
+
+            function exec() {
+
+                handler = reqHandlers.pop();
+
+                if (isFunction(handler)) {
+                    handler.call(context, request, next);
+                } else {
+                    warn(("Invalid interceptor of type " + (typeof handler) + ", must be a function"));
+                    next();
+                }
+            }
+
+            function next(response) {
+
+                if (isFunction(response)) {
+
+                    resHandlers.unshift(response);
+
+                } else if (isObject(response)) {
+
+                    resHandlers.forEach(function (handler) {
+                        response = when(response, function (response) {
+                            return handler.call(context, response) || response;
+                        });
+                    });
+
+                    when(response, resolve);
+
+                    return;
+                }
+
+                exec();
+            }
+
+            exec();
+
+        }, context);
+    }
+
+    Client.use = function (handler) {
+        reqHandlers.push(handler);
+    };
+
+    return Client;
+};
+
+function sendRequest(request, resolve) {
+
+    var client = request.client || (inBrowser ? xhrClient : nodeClient);
+
+    resolve(client(request));
+}
+
+/**
+ * HTTP Headers.
+ */
+
+var Headers = function Headers(headers) {
+    var this$1 = this;
+
+
+    this.map = {};
+
+    each(headers, function (value, name) { return this$1.append(name, value); });
+};
+
+Headers.prototype.has = function has (name) {
+    return getName(this.map, name) !== null;
+};
+
+Headers.prototype.get = function get (name) {
+
+    var list = this.map[getName(this.map, name)];
+
+    return list ? list.join() : null;
+};
+
+Headers.prototype.getAll = function getAll (name) {
+    return this.map[getName(this.map, name)] || [];
+};
+
+Headers.prototype.set = function set (name, value) {
+    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
+};
+
+Headers.prototype.append = function append (name, value){
+
+    var list = this.map[getName(this.map, name)];
+
+    if (list) {
+        list.push(trim(value));
+    } else {
+        this.set(name, value);
+    }
+};
+
+Headers.prototype.delete = function delete$1 (name){
+    delete this.map[getName(this.map, name)];
+};
+
+Headers.prototype.deleteAll = function deleteAll (){
+    this.map = {};
+};
+
+Headers.prototype.forEach = function forEach (callback, thisArg) {
+        var this$1 = this;
+
+    each(this.map, function (list, name) {
+        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });
+    });
+};
+
+function getName(map, name) {
+    return Object.keys(map).reduce(function (prev, curr) {
+        return toLower(name) === toLower(curr) ? curr : prev;
+    }, null);
+}
+
+function normalizeName(name) {
+
+    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
+        throw new TypeError('Invalid character in header field name');
+    }
+
+    return trim(name);
+}
+
+/**
+ * HTTP Response.
+ */
+
+var Response = function Response(body, ref) {
+    var url = ref.url;
+    var headers = ref.headers;
+    var status = ref.status;
+    var statusText = ref.statusText;
+
+
+    this.url = url;
+    this.ok = status >= 200 && status < 300;
+    this.status = status || 0;
+    this.statusText = statusText || '';
+    this.headers = new Headers(headers);
+    this.body = body;
+
+    if (isString(body)) {
+
+        this.bodyText = body;
+
+    } else if (isBlob(body)) {
+
+        this.bodyBlob = body;
+
+        if (isBlobText(body)) {
+            this.bodyText = blobText(body);
+        }
+    }
+};
+
+Response.prototype.blob = function blob () {
+    return when(this.bodyBlob);
+};
+
+Response.prototype.text = function text () {
+    return when(this.bodyText);
+};
+
+Response.prototype.json = function json () {
+    return when(this.text(), function (text) { return JSON.parse(text); });
+};
+
+function blobText(body) {
+    return new PromiseObj(function (resolve) {
+
+        var reader = new FileReader();
+
+        reader.readAsText(body);
+        reader.onload = function () {
+            resolve(reader.result);
+        };
+
+    });
+}
+
+function isBlobText(body) {
+    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
+}
+
+/**
+ * HTTP Request.
+ */
+
+var Request = function Request(options$$1) {
+
+    this.body = null;
+    this.params = {};
+
+    assign(this, options$$1, {
+        method: toUpper(options$$1.method || 'GET')
+    });
+
+    if (!(this.headers instanceof Headers)) {
+        this.headers = new Headers(this.headers);
+    }
+};
+
+Request.prototype.getUrl = function getUrl (){
+    return Url(this);
+};
+
+Request.prototype.getBody = function getBody (){
+    return this.body;
+};
+
+Request.prototype.respondWith = function respondWith (body, options$$1) {
+    return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));
+};
+
+/**
+ * Service for sending network requests.
+ */
+
+var COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
+var JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};
+
+function Http(options$$1) {
+
+    var self = this || {}, client = Client(self.$vm);
+
+    defaults(options$$1 || {}, self.$options, Http.options);
+
+    Http.interceptors.forEach(function (handler) {
+        client.use(handler);
+    });
+
+    return client(new Request(options$$1)).then(function (response) {
+
+        return response.ok ? response : PromiseObj.reject(response);
+
+    }, function (response) {
+
+        if (response instanceof Error) {
+            error(response);
+        }
+
+        return PromiseObj.reject(response);
+    });
+}
+
+Http.options = {};
+
+Http.headers = {
+    put: JSON_CONTENT_TYPE,
+    post: JSON_CONTENT_TYPE,
+    patch: JSON_CONTENT_TYPE,
+    delete: JSON_CONTENT_TYPE,
+    common: COMMON_HEADERS,
+    custom: {}
+};
+
+Http.interceptors = [before, method, body, jsonp, header, cors];
+
+['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {
+
+    Http[method$$1] = function (url, options$$1) {
+        return this(assign(options$$1 || {}, {url: url, method: method$$1}));
+    };
+
+});
+
+['post', 'put', 'patch'].forEach(function (method$$1) {
+
+    Http[method$$1] = function (url, body$$1, options$$1) {
+        return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body$$1}));
+    };
+
+});
+
+/**
+ * Service for interacting with RESTful services.
+ */
+
+function Resource(url, params, actions, options$$1) {
+
+    var self = this || {}, resource = {};
+
+    actions = assign({},
+        Resource.actions,
+        actions
+    );
+
+    each(actions, function (action, name) {
+
+        action = merge({url: url, params: assign({}, params)}, options$$1, action);
+
+        resource[name] = function () {
+            return (self.$http || Http)(opts(action, arguments));
+        };
+    });
+
+    return resource;
+}
+
+function opts(action, args) {
+
+    var options$$1 = assign({}, action), params = {}, body;
+
+    switch (args.length) {
+
+        case 2:
+
+            params = args[0];
+            body = args[1];
+
+            break;
+
+        case 1:
+
+            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
+                body = args[0];
+            } else {
+                params = args[0];
+            }
+
+            break;
+
+        case 0:
+
+            break;
+
+        default:
+
+            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
+    }
+
+    options$$1.body = body;
+    options$$1.params = assign({}, options$$1.params, params);
+
+    return options$$1;
+}
+
+Resource.actions = {
+
+    get: {method: 'GET'},
+    save: {method: 'POST'},
+    query: {method: 'GET'},
+    update: {method: 'PUT'},
+    remove: {method: 'DELETE'},
+    delete: {method: 'DELETE'}
+
+};
+
+/**
+ * Install plugin.
+ */
+
+function plugin(Vue) {
+
+    if (plugin.installed) {
+        return;
+    }
+
+    Util(Vue);
+
+    Vue.url = Url;
+    Vue.http = Http;
+    Vue.resource = Resource;
+    Vue.Promise = PromiseObj;
+
+    Object.defineProperties(Vue.prototype, {
+
+        $url: {
+            get: function get() {
+                return options(Vue.url, this, this.$options.url);
+            }
+        },
+
+        $http: {
+            get: function get() {
+                return options(Vue.http, this, this.$options.http);
+            }
+        },
+
+        $resource: {
+            get: function get() {
+                return Vue.resource.bind(this);
+            }
+        },
+
+        $promise: {
+            get: function get() {
+                var this$1 = this;
+
+                return function (executor) { return new Vue.Promise(executor, this$1); };
+            }
+        }
+
+    });
+}
+
+if (typeof window !== 'undefined' && window.Vue) {
+    window.Vue.use(plugin);
+}
+
+module.exports = plugin;
Index: public/node_modules/vue/src/platforms/web/runtime/directives/show.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/directives/show.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/directives/show.js	(revision )
@@ -0,0 +1,61 @@
+/* @flow */
+
+import { isIE9 } from 'core/util/env'
+import { enter, leave } from '../modules/transition'
+
+// recursively search for possible transition defined inside the component root
+function locateNode (vnode: VNode): VNodeWithData {
+  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
+    ? locateNode(vnode.componentInstance._vnode)
+    : vnode
+}
+
+export default {
+  bind (el: any, { value }: VNodeDirective, vnode: VNodeWithData) {
+    vnode = locateNode(vnode)
+    const transition = vnode.data && vnode.data.transition
+    const originalDisplay = el.__vOriginalDisplay =
+      el.style.display === 'none' ? '' : el.style.display
+    if (value && transition && !isIE9) {
+      vnode.data.show = true
+      enter(vnode, () => {
+        el.style.display = originalDisplay
+      })
+    } else {
+      el.style.display = value ? originalDisplay : 'none'
+    }
+  },
+
+  update (el: any, { value, oldValue }: VNodeDirective, vnode: VNodeWithData) {
+    /* istanbul ignore if */
+    if (value === oldValue) return
+    vnode = locateNode(vnode)
+    const transition = vnode.data && vnode.data.transition
+    if (transition && !isIE9) {
+      vnode.data.show = true
+      if (value) {
+        enter(vnode, () => {
+          el.style.display = el.__vOriginalDisplay
+        })
+      } else {
+        leave(vnode, () => {
+          el.style.display = 'none'
+        })
+      }
+    } else {
+      el.style.display = value ? el.__vOriginalDisplay : 'none'
+    }
+  },
+
+  unbind (
+    el: any,
+    binding: VNodeDirective,
+    vnode: VNodeWithData,
+    oldVnode: VNodeWithData,
+    isDestroy: boolean
+  ) {
+    if (!isDestroy) {
+      el.style.display = el.__vOriginalDisplay
+    }
+  }
+}
Index: public/node_modules/vue/src/core/vdom/modules/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/modules/index.js	(revision )
+++ public/node_modules/vue/src/core/vdom/modules/index.js	(revision )
@@ -0,0 +1,7 @@
+import directives from './directives'
+import ref from './ref'
+
+export default [
+  ref,
+  directives
+]
Index: public/node_modules/vue/src/entries/web-compiler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/entries/web-compiler.js	(revision )
+++ public/node_modules/vue/src/entries/web-compiler.js	(revision )
@@ -0,0 +1,4 @@
+/* @flow */
+
+export { parseComponent } from 'sfc/parser'
+export { compile, compileToFunctions } from 'web/compiler/index'
Index: public/node_modules/vue-resource/yarn.lock
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/yarn.lock	(revision )
+++ public/node_modules/vue-resource/yarn.lock	(revision )
@@ -0,0 +1,3083 @@
+# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
+# yarn lockfile v1
+
+
+abab@^1.0.3:
+  version "1.0.3"
+  resolved "https://registry.yarnpkg.com/abab/-/abab-1.0.3.tgz#b81de5f7274ec4e756d797cd834f303642724e5d"
+
+abbrev@1:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/abbrev/-/abbrev-1.1.0.tgz#d0554c2256636e2f56e7c2e5ad183f859428d81f"
+
+acorn-dynamic-import@^2.0.0:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/acorn-dynamic-import/-/acorn-dynamic-import-2.0.1.tgz#23f671eb6e650dab277fef477c321b1178a8cca2"
+  dependencies:
+    acorn "^4.0.3"
+
+acorn-globals@^3.1.0:
+  version "3.1.0"
+  resolved "https://registry.yarnpkg.com/acorn-globals/-/acorn-globals-3.1.0.tgz#fd8270f71fbb4996b004fa880ee5d46573a731bf"
+  dependencies:
+    acorn "^4.0.4"
+
+acorn-jsx@^3.0.1:
+  version "3.0.1"
+  resolved "https://registry.yarnpkg.com/acorn-jsx/-/acorn-jsx-3.0.1.tgz#afdf9488fb1ecefc8348f6fb22f464e32a58b36b"
+  dependencies:
+    acorn "^3.0.4"
+
+acorn-object-spread@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/acorn-object-spread/-/acorn-object-spread-1.0.0.tgz#48ead0f4a8eb16995a17a0db9ffc6acaada4ba68"
+  dependencies:
+    acorn "^3.1.0"
+
+acorn@^3.0.4, acorn@^3.1.0, acorn@^3.3.0:
+  version "3.3.0"
+  resolved "https://registry.yarnpkg.com/acorn/-/acorn-3.3.0.tgz#45e37fb39e8da3f25baee3ff5369e2bb5f22017a"
+
+acorn@^4.0.3, acorn@^4.0.4:
+  version "4.0.11"
+  resolved "https://registry.yarnpkg.com/acorn/-/acorn-4.0.11.tgz#edcda3bd937e7556410d42ed5860f67399c794c0"
+
+ajv-keywords@^1.1.1:
+  version "1.5.1"
+  resolved "https://registry.yarnpkg.com/ajv-keywords/-/ajv-keywords-1.5.1.tgz#314dd0a4b3368fad3dfcdc54ede6171b886daf3c"
+
+ajv@^4.7.0:
+  version "4.11.3"
+  resolved "https://registry.yarnpkg.com/ajv/-/ajv-4.11.3.tgz#ce30bdb90d1254f762c75af915fb3a63e7183d22"
+  dependencies:
+    co "^4.6.0"
+    json-stable-stringify "^1.0.1"
+
+align-text@^0.1.1, align-text@^0.1.3:
+  version "0.1.4"
+  resolved "https://registry.yarnpkg.com/align-text/-/align-text-0.1.4.tgz#0cd90a561093f35d0a99256c22b7069433fad117"
+  dependencies:
+    kind-of "^3.0.2"
+    longest "^1.0.1"
+    repeat-string "^1.5.2"
+
+amdefine@>=0.0.4:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/amdefine/-/amdefine-1.0.1.tgz#4a5282ac164729e93619bcfd3ad151f817ce91f5"
+
+ansi-escapes@^1.1.0, ansi-escapes@^1.4.0:
+  version "1.4.0"
+  resolved "https://registry.yarnpkg.com/ansi-escapes/-/ansi-escapes-1.4.0.tgz#d3a8a83b319aa67793662b13e761c7911422306e"
+
+ansi-regex@^2.0.0:
+  version "2.1.1"
+  resolved "https://registry.yarnpkg.com/ansi-regex/-/ansi-regex-2.1.1.tgz#c3b33ab5ee360d86e0e628f0468ae7ef27d654df"
+
+ansi-styles@^2.2.1:
+  version "2.2.1"
+  resolved "https://registry.yarnpkg.com/ansi-styles/-/ansi-styles-2.2.1.tgz#b432dd3358b634cf75e1e4664368240533c1ddbe"
+
+ansi-styles@^3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/ansi-styles/-/ansi-styles-3.0.0.tgz#5404e93a544c4fec7f048262977bebfe3155e0c1"
+  dependencies:
+    color-convert "^1.0.0"
+
+anymatch@^1.3.0:
+  version "1.3.0"
+  resolved "https://registry.yarnpkg.com/anymatch/-/anymatch-1.3.0.tgz#a3e52fa39168c825ff57b0248126ce5a8ff95507"
+  dependencies:
+    arrify "^1.0.0"
+    micromatch "^2.1.5"
+
+append-transform@^0.4.0:
+  version "0.4.0"
+  resolved "https://registry.yarnpkg.com/append-transform/-/append-transform-0.4.0.tgz#d76ebf8ca94d276e247a36bad44a4b74ab611991"
+  dependencies:
+    default-require-extensions "^1.0.0"
+
+aproba@^1.0.3:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/aproba/-/aproba-1.1.1.tgz#95d3600f07710aa0e9298c726ad5ecf2eacbabab"
+
+are-we-there-yet@~1.1.2:
+  version "1.1.2"
+  resolved "https://registry.yarnpkg.com/are-we-there-yet/-/are-we-there-yet-1.1.2.tgz#80e470e95a084794fe1899262c5667c6e88de1b3"
+  dependencies:
+    delegates "^1.0.0"
+    readable-stream "^2.0.0 || ^1.1.13"
+
+argparse@^1.0.7:
+  version "1.0.9"
+  resolved "https://registry.yarnpkg.com/argparse/-/argparse-1.0.9.tgz#73d83bc263f86e97f8cc4f6bae1b0e90a7d22c86"
+  dependencies:
+    sprintf-js "~1.0.2"
+
+arr-diff@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/arr-diff/-/arr-diff-2.0.0.tgz#8f3b827f955a8bd669697e4a4256ac3ceae356cf"
+  dependencies:
+    arr-flatten "^1.0.1"
+
+arr-flatten@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/arr-flatten/-/arr-flatten-1.0.1.tgz#e5ffe54d45e19f32f216e91eb99c8ce892bb604b"
+
+array-equal@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/array-equal/-/array-equal-1.0.0.tgz#8c2a5ef2472fd9ea742b04c77a75093ba2757c93"
+
+array-unique@^0.2.1:
+  version "0.2.1"
+  resolved "https://registry.yarnpkg.com/array-unique/-/array-unique-0.2.1.tgz#a1d97ccafcbc2625cc70fadceb36a50c58b01a53"
+
+arrify@^1.0.0, arrify@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/arrify/-/arrify-1.0.1.tgz#898508da2226f380df904728456849c1501a4b0d"
+
+asn1.js@^4.0.0:
+  version "4.9.1"
+  resolved "https://registry.yarnpkg.com/asn1.js/-/asn1.js-4.9.1.tgz#48ba240b45a9280e94748990ba597d216617fd40"
+  dependencies:
+    bn.js "^4.0.0"
+    inherits "^2.0.1"
+    minimalistic-assert "^1.0.0"
+
+asn1@~0.2.3:
+  version "0.2.3"
+  resolved "https://registry.yarnpkg.com/asn1/-/asn1-0.2.3.tgz#dac8787713c9966849fc8180777ebe9c1ddf3b86"
+
+assert-plus@^0.2.0:
+  version "0.2.0"
+  resolved "https://registry.yarnpkg.com/assert-plus/-/assert-plus-0.2.0.tgz#d74e1b87e7affc0db8aadb7021f3fe48101ab234"
+
+assert-plus@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/assert-plus/-/assert-plus-1.0.0.tgz#f12e0f3c5d77b0b1cdd9146942e4e96c1e4dd525"
+
+assert@^1.1.1:
+  version "1.4.1"
+  resolved "https://registry.yarnpkg.com/assert/-/assert-1.4.1.tgz#99912d591836b5a6f5b345c0f07eefc08fc65d91"
+  dependencies:
+    util "0.10.3"
+
+async-each@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/async-each/-/async-each-1.0.1.tgz#19d386a1d9edc6e7c1c85d388aedbcc56d33602d"
+
+async@^1.4.0, async@^1.4.2:
+  version "1.5.2"
+  resolved "https://registry.yarnpkg.com/async/-/async-1.5.2.tgz#ec6a61ae56480c0c3cb241c95618e20892f9672a"
+
+async@^2.1.2, async@^2.1.4:
+  version "2.1.5"
+  resolved "https://registry.yarnpkg.com/async/-/async-2.1.5.tgz#e587c68580994ac67fc56ff86d3ac56bdbe810bc"
+  dependencies:
+    lodash "^4.14.0"
+
+async@~0.2.6:
+  version "0.2.10"
+  resolved "https://registry.yarnpkg.com/async/-/async-0.2.10.tgz#b6bbe0b0674b9d719708ca38de8c237cb526c3d1"
+
+asynckit@^0.4.0:
+  version "0.4.0"
+  resolved "https://registry.yarnpkg.com/asynckit/-/asynckit-0.4.0.tgz#c79ed97f7f34cb8f2ba1bc9790bcc366474b4b79"
+
+aws-sign2@~0.6.0:
+  version "0.6.0"
+  resolved "https://registry.yarnpkg.com/aws-sign2/-/aws-sign2-0.6.0.tgz#14342dd38dbcc94d0e5b87d763cd63612c0e794f"
+
+aws4@^1.2.1:
+  version "1.6.0"
+  resolved "https://registry.yarnpkg.com/aws4/-/aws4-1.6.0.tgz#83ef5ca860b2b32e4a0deedee8c771b9db57471e"
+
+babel-code-frame@^6.22.0:
+  version "6.22.0"
+  resolved "https://registry.yarnpkg.com/babel-code-frame/-/babel-code-frame-6.22.0.tgz#027620bee567a88c32561574e7fd0801d33118e4"
+  dependencies:
+    chalk "^1.1.0"
+    esutils "^2.0.2"
+    js-tokens "^3.0.0"
+
+babel-core@^6.0.0, babel-core@^6.23.0:
+  version "6.23.1"
+  resolved "https://registry.yarnpkg.com/babel-core/-/babel-core-6.23.1.tgz#c143cb621bb2f621710c220c5d579d15b8a442df"
+  dependencies:
+    babel-code-frame "^6.22.0"
+    babel-generator "^6.23.0"
+    babel-helpers "^6.23.0"
+    babel-messages "^6.23.0"
+    babel-register "^6.23.0"
+    babel-runtime "^6.22.0"
+    babel-template "^6.23.0"
+    babel-traverse "^6.23.1"
+    babel-types "^6.23.0"
+    babylon "^6.11.0"
+    convert-source-map "^1.1.0"
+    debug "^2.1.1"
+    json5 "^0.5.0"
+    lodash "^4.2.0"
+    minimatch "^3.0.2"
+    path-is-absolute "^1.0.0"
+    private "^0.1.6"
+    slash "^1.0.0"
+    source-map "^0.5.0"
+
+babel-generator@^6.18.0, babel-generator@^6.23.0:
+  version "6.23.0"
+  resolved "https://registry.yarnpkg.com/babel-generator/-/babel-generator-6.23.0.tgz#6b8edab956ef3116f79d8c84c5a3c05f32a74bc5"
+  dependencies:
+    babel-messages "^6.23.0"
+    babel-runtime "^6.22.0"
+    babel-types "^6.23.0"
+    detect-indent "^4.0.0"
+    jsesc "^1.3.0"
+    lodash "^4.2.0"
+    source-map "^0.5.0"
+    trim-right "^1.0.1"
+
+babel-helpers@^6.23.0:
+  version "6.23.0"
+  resolved "https://registry.yarnpkg.com/babel-helpers/-/babel-helpers-6.23.0.tgz#4f8f2e092d0b6a8808a4bde79c27f1e2ecf0d992"
+  dependencies:
+    babel-runtime "^6.22.0"
+    babel-template "^6.23.0"
+
+babel-jest@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/babel-jest/-/babel-jest-19.0.0.tgz#59323ced99a3a84d359da219ca881074ffc6ce3f"
+  dependencies:
+    babel-core "^6.0.0"
+    babel-plugin-istanbul "^4.0.0"
+    babel-preset-jest "^19.0.0"
+
+babel-messages@^6.23.0:
+  version "6.23.0"
+  resolved "https://registry.yarnpkg.com/babel-messages/-/babel-messages-6.23.0.tgz#f3cdf4703858035b2a2951c6ec5edf6c62f2630e"
+  dependencies:
+    babel-runtime "^6.22.0"
+
+babel-plugin-istanbul@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/babel-plugin-istanbul/-/babel-plugin-istanbul-4.0.0.tgz#36bde8fbef4837e5ff0366531a2beabd7b1ffa10"
+  dependencies:
+    find-up "^2.1.0"
+    istanbul-lib-instrument "^1.4.2"
+    test-exclude "^4.0.0"
+
+babel-plugin-jest-hoist@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/babel-plugin-jest-hoist/-/babel-plugin-jest-hoist-19.0.0.tgz#4ae2a04ea612a6e73651f3fde52c178991304bea"
+
+babel-preset-jest@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/babel-preset-jest/-/babel-preset-jest-19.0.0.tgz#22d67201d02324a195811288eb38294bb3cac396"
+  dependencies:
+    babel-plugin-jest-hoist "^19.0.0"
+
+babel-register@^6.23.0:
+  version "6.23.0"
+  resolved "https://registry.yarnpkg.com/babel-register/-/babel-register-6.23.0.tgz#c9aa3d4cca94b51da34826c4a0f9e08145d74ff3"
+  dependencies:
+    babel-core "^6.23.0"
+    babel-runtime "^6.22.0"
+    core-js "^2.4.0"
+    home-or-tmp "^2.0.0"
+    lodash "^4.2.0"
+    mkdirp "^0.5.1"
+    source-map-support "^0.4.2"
+
+babel-runtime@^6.22.0:
+  version "6.23.0"
+  resolved "https://registry.yarnpkg.com/babel-runtime/-/babel-runtime-6.23.0.tgz#0a9489f144de70efb3ce4300accdb329e2fc543b"
+  dependencies:
+    core-js "^2.4.0"
+    regenerator-runtime "^0.10.0"
+
+babel-template@^6.16.0, babel-template@^6.23.0:
+  version "6.23.0"
+  resolved "https://registry.yarnpkg.com/babel-template/-/babel-template-6.23.0.tgz#04d4f270adbb3aa704a8143ae26faa529238e638"
+  dependencies:
+    babel-runtime "^6.22.0"
+    babel-traverse "^6.23.0"
+    babel-types "^6.23.0"
+    babylon "^6.11.0"
+    lodash "^4.2.0"
+
+babel-traverse@^6.18.0, babel-traverse@^6.23.0, babel-traverse@^6.23.1:
+  version "6.23.1"
+  resolved "https://registry.yarnpkg.com/babel-traverse/-/babel-traverse-6.23.1.tgz#d3cb59010ecd06a97d81310065f966b699e14f48"
+  dependencies:
+    babel-code-frame "^6.22.0"
+    babel-messages "^6.23.0"
+    babel-runtime "^6.22.0"
+    babel-types "^6.23.0"
+    babylon "^6.15.0"
+    debug "^2.2.0"
+    globals "^9.0.0"
+    invariant "^2.2.0"
+    lodash "^4.2.0"
+
+babel-types@^6.18.0, babel-types@^6.23.0:
+  version "6.23.0"
+  resolved "https://registry.yarnpkg.com/babel-types/-/babel-types-6.23.0.tgz#bb17179d7538bad38cd0c9e115d340f77e7e9acf"
+  dependencies:
+    babel-runtime "^6.22.0"
+    esutils "^2.0.2"
+    lodash "^4.2.0"
+    to-fast-properties "^1.0.1"
+
+babylon@^6.11.0, babylon@^6.13.0, babylon@^6.15.0:
+  version "6.16.1"
+  resolved "https://registry.yarnpkg.com/babylon/-/babylon-6.16.1.tgz#30c5a22f481978a9e7f8cdfdf496b11d94b404d3"
+
+balanced-match@^0.4.1:
+  version "0.4.2"
+  resolved "https://registry.yarnpkg.com/balanced-match/-/balanced-match-0.4.2.tgz#cb3f3e3c732dc0f01ee70b403f302e61d7709838"
+
+base64-js@^1.0.2:
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/base64-js/-/base64-js-1.2.0.tgz#a39992d723584811982be5e290bb6a53d86700f1"
+
+bcrypt-pbkdf@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/bcrypt-pbkdf/-/bcrypt-pbkdf-1.0.1.tgz#63bc5dcb61331b92bc05fd528953c33462a06f8d"
+  dependencies:
+    tweetnacl "^0.14.3"
+
+big.js@^3.1.3:
+  version "3.1.3"
+  resolved "https://registry.yarnpkg.com/big.js/-/big.js-3.1.3.tgz#4cada2193652eb3ca9ec8e55c9015669c9806978"
+
+binary-extensions@^1.0.0:
+  version "1.8.0"
+  resolved "https://registry.yarnpkg.com/binary-extensions/-/binary-extensions-1.8.0.tgz#48ec8d16df4377eae5fa5884682480af4d95c774"
+
+block-stream@*:
+  version "0.0.9"
+  resolved "https://registry.yarnpkg.com/block-stream/-/block-stream-0.0.9.tgz#13ebfe778a03205cfe03751481ebb4b3300c126a"
+  dependencies:
+    inherits "~2.0.0"
+
+bluebird@^3.1.2:
+  version "3.4.7"
+  resolved "https://registry.yarnpkg.com/bluebird/-/bluebird-3.4.7.tgz#f72d760be09b7f76d08ed8fae98b289a8d05fab3"
+
+bn.js@^4.0.0, bn.js@^4.1.0, bn.js@^4.1.1, bn.js@^4.4.0:
+  version "4.11.6"
+  resolved "https://registry.yarnpkg.com/bn.js/-/bn.js-4.11.6.tgz#53344adb14617a13f6e8dd2ce28905d1c0ba3215"
+
+boom@2.x.x:
+  version "2.10.1"
+  resolved "https://registry.yarnpkg.com/boom/-/boom-2.10.1.tgz#39c8918ceff5799f83f9492a848f625add0c766f"
+  dependencies:
+    hoek "2.x.x"
+
+brace-expansion@^1.0.0:
+  version "1.1.6"
+  resolved "https://registry.yarnpkg.com/brace-expansion/-/brace-expansion-1.1.6.tgz#7197d7eaa9b87e648390ea61fc66c84427420df9"
+  dependencies:
+    balanced-match "^0.4.1"
+    concat-map "0.0.1"
+
+braces@^1.8.2:
+  version "1.8.5"
+  resolved "https://registry.yarnpkg.com/braces/-/braces-1.8.5.tgz#ba77962e12dff969d6b76711e914b737857bf6a7"
+  dependencies:
+    expand-range "^1.8.1"
+    preserve "^0.2.0"
+    repeat-element "^1.1.2"
+
+brorand@^1.0.1:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/brorand/-/brorand-1.1.0.tgz#12c25efe40a45e3c323eb8675a0a0ce57b22371f"
+
+browser-resolve@^1.11.2:
+  version "1.11.2"
+  resolved "https://registry.yarnpkg.com/browser-resolve/-/browser-resolve-1.11.2.tgz#8ff09b0a2c421718a1051c260b32e48f442938ce"
+  dependencies:
+    resolve "1.1.7"
+
+browserify-aes@^1.0.0, browserify-aes@^1.0.4:
+  version "1.0.6"
+  resolved "https://registry.yarnpkg.com/browserify-aes/-/browserify-aes-1.0.6.tgz#5e7725dbdef1fd5930d4ebab48567ce451c48a0a"
+  dependencies:
+    buffer-xor "^1.0.2"
+    cipher-base "^1.0.0"
+    create-hash "^1.1.0"
+    evp_bytestokey "^1.0.0"
+    inherits "^2.0.1"
+
+browserify-cipher@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/browserify-cipher/-/browserify-cipher-1.0.0.tgz#9988244874bf5ed4e28da95666dcd66ac8fc363a"
+  dependencies:
+    browserify-aes "^1.0.4"
+    browserify-des "^1.0.0"
+    evp_bytestokey "^1.0.0"
+
+browserify-des@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/browserify-des/-/browserify-des-1.0.0.tgz#daa277717470922ed2fe18594118a175439721dd"
+  dependencies:
+    cipher-base "^1.0.1"
+    des.js "^1.0.0"
+    inherits "^2.0.1"
+
+browserify-rsa@^4.0.0:
+  version "4.0.1"
+  resolved "https://registry.yarnpkg.com/browserify-rsa/-/browserify-rsa-4.0.1.tgz#21e0abfaf6f2029cf2fafb133567a701d4135524"
+  dependencies:
+    bn.js "^4.1.0"
+    randombytes "^2.0.1"
+
+browserify-sign@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/browserify-sign/-/browserify-sign-4.0.0.tgz#10773910c3c206d5420a46aad8694f820b85968f"
+  dependencies:
+    bn.js "^4.1.1"
+    browserify-rsa "^4.0.0"
+    create-hash "^1.1.0"
+    create-hmac "^1.1.2"
+    elliptic "^6.0.0"
+    inherits "^2.0.1"
+    parse-asn1 "^5.0.0"
+
+browserify-zlib@^0.1.4:
+  version "0.1.4"
+  resolved "https://registry.yarnpkg.com/browserify-zlib/-/browserify-zlib-0.1.4.tgz#bb35f8a519f600e0fa6b8485241c979d0141fb2d"
+  dependencies:
+    pako "~0.2.0"
+
+bser@1.0.2:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/bser/-/bser-1.0.2.tgz#381116970b2a6deea5646dd15dd7278444b56169"
+  dependencies:
+    node-int64 "^0.4.0"
+
+bser@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/bser/-/bser-2.0.0.tgz#9ac78d3ed5d915804fd87acb158bc797147a1719"
+  dependencies:
+    node-int64 "^0.4.0"
+
+buble-loader@^0.4.0:
+  version "0.4.0"
+  resolved "https://registry.yarnpkg.com/buble-loader/-/buble-loader-0.4.0.tgz#003379dca61f038e1a5357a12aecb2223c5a22f0"
+  dependencies:
+    buble "^0.15.0"
+    loader-utils "^0.2.15"
+    webpack "*"
+
+buble@^0.15.0, buble@^0.15.2:
+  version "0.15.2"
+  resolved "https://registry.yarnpkg.com/buble/-/buble-0.15.2.tgz#547fc47483f8e5e8176d82aa5ebccb183b02d613"
+  dependencies:
+    acorn "^3.3.0"
+    acorn-jsx "^3.0.1"
+    acorn-object-spread "^1.0.0"
+    chalk "^1.1.3"
+    magic-string "^0.14.0"
+    minimist "^1.2.0"
+    os-homedir "^1.0.1"
+
+buffer-shims@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/buffer-shims/-/buffer-shims-1.0.0.tgz#9978ce317388c649ad8793028c3477ef044a8b51"
+
+buffer-xor@^1.0.2:
+  version "1.0.3"
+  resolved "https://registry.yarnpkg.com/buffer-xor/-/buffer-xor-1.0.3.tgz#26e61ed1422fb70dd42e6e36729ed51d855fe8d9"
+
+buffer@^4.3.0:
+  version "4.9.1"
+  resolved "https://registry.yarnpkg.com/buffer/-/buffer-4.9.1.tgz#6d1bb601b07a4efced97094132093027c95bc298"
+  dependencies:
+    base64-js "^1.0.2"
+    ieee754 "^1.1.4"
+    isarray "^1.0.0"
+
+builtin-modules@^1.0.0:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/builtin-modules/-/builtin-modules-1.1.1.tgz#270f076c5a72c02f5b65a47df94c5fe3a278892f"
+
+builtin-status-codes@^3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/builtin-status-codes/-/builtin-status-codes-3.0.0.tgz#85982878e21b98e1c66425e03d0174788f569ee8"
+
+callsites@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/callsites/-/callsites-2.0.0.tgz#06eb84f00eea413da86affefacbffb36093b3c50"
+
+camelcase@^1.0.2:
+  version "1.2.1"
+  resolved "https://registry.yarnpkg.com/camelcase/-/camelcase-1.2.1.tgz#9bb5304d2e0b56698b2c758b08a3eaa9daa58a39"
+
+camelcase@^3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/camelcase/-/camelcase-3.0.0.tgz#32fc4b9fcdaf845fcdf7e73bb97cac2261f0ab0a"
+
+capture-stack-trace@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/capture-stack-trace/-/capture-stack-trace-1.0.0.tgz#4a6fa07399c26bba47f0b2496b4d0fb408c5550d"
+
+caseless@~0.11.0:
+  version "0.11.0"
+  resolved "https://registry.yarnpkg.com/caseless/-/caseless-0.11.0.tgz#715b96ea9841593cc33067923f5ec60ebda4f7d7"
+
+center-align@^0.1.1:
+  version "0.1.3"
+  resolved "https://registry.yarnpkg.com/center-align/-/center-align-0.1.3.tgz#aa0d32629b6ee972200411cbd4461c907bc2b7ad"
+  dependencies:
+    align-text "^0.1.3"
+    lazy-cache "^1.0.3"
+
+chalk@^1.0.0, chalk@^1.1.0, chalk@^1.1.1, chalk@^1.1.3:
+  version "1.1.3"
+  resolved "https://registry.yarnpkg.com/chalk/-/chalk-1.1.3.tgz#a8115c55e4a702fe4d150abd3872822a7e09fc98"
+  dependencies:
+    ansi-styles "^2.2.1"
+    escape-string-regexp "^1.0.2"
+    has-ansi "^2.0.0"
+    strip-ansi "^3.0.0"
+    supports-color "^2.0.0"
+
+chokidar@^1.4.3:
+  version "1.6.1"
+  resolved "https://registry.yarnpkg.com/chokidar/-/chokidar-1.6.1.tgz#2f4447ab5e96e50fb3d789fd90d4c72e0e4c70c2"
+  dependencies:
+    anymatch "^1.3.0"
+    async-each "^1.0.0"
+    glob-parent "^2.0.0"
+    inherits "^2.0.1"
+    is-binary-path "^1.0.0"
+    is-glob "^2.0.0"
+    path-is-absolute "^1.0.0"
+    readdirp "^2.0.0"
+  optionalDependencies:
+    fsevents "^1.0.0"
+
+ci-info@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/ci-info/-/ci-info-1.0.0.tgz#dc5285f2b4e251821683681c381c3388f46ec534"
+
+cipher-base@^1.0.0, cipher-base@^1.0.1:
+  version "1.0.3"
+  resolved "https://registry.yarnpkg.com/cipher-base/-/cipher-base-1.0.3.tgz#eeabf194419ce900da3018c207d212f2a6df0a07"
+  dependencies:
+    inherits "^2.0.1"
+
+cli-cursor@^1.0.1:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/cli-cursor/-/cli-cursor-1.0.2.tgz#64da3f7d56a54412e59794bd62dc35295e8f2987"
+  dependencies:
+    restore-cursor "^1.0.1"
+
+cli-width@^2.0.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/cli-width/-/cli-width-2.1.0.tgz#b234ca209b29ef66fc518d9b98d5847b00edf00a"
+
+cliui@^2.1.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/cliui/-/cliui-2.1.0.tgz#4b475760ff80264c762c3a1719032e91c7fea0d1"
+  dependencies:
+    center-align "^0.1.1"
+    right-align "^0.1.1"
+    wordwrap "0.0.2"
+
+cliui@^3.2.0:
+  version "3.2.0"
+  resolved "https://registry.yarnpkg.com/cliui/-/cliui-3.2.0.tgz#120601537a916d29940f934da3b48d585a39213d"
+  dependencies:
+    string-width "^1.0.1"
+    strip-ansi "^3.0.1"
+    wrap-ansi "^2.0.0"
+
+co@^4.6.0:
+  version "4.6.0"
+  resolved "https://registry.yarnpkg.com/co/-/co-4.6.0.tgz#6ea6bdf3d853ae54ccb8e47bfa0bf3f9031fb184"
+
+code-point-at@^1.0.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/code-point-at/-/code-point-at-1.1.0.tgz#0d070b4d043a5bea33a2f1a40e2edb3d9a4ccf77"
+
+color-convert@^1.0.0:
+  version "1.9.0"
+  resolved "https://registry.yarnpkg.com/color-convert/-/color-convert-1.9.0.tgz#1accf97dd739b983bf994d56fec8f95853641b7a"
+  dependencies:
+    color-name "^1.1.1"
+
+color-name@^1.1.1:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/color-name/-/color-name-1.1.1.tgz#4b1415304cf50028ea81643643bd82ea05803689"
+
+combined-stream@^1.0.5, combined-stream@~1.0.5:
+  version "1.0.5"
+  resolved "https://registry.yarnpkg.com/combined-stream/-/combined-stream-1.0.5.tgz#938370a57b4a51dea2c77c15d5c5fdf895164009"
+  dependencies:
+    delayed-stream "~1.0.0"
+
+commander@^2.9.0:
+  version "2.9.0"
+  resolved "https://registry.yarnpkg.com/commander/-/commander-2.9.0.tgz#9c99094176e12240cb22d6c5146098400fe0f7d4"
+  dependencies:
+    graceful-readlink ">= 1.0.0"
+
+concat-map@0.0.1:
+  version "0.0.1"
+  resolved "https://registry.yarnpkg.com/concat-map/-/concat-map-0.0.1.tgz#d8a96bd77fd68df7793a73036a3ba0d5405d477b"
+
+concat-stream@^1.4.7:
+  version "1.6.0"
+  resolved "https://registry.yarnpkg.com/concat-stream/-/concat-stream-1.6.0.tgz#0aac662fd52be78964d5532f694784e70110acf7"
+  dependencies:
+    inherits "^2.0.3"
+    readable-stream "^2.2.2"
+    typedarray "^0.0.6"
+
+console-browserify@^1.1.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/console-browserify/-/console-browserify-1.1.0.tgz#f0241c45730a9fc6323b206dbf38edc741d0bb10"
+  dependencies:
+    date-now "^0.1.4"
+
+console-control-strings@^1.0.0, console-control-strings@~1.1.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/console-control-strings/-/console-control-strings-1.1.0.tgz#3d7cf4464db6446ea644bf4b39507f9851008e8e"
+
+constants-browserify@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/constants-browserify/-/constants-browserify-1.0.0.tgz#c20b96d8c617748aaf1c16021760cd27fcb8cb75"
+
+content-type-parser@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/content-type-parser/-/content-type-parser-1.0.1.tgz#c3e56988c53c65127fb46d4032a3a900246fdc94"
+
+convert-source-map@^1.1.0:
+  version "1.4.0"
+  resolved "https://registry.yarnpkg.com/convert-source-map/-/convert-source-map-1.4.0.tgz#e3dad195bf61bfe13a7a3c73e9876ec14a0268f3"
+
+core-js@^2.4.0:
+  version "2.4.1"
+  resolved "https://registry.yarnpkg.com/core-js/-/core-js-2.4.1.tgz#4de911e667b0eae9124e34254b53aea6fc618d3e"
+
+core-util-is@~1.0.0:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/core-util-is/-/core-util-is-1.0.2.tgz#b5fd54220aa2bc5ab57aab7140c940754503c1a7"
+
+create-ecdh@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/create-ecdh/-/create-ecdh-4.0.0.tgz#888c723596cdf7612f6498233eebd7a35301737d"
+  dependencies:
+    bn.js "^4.1.0"
+    elliptic "^6.0.0"
+
+create-error-class@^3.0.0:
+  version "3.0.2"
+  resolved "https://registry.yarnpkg.com/create-error-class/-/create-error-class-3.0.2.tgz#06be7abef947a3f14a30fd610671d401bca8b7b6"
+  dependencies:
+    capture-stack-trace "^1.0.0"
+
+create-hash@^1.1.0, create-hash@^1.1.1:
+  version "1.1.2"
+  resolved "https://registry.yarnpkg.com/create-hash/-/create-hash-1.1.2.tgz#51210062d7bb7479f6c65bb41a92208b1d61abad"
+  dependencies:
+    cipher-base "^1.0.1"
+    inherits "^2.0.1"
+    ripemd160 "^1.0.0"
+    sha.js "^2.3.6"
+
+create-hmac@^1.1.0, create-hmac@^1.1.2:
+  version "1.1.4"
+  resolved "https://registry.yarnpkg.com/create-hmac/-/create-hmac-1.1.4.tgz#d3fb4ba253eb8b3f56e39ea2fbcb8af747bd3170"
+  dependencies:
+    create-hash "^1.1.0"
+    inherits "^2.0.1"
+
+cryptiles@2.x.x:
+  version "2.0.5"
+  resolved "https://registry.yarnpkg.com/cryptiles/-/cryptiles-2.0.5.tgz#3bdfecdc608147c1c67202fa291e7dca59eaa3b8"
+  dependencies:
+    boom "2.x.x"
+
+crypto-browserify@^3.11.0:
+  version "3.11.0"
+  resolved "https://registry.yarnpkg.com/crypto-browserify/-/crypto-browserify-3.11.0.tgz#3652a0906ab9b2a7e0c3ce66a408e957a2485522"
+  dependencies:
+    browserify-cipher "^1.0.0"
+    browserify-sign "^4.0.0"
+    create-ecdh "^4.0.0"
+    create-hash "^1.1.0"
+    create-hmac "^1.1.0"
+    diffie-hellman "^5.0.0"
+    inherits "^2.0.1"
+    pbkdf2 "^3.0.3"
+    public-encrypt "^4.0.0"
+    randombytes "^2.0.0"
+
+cssom@0.3.x, "cssom@>= 0.3.2 < 0.4.0":
+  version "0.3.2"
+  resolved "https://registry.yarnpkg.com/cssom/-/cssom-0.3.2.tgz#b8036170c79f07a90ff2f16e22284027a243848b"
+
+"cssstyle@>= 0.2.37 < 0.3.0":
+  version "0.2.37"
+  resolved "https://registry.yarnpkg.com/cssstyle/-/cssstyle-0.2.37.tgz#541097234cb2513c83ceed3acddc27ff27987d54"
+  dependencies:
+    cssom "0.3.x"
+
+dashdash@^1.12.0:
+  version "1.14.1"
+  resolved "https://registry.yarnpkg.com/dashdash/-/dashdash-1.14.1.tgz#853cfa0f7cbe2fed5de20326b8dd581035f6e2f0"
+  dependencies:
+    assert-plus "^1.0.0"
+
+date-now@^0.1.4:
+  version "0.1.4"
+  resolved "https://registry.yarnpkg.com/date-now/-/date-now-0.1.4.tgz#eaf439fd4d4848ad74e5cc7dbef200672b9e345b"
+
+debug@^2.1.1, debug@^2.2.0, debug@~2.2.0:
+  version "2.2.0"
+  resolved "https://registry.yarnpkg.com/debug/-/debug-2.2.0.tgz#f87057e995b1a1f6ae6a4960664137bc56f039da"
+  dependencies:
+    ms "0.7.1"
+
+decamelize@^1.0.0, decamelize@^1.1.1:
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/decamelize/-/decamelize-1.2.0.tgz#f6534d15148269b20352e7bee26f501f9a191290"
+
+deep-extend@~0.4.0:
+  version "0.4.1"
+  resolved "https://registry.yarnpkg.com/deep-extend/-/deep-extend-0.4.1.tgz#efe4113d08085f4e6f9687759810f807469e2253"
+
+deep-is@~0.1.3:
+  version "0.1.3"
+  resolved "https://registry.yarnpkg.com/deep-is/-/deep-is-0.1.3.tgz#b369d6fb5dbc13eecf524f91b070feedc357cf34"
+
+default-require-extensions@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/default-require-extensions/-/default-require-extensions-1.0.0.tgz#f37ea15d3e13ffd9b437d33e1a75b5fb97874cb8"
+  dependencies:
+    strip-bom "^2.0.0"
+
+delayed-stream@~1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/delayed-stream/-/delayed-stream-1.0.0.tgz#df3ae199acadfb7d440aaae0b29e2272b24ec619"
+
+delegates@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/delegates/-/delegates-1.0.0.tgz#84c6e159b81904fdca59a0ef44cd870d31250f9a"
+
+des.js@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/des.js/-/des.js-1.0.0.tgz#c074d2e2aa6a8a9a07dbd61f9a15c2cd83ec8ecc"
+  dependencies:
+    inherits "^2.0.1"
+    minimalistic-assert "^1.0.0"
+
+detect-indent@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/detect-indent/-/detect-indent-4.0.0.tgz#f76d064352cdf43a1cb6ce619c4ee3a9475de208"
+  dependencies:
+    repeating "^2.0.0"
+
+diff@^3.0.0:
+  version "3.2.0"
+  resolved "https://registry.yarnpkg.com/diff/-/diff-3.2.0.tgz#c9ce393a4b7cbd0b058a725c93df299027868ff9"
+
+diffie-hellman@^5.0.0:
+  version "5.0.2"
+  resolved "https://registry.yarnpkg.com/diffie-hellman/-/diffie-hellman-5.0.2.tgz#b5835739270cfe26acf632099fded2a07f209e5e"
+  dependencies:
+    bn.js "^4.1.0"
+    miller-rabin "^4.0.0"
+    randombytes "^2.0.0"
+
+domain-browser@^1.1.1:
+  version "1.1.7"
+  resolved "https://registry.yarnpkg.com/domain-browser/-/domain-browser-1.1.7.tgz#867aa4b093faa05f1de08c06f4d7b21fdf8698bc"
+
+duplexer3@^0.1.4:
+  version "0.1.4"
+  resolved "https://registry.yarnpkg.com/duplexer3/-/duplexer3-0.1.4.tgz#ee01dd1cac0ed3cbc7fdbea37dc0a8f1ce002ce2"
+
+ecc-jsbn@~0.1.1:
+  version "0.1.1"
+  resolved "https://registry.yarnpkg.com/ecc-jsbn/-/ecc-jsbn-0.1.1.tgz#0fc73a9ed5f0d53c38193398523ef7e543777505"
+  dependencies:
+    jsbn "~0.1.0"
+
+elliptic@^6.0.0:
+  version "6.4.0"
+  resolved "https://registry.yarnpkg.com/elliptic/-/elliptic-6.4.0.tgz#cac9af8762c85836187003c8dfe193e5e2eae5df"
+  dependencies:
+    bn.js "^4.4.0"
+    brorand "^1.0.1"
+    hash.js "^1.0.0"
+    hmac-drbg "^1.0.0"
+    inherits "^2.0.1"
+    minimalistic-assert "^1.0.0"
+    minimalistic-crypto-utils "^1.0.0"
+
+emojis-list@^2.0.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/emojis-list/-/emojis-list-2.1.0.tgz#4daa4d9db00f9819880c79fa457ae5b09a1fd389"
+
+enhanced-resolve@^3.0.0:
+  version "3.1.0"
+  resolved "https://registry.yarnpkg.com/enhanced-resolve/-/enhanced-resolve-3.1.0.tgz#9f4b626f577245edcf4b2ad83d86e17f4f421dec"
+  dependencies:
+    graceful-fs "^4.1.2"
+    memory-fs "^0.4.0"
+    object-assign "^4.0.1"
+    tapable "^0.2.5"
+
+"errno@>=0.1.1 <0.2.0-0", errno@^0.1.3:
+  version "0.1.4"
+  resolved "https://registry.yarnpkg.com/errno/-/errno-0.1.4.tgz#b896e23a9e5e8ba33871fc996abd3635fc9a1c7d"
+  dependencies:
+    prr "~0.0.0"
+
+error-ex@^1.2.0:
+  version "1.3.0"
+  resolved "https://registry.yarnpkg.com/error-ex/-/error-ex-1.3.0.tgz#e67b43f3e82c96ea3a584ffee0b9fc3325d802d9"
+  dependencies:
+    is-arrayish "^0.2.1"
+
+escape-string-regexp@^1.0.2, escape-string-regexp@^1.0.5:
+  version "1.0.5"
+  resolved "https://registry.yarnpkg.com/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz#1b61c0562190a8dff6ae3bb2cf0200ca130b86d4"
+
+escodegen@^1.6.1:
+  version "1.8.1"
+  resolved "https://registry.yarnpkg.com/escodegen/-/escodegen-1.8.1.tgz#5a5b53af4693110bebb0867aa3430dd3b70a1018"
+  dependencies:
+    esprima "^2.7.1"
+    estraverse "^1.9.1"
+    esutils "^2.0.2"
+    optionator "^0.8.1"
+  optionalDependencies:
+    source-map "~0.2.0"
+
+esprima@^2.7.1:
+  version "2.7.3"
+  resolved "https://registry.yarnpkg.com/esprima/-/esprima-2.7.3.tgz#96e3b70d5779f6ad49cd032673d1c312767ba581"
+
+esprima@^3.1.1:
+  version "3.1.3"
+  resolved "https://registry.yarnpkg.com/esprima/-/esprima-3.1.3.tgz#fdca51cee6133895e3c88d535ce49dbff62a4633"
+
+estraverse@^1.9.1:
+  version "1.9.3"
+  resolved "https://registry.yarnpkg.com/estraverse/-/estraverse-1.9.3.tgz#af67f2dc922582415950926091a4005d29c9bb44"
+
+estree-walker@^0.2.1:
+  version "0.2.1"
+  resolved "https://registry.yarnpkg.com/estree-walker/-/estree-walker-0.2.1.tgz#bdafe8095383d8414d5dc2ecf4c9173b6db9412e"
+
+esutils@^2.0.2:
+  version "2.0.2"
+  resolved "https://registry.yarnpkg.com/esutils/-/esutils-2.0.2.tgz#0abf4f1caa5bcb1f7a9d8acc6dea4faaa04bac9b"
+
+events@^1.0.0:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/events/-/events-1.1.1.tgz#9ebdb7635ad099c70dcc4c2a1f5004288e8bd924"
+
+evp_bytestokey@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/evp_bytestokey/-/evp_bytestokey-1.0.0.tgz#497b66ad9fef65cd7c08a6180824ba1476b66e53"
+  dependencies:
+    create-hash "^1.1.1"
+
+exec-sh@^0.2.0:
+  version "0.2.0"
+  resolved "https://registry.yarnpkg.com/exec-sh/-/exec-sh-0.2.0.tgz#14f75de3f20d286ef933099b2ce50a90359cef10"
+  dependencies:
+    merge "^1.1.3"
+
+exists-sync@0.0.3:
+  version "0.0.3"
+  resolved "https://registry.yarnpkg.com/exists-sync/-/exists-sync-0.0.3.tgz#b910000bedbb113b378b82f5f5a7638107622dcf"
+
+exit-hook@^1.0.0:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/exit-hook/-/exit-hook-1.1.1.tgz#f05ca233b48c05d54fff07765df8507e95c02ff8"
+
+expand-brackets@^0.1.4:
+  version "0.1.5"
+  resolved "https://registry.yarnpkg.com/expand-brackets/-/expand-brackets-0.1.5.tgz#df07284e342a807cd733ac5af72411e581d1177b"
+  dependencies:
+    is-posix-bracket "^0.1.0"
+
+expand-range@^1.8.1:
+  version "1.8.2"
+  resolved "https://registry.yarnpkg.com/expand-range/-/expand-range-1.8.2.tgz#a299effd335fe2721ebae8e257ec79644fc85337"
+  dependencies:
+    fill-range "^2.1.0"
+
+extend@^3.0.0, extend@~3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/extend/-/extend-3.0.0.tgz#5a474353b9f3353ddd8176dfd37b91c83a46f1d4"
+
+external-editor@^1.1.0:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/external-editor/-/external-editor-1.1.1.tgz#12d7b0db850f7ff7e7081baf4005700060c4600b"
+  dependencies:
+    extend "^3.0.0"
+    spawn-sync "^1.0.15"
+    tmp "^0.0.29"
+
+extglob@^0.3.1:
+  version "0.3.2"
+  resolved "https://registry.yarnpkg.com/extglob/-/extglob-0.3.2.tgz#2e18ff3d2f49ab2765cec9023f011daa8d8349a1"
+  dependencies:
+    is-extglob "^1.0.0"
+
+extsprintf@1.0.2:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/extsprintf/-/extsprintf-1.0.2.tgz#e1080e0658e300b06294990cc70e1502235fd550"
+
+fast-levenshtein@~2.0.4:
+  version "2.0.6"
+  resolved "https://registry.yarnpkg.com/fast-levenshtein/-/fast-levenshtein-2.0.6.tgz#3d8a5c66883a16a30ca8643e851f19baa7797917"
+
+fb-watchman@^1.8.0:
+  version "1.9.2"
+  resolved "https://registry.yarnpkg.com/fb-watchman/-/fb-watchman-1.9.2.tgz#a24cf47827f82d38fb59a69ad70b76e3b6ae7383"
+  dependencies:
+    bser "1.0.2"
+
+fb-watchman@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/fb-watchman/-/fb-watchman-2.0.0.tgz#54e9abf7dfa2f26cd9b1636c588c1afc05de5d58"
+  dependencies:
+    bser "^2.0.0"
+
+figures@^1.3.5:
+  version "1.7.0"
+  resolved "https://registry.yarnpkg.com/figures/-/figures-1.7.0.tgz#cbe1e3affcf1cd44b80cadfed28dc793a9701d2e"
+  dependencies:
+    escape-string-regexp "^1.0.5"
+    object-assign "^4.1.0"
+
+filename-regex@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/filename-regex/-/filename-regex-2.0.0.tgz#996e3e80479b98b9897f15a8a58b3d084e926775"
+
+fileset@^2.0.2:
+  version "2.0.3"
+  resolved "https://registry.yarnpkg.com/fileset/-/fileset-2.0.3.tgz#8e7548a96d3cc2327ee5e674168723a333bba2a0"
+  dependencies:
+    glob "^7.0.3"
+    minimatch "^3.0.3"
+
+fill-range@^2.1.0:
+  version "2.2.3"
+  resolved "https://registry.yarnpkg.com/fill-range/-/fill-range-2.2.3.tgz#50b77dfd7e469bc7492470963699fe7a8485a723"
+  dependencies:
+    is-number "^2.1.0"
+    isobject "^2.0.0"
+    randomatic "^1.1.3"
+    repeat-element "^1.1.2"
+    repeat-string "^1.5.2"
+
+find-up@^1.0.0:
+  version "1.1.2"
+  resolved "https://registry.yarnpkg.com/find-up/-/find-up-1.1.2.tgz#6b2e9822b1a2ce0a60ab64d610eccad53cb24d0f"
+  dependencies:
+    path-exists "^2.0.0"
+    pinkie-promise "^2.0.0"
+
+find-up@^2.1.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/find-up/-/find-up-2.1.0.tgz#45d1b7e506c717ddd482775a2b77920a3c0c57a7"
+  dependencies:
+    locate-path "^2.0.0"
+
+for-in@^0.1.5:
+  version "0.1.6"
+  resolved "https://registry.yarnpkg.com/for-in/-/for-in-0.1.6.tgz#c9f96e89bfad18a545af5ec3ed352a1d9e5b4dc8"
+
+for-own@^0.1.4:
+  version "0.1.4"
+  resolved "https://registry.yarnpkg.com/for-own/-/for-own-0.1.4.tgz#0149b41a39088c7515f51ebe1c1386d45f935072"
+  dependencies:
+    for-in "^0.1.5"
+
+forever-agent@~0.6.1:
+  version "0.6.1"
+  resolved "https://registry.yarnpkg.com/forever-agent/-/forever-agent-0.6.1.tgz#fbc71f0c41adeb37f96c577ad1ed42d8fdacca91"
+
+form-data@~2.1.1:
+  version "2.1.2"
+  resolved "https://registry.yarnpkg.com/form-data/-/form-data-2.1.2.tgz#89c3534008b97eada4cbb157d58f6f5df025eae4"
+  dependencies:
+    asynckit "^0.4.0"
+    combined-stream "^1.0.5"
+    mime-types "^2.1.12"
+
+fs.realpath@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/fs.realpath/-/fs.realpath-1.0.0.tgz#1504ad2523158caa40db4a2787cb01411994ea4f"
+
+fsevents@^1.0.0:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/fsevents/-/fsevents-1.1.1.tgz#f19fd28f43eeaf761680e519a203c4d0b3d31aff"
+  dependencies:
+    nan "^2.3.0"
+    node-pre-gyp "^0.6.29"
+
+fstream-ignore@~1.0.5:
+  version "1.0.5"
+  resolved "https://registry.yarnpkg.com/fstream-ignore/-/fstream-ignore-1.0.5.tgz#9c31dae34767018fe1d249b24dada67d092da105"
+  dependencies:
+    fstream "^1.0.0"
+    inherits "2"
+    minimatch "^3.0.0"
+
+fstream@^1.0.0, fstream@^1.0.2, fstream@~1.0.10:
+  version "1.0.10"
+  resolved "https://registry.yarnpkg.com/fstream/-/fstream-1.0.10.tgz#604e8a92fe26ffd9f6fae30399d4984e1ab22822"
+  dependencies:
+    graceful-fs "^4.1.2"
+    inherits "~2.0.0"
+    mkdirp ">=0.5 0"
+    rimraf "2"
+
+gauge@~2.7.1:
+  version "2.7.3"
+  resolved "https://registry.yarnpkg.com/gauge/-/gauge-2.7.3.tgz#1c23855f962f17b3ad3d0dc7443f304542edfe09"
+  dependencies:
+    aproba "^1.0.3"
+    console-control-strings "^1.0.0"
+    has-unicode "^2.0.0"
+    object-assign "^4.1.0"
+    signal-exit "^3.0.0"
+    string-width "^1.0.1"
+    strip-ansi "^3.0.1"
+    wide-align "^1.1.0"
+
+generate-function@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/generate-function/-/generate-function-2.0.0.tgz#6858fe7c0969b7d4e9093337647ac79f60dfbe74"
+
+generate-object-property@^1.1.0:
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/generate-object-property/-/generate-object-property-1.2.0.tgz#9c0e1c40308ce804f4783618b937fa88f99d50d0"
+  dependencies:
+    is-property "^1.0.0"
+
+generate-release@^0.11.0:
+  version "0.11.0"
+  resolved "https://registry.yarnpkg.com/generate-release/-/generate-release-0.11.0.tgz#235824e3e27ff79a7eb6f85d648f5913608f9a2e"
+  dependencies:
+    bluebird "^3.1.2"
+    exists-sync "0.0.3"
+    glob "^7.0.4"
+    iniparser "^1.0.5"
+    inquirer "^1.1.0"
+    minimist "^1.2.0"
+    observatory "^1.0.0"
+    rmdir "^1.2.0"
+    temp "^0.8.3"
+    xtend "^4.0.1"
+
+get-caller-file@^1.0.1:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/get-caller-file/-/get-caller-file-1.0.2.tgz#f702e63127e7e231c160a80c1554acb70d5047e5"
+
+get-stream@^3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/get-stream/-/get-stream-3.0.0.tgz#8e943d1358dc37555054ecbe2edb05aa174ede14"
+
+getpass@^0.1.1:
+  version "0.1.6"
+  resolved "https://registry.yarnpkg.com/getpass/-/getpass-0.1.6.tgz#283ffd9fc1256840875311c1b60e8c40187110e6"
+  dependencies:
+    assert-plus "^1.0.0"
+
+glob-base@^0.3.0:
+  version "0.3.0"
+  resolved "https://registry.yarnpkg.com/glob-base/-/glob-base-0.3.0.tgz#dbb164f6221b1c0b1ccf82aea328b497df0ea3c4"
+  dependencies:
+    glob-parent "^2.0.0"
+    is-glob "^2.0.0"
+
+glob-parent@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/glob-parent/-/glob-parent-2.0.0.tgz#81383d72db054fcccf5336daa902f182f6edbb28"
+  dependencies:
+    is-glob "^2.0.0"
+
+glob@^7.0.3, glob@^7.0.4, glob@^7.0.5, glob@^7.1.1:
+  version "7.1.1"
+  resolved "https://registry.yarnpkg.com/glob/-/glob-7.1.1.tgz#805211df04faaf1c63a3600306cdf5ade50b2ec8"
+  dependencies:
+    fs.realpath "^1.0.0"
+    inflight "^1.0.4"
+    inherits "2"
+    minimatch "^3.0.2"
+    once "^1.3.0"
+    path-is-absolute "^1.0.0"
+
+globals@^9.0.0:
+  version "9.16.0"
+  resolved "https://registry.yarnpkg.com/globals/-/globals-9.16.0.tgz#63e903658171ec2d9f51b1d31de5e2b8dc01fb80"
+
+got@^6.7.1:
+  version "6.7.1"
+  resolved "https://registry.yarnpkg.com/got/-/got-6.7.1.tgz#240cd05785a9a18e561dc1b44b41c763ef1e8db0"
+  dependencies:
+    create-error-class "^3.0.0"
+    duplexer3 "^0.1.4"
+    get-stream "^3.0.0"
+    is-redirect "^1.0.0"
+    is-retry-allowed "^1.0.0"
+    is-stream "^1.0.0"
+    lowercase-keys "^1.0.0"
+    safe-buffer "^5.0.1"
+    timed-out "^4.0.0"
+    unzip-response "^2.0.1"
+    url-parse-lax "^1.0.0"
+
+graceful-fs@^4.1.2, graceful-fs@^4.1.6:
+  version "4.1.11"
+  resolved "https://registry.yarnpkg.com/graceful-fs/-/graceful-fs-4.1.11.tgz#0e8bdfe4d1ddb8854d64e04ea7c00e2a026e5658"
+
+"graceful-readlink@>= 1.0.0":
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/graceful-readlink/-/graceful-readlink-1.0.1.tgz#4cafad76bc62f02fa039b2f94e9a3dd3a391a725"
+
+growly@^1.3.0:
+  version "1.3.0"
+  resolved "https://registry.yarnpkg.com/growly/-/growly-1.3.0.tgz#f10748cbe76af964b7c96c93c6bcc28af120c081"
+
+handlebars@^4.0.3:
+  version "4.0.6"
+  resolved "https://registry.yarnpkg.com/handlebars/-/handlebars-4.0.6.tgz#2ce4484850537f9c97a8026d5399b935c4ed4ed7"
+  dependencies:
+    async "^1.4.0"
+    optimist "^0.6.1"
+    source-map "^0.4.4"
+  optionalDependencies:
+    uglify-js "^2.6"
+
+har-validator@~2.0.6:
+  version "2.0.6"
+  resolved "https://registry.yarnpkg.com/har-validator/-/har-validator-2.0.6.tgz#cdcbc08188265ad119b6a5a7c8ab70eecfb5d27d"
+  dependencies:
+    chalk "^1.1.1"
+    commander "^2.9.0"
+    is-my-json-valid "^2.12.4"
+    pinkie-promise "^2.0.0"
+
+has-ansi@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/has-ansi/-/has-ansi-2.0.0.tgz#34f5049ce1ecdf2b0649af3ef24e45ed35416d91"
+  dependencies:
+    ansi-regex "^2.0.0"
+
+has-flag@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/has-flag/-/has-flag-1.0.0.tgz#9d9e793165ce017a00f00418c43f942a7b1d11fa"
+
+has-unicode@^2.0.0:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/has-unicode/-/has-unicode-2.0.1.tgz#e0e6fe6a28cf51138855e086d1691e771de2a8b9"
+
+hash.js@^1.0.0, hash.js@^1.0.3:
+  version "1.0.3"
+  resolved "https://registry.yarnpkg.com/hash.js/-/hash.js-1.0.3.tgz#1332ff00156c0a0ffdd8236013d07b77a0451573"
+  dependencies:
+    inherits "^2.0.1"
+
+hawk@~3.1.3:
+  version "3.1.3"
+  resolved "https://registry.yarnpkg.com/hawk/-/hawk-3.1.3.tgz#078444bd7c1640b0fe540d2c9b73d59678e8e1c4"
+  dependencies:
+    boom "2.x.x"
+    cryptiles "2.x.x"
+    hoek "2.x.x"
+    sntp "1.x.x"
+
+hmac-drbg@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/hmac-drbg/-/hmac-drbg-1.0.0.tgz#3db471f45aae4a994a0688322171f51b8b91bee5"
+  dependencies:
+    hash.js "^1.0.3"
+    minimalistic-assert "^1.0.0"
+    minimalistic-crypto-utils "^1.0.1"
+
+hoek@2.x.x:
+  version "2.16.3"
+  resolved "https://registry.yarnpkg.com/hoek/-/hoek-2.16.3.tgz#20bb7403d3cea398e91dc4710a8ff1b8274a25ed"
+
+home-or-tmp@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/home-or-tmp/-/home-or-tmp-2.0.0.tgz#e36c3f2d2cae7d746a857e38d18d5f32a7882db8"
+  dependencies:
+    os-homedir "^1.0.0"
+    os-tmpdir "^1.0.1"
+
+hosted-git-info@^2.1.4:
+  version "2.2.0"
+  resolved "https://registry.yarnpkg.com/hosted-git-info/-/hosted-git-info-2.2.0.tgz#7a0d097863d886c0fabbdcd37bf1758d8becf8a5"
+
+html-encoding-sniffer@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/html-encoding-sniffer/-/html-encoding-sniffer-1.0.1.tgz#79bf7a785ea495fe66165e734153f363ff5437da"
+  dependencies:
+    whatwg-encoding "^1.0.1"
+
+http-signature@~1.1.0:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/http-signature/-/http-signature-1.1.1.tgz#df72e267066cd0ac67fb76adf8e134a8fbcf91bf"
+  dependencies:
+    assert-plus "^0.2.0"
+    jsprim "^1.2.2"
+    sshpk "^1.7.0"
+
+https-browserify@0.0.1:
+  version "0.0.1"
+  resolved "https://registry.yarnpkg.com/https-browserify/-/https-browserify-0.0.1.tgz#3f91365cabe60b77ed0ebba24b454e3e09d95a82"
+
+iconv-lite@0.4.13:
+  version "0.4.13"
+  resolved "https://registry.yarnpkg.com/iconv-lite/-/iconv-lite-0.4.13.tgz#1f88aba4ab0b1508e8312acc39345f36e992e2f2"
+
+ieee754@^1.1.4:
+  version "1.1.8"
+  resolved "https://registry.yarnpkg.com/ieee754/-/ieee754-1.1.8.tgz#be33d40ac10ef1926701f6f08a2d86fbfd1ad3e4"
+
+indexof@0.0.1:
+  version "0.0.1"
+  resolved "https://registry.yarnpkg.com/indexof/-/indexof-0.0.1.tgz#82dc336d232b9062179d05ab3293a66059fd435d"
+
+inflight@^1.0.4:
+  version "1.0.6"
+  resolved "https://registry.yarnpkg.com/inflight/-/inflight-1.0.6.tgz#49bd6331d7d02d0c09bc910a1075ba8165b56df9"
+  dependencies:
+    once "^1.3.0"
+    wrappy "1"
+
+inherits@2, inherits@^2.0.1, inherits@^2.0.3, inherits@~2.0.0, inherits@~2.0.1:
+  version "2.0.3"
+  resolved "https://registry.yarnpkg.com/inherits/-/inherits-2.0.3.tgz#633c2c83e3da42a502f52466022480f4208261de"
+
+inherits@2.0.1:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/inherits/-/inherits-2.0.1.tgz#b17d08d326b4423e568eff719f91b0b1cbdf69f1"
+
+ini@~1.3.0:
+  version "1.3.4"
+  resolved "https://registry.yarnpkg.com/ini/-/ini-1.3.4.tgz#0537cb79daf59b59a1a517dff706c86ec039162e"
+
+iniparser@^1.0.5:
+  version "1.0.5"
+  resolved "https://registry.yarnpkg.com/iniparser/-/iniparser-1.0.5.tgz#836d6befe6dfbfcee0bccf1cf9f2acc7027f783d"
+
+inquirer@^1.1.0:
+  version "1.2.3"
+  resolved "https://registry.yarnpkg.com/inquirer/-/inquirer-1.2.3.tgz#4dec6f32f37ef7bb0b2ed3f1d1a5c3f545074918"
+  dependencies:
+    ansi-escapes "^1.1.0"
+    chalk "^1.0.0"
+    cli-cursor "^1.0.1"
+    cli-width "^2.0.0"
+    external-editor "^1.1.0"
+    figures "^1.3.5"
+    lodash "^4.3.0"
+    mute-stream "0.0.6"
+    pinkie-promise "^2.0.0"
+    run-async "^2.2.0"
+    rx "^4.1.0"
+    string-width "^1.0.1"
+    strip-ansi "^3.0.0"
+    through "^2.3.6"
+
+interpret@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/interpret/-/interpret-1.0.1.tgz#d579fb7f693b858004947af39fa0db49f795602c"
+
+invariant@^2.2.0:
+  version "2.2.2"
+  resolved "https://registry.yarnpkg.com/invariant/-/invariant-2.2.2.tgz#9e1f56ac0acdb6bf303306f338be3b204ae60360"
+  dependencies:
+    loose-envify "^1.0.0"
+
+invert-kv@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/invert-kv/-/invert-kv-1.0.0.tgz#104a8e4aaca6d3d8cd157a8ef8bfab2d7a3ffdb6"
+
+is-arrayish@^0.2.1:
+  version "0.2.1"
+  resolved "https://registry.yarnpkg.com/is-arrayish/-/is-arrayish-0.2.1.tgz#77c99840527aa8ecb1a8ba697b80645a7a926a9d"
+
+is-binary-path@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/is-binary-path/-/is-binary-path-1.0.1.tgz#75f16642b480f187a711c814161fd3a4a7655898"
+  dependencies:
+    binary-extensions "^1.0.0"
+
+is-buffer@^1.0.2:
+  version "1.1.4"
+  resolved "https://registry.yarnpkg.com/is-buffer/-/is-buffer-1.1.4.tgz#cfc86ccd5dc5a52fa80489111c6920c457e2d98b"
+
+is-builtin-module@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/is-builtin-module/-/is-builtin-module-1.0.0.tgz#540572d34f7ac3119f8f76c30cbc1b1e037affbe"
+  dependencies:
+    builtin-modules "^1.0.0"
+
+is-ci@^1.0.9:
+  version "1.0.10"
+  resolved "https://registry.yarnpkg.com/is-ci/-/is-ci-1.0.10.tgz#f739336b2632365061a9d48270cd56ae3369318e"
+  dependencies:
+    ci-info "^1.0.0"
+
+is-dotfile@^1.0.0:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/is-dotfile/-/is-dotfile-1.0.2.tgz#2c132383f39199f8edc268ca01b9b007d205cc4d"
+
+is-equal-shallow@^0.1.3:
+  version "0.1.3"
+  resolved "https://registry.yarnpkg.com/is-equal-shallow/-/is-equal-shallow-0.1.3.tgz#2238098fc221de0bcfa5d9eac4c45d638aa1c534"
+  dependencies:
+    is-primitive "^2.0.0"
+
+is-extendable@^0.1.1:
+  version "0.1.1"
+  resolved "https://registry.yarnpkg.com/is-extendable/-/is-extendable-0.1.1.tgz#62b110e289a471418e3ec36a617d472e301dfc89"
+
+is-extglob@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/is-extglob/-/is-extglob-1.0.0.tgz#ac468177c4943405a092fc8f29760c6ffc6206c0"
+
+is-finite@^1.0.0:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/is-finite/-/is-finite-1.0.2.tgz#cc6677695602be550ef11e8b4aa6305342b6d0aa"
+  dependencies:
+    number-is-nan "^1.0.0"
+
+is-fullwidth-code-point@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/is-fullwidth-code-point/-/is-fullwidth-code-point-1.0.0.tgz#ef9e31386f031a7f0d643af82fde50c457ef00cb"
+  dependencies:
+    number-is-nan "^1.0.0"
+
+is-glob@^2.0.0, is-glob@^2.0.1:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/is-glob/-/is-glob-2.0.1.tgz#d096f926a3ded5600f3fdfd91198cb0888c2d863"
+  dependencies:
+    is-extglob "^1.0.0"
+
+is-my-json-valid@^2.12.4:
+  version "2.15.0"
+  resolved "https://registry.yarnpkg.com/is-my-json-valid/-/is-my-json-valid-2.15.0.tgz#936edda3ca3c211fd98f3b2d3e08da43f7b2915b"
+  dependencies:
+    generate-function "^2.0.0"
+    generate-object-property "^1.1.0"
+    jsonpointer "^4.0.0"
+    xtend "^4.0.0"
+
+is-number@^2.0.2, is-number@^2.1.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/is-number/-/is-number-2.1.0.tgz#01fcbbb393463a548f2f466cce16dece49db908f"
+  dependencies:
+    kind-of "^3.0.2"
+
+is-posix-bracket@^0.1.0:
+  version "0.1.1"
+  resolved "https://registry.yarnpkg.com/is-posix-bracket/-/is-posix-bracket-0.1.1.tgz#3334dc79774368e92f016e6fbc0a88f5cd6e6bc4"
+
+is-primitive@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/is-primitive/-/is-primitive-2.0.0.tgz#207bab91638499c07b2adf240a41a87210034575"
+
+is-promise@^2.1.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/is-promise/-/is-promise-2.1.0.tgz#79a2a9ece7f096e80f36d2b2f3bc16c1ff4bf3fa"
+
+is-property@^1.0.0:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/is-property/-/is-property-1.0.2.tgz#57fe1c4e48474edd65b09911f26b1cd4095dda84"
+
+is-redirect@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/is-redirect/-/is-redirect-1.0.0.tgz#1d03dded53bd8db0f30c26e4f95d36fc7c87dc24"
+
+is-retry-allowed@^1.0.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/is-retry-allowed/-/is-retry-allowed-1.1.0.tgz#11a060568b67339444033d0125a61a20d564fb34"
+
+is-stream@^1.0.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/is-stream/-/is-stream-1.1.0.tgz#12d4a3dd4e68e0b79ceb8dbc84173ae80d91ca44"
+
+is-typedarray@~1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/is-typedarray/-/is-typedarray-1.0.0.tgz#e479c80858df0c1b11ddda6940f96011fcda4a9a"
+
+is-utf8@^0.2.0:
+  version "0.2.1"
+  resolved "https://registry.yarnpkg.com/is-utf8/-/is-utf8-0.2.1.tgz#4b0da1442104d1b336340e80797e865cf39f7d72"
+
+is@~0.2.6:
+  version "0.2.7"
+  resolved "https://registry.yarnpkg.com/is/-/is-0.2.7.tgz#3b34a2c48f359972f35042849193ae7264b63562"
+
+isarray@1.0.0, isarray@^1.0.0, isarray@~1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/isarray/-/isarray-1.0.0.tgz#bb935d48582cba168c06834957a54a3e07124f11"
+
+isexe@^1.1.1:
+  version "1.1.2"
+  resolved "https://registry.yarnpkg.com/isexe/-/isexe-1.1.2.tgz#36f3e22e60750920f5e7241a476a8c6a42275ad0"
+
+isobject@^2.0.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/isobject/-/isobject-2.1.0.tgz#f065561096a3f1da2ef46272f815c840d87e0c89"
+  dependencies:
+    isarray "1.0.0"
+
+isstream@~0.1.2:
+  version "0.1.2"
+  resolved "https://registry.yarnpkg.com/isstream/-/isstream-0.1.2.tgz#47e63f7af55afa6f92e1500e690eb8b8529c099a"
+
+istanbul-api@^1.1.0-alpha.1:
+  version "1.1.1"
+  resolved "https://registry.yarnpkg.com/istanbul-api/-/istanbul-api-1.1.1.tgz#d36e2f1560d1a43ce304c4ff7338182de61c8f73"
+  dependencies:
+    async "^2.1.4"
+    fileset "^2.0.2"
+    istanbul-lib-coverage "^1.0.0"
+    istanbul-lib-hook "^1.0.0"
+    istanbul-lib-instrument "^1.3.0"
+    istanbul-lib-report "^1.0.0-alpha.3"
+    istanbul-lib-source-maps "^1.1.0"
+    istanbul-reports "^1.0.0"
+    js-yaml "^3.7.0"
+    mkdirp "^0.5.1"
+    once "^1.4.0"
+
+istanbul-lib-coverage@^1.0.0, istanbul-lib-coverage@^1.0.0-alpha, istanbul-lib-coverage@^1.0.0-alpha.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/istanbul-lib-coverage/-/istanbul-lib-coverage-1.0.1.tgz#f263efb519c051c5f1f3343034fc40e7b43ff212"
+
+istanbul-lib-hook@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/istanbul-lib-hook/-/istanbul-lib-hook-1.0.0.tgz#fc5367ee27f59268e8f060b0c7aaf051d9c425c5"
+  dependencies:
+    append-transform "^0.4.0"
+
+istanbul-lib-instrument@^1.1.1, istanbul-lib-instrument@^1.3.0, istanbul-lib-instrument@^1.4.2:
+  version "1.4.2"
+  resolved "https://registry.yarnpkg.com/istanbul-lib-instrument/-/istanbul-lib-instrument-1.4.2.tgz#0e2fdfac93c1dabf2e31578637dc78a19089f43e"
+  dependencies:
+    babel-generator "^6.18.0"
+    babel-template "^6.16.0"
+    babel-traverse "^6.18.0"
+    babel-types "^6.18.0"
+    babylon "^6.13.0"
+    istanbul-lib-coverage "^1.0.0"
+    semver "^5.3.0"
+
+istanbul-lib-report@^1.0.0-alpha.3:
+  version "1.0.0-alpha.3"
+  resolved "https://registry.yarnpkg.com/istanbul-lib-report/-/istanbul-lib-report-1.0.0-alpha.3.tgz#32d5f6ec7f33ca3a602209e278b2e6ff143498af"
+  dependencies:
+    async "^1.4.2"
+    istanbul-lib-coverage "^1.0.0-alpha"
+    mkdirp "^0.5.1"
+    path-parse "^1.0.5"
+    rimraf "^2.4.3"
+    supports-color "^3.1.2"
+
+istanbul-lib-source-maps@^1.1.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/istanbul-lib-source-maps/-/istanbul-lib-source-maps-1.1.0.tgz#9d429218f35b823560ea300a96ff0c3bbdab785f"
+  dependencies:
+    istanbul-lib-coverage "^1.0.0-alpha.0"
+    mkdirp "^0.5.1"
+    rimraf "^2.4.4"
+    source-map "^0.5.3"
+
+istanbul-reports@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/istanbul-reports/-/istanbul-reports-1.0.1.tgz#9a17176bc4a6cbebdae52b2f15961d52fa623fbc"
+  dependencies:
+    handlebars "^4.0.3"
+
+jasmine-core@^2.5.2:
+  version "2.5.2"
+  resolved "https://registry.yarnpkg.com/jasmine-core/-/jasmine-core-2.5.2.tgz#6f61bd79061e27f43e6f9355e44b3c6cab6ff297"
+
+jest-changed-files@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-changed-files/-/jest-changed-files-19.0.2.tgz#16c54c84c3270be408e06d2e8af3f3e37a885824"
+
+jest-cli@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-cli/-/jest-cli-19.0.2.tgz#cc3620b62acac5f2d93a548cb6ef697d4ec85443"
+  dependencies:
+    ansi-escapes "^1.4.0"
+    callsites "^2.0.0"
+    chalk "^1.1.1"
+    graceful-fs "^4.1.6"
+    is-ci "^1.0.9"
+    istanbul-api "^1.1.0-alpha.1"
+    istanbul-lib-coverage "^1.0.0"
+    istanbul-lib-instrument "^1.1.1"
+    jest-changed-files "^19.0.2"
+    jest-config "^19.0.2"
+    jest-environment-jsdom "^19.0.2"
+    jest-haste-map "^19.0.0"
+    jest-jasmine2 "^19.0.2"
+    jest-message-util "^19.0.0"
+    jest-regex-util "^19.0.0"
+    jest-resolve-dependencies "^19.0.0"
+    jest-runtime "^19.0.2"
+    jest-snapshot "^19.0.2"
+    jest-util "^19.0.2"
+    micromatch "^2.3.11"
+    node-notifier "^5.0.1"
+    slash "^1.0.0"
+    string-length "^1.0.1"
+    throat "^3.0.0"
+    which "^1.1.1"
+    worker-farm "^1.3.1"
+    yargs "^6.3.0"
+
+jest-config@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-config/-/jest-config-19.0.2.tgz#1b9bd2db0ddd16df61c2b10a54009e1768da6411"
+  dependencies:
+    chalk "^1.1.1"
+    jest-environment-jsdom "^19.0.2"
+    jest-environment-node "^19.0.2"
+    jest-jasmine2 "^19.0.2"
+    jest-regex-util "^19.0.0"
+    jest-resolve "^19.0.2"
+    jest-validate "^19.0.2"
+    pretty-format "^19.0.0"
+
+jest-diff@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-diff/-/jest-diff-19.0.0.tgz#d1563cfc56c8b60232988fbc05d4d16ed90f063c"
+  dependencies:
+    chalk "^1.1.3"
+    diff "^3.0.0"
+    jest-matcher-utils "^19.0.0"
+    pretty-format "^19.0.0"
+
+jest-environment-jsdom@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-environment-jsdom/-/jest-environment-jsdom-19.0.2.tgz#ceda859c4a4b94ab35e4de7dab54b926f293e4a3"
+  dependencies:
+    jest-mock "^19.0.0"
+    jest-util "^19.0.2"
+    jsdom "^9.11.0"
+
+jest-environment-node@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-environment-node/-/jest-environment-node-19.0.2.tgz#6e84079db87ed21d0c05e1f9669f207b116fe99b"
+  dependencies:
+    jest-mock "^19.0.0"
+    jest-util "^19.0.2"
+
+jest-file-exists@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-file-exists/-/jest-file-exists-19.0.0.tgz#cca2e587a11ec92e24cfeab3f8a94d657f3fceb8"
+
+jest-haste-map@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-haste-map/-/jest-haste-map-19.0.0.tgz#adde00b62b1fe04432a104b3254fc5004514b55e"
+  dependencies:
+    fb-watchman "^2.0.0"
+    graceful-fs "^4.1.6"
+    micromatch "^2.3.11"
+    sane "~1.5.0"
+    worker-farm "^1.3.1"
+
+jest-jasmine2@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-jasmine2/-/jest-jasmine2-19.0.2.tgz#167991ac825981fb1a800af126e83afcca832c73"
+  dependencies:
+    graceful-fs "^4.1.6"
+    jest-matcher-utils "^19.0.0"
+    jest-matchers "^19.0.0"
+    jest-message-util "^19.0.0"
+    jest-snapshot "^19.0.2"
+
+jest-matcher-utils@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-matcher-utils/-/jest-matcher-utils-19.0.0.tgz#5ecd9b63565d2b001f61fbf7ec4c7f537964564d"
+  dependencies:
+    chalk "^1.1.3"
+    pretty-format "^19.0.0"
+
+jest-matchers@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-matchers/-/jest-matchers-19.0.0.tgz#c74ecc6ebfec06f384767ba4d6fa4a42d6755754"
+  dependencies:
+    jest-diff "^19.0.0"
+    jest-matcher-utils "^19.0.0"
+    jest-message-util "^19.0.0"
+    jest-regex-util "^19.0.0"
+
+jest-message-util@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-message-util/-/jest-message-util-19.0.0.tgz#721796b89c0e4d761606f9ba8cb828a3b6246416"
+  dependencies:
+    chalk "^1.1.1"
+    micromatch "^2.3.11"
+
+jest-mock@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-mock/-/jest-mock-19.0.0.tgz#67038641e9607ab2ce08ec4a8cb83aabbc899d01"
+
+jest-regex-util@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-regex-util/-/jest-regex-util-19.0.0.tgz#b7754587112aede1456510bb1f6afe74ef598691"
+
+jest-resolve-dependencies@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/jest-resolve-dependencies/-/jest-resolve-dependencies-19.0.0.tgz#a741ad1fa094140e64ecf2642a504f834ece22ee"
+  dependencies:
+    jest-file-exists "^19.0.0"
+
+jest-resolve@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-resolve/-/jest-resolve-19.0.2.tgz#5793575de4f07aec32f7d7ff0c6c181963eefb3c"
+  dependencies:
+    browser-resolve "^1.11.2"
+    jest-haste-map "^19.0.0"
+    resolve "^1.2.0"
+
+jest-runtime@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-runtime/-/jest-runtime-19.0.2.tgz#d9a43e72de416d27d196fd9c7940d98fe6685407"
+  dependencies:
+    babel-core "^6.0.0"
+    babel-jest "^19.0.0"
+    babel-plugin-istanbul "^4.0.0"
+    chalk "^1.1.3"
+    graceful-fs "^4.1.6"
+    jest-config "^19.0.2"
+    jest-file-exists "^19.0.0"
+    jest-haste-map "^19.0.0"
+    jest-regex-util "^19.0.0"
+    jest-resolve "^19.0.2"
+    jest-util "^19.0.2"
+    json-stable-stringify "^1.0.1"
+    micromatch "^2.3.11"
+    strip-bom "3.0.0"
+    yargs "^6.3.0"
+
+jest-snapshot@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-snapshot/-/jest-snapshot-19.0.2.tgz#9c1b216214f7187c38bfd5c70b1efab16b0ff50b"
+  dependencies:
+    chalk "^1.1.3"
+    jest-diff "^19.0.0"
+    jest-file-exists "^19.0.0"
+    jest-matcher-utils "^19.0.0"
+    jest-util "^19.0.2"
+    natural-compare "^1.4.0"
+    pretty-format "^19.0.0"
+
+jest-util@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-util/-/jest-util-19.0.2.tgz#e0a0232a2ab9e6b2b53668bdb3534c2b5977ed41"
+  dependencies:
+    chalk "^1.1.1"
+    graceful-fs "^4.1.6"
+    jest-file-exists "^19.0.0"
+    jest-message-util "^19.0.0"
+    jest-mock "^19.0.0"
+    jest-validate "^19.0.2"
+    leven "^2.0.0"
+    mkdirp "^0.5.1"
+
+jest-validate@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest-validate/-/jest-validate-19.0.2.tgz#dc534df5f1278d5b63df32b14241d4dbf7244c0c"
+  dependencies:
+    chalk "^1.1.1"
+    jest-matcher-utils "^19.0.0"
+    leven "^2.0.0"
+    pretty-format "^19.0.0"
+
+jest@^19.0.2:
+  version "19.0.2"
+  resolved "https://registry.yarnpkg.com/jest/-/jest-19.0.2.tgz#b794faaf8ff461e7388f28beef559a54f20b2c10"
+  dependencies:
+    jest-cli "^19.0.2"
+
+jodid25519@^1.0.0:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/jodid25519/-/jodid25519-1.0.2.tgz#06d4912255093419477d425633606e0e90782967"
+  dependencies:
+    jsbn "~0.1.0"
+
+js-tokens@^3.0.0:
+  version "3.0.1"
+  resolved "https://registry.yarnpkg.com/js-tokens/-/js-tokens-3.0.1.tgz#08e9f132484a2c45a30907e9dc4d5567b7f114d7"
+
+js-yaml@^3.7.0:
+  version "3.8.1"
+  resolved "https://registry.yarnpkg.com/js-yaml/-/js-yaml-3.8.1.tgz#782ba50200be7b9e5a8537001b7804db3ad02628"
+  dependencies:
+    argparse "^1.0.7"
+    esprima "^3.1.1"
+
+jsbn@~0.1.0:
+  version "0.1.1"
+  resolved "https://registry.yarnpkg.com/jsbn/-/jsbn-0.1.1.tgz#a5e654c2e5a2deb5f201d96cefbca80c0ef2f513"
+
+jsdom@^9.11.0:
+  version "9.11.0"
+  resolved "https://registry.yarnpkg.com/jsdom/-/jsdom-9.11.0.tgz#a95b0304e521a2ca5a63c6ea47bf7708a7a84591"
+  dependencies:
+    abab "^1.0.3"
+    acorn "^4.0.4"
+    acorn-globals "^3.1.0"
+    array-equal "^1.0.0"
+    content-type-parser "^1.0.1"
+    cssom ">= 0.3.2 < 0.4.0"
+    cssstyle ">= 0.2.37 < 0.3.0"
+    escodegen "^1.6.1"
+    html-encoding-sniffer "^1.0.1"
+    nwmatcher ">= 1.3.9 < 2.0.0"
+    parse5 "^1.5.1"
+    request "^2.79.0"
+    sax "^1.2.1"
+    symbol-tree "^3.2.1"
+    tough-cookie "^2.3.2"
+    webidl-conversions "^4.0.0"
+    whatwg-encoding "^1.0.1"
+    whatwg-url "^4.3.0"
+    xml-name-validator "^2.0.1"
+
+jsesc@^1.3.0:
+  version "1.3.0"
+  resolved "https://registry.yarnpkg.com/jsesc/-/jsesc-1.3.0.tgz#46c3fec8c1892b12b0833db9bc7622176dbab34b"
+
+json-loader@^0.5.4:
+  version "0.5.4"
+  resolved "https://registry.yarnpkg.com/json-loader/-/json-loader-0.5.4.tgz#8baa1365a632f58a3c46d20175fc6002c96e37de"
+
+json-schema@0.2.3:
+  version "0.2.3"
+  resolved "https://registry.yarnpkg.com/json-schema/-/json-schema-0.2.3.tgz#b480c892e59a2f05954ce727bd3f2a4e882f9e13"
+
+json-stable-stringify@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/json-stable-stringify/-/json-stable-stringify-1.0.1.tgz#9a759d39c5f2ff503fd5300646ed445f88c4f9af"
+  dependencies:
+    jsonify "~0.0.0"
+
+json-stringify-safe@~5.0.1:
+  version "5.0.1"
+  resolved "https://registry.yarnpkg.com/json-stringify-safe/-/json-stringify-safe-5.0.1.tgz#1296a2d58fd45f19a0f6ce01d65701e2c735b6eb"
+
+json5@^0.5.0:
+  version "0.5.1"
+  resolved "https://registry.yarnpkg.com/json5/-/json5-0.5.1.tgz#1eade7acc012034ad84e2396767ead9fa5495821"
+
+jsonify@~0.0.0:
+  version "0.0.0"
+  resolved "https://registry.yarnpkg.com/jsonify/-/jsonify-0.0.0.tgz#2c74b6ee41d93ca51b7b5aaee8f503631d252a73"
+
+jsonpointer@^4.0.0:
+  version "4.0.1"
+  resolved "https://registry.yarnpkg.com/jsonpointer/-/jsonpointer-4.0.1.tgz#4fd92cb34e0e9db3c89c8622ecf51f9b978c6cb9"
+
+jsprim@^1.2.2:
+  version "1.3.1"
+  resolved "https://registry.yarnpkg.com/jsprim/-/jsprim-1.3.1.tgz#2a7256f70412a29ee3670aaca625994c4dcff252"
+  dependencies:
+    extsprintf "1.0.2"
+    json-schema "0.2.3"
+    verror "1.3.6"
+
+kind-of@^3.0.2:
+  version "3.1.0"
+  resolved "https://registry.yarnpkg.com/kind-of/-/kind-of-3.1.0.tgz#475d698a5e49ff5e53d14e3e732429dc8bf4cf47"
+  dependencies:
+    is-buffer "^1.0.2"
+
+lazy-cache@^1.0.3:
+  version "1.0.4"
+  resolved "https://registry.yarnpkg.com/lazy-cache/-/lazy-cache-1.0.4.tgz#a1d78fc3a50474cb80845d3b3b6e1da49a446e8e"
+
+lcid@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/lcid/-/lcid-1.0.0.tgz#308accafa0bc483a3867b4b6f2b9506251d1b835"
+  dependencies:
+    invert-kv "^1.0.0"
+
+leven@^2.0.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/leven/-/leven-2.1.0.tgz#c2e7a9f772094dee9d34202ae8acce4687875580"
+
+levn@~0.3.0:
+  version "0.3.0"
+  resolved "https://registry.yarnpkg.com/levn/-/levn-0.3.0.tgz#3b09924edf9f083c0490fdd4c0bc4421e04764ee"
+  dependencies:
+    prelude-ls "~1.1.2"
+    type-check "~0.3.2"
+
+load-json-file@^1.0.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/load-json-file/-/load-json-file-1.1.0.tgz#956905708d58b4bab4c2261b04f59f31c99374c0"
+  dependencies:
+    graceful-fs "^4.1.2"
+    parse-json "^2.2.0"
+    pify "^2.0.0"
+    pinkie-promise "^2.0.0"
+    strip-bom "^2.0.0"
+
+loader-runner@^2.3.0:
+  version "2.3.0"
+  resolved "https://registry.yarnpkg.com/loader-runner/-/loader-runner-2.3.0.tgz#f482aea82d543e07921700d5a46ef26fdac6b8a2"
+
+loader-utils@^0.2.15, loader-utils@^0.2.16:
+  version "0.2.17"
+  resolved "https://registry.yarnpkg.com/loader-utils/-/loader-utils-0.2.17.tgz#f86e6374d43205a6e6c60e9196f17c0299bfb348"
+  dependencies:
+    big.js "^3.1.3"
+    emojis-list "^2.0.0"
+    json5 "^0.5.0"
+    object-assign "^4.0.1"
+
+locate-path@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/locate-path/-/locate-path-2.0.0.tgz#2b568b265eec944c6d9c0de9c3dbbbca0354cd8e"
+  dependencies:
+    p-locate "^2.0.0"
+    path-exists "^3.0.0"
+
+lodash@^3.10.1:
+  version "3.10.1"
+  resolved "https://registry.yarnpkg.com/lodash/-/lodash-3.10.1.tgz#5bf45e8e49ba4189e17d482789dfd15bd140b7b6"
+
+lodash@^4.14.0, lodash@^4.2.0, lodash@^4.3.0:
+  version "4.17.4"
+  resolved "https://registry.yarnpkg.com/lodash/-/lodash-4.17.4.tgz#78203a4d1c328ae1d86dca6460e369b57f4055ae"
+
+longest@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/longest/-/longest-1.0.1.tgz#30a0b2da38f73770e8294a0d22e6625ed77d0097"
+
+loose-envify@^1.0.0:
+  version "1.3.1"
+  resolved "https://registry.yarnpkg.com/loose-envify/-/loose-envify-1.3.1.tgz#d1a8ad33fa9ce0e713d65fdd0ac8b748d478c848"
+  dependencies:
+    js-tokens "^3.0.0"
+
+lowercase-keys@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/lowercase-keys/-/lowercase-keys-1.0.0.tgz#4e3366b39e7f5457e35f1324bdf6f88d0bfc7306"
+
+magic-string@^0.14.0:
+  version "0.14.0"
+  resolved "https://registry.yarnpkg.com/magic-string/-/magic-string-0.14.0.tgz#57224aef1701caeed273b17a39a956e72b172462"
+  dependencies:
+    vlq "^0.2.1"
+
+makeerror@1.0.x:
+  version "1.0.11"
+  resolved "https://registry.yarnpkg.com/makeerror/-/makeerror-1.0.11.tgz#e01a5c9109f2af79660e4e8b9587790184f5a96c"
+  dependencies:
+    tmpl "1.0.x"
+
+memory-fs@^0.4.0, memory-fs@~0.4.1:
+  version "0.4.1"
+  resolved "https://registry.yarnpkg.com/memory-fs/-/memory-fs-0.4.1.tgz#3a9a20b8462523e447cfbc7e8bb80ed667bfc552"
+  dependencies:
+    errno "^0.1.3"
+    readable-stream "^2.0.1"
+
+merge@^1.1.3:
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/merge/-/merge-1.2.0.tgz#7531e39d4949c281a66b8c5a6e0265e8b05894da"
+
+micromatch@^2.1.5, micromatch@^2.3.11:
+  version "2.3.11"
+  resolved "https://registry.yarnpkg.com/micromatch/-/micromatch-2.3.11.tgz#86677c97d1720b363431d04d0d15293bd38c1565"
+  dependencies:
+    arr-diff "^2.0.0"
+    array-unique "^0.2.1"
+    braces "^1.8.2"
+    expand-brackets "^0.1.4"
+    extglob "^0.3.1"
+    filename-regex "^2.0.0"
+    is-extglob "^1.0.0"
+    is-glob "^2.0.1"
+    kind-of "^3.0.2"
+    normalize-path "^2.0.1"
+    object.omit "^2.0.0"
+    parse-glob "^3.0.4"
+    regex-cache "^0.4.2"
+
+miller-rabin@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/miller-rabin/-/miller-rabin-4.0.0.tgz#4a62fb1d42933c05583982f4c716f6fb9e6c6d3d"
+  dependencies:
+    bn.js "^4.0.0"
+    brorand "^1.0.1"
+
+mime-db@~1.26.0:
+  version "1.26.0"
+  resolved "https://registry.yarnpkg.com/mime-db/-/mime-db-1.26.0.tgz#eaffcd0e4fc6935cf8134da246e2e6c35305adff"
+
+mime-types@^2.1.12, mime-types@~2.1.7:
+  version "2.1.14"
+  resolved "https://registry.yarnpkg.com/mime-types/-/mime-types-2.1.14.tgz#f7ef7d97583fcaf3b7d282b6f8b5679dab1e94ee"
+  dependencies:
+    mime-db "~1.26.0"
+
+minimalistic-assert@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/minimalistic-assert/-/minimalistic-assert-1.0.0.tgz#702be2dda6b37f4836bcb3f5db56641b64a1d3d3"
+
+minimalistic-crypto-utils@^1.0.0, minimalistic-crypto-utils@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/minimalistic-crypto-utils/-/minimalistic-crypto-utils-1.0.1.tgz#f6c00c1c0b082246e5c4d99dfb8c7c083b2b582a"
+
+minimatch@^3.0.0, minimatch@^3.0.2, minimatch@^3.0.3:
+  version "3.0.3"
+  resolved "https://registry.yarnpkg.com/minimatch/-/minimatch-3.0.3.tgz#2a4e4090b96b2db06a9d7df01055a62a77c9b774"
+  dependencies:
+    brace-expansion "^1.0.0"
+
+minimist@0.0.8, minimist@~0.0.1:
+  version "0.0.8"
+  resolved "https://registry.yarnpkg.com/minimist/-/minimist-0.0.8.tgz#857fcabfc3397d2625b8228262e86aa7a011b05d"
+
+minimist@^1.1.1, minimist@^1.2.0:
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/minimist/-/minimist-1.2.0.tgz#a35008b20f41383eec1fb914f4cd5df79a264284"
+
+"mkdirp@>=0.5 0", mkdirp@^0.5.1, mkdirp@~0.5.0, mkdirp@~0.5.1:
+  version "0.5.1"
+  resolved "https://registry.yarnpkg.com/mkdirp/-/mkdirp-0.5.1.tgz#30057438eac6cf7f8c4767f38648d6697d75c903"
+  dependencies:
+    minimist "0.0.8"
+
+ms@0.7.1:
+  version "0.7.1"
+  resolved "https://registry.yarnpkg.com/ms/-/ms-0.7.1.tgz#9cd13c03adbff25b65effde7ce864ee952017098"
+
+mute-stream@0.0.6:
+  version "0.0.6"
+  resolved "https://registry.yarnpkg.com/mute-stream/-/mute-stream-0.0.6.tgz#48962b19e169fd1dfc240b3f1e7317627bbc47db"
+
+nan@^2.3.0:
+  version "2.5.1"
+  resolved "https://registry.yarnpkg.com/nan/-/nan-2.5.1.tgz#d5b01691253326a97a2bbee9e61c55d8d60351e2"
+
+natural-compare@^1.4.0:
+  version "1.4.0"
+  resolved "https://registry.yarnpkg.com/natural-compare/-/natural-compare-1.4.0.tgz#4abebfeed7541f2c27acfb29bdbbd15c8d5ba4f7"
+
+node-int64@^0.4.0:
+  version "0.4.0"
+  resolved "https://registry.yarnpkg.com/node-int64/-/node-int64-0.4.0.tgz#87a9065cdb355d3182d8f94ce11188b825c68a3b"
+
+node-libs-browser@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/node-libs-browser/-/node-libs-browser-2.0.0.tgz#a3a59ec97024985b46e958379646f96c4b616646"
+  dependencies:
+    assert "^1.1.1"
+    browserify-zlib "^0.1.4"
+    buffer "^4.3.0"
+    console-browserify "^1.1.0"
+    constants-browserify "^1.0.0"
+    crypto-browserify "^3.11.0"
+    domain-browser "^1.1.1"
+    events "^1.0.0"
+    https-browserify "0.0.1"
+    os-browserify "^0.2.0"
+    path-browserify "0.0.0"
+    process "^0.11.0"
+    punycode "^1.2.4"
+    querystring-es3 "^0.2.0"
+    readable-stream "^2.0.5"
+    stream-browserify "^2.0.1"
+    stream-http "^2.3.1"
+    string_decoder "^0.10.25"
+    timers-browserify "^2.0.2"
+    tty-browserify "0.0.0"
+    url "^0.11.0"
+    util "^0.10.3"
+    vm-browserify "0.0.4"
+
+node-notifier@^5.0.1:
+  version "5.0.2"
+  resolved "https://registry.yarnpkg.com/node-notifier/-/node-notifier-5.0.2.tgz#4438449fe69e321f941cef943986b0797032701b"
+  dependencies:
+    growly "^1.3.0"
+    semver "^5.3.0"
+    shellwords "^0.1.0"
+    which "^1.2.12"
+
+node-pre-gyp@^0.6.29:
+  version "0.6.33"
+  resolved "https://registry.yarnpkg.com/node-pre-gyp/-/node-pre-gyp-0.6.33.tgz#640ac55198f6a925972e0c16c4ac26a034d5ecc9"
+  dependencies:
+    mkdirp "~0.5.1"
+    nopt "~3.0.6"
+    npmlog "^4.0.1"
+    rc "~1.1.6"
+    request "^2.79.0"
+    rimraf "~2.5.4"
+    semver "~5.3.0"
+    tar "~2.2.1"
+    tar-pack "~3.3.0"
+
+node.extend@1.0.8:
+  version "1.0.8"
+  resolved "https://registry.yarnpkg.com/node.extend/-/node.extend-1.0.8.tgz#bab04379f7383f4587990c9df07b6a7f65db772b"
+  dependencies:
+    is "~0.2.6"
+    object-keys "~0.4.0"
+
+node.flow@1.2.3:
+  version "1.2.3"
+  resolved "https://registry.yarnpkg.com/node.flow/-/node.flow-1.2.3.tgz#e1c44a82aeca8d78b458a77fb3dc642f2eba2649"
+  dependencies:
+    node.extend "1.0.8"
+
+nopt@~3.0.6:
+  version "3.0.6"
+  resolved "https://registry.yarnpkg.com/nopt/-/nopt-3.0.6.tgz#c6465dbf08abcd4db359317f79ac68a646b28ff9"
+  dependencies:
+    abbrev "1"
+
+normalize-package-data@^2.3.2:
+  version "2.3.5"
+  resolved "https://registry.yarnpkg.com/normalize-package-data/-/normalize-package-data-2.3.5.tgz#8d924f142960e1777e7ffe170543631cc7cb02df"
+  dependencies:
+    hosted-git-info "^2.1.4"
+    is-builtin-module "^1.0.0"
+    semver "2 || 3 || 4 || 5"
+    validate-npm-package-license "^3.0.1"
+
+normalize-path@^2.0.1:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/normalize-path/-/normalize-path-2.0.1.tgz#47886ac1662760d4261b7d979d241709d3ce3f7a"
+
+npmlog@^4.0.1:
+  version "4.0.2"
+  resolved "https://registry.yarnpkg.com/npmlog/-/npmlog-4.0.2.tgz#d03950e0e78ce1527ba26d2a7592e9348ac3e75f"
+  dependencies:
+    are-we-there-yet "~1.1.2"
+    console-control-strings "~1.1.0"
+    gauge "~2.7.1"
+    set-blocking "~2.0.0"
+
+number-is-nan@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/number-is-nan/-/number-is-nan-1.0.1.tgz#097b602b53422a522c1afb8790318336941a011d"
+
+"nwmatcher@>= 1.3.9 < 2.0.0":
+  version "1.3.9"
+  resolved "https://registry.yarnpkg.com/nwmatcher/-/nwmatcher-1.3.9.tgz#8bab486ff7fa3dfd086656bbe8b17116d3692d2a"
+
+oauth-sign@~0.8.1:
+  version "0.8.2"
+  resolved "https://registry.yarnpkg.com/oauth-sign/-/oauth-sign-0.8.2.tgz#46a6ab7f0aead8deae9ec0565780b7d4efeb9d43"
+
+object-assign@^4.0.1, object-assign@^4.1.0:
+  version "4.1.1"
+  resolved "https://registry.yarnpkg.com/object-assign/-/object-assign-4.1.1.tgz#2109adc7965887cfc05cbbd442cac8bfbb360863"
+
+object-keys@~0.4.0:
+  version "0.4.0"
+  resolved "https://registry.yarnpkg.com/object-keys/-/object-keys-0.4.0.tgz#28a6aae7428dd2c3a92f3d95f21335dd204e0336"
+
+object.omit@^2.0.0:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/object.omit/-/object.omit-2.0.1.tgz#1a9c744829f39dbb858c76ca3579ae2a54ebd1fa"
+  dependencies:
+    for-own "^0.1.4"
+    is-extendable "^0.1.1"
+
+observatory@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/observatory/-/observatory-1.0.0.tgz#2baa606e8299e6866914ec9c8a4db6a41136e59b"
+  dependencies:
+    ansi-escapes "^1.1.0"
+    chalk "^1.1.1"
+    lodash "^3.10.1"
+
+once@^1.3.0, once@^1.4.0:
+  version "1.4.0"
+  resolved "https://registry.yarnpkg.com/once/-/once-1.4.0.tgz#583b1aa775961d4b113ac17d9c50baef9dd76bd1"
+  dependencies:
+    wrappy "1"
+
+once@~1.3.3:
+  version "1.3.3"
+  resolved "https://registry.yarnpkg.com/once/-/once-1.3.3.tgz#b2e261557ce4c314ec8304f3fa82663e4297ca20"
+  dependencies:
+    wrappy "1"
+
+onetime@^1.0.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/onetime/-/onetime-1.1.0.tgz#a1f7838f8314c516f05ecefcbc4ccfe04b4ed789"
+
+optimist@^0.6.1:
+  version "0.6.1"
+  resolved "https://registry.yarnpkg.com/optimist/-/optimist-0.6.1.tgz#da3ea74686fa21a19a111c326e90eb15a0196686"
+  dependencies:
+    minimist "~0.0.1"
+    wordwrap "~0.0.2"
+
+optionator@^0.8.1:
+  version "0.8.2"
+  resolved "https://registry.yarnpkg.com/optionator/-/optionator-0.8.2.tgz#364c5e409d3f4d6301d6c0b4c05bba50180aeb64"
+  dependencies:
+    deep-is "~0.1.3"
+    fast-levenshtein "~2.0.4"
+    levn "~0.3.0"
+    prelude-ls "~1.1.2"
+    type-check "~0.3.2"
+    wordwrap "~1.0.0"
+
+os-browserify@^0.2.0:
+  version "0.2.1"
+  resolved "https://registry.yarnpkg.com/os-browserify/-/os-browserify-0.2.1.tgz#63fc4ccee5d2d7763d26bbf8601078e6c2e0044f"
+
+os-homedir@^1.0.0, os-homedir@^1.0.1:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/os-homedir/-/os-homedir-1.0.2.tgz#ffbc4988336e0e833de0c168c7ef152121aa7fb3"
+
+os-locale@^1.4.0:
+  version "1.4.0"
+  resolved "https://registry.yarnpkg.com/os-locale/-/os-locale-1.4.0.tgz#20f9f17ae29ed345e8bde583b13d2009803c14d9"
+  dependencies:
+    lcid "^1.0.0"
+
+os-shim@^0.1.2:
+  version "0.1.3"
+  resolved "https://registry.yarnpkg.com/os-shim/-/os-shim-0.1.3.tgz#6b62c3791cf7909ea35ed46e17658bb417cb3917"
+
+os-tmpdir@^1.0.0, os-tmpdir@^1.0.1, os-tmpdir@~1.0.1:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/os-tmpdir/-/os-tmpdir-1.0.2.tgz#bbe67406c79aa85c5cfec766fe5734555dfa1274"
+
+p-limit@^1.1.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/p-limit/-/p-limit-1.1.0.tgz#b07ff2d9a5d88bec806035895a2bab66a27988bc"
+
+p-locate@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/p-locate/-/p-locate-2.0.0.tgz#20a0103b222a70c8fd39cc2e580680f3dde5ec43"
+  dependencies:
+    p-limit "^1.1.0"
+
+pako@~0.2.0:
+  version "0.2.9"
+  resolved "https://registry.yarnpkg.com/pako/-/pako-0.2.9.tgz#f3f7522f4ef782348da8161bad9ecfd51bf83a75"
+
+parse-asn1@^5.0.0:
+  version "5.0.0"
+  resolved "https://registry.yarnpkg.com/parse-asn1/-/parse-asn1-5.0.0.tgz#35060f6d5015d37628c770f4e091a0b5a278bc23"
+  dependencies:
+    asn1.js "^4.0.0"
+    browserify-aes "^1.0.0"
+    create-hash "^1.1.0"
+    evp_bytestokey "^1.0.0"
+    pbkdf2 "^3.0.3"
+
+parse-glob@^3.0.4:
+  version "3.0.4"
+  resolved "https://registry.yarnpkg.com/parse-glob/-/parse-glob-3.0.4.tgz#b2c376cfb11f35513badd173ef0bb6e3a388391c"
+  dependencies:
+    glob-base "^0.3.0"
+    is-dotfile "^1.0.0"
+    is-extglob "^1.0.0"
+    is-glob "^2.0.0"
+
+parse-json@^2.2.0:
+  version "2.2.0"
+  resolved "https://registry.yarnpkg.com/parse-json/-/parse-json-2.2.0.tgz#f480f40434ef80741f8469099f8dea18f55a4dc9"
+  dependencies:
+    error-ex "^1.2.0"
+
+parse5@^1.5.1:
+  version "1.5.1"
+  resolved "https://registry.yarnpkg.com/parse5/-/parse5-1.5.1.tgz#9b7f3b0de32be78dc2401b17573ccaf0f6f59d94"
+
+path-browserify@0.0.0:
+  version "0.0.0"
+  resolved "https://registry.yarnpkg.com/path-browserify/-/path-browserify-0.0.0.tgz#a0b870729aae214005b7d5032ec2cbbb0fb4451a"
+
+path-exists@^2.0.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/path-exists/-/path-exists-2.1.0.tgz#0feb6c64f0fc518d9a754dd5efb62c7022761f4b"
+  dependencies:
+    pinkie-promise "^2.0.0"
+
+path-exists@^3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/path-exists/-/path-exists-3.0.0.tgz#ce0ebeaa5f78cb18925ea7d810d7b59b010fd515"
+
+path-is-absolute@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/path-is-absolute/-/path-is-absolute-1.0.1.tgz#174b9268735534ffbc7ace6bf53a5a9e1b5c5f5f"
+
+path-parse@^1.0.5:
+  version "1.0.5"
+  resolved "https://registry.yarnpkg.com/path-parse/-/path-parse-1.0.5.tgz#3c1adf871ea9cd6c9431b6ea2bd74a0ff055c4c1"
+
+path-type@^1.0.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/path-type/-/path-type-1.1.0.tgz#59c44f7ee491da704da415da5a4070ba4f8fe441"
+  dependencies:
+    graceful-fs "^4.1.2"
+    pify "^2.0.0"
+    pinkie-promise "^2.0.0"
+
+pbkdf2@^3.0.3:
+  version "3.0.9"
+  resolved "https://registry.yarnpkg.com/pbkdf2/-/pbkdf2-3.0.9.tgz#f2c4b25a600058b3c3773c086c37dbbee1ffe693"
+  dependencies:
+    create-hmac "^1.1.2"
+
+pify@^2.0.0:
+  version "2.3.0"
+  resolved "https://registry.yarnpkg.com/pify/-/pify-2.3.0.tgz#ed141a6ac043a849ea588498e7dca8b15330e90c"
+
+pinkie-promise@^2.0.0:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/pinkie-promise/-/pinkie-promise-2.0.1.tgz#2135d6dfa7a358c069ac9b178776288228450ffa"
+  dependencies:
+    pinkie "^2.0.0"
+
+pinkie@^2.0.0:
+  version "2.0.4"
+  resolved "https://registry.yarnpkg.com/pinkie/-/pinkie-2.0.4.tgz#72556b80cfa0d48a974e80e77248e80ed4f7f870"
+
+prelude-ls@~1.1.2:
+  version "1.1.2"
+  resolved "https://registry.yarnpkg.com/prelude-ls/-/prelude-ls-1.1.2.tgz#21932a549f5e52ffd9a827f570e04be62a97da54"
+
+prepend-http@^1.0.1:
+  version "1.0.4"
+  resolved "https://registry.yarnpkg.com/prepend-http/-/prepend-http-1.0.4.tgz#d4f4562b0ce3696e41ac52d0e002e57a635dc6dc"
+
+preserve@^0.2.0:
+  version "0.2.0"
+  resolved "https://registry.yarnpkg.com/preserve/-/preserve-0.2.0.tgz#815ed1f6ebc65926f865b310c0713bcb3315ce4b"
+
+pretty-format@^19.0.0:
+  version "19.0.0"
+  resolved "https://registry.yarnpkg.com/pretty-format/-/pretty-format-19.0.0.tgz#56530d32acb98a3fa4851c4e2b9d37b420684c84"
+  dependencies:
+    ansi-styles "^3.0.0"
+
+private@^0.1.6:
+  version "0.1.7"
+  resolved "https://registry.yarnpkg.com/private/-/private-0.1.7.tgz#68ce5e8a1ef0a23bb570cc28537b5332aba63ef1"
+
+process-nextick-args@~1.0.6:
+  version "1.0.7"
+  resolved "https://registry.yarnpkg.com/process-nextick-args/-/process-nextick-args-1.0.7.tgz#150e20b756590ad3f91093f25a4f2ad8bff30ba3"
+
+process@^0.11.0:
+  version "0.11.9"
+  resolved "https://registry.yarnpkg.com/process/-/process-0.11.9.tgz#7bd5ad21aa6253e7da8682264f1e11d11c0318c1"
+
+prr@~0.0.0:
+  version "0.0.0"
+  resolved "https://registry.yarnpkg.com/prr/-/prr-0.0.0.tgz#1a84b85908325501411853d0081ee3fa86e2926a"
+
+public-encrypt@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/public-encrypt/-/public-encrypt-4.0.0.tgz#39f699f3a46560dd5ebacbca693caf7c65c18cc6"
+  dependencies:
+    bn.js "^4.1.0"
+    browserify-rsa "^4.0.0"
+    create-hash "^1.1.0"
+    parse-asn1 "^5.0.0"
+    randombytes "^2.0.1"
+
+punycode@1.3.2:
+  version "1.3.2"
+  resolved "https://registry.yarnpkg.com/punycode/-/punycode-1.3.2.tgz#9653a036fb7c1ee42342f2325cceefea3926c48d"
+
+punycode@^1.2.4, punycode@^1.4.1:
+  version "1.4.1"
+  resolved "https://registry.yarnpkg.com/punycode/-/punycode-1.4.1.tgz#c0d5a63b2718800ad8e1eb0fa5269c84dd41845e"
+
+qs@~6.3.0:
+  version "6.3.1"
+  resolved "https://registry.yarnpkg.com/qs/-/qs-6.3.1.tgz#918c0b3bcd36679772baf135b1acb4c1651ed79d"
+
+querystring-es3@^0.2.0:
+  version "0.2.1"
+  resolved "https://registry.yarnpkg.com/querystring-es3/-/querystring-es3-0.2.1.tgz#9ec61f79049875707d69414596fd907a4d711e73"
+
+querystring@0.2.0:
+  version "0.2.0"
+  resolved "https://registry.yarnpkg.com/querystring/-/querystring-0.2.0.tgz#b209849203bb25df820da756e747005878521620"
+
+randomatic@^1.1.3:
+  version "1.1.6"
+  resolved "https://registry.yarnpkg.com/randomatic/-/randomatic-1.1.6.tgz#110dcabff397e9dcff7c0789ccc0a49adf1ec5bb"
+  dependencies:
+    is-number "^2.0.2"
+    kind-of "^3.0.2"
+
+randombytes@^2.0.0, randombytes@^2.0.1:
+  version "2.0.3"
+  resolved "https://registry.yarnpkg.com/randombytes/-/randombytes-2.0.3.tgz#674c99760901c3c4112771a31e521dc349cc09ec"
+
+rc@~1.1.6:
+  version "1.1.7"
+  resolved "https://registry.yarnpkg.com/rc/-/rc-1.1.7.tgz#c5ea564bb07aff9fd3a5b32e906c1d3a65940fea"
+  dependencies:
+    deep-extend "~0.4.0"
+    ini "~1.3.0"
+    minimist "^1.2.0"
+    strip-json-comments "~2.0.1"
+
+read-pkg-up@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/read-pkg-up/-/read-pkg-up-1.0.1.tgz#9d63c13276c065918d57f002a57f40a1b643fb02"
+  dependencies:
+    find-up "^1.0.0"
+    read-pkg "^1.0.0"
+
+read-pkg@^1.0.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/read-pkg/-/read-pkg-1.1.0.tgz#f5ffaa5ecd29cb31c0474bca7d756b6bb29e3f28"
+  dependencies:
+    load-json-file "^1.0.0"
+    normalize-package-data "^2.3.2"
+    path-type "^1.0.0"
+
+"readable-stream@^2.0.0 || ^1.1.13", readable-stream@^2.0.1, readable-stream@^2.0.2, readable-stream@^2.0.5, readable-stream@^2.1.0, readable-stream@^2.2.2:
+  version "2.2.3"
+  resolved "https://registry.yarnpkg.com/readable-stream/-/readable-stream-2.2.3.tgz#9cf49463985df016c8ae8813097a9293a9b33729"
+  dependencies:
+    buffer-shims "^1.0.0"
+    core-util-is "~1.0.0"
+    inherits "~2.0.1"
+    isarray "~1.0.0"
+    process-nextick-args "~1.0.6"
+    string_decoder "~0.10.x"
+    util-deprecate "~1.0.1"
+
+readable-stream@~2.1.4:
+  version "2.1.5"
+  resolved "https://registry.yarnpkg.com/readable-stream/-/readable-stream-2.1.5.tgz#66fa8b720e1438b364681f2ad1a63c618448c9d0"
+  dependencies:
+    buffer-shims "^1.0.0"
+    core-util-is "~1.0.0"
+    inherits "~2.0.1"
+    isarray "~1.0.0"
+    process-nextick-args "~1.0.6"
+    string_decoder "~0.10.x"
+    util-deprecate "~1.0.1"
+
+readdirp@^2.0.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/readdirp/-/readdirp-2.1.0.tgz#4ed0ad060df3073300c48440373f72d1cc642d78"
+  dependencies:
+    graceful-fs "^4.1.2"
+    minimatch "^3.0.2"
+    readable-stream "^2.0.2"
+    set-immediate-shim "^1.0.1"
+
+regenerator-runtime@^0.10.0:
+  version "0.10.3"
+  resolved "https://registry.yarnpkg.com/regenerator-runtime/-/regenerator-runtime-0.10.3.tgz#8c4367a904b51ea62a908ac310bf99ff90a82a3e"
+
+regex-cache@^0.4.2:
+  version "0.4.3"
+  resolved "https://registry.yarnpkg.com/regex-cache/-/regex-cache-0.4.3.tgz#9b1a6c35d4d0dfcef5711ae651e8e9d3d7114145"
+  dependencies:
+    is-equal-shallow "^0.1.3"
+    is-primitive "^2.0.0"
+
+repeat-element@^1.1.2:
+  version "1.1.2"
+  resolved "https://registry.yarnpkg.com/repeat-element/-/repeat-element-1.1.2.tgz#ef089a178d1483baae4d93eb98b4f9e4e11d990a"
+
+repeat-string@^1.5.2:
+  version "1.6.1"
+  resolved "https://registry.yarnpkg.com/repeat-string/-/repeat-string-1.6.1.tgz#8dcae470e1c88abc2d600fff4a776286da75e637"
+
+repeating@^2.0.0:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/repeating/-/repeating-2.0.1.tgz#5214c53a926d3552707527fbab415dbc08d06dda"
+  dependencies:
+    is-finite "^1.0.0"
+
+replace-in-file@^2.0.1:
+  version "2.4.0"
+  resolved "https://registry.yarnpkg.com/replace-in-file/-/replace-in-file-2.4.0.tgz#24b82abc6a25f19c9e67c2f6b6c8da7da1976296"
+  dependencies:
+    chalk "^1.1.3"
+    glob "^7.1.1"
+    yargs "^6.6.0"
+
+request@^2.79.0:
+  version "2.79.0"
+  resolved "https://registry.yarnpkg.com/request/-/request-2.79.0.tgz#4dfe5bf6be8b8cdc37fcf93e04b65577722710de"
+  dependencies:
+    aws-sign2 "~0.6.0"
+    aws4 "^1.2.1"
+    caseless "~0.11.0"
+    combined-stream "~1.0.5"
+    extend "~3.0.0"
+    forever-agent "~0.6.1"
+    form-data "~2.1.1"
+    har-validator "~2.0.6"
+    hawk "~3.1.3"
+    http-signature "~1.1.0"
+    is-typedarray "~1.0.0"
+    isstream "~0.1.2"
+    json-stringify-safe "~5.0.1"
+    mime-types "~2.1.7"
+    oauth-sign "~0.8.1"
+    qs "~6.3.0"
+    stringstream "~0.0.4"
+    tough-cookie "~2.3.0"
+    tunnel-agent "~0.4.1"
+    uuid "^3.0.0"
+
+require-directory@^2.1.1:
+  version "2.1.1"
+  resolved "https://registry.yarnpkg.com/require-directory/-/require-directory-2.1.1.tgz#8c64ad5fd30dab1c976e2344ffe7f792a6a6df42"
+
+require-main-filename@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/require-main-filename/-/require-main-filename-1.0.1.tgz#97f717b69d48784f5f526a6c5aa8ffdda055a4d1"
+
+resolve@1.1.7:
+  version "1.1.7"
+  resolved "https://registry.yarnpkg.com/resolve/-/resolve-1.1.7.tgz#203114d82ad2c5ed9e8e0411b3932875e889e97b"
+
+resolve@^1.2.0:
+  version "1.3.1"
+  resolved "https://registry.yarnpkg.com/resolve/-/resolve-1.3.1.tgz#5d0a1632609b6b00a22284293db1d5d973676314"
+  dependencies:
+    path-parse "^1.0.5"
+
+restore-cursor@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/restore-cursor/-/restore-cursor-1.0.1.tgz#34661f46886327fed2991479152252df92daa541"
+  dependencies:
+    exit-hook "^1.0.0"
+    onetime "^1.0.0"
+
+right-align@^0.1.1:
+  version "0.1.3"
+  resolved "https://registry.yarnpkg.com/right-align/-/right-align-0.1.3.tgz#61339b722fe6a3515689210d24e14c96148613ef"
+  dependencies:
+    align-text "^0.1.1"
+
+rimraf@2, rimraf@^2.4.3, rimraf@^2.4.4, rimraf@~2.5.1, rimraf@~2.5.4:
+  version "2.5.4"
+  resolved "https://registry.yarnpkg.com/rimraf/-/rimraf-2.5.4.tgz#96800093cbf1a0c86bd95b4625467535c29dfa04"
+  dependencies:
+    glob "^7.0.5"
+
+rimraf@~2.2.6:
+  version "2.2.8"
+  resolved "https://registry.yarnpkg.com/rimraf/-/rimraf-2.2.8.tgz#e439be2aaee327321952730f99a8929e4fc50582"
+
+ripemd160@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/ripemd160/-/ripemd160-1.0.1.tgz#93a4bbd4942bc574b69a8fa57c71de10ecca7d6e"
+
+rmdir@^1.2.0:
+  version "1.2.0"
+  resolved "https://registry.yarnpkg.com/rmdir/-/rmdir-1.2.0.tgz#4fe0357cb06168c258e73e968093dc4e8a0f3253"
+  dependencies:
+    node.flow "1.2.3"
+
+rollup-plugin-buble@^0.15.0:
+  version "0.15.0"
+  resolved "https://registry.yarnpkg.com/rollup-plugin-buble/-/rollup-plugin-buble-0.15.0.tgz#83c3e89c7fd2266c7918f41ba3980313519c7fd0"
+  dependencies:
+    buble "^0.15.0"
+    rollup-pluginutils "^1.5.0"
+
+rollup-pluginutils@^1.5.0:
+  version "1.5.2"
+  resolved "https://registry.yarnpkg.com/rollup-pluginutils/-/rollup-pluginutils-1.5.2.tgz#1e156e778f94b7255bfa1b3d0178be8f5c552408"
+  dependencies:
+    estree-walker "^0.2.1"
+    minimatch "^3.0.2"
+
+rollup@^0.41.4:
+  version "0.41.4"
+  resolved "https://registry.yarnpkg.com/rollup/-/rollup-0.41.4.tgz#a970580176329f9ead86854d7fd4c46de752aef8"
+  dependencies:
+    source-map-support "^0.4.0"
+
+run-async@^2.2.0:
+  version "2.3.0"
+  resolved "https://registry.yarnpkg.com/run-async/-/run-async-2.3.0.tgz#0371ab4ae0bdd720d4166d7dfda64ff7a445a6c0"
+  dependencies:
+    is-promise "^2.1.0"
+
+rx@^4.1.0:
+  version "4.1.0"
+  resolved "https://registry.yarnpkg.com/rx/-/rx-4.1.0.tgz#a5f13ff79ef3b740fe30aa803fb09f98805d4782"
+
+safe-buffer@^5.0.1:
+  version "5.0.1"
+  resolved "https://registry.yarnpkg.com/safe-buffer/-/safe-buffer-5.0.1.tgz#d263ca54696cd8a306b5ca6551e92de57918fbe7"
+
+sane@~1.5.0:
+  version "1.5.0"
+  resolved "https://registry.yarnpkg.com/sane/-/sane-1.5.0.tgz#a4adeae764d048621ecb27d5f9ecf513101939f3"
+  dependencies:
+    anymatch "^1.3.0"
+    exec-sh "^0.2.0"
+    fb-watchman "^1.8.0"
+    minimatch "^3.0.2"
+    minimist "^1.1.1"
+    walker "~1.0.5"
+    watch "~0.10.0"
+
+sax@^1.2.1:
+  version "1.2.2"
+  resolved "https://registry.yarnpkg.com/sax/-/sax-1.2.2.tgz#fd8631a23bc7826bef5d871bdb87378c95647828"
+
+"semver@2 || 3 || 4 || 5", semver@^5.3.0, semver@~5.3.0:
+  version "5.3.0"
+  resolved "https://registry.yarnpkg.com/semver/-/semver-5.3.0.tgz#9b2ce5d3de02d17c6012ad326aa6b4d0cf54f94f"
+
+set-blocking@^2.0.0, set-blocking@~2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/set-blocking/-/set-blocking-2.0.0.tgz#045f9782d011ae9a6803ddd382b24392b3d890f7"
+
+set-immediate-shim@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/set-immediate-shim/-/set-immediate-shim-1.0.1.tgz#4b2b1b27eb808a9f8dcc481a58e5e56f599f3f61"
+
+setimmediate@^1.0.4:
+  version "1.0.5"
+  resolved "https://registry.yarnpkg.com/setimmediate/-/setimmediate-1.0.5.tgz#290cbb232e306942d7d7ea9b83732ab7856f8285"
+
+sha.js@^2.3.6:
+  version "2.4.8"
+  resolved "https://registry.yarnpkg.com/sha.js/-/sha.js-2.4.8.tgz#37068c2c476b6baf402d14a49c67f597921f634f"
+  dependencies:
+    inherits "^2.0.1"
+
+shellwords@^0.1.0:
+  version "0.1.0"
+  resolved "https://registry.yarnpkg.com/shellwords/-/shellwords-0.1.0.tgz#66afd47b6a12932d9071cbfd98a52e785cd0ba14"
+
+signal-exit@^3.0.0:
+  version "3.0.2"
+  resolved "https://registry.yarnpkg.com/signal-exit/-/signal-exit-3.0.2.tgz#b5fdc08f1287ea1178628e415e25132b73646c6d"
+
+slash@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/slash/-/slash-1.0.0.tgz#c41f2f6c39fc16d1cd17ad4b5d896114ae470d55"
+
+sntp@1.x.x:
+  version "1.0.9"
+  resolved "https://registry.yarnpkg.com/sntp/-/sntp-1.0.9.tgz#6541184cc90aeea6c6e7b35e2659082443c66198"
+  dependencies:
+    hoek "2.x.x"
+
+source-list-map@~0.1.7:
+  version "0.1.8"
+  resolved "https://registry.yarnpkg.com/source-list-map/-/source-list-map-0.1.8.tgz#c550b2ab5427f6b3f21f5afead88c4f5587b2106"
+
+source-map-support@^0.4.0, source-map-support@^0.4.2:
+  version "0.4.11"
+  resolved "https://registry.yarnpkg.com/source-map-support/-/source-map-support-0.4.11.tgz#647f939978b38535909530885303daf23279f322"
+  dependencies:
+    source-map "^0.5.3"
+
+source-map@^0.4.4:
+  version "0.4.4"
+  resolved "https://registry.yarnpkg.com/source-map/-/source-map-0.4.4.tgz#eba4f5da9c0dc999de68032d8b4f76173652036b"
+  dependencies:
+    amdefine ">=0.0.4"
+
+source-map@^0.5.0, source-map@^0.5.3, source-map@~0.5.1, source-map@~0.5.3:
+  version "0.5.6"
+  resolved "https://registry.yarnpkg.com/source-map/-/source-map-0.5.6.tgz#75ce38f52bf0733c5a7f0c118d81334a2bb5f412"
+
+source-map@~0.2.0:
+  version "0.2.0"
+  resolved "https://registry.yarnpkg.com/source-map/-/source-map-0.2.0.tgz#dab73fbcfc2ba819b4de03bd6f6eaa48164b3f9d"
+  dependencies:
+    amdefine ">=0.0.4"
+
+spawn-sync@^1.0.15:
+  version "1.0.15"
+  resolved "https://registry.yarnpkg.com/spawn-sync/-/spawn-sync-1.0.15.tgz#b00799557eb7fb0c8376c29d44e8a1ea67e57476"
+  dependencies:
+    concat-stream "^1.4.7"
+    os-shim "^0.1.2"
+
+spdx-correct@~1.0.0:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/spdx-correct/-/spdx-correct-1.0.2.tgz#4b3073d933ff51f3912f03ac5519498a4150db40"
+  dependencies:
+    spdx-license-ids "^1.0.2"
+
+spdx-expression-parse@~1.0.0:
+  version "1.0.4"
+  resolved "https://registry.yarnpkg.com/spdx-expression-parse/-/spdx-expression-parse-1.0.4.tgz#9bdf2f20e1f40ed447fbe273266191fced51626c"
+
+spdx-license-ids@^1.0.2:
+  version "1.2.2"
+  resolved "https://registry.yarnpkg.com/spdx-license-ids/-/spdx-license-ids-1.2.2.tgz#c9df7a3424594ade6bd11900d596696dc06bac57"
+
+sprintf-js@~1.0.2:
+  version "1.0.3"
+  resolved "https://registry.yarnpkg.com/sprintf-js/-/sprintf-js-1.0.3.tgz#04e6926f662895354f3dd015203633b857297e2c"
+
+sshpk@^1.7.0:
+  version "1.10.2"
+  resolved "https://registry.yarnpkg.com/sshpk/-/sshpk-1.10.2.tgz#d5a804ce22695515638e798dbe23273de070a5fa"
+  dependencies:
+    asn1 "~0.2.3"
+    assert-plus "^1.0.0"
+    dashdash "^1.12.0"
+    getpass "^0.1.1"
+  optionalDependencies:
+    bcrypt-pbkdf "^1.0.0"
+    ecc-jsbn "~0.1.1"
+    jodid25519 "^1.0.0"
+    jsbn "~0.1.0"
+    tweetnacl "~0.14.0"
+
+stream-browserify@^2.0.1:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/stream-browserify/-/stream-browserify-2.0.1.tgz#66266ee5f9bdb9940a4e4514cafb43bb71e5c9db"
+  dependencies:
+    inherits "~2.0.1"
+    readable-stream "^2.0.2"
+
+stream-http@^2.3.1:
+  version "2.6.3"
+  resolved "https://registry.yarnpkg.com/stream-http/-/stream-http-2.6.3.tgz#4c3ddbf9635968ea2cfd4e48d43de5def2625ac3"
+  dependencies:
+    builtin-status-codes "^3.0.0"
+    inherits "^2.0.1"
+    readable-stream "^2.1.0"
+    to-arraybuffer "^1.0.0"
+    xtend "^4.0.0"
+
+string-length@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/string-length/-/string-length-1.0.1.tgz#56970fb1c38558e9e70b728bf3de269ac45adfac"
+  dependencies:
+    strip-ansi "^3.0.0"
+
+string-width@^1.0.1, string-width@^1.0.2:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/string-width/-/string-width-1.0.2.tgz#118bdf5b8cdc51a2a7e70d211e07e2b0b9b107d3"
+  dependencies:
+    code-point-at "^1.0.0"
+    is-fullwidth-code-point "^1.0.0"
+    strip-ansi "^3.0.0"
+
+string_decoder@^0.10.25, string_decoder@~0.10.x:
+  version "0.10.31"
+  resolved "https://registry.yarnpkg.com/string_decoder/-/string_decoder-0.10.31.tgz#62e203bc41766c6c28c9fc84301dab1c5310fa94"
+
+stringstream@~0.0.4:
+  version "0.0.5"
+  resolved "https://registry.yarnpkg.com/stringstream/-/stringstream-0.0.5.tgz#4e484cd4de5a0bbbee18e46307710a8a81621878"
+
+strip-ansi@^3.0.0, strip-ansi@^3.0.1:
+  version "3.0.1"
+  resolved "https://registry.yarnpkg.com/strip-ansi/-/strip-ansi-3.0.1.tgz#6a385fb8853d952d5ff05d0e8aaf94278dc63dcf"
+  dependencies:
+    ansi-regex "^2.0.0"
+
+strip-bom@3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/strip-bom/-/strip-bom-3.0.0.tgz#2334c18e9c759f7bdd56fdef7e9ae3d588e68ed3"
+
+strip-bom@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/strip-bom/-/strip-bom-2.0.0.tgz#6219a85616520491f35788bdbf1447a99c7e6b0e"
+  dependencies:
+    is-utf8 "^0.2.0"
+
+strip-json-comments@~2.0.1:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/strip-json-comments/-/strip-json-comments-2.0.1.tgz#3c531942e908c2697c0ec344858c286c7ca0a60a"
+
+supports-color@^2.0.0:
+  version "2.0.0"
+  resolved "https://registry.yarnpkg.com/supports-color/-/supports-color-2.0.0.tgz#535d045ce6b6363fa40117084629995e9df324c7"
+
+supports-color@^3.1.0, supports-color@^3.1.2:
+  version "3.2.3"
+  resolved "https://registry.yarnpkg.com/supports-color/-/supports-color-3.2.3.tgz#65ac0504b3954171d8a64946b2ae3cbb8a5f54f6"
+  dependencies:
+    has-flag "^1.0.0"
+
+symbol-tree@^3.2.1:
+  version "3.2.2"
+  resolved "https://registry.yarnpkg.com/symbol-tree/-/symbol-tree-3.2.2.tgz#ae27db38f660a7ae2e1c3b7d1bc290819b8519e6"
+
+tapable@^0.2.5, tapable@~0.2.5:
+  version "0.2.6"
+  resolved "https://registry.yarnpkg.com/tapable/-/tapable-0.2.6.tgz#206be8e188860b514425375e6f1ae89bfb01fd8d"
+
+tar-pack@~3.3.0:
+  version "3.3.0"
+  resolved "https://registry.yarnpkg.com/tar-pack/-/tar-pack-3.3.0.tgz#30931816418f55afc4d21775afdd6720cee45dae"
+  dependencies:
+    debug "~2.2.0"
+    fstream "~1.0.10"
+    fstream-ignore "~1.0.5"
+    once "~1.3.3"
+    readable-stream "~2.1.4"
+    rimraf "~2.5.1"
+    tar "~2.2.1"
+    uid-number "~0.0.6"
+
+tar@~2.2.1:
+  version "2.2.1"
+  resolved "https://registry.yarnpkg.com/tar/-/tar-2.2.1.tgz#8e4d2a256c0e2185c6b18ad694aec968b83cb1d1"
+  dependencies:
+    block-stream "*"
+    fstream "^1.0.2"
+    inherits "2"
+
+temp@^0.8.3:
+  version "0.8.3"
+  resolved "https://registry.yarnpkg.com/temp/-/temp-0.8.3.tgz#e0c6bc4d26b903124410e4fed81103014dfc1f59"
+  dependencies:
+    os-tmpdir "^1.0.0"
+    rimraf "~2.2.6"
+
+test-exclude@^4.0.0:
+  version "4.0.0"
+  resolved "https://registry.yarnpkg.com/test-exclude/-/test-exclude-4.0.0.tgz#0ddc0100b8ae7e88b34eb4fd98a907e961991900"
+  dependencies:
+    arrify "^1.0.1"
+    micromatch "^2.3.11"
+    object-assign "^4.1.0"
+    read-pkg-up "^1.0.1"
+    require-main-filename "^1.0.1"
+
+throat@^3.0.0:
+  version "3.0.0"
+  resolved "https://registry.yarnpkg.com/throat/-/throat-3.0.0.tgz#e7c64c867cbb3845f10877642f7b60055b8ec0d6"
+
+through@^2.3.6:
+  version "2.3.8"
+  resolved "https://registry.yarnpkg.com/through/-/through-2.3.8.tgz#0dd4c9ffaabc357960b1b724115d7e0e86a2e1f5"
+
+timed-out@^4.0.0:
+  version "4.0.1"
+  resolved "https://registry.yarnpkg.com/timed-out/-/timed-out-4.0.1.tgz#f32eacac5a175bea25d7fab565ab3ed8741ef56f"
+
+timers-browserify@^2.0.2:
+  version "2.0.2"
+  resolved "https://registry.yarnpkg.com/timers-browserify/-/timers-browserify-2.0.2.tgz#ab4883cf597dcd50af211349a00fbca56ac86b86"
+  dependencies:
+    setimmediate "^1.0.4"
+
+tmp@^0.0.29:
+  version "0.0.29"
+  resolved "https://registry.yarnpkg.com/tmp/-/tmp-0.0.29.tgz#f25125ff0dd9da3ccb0c2dd371ee1288bb9128c0"
+  dependencies:
+    os-tmpdir "~1.0.1"
+
+tmpl@1.0.x:
+  version "1.0.4"
+  resolved "https://registry.yarnpkg.com/tmpl/-/tmpl-1.0.4.tgz#23640dd7b42d00433911140820e5cf440e521dd1"
+
+to-arraybuffer@^1.0.0:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/to-arraybuffer/-/to-arraybuffer-1.0.1.tgz#7d229b1fcc637e466ca081180836a7aabff83f43"
+
+to-fast-properties@^1.0.1:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/to-fast-properties/-/to-fast-properties-1.0.2.tgz#f3f5c0c3ba7299a7ef99427e44633257ade43320"
+
+tough-cookie@^2.3.2, tough-cookie@~2.3.0:
+  version "2.3.2"
+  resolved "https://registry.yarnpkg.com/tough-cookie/-/tough-cookie-2.3.2.tgz#f081f76e4c85720e6c37a5faced737150d84072a"
+  dependencies:
+    punycode "^1.4.1"
+
+tr46@~0.0.3:
+  version "0.0.3"
+  resolved "https://registry.yarnpkg.com/tr46/-/tr46-0.0.3.tgz#8184fd347dac9cdc185992f3a6622e14b9d9ab6a"
+
+trim-right@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/trim-right/-/trim-right-1.0.1.tgz#cb2e1203067e0c8de1f614094b9fe45704ea6003"
+
+tty-browserify@0.0.0:
+  version "0.0.0"
+  resolved "https://registry.yarnpkg.com/tty-browserify/-/tty-browserify-0.0.0.tgz#a157ba402da24e9bf957f9aa69d524eed42901a6"
+
+tunnel-agent@~0.4.1:
+  version "0.4.3"
+  resolved "https://registry.yarnpkg.com/tunnel-agent/-/tunnel-agent-0.4.3.tgz#6373db76909fe570e08d73583365ed828a74eeeb"
+
+tweetnacl@^0.14.3, tweetnacl@~0.14.0:
+  version "0.14.5"
+  resolved "https://registry.yarnpkg.com/tweetnacl/-/tweetnacl-0.14.5.tgz#5ae68177f192d4456269d108afa93ff8743f4f64"
+
+type-check@~0.3.2:
+  version "0.3.2"
+  resolved "https://registry.yarnpkg.com/type-check/-/type-check-0.3.2.tgz#5884cab512cf1d355e3fb784f30804b2b520db72"
+  dependencies:
+    prelude-ls "~1.1.2"
+
+typedarray@^0.0.6:
+  version "0.0.6"
+  resolved "https://registry.yarnpkg.com/typedarray/-/typedarray-0.0.6.tgz#867ac74e3864187b1d3d47d996a78ec5c8830777"
+
+uglify-js@^2.6, uglify-js@^2.7.5:
+  version "2.7.5"
+  resolved "https://registry.yarnpkg.com/uglify-js/-/uglify-js-2.7.5.tgz#4612c0c7baaee2ba7c487de4904ae122079f2ca8"
+  dependencies:
+    async "~0.2.6"
+    source-map "~0.5.1"
+    uglify-to-browserify "~1.0.0"
+    yargs "~3.10.0"
+
+uglify-to-browserify@~1.0.0:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/uglify-to-browserify/-/uglify-to-browserify-1.0.2.tgz#6e0924d6bda6b5afe349e39a6d632850a0f882b7"
+
+uid-number@~0.0.6:
+  version "0.0.6"
+  resolved "https://registry.yarnpkg.com/uid-number/-/uid-number-0.0.6.tgz#0ea10e8035e8eb5b8e4449f06da1c730663baa81"
+
+unzip-response@^2.0.1:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/unzip-response/-/unzip-response-2.0.1.tgz#d2f0f737d16b0615e72a6935ed04214572d56f97"
+
+url-parse-lax@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/url-parse-lax/-/url-parse-lax-1.0.0.tgz#7af8f303645e9bd79a272e7a14ac68bc0609da73"
+  dependencies:
+    prepend-http "^1.0.1"
+
+url@^0.11.0:
+  version "0.11.0"
+  resolved "https://registry.yarnpkg.com/url/-/url-0.11.0.tgz#3838e97cfc60521eb73c525a8e55bfdd9e2e28f1"
+  dependencies:
+    punycode "1.3.2"
+    querystring "0.2.0"
+
+util-deprecate@~1.0.1:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/util-deprecate/-/util-deprecate-1.0.2.tgz#450d4dc9fa70de732762fbd2d4a28981419a0ccf"
+
+util@0.10.3, util@^0.10.3:
+  version "0.10.3"
+  resolved "https://registry.yarnpkg.com/util/-/util-0.10.3.tgz#7afb1afe50805246489e3db7fe0ed379336ac0f9"
+  dependencies:
+    inherits "2.0.1"
+
+uuid@^3.0.0:
+  version "3.0.1"
+  resolved "https://registry.yarnpkg.com/uuid/-/uuid-3.0.1.tgz#6544bba2dfda8c1cf17e629a3a305e2bb1fee6c1"
+
+validate-npm-package-license@^3.0.1:
+  version "3.0.1"
+  resolved "https://registry.yarnpkg.com/validate-npm-package-license/-/validate-npm-package-license-3.0.1.tgz#2804babe712ad3379459acfbe24746ab2c303fbc"
+  dependencies:
+    spdx-correct "~1.0.0"
+    spdx-expression-parse "~1.0.0"
+
+verror@1.3.6:
+  version "1.3.6"
+  resolved "https://registry.yarnpkg.com/verror/-/verror-1.3.6.tgz#cff5df12946d297d2baaefaa2689e25be01c005c"
+  dependencies:
+    extsprintf "1.0.2"
+
+vlq@^0.2.1:
+  version "0.2.1"
+  resolved "https://registry.yarnpkg.com/vlq/-/vlq-0.2.1.tgz#14439d711891e682535467f8587c5630e4222a6c"
+
+vm-browserify@0.0.4:
+  version "0.0.4"
+  resolved "https://registry.yarnpkg.com/vm-browserify/-/vm-browserify-0.0.4.tgz#5d7ea45bbef9e4a6ff65f95438e0a87c357d5a73"
+  dependencies:
+    indexof "0.0.1"
+
+vue@^2.2.1:
+  version "2.2.1"
+  resolved "https://registry.yarnpkg.com/vue/-/vue-2.2.1.tgz#ddbfd2f0caf38f374f5a36eea2e1edf25225b68e"
+
+walker@~1.0.5:
+  version "1.0.7"
+  resolved "https://registry.yarnpkg.com/walker/-/walker-1.0.7.tgz#2f7f9b8fd10d677262b18a884e28d19618e028fb"
+  dependencies:
+    makeerror "1.0.x"
+
+watch@~0.10.0:
+  version "0.10.0"
+  resolved "https://registry.yarnpkg.com/watch/-/watch-0.10.0.tgz#77798b2da0f9910d595f1ace5b0c2258521f21dc"
+
+watchpack@^1.2.0:
+  version "1.3.1"
+  resolved "https://registry.yarnpkg.com/watchpack/-/watchpack-1.3.1.tgz#7d8693907b28ce6013e7f3610aa2a1acf07dad87"
+  dependencies:
+    async "^2.1.2"
+    chokidar "^1.4.3"
+    graceful-fs "^4.1.2"
+
+webidl-conversions@^3.0.0:
+  version "3.0.1"
+  resolved "https://registry.yarnpkg.com/webidl-conversions/-/webidl-conversions-3.0.1.tgz#24534275e2a7bc6be7bc86611cc16ae0a5654871"
+
+webidl-conversions@^4.0.0:
+  version "4.0.1"
+  resolved "https://registry.yarnpkg.com/webidl-conversions/-/webidl-conversions-4.0.1.tgz#8015a17ab83e7e1b311638486ace81da6ce206a0"
+
+webpack-sources@^0.1.4:
+  version "0.1.4"
+  resolved "https://registry.yarnpkg.com/webpack-sources/-/webpack-sources-0.1.4.tgz#ccc2c817e08e5fa393239412690bb481821393cd"
+  dependencies:
+    source-list-map "~0.1.7"
+    source-map "~0.5.3"
+
+webpack@*, webpack@^2.2.0:
+  version "2.2.1"
+  resolved "https://registry.yarnpkg.com/webpack/-/webpack-2.2.1.tgz#7bb1d72ae2087dd1a4af526afec15eed17dda475"
+  dependencies:
+    acorn "^4.0.4"
+    acorn-dynamic-import "^2.0.0"
+    ajv "^4.7.0"
+    ajv-keywords "^1.1.1"
+    async "^2.1.2"
+    enhanced-resolve "^3.0.0"
+    interpret "^1.0.0"
+    json-loader "^0.5.4"
+    loader-runner "^2.3.0"
+    loader-utils "^0.2.16"
+    memory-fs "~0.4.1"
+    mkdirp "~0.5.0"
+    node-libs-browser "^2.0.0"
+    source-map "^0.5.3"
+    supports-color "^3.1.0"
+    tapable "~0.2.5"
+    uglify-js "^2.7.5"
+    watchpack "^1.2.0"
+    webpack-sources "^0.1.4"
+    yargs "^6.0.0"
+
+whatwg-encoding@^1.0.1:
+  version "1.0.1"
+  resolved "https://registry.yarnpkg.com/whatwg-encoding/-/whatwg-encoding-1.0.1.tgz#3c6c451a198ee7aec55b1ec61d0920c67801a5f4"
+  dependencies:
+    iconv-lite "0.4.13"
+
+whatwg-url@^4.3.0:
+  version "4.5.0"
+  resolved "https://registry.yarnpkg.com/whatwg-url/-/whatwg-url-4.5.0.tgz#79bb6f0e370a4dda1cbc8f3062a490cf8bbb09ea"
+  dependencies:
+    tr46 "~0.0.3"
+    webidl-conversions "^3.0.0"
+
+which-module@^1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/which-module/-/which-module-1.0.0.tgz#bba63ca861948994ff307736089e3b96026c2a4f"
+
+which@^1.1.1, which@^1.2.12:
+  version "1.2.12"
+  resolved "https://registry.yarnpkg.com/which/-/which-1.2.12.tgz#de67b5e450269f194909ef23ece4ebe416fa1192"
+  dependencies:
+    isexe "^1.1.1"
+
+wide-align@^1.1.0:
+  version "1.1.0"
+  resolved "https://registry.yarnpkg.com/wide-align/-/wide-align-1.1.0.tgz#40edde802a71fea1f070da3e62dcda2e7add96ad"
+  dependencies:
+    string-width "^1.0.1"
+
+window-size@0.1.0:
+  version "0.1.0"
+  resolved "https://registry.yarnpkg.com/window-size/-/window-size-0.1.0.tgz#5438cd2ea93b202efa3a19fe8887aee7c94f9c9d"
+
+wordwrap@0.0.2, wordwrap@~0.0.2:
+  version "0.0.2"
+  resolved "https://registry.yarnpkg.com/wordwrap/-/wordwrap-0.0.2.tgz#b79669bb42ecb409f83d583cad52ca17eaa1643f"
+
+wordwrap@~1.0.0:
+  version "1.0.0"
+  resolved "https://registry.yarnpkg.com/wordwrap/-/wordwrap-1.0.0.tgz#27584810891456a4171c8d0226441ade90cbcaeb"
+
+worker-farm@^1.3.1:
+  version "1.3.1"
+  resolved "https://registry.yarnpkg.com/worker-farm/-/worker-farm-1.3.1.tgz#4333112bb49b17aa050b87895ca6b2cacf40e5ff"
+  dependencies:
+    errno ">=0.1.1 <0.2.0-0"
+    xtend ">=4.0.0 <4.1.0-0"
+
+wrap-ansi@^2.0.0:
+  version "2.1.0"
+  resolved "https://registry.yarnpkg.com/wrap-ansi/-/wrap-ansi-2.1.0.tgz#d8fc3d284dd05794fe84973caecdd1cf824fdd85"
+  dependencies:
+    string-width "^1.0.1"
+    strip-ansi "^3.0.1"
+
+wrappy@1:
+  version "1.0.2"
+  resolved "https://registry.yarnpkg.com/wrappy/-/wrappy-1.0.2.tgz#b5243d8f3ec1aa35f1364605bc0d1036e30ab69f"
+
+xml-name-validator@^2.0.1:
+  version "2.0.1"
+  resolved "https://registry.yarnpkg.com/xml-name-validator/-/xml-name-validator-2.0.1.tgz#4d8b8f1eccd3419aa362061becef515e1e559635"
+
+"xtend@>=4.0.0 <4.1.0-0", xtend@^4.0.0, xtend@^4.0.1:
+  version "4.0.1"
+  resolved "https://registry.yarnpkg.com/xtend/-/xtend-4.0.1.tgz#a5c6d532be656e23db820efb943a1f04998d63af"
+
+y18n@^3.2.1:
+  version "3.2.1"
+  resolved "https://registry.yarnpkg.com/y18n/-/y18n-3.2.1.tgz#6d15fba884c08679c0d77e88e7759e811e07fa41"
+
+yargs-parser@^4.2.0:
+  version "4.2.1"
+  resolved "https://registry.yarnpkg.com/yargs-parser/-/yargs-parser-4.2.1.tgz#29cceac0dc4f03c6c87b4a9f217dd18c9f74871c"
+  dependencies:
+    camelcase "^3.0.0"
+
+yargs@^6.0.0, yargs@^6.3.0, yargs@^6.6.0:
+  version "6.6.0"
+  resolved "https://registry.yarnpkg.com/yargs/-/yargs-6.6.0.tgz#782ec21ef403345f830a808ca3d513af56065208"
+  dependencies:
+    camelcase "^3.0.0"
+    cliui "^3.2.0"
+    decamelize "^1.1.1"
+    get-caller-file "^1.0.1"
+    os-locale "^1.4.0"
+    read-pkg-up "^1.0.1"
+    require-directory "^2.1.1"
+    require-main-filename "^1.0.1"
+    set-blocking "^2.0.0"
+    string-width "^1.0.2"
+    which-module "^1.0.0"
+    y18n "^3.2.1"
+    yargs-parser "^4.2.0"
+
+yargs@~3.10.0:
+  version "3.10.0"
+  resolved "https://registry.yarnpkg.com/yargs/-/yargs-3.10.0.tgz#f7ee7bd857dd7c1d2d38c0e74efbd681d1431fd1"
+  dependencies:
+    camelcase "^1.0.2"
+    cliui "^2.1.0"
+    decamelize "^1.0.0"
+    window-size "0.1.0"
Index: public/node_modules/vue/src/platforms/web/compiler/modules/class.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/modules/class.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/modules/class.js	(revision )
@@ -0,0 +1,48 @@
+/* @flow */
+
+import { parseText } from 'compiler/parser/text-parser'
+import {
+  getAndRemoveAttr,
+  getBindingAttr,
+  baseWarn
+} from 'compiler/helpers'
+
+function transformNode (el: ASTElement, options: CompilerOptions) {
+  const warn = options.warn || baseWarn
+  const staticClass = getAndRemoveAttr(el, 'class')
+  if (process.env.NODE_ENV !== 'production' && staticClass) {
+    const expression = parseText(staticClass, options.delimiters)
+    if (expression) {
+      warn(
+        `class="${staticClass}": ` +
+        'Interpolation inside attributes has been removed. ' +
+        'Use v-bind or the colon shorthand instead. For example, ' +
+        'instead of <div class="{{ val }}">, use <div :class="val">.'
+      )
+    }
+  }
+  if (staticClass) {
+    el.staticClass = JSON.stringify(staticClass)
+  }
+  const classBinding = getBindingAttr(el, 'class', false /* getStatic */)
+  if (classBinding) {
+    el.classBinding = classBinding
+  }
+}
+
+function genData (el: ASTElement): string {
+  let data = ''
+  if (el.staticClass) {
+    data += `staticClass:${el.staticClass},`
+  }
+  if (el.classBinding) {
+    data += `class:${el.classBinding},`
+  }
+  return data
+}
+
+export default {
+  staticKeys: ['staticClass'],
+  transformNode,
+  genData
+}
Index: public/node_modules/vue/src/platforms/weex/runtime/text-node.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/text-node.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/text-node.js	(revision )
@@ -0,0 +1,9 @@
+let latestNodeId = 1
+
+export default function TextNode (text) {
+  this.instanceId = ''
+  this.nodeId = latestNodeId++
+  this.parentNode = null
+  this.nodeType = 3
+  this.text = text
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/index.js	(revision )
@@ -0,0 +1,14 @@
+'use strict';
+module.exports = function (url) {
+	if (typeof url !== 'string') {
+		throw new TypeError('Expected a string, got ' + typeof url);
+	}
+
+	url = url.trim();
+
+	if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
+		return url;
+	}
+
+	return url.replace(/^(?!(?:\w+:)?\/\/)/, 'http://');
+};
Index: public/node_modules/vue/types/plugin.d.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/types/plugin.d.ts	(revision )
+++ public/node_modules/vue/types/plugin.d.ts	(revision )
@@ -0,0 +1,8 @@
+import { Vue as _Vue } from "./vue";
+
+export type PluginFunction<T> = (Vue: typeof _Vue, options?: T) => void;
+
+export interface PluginObject<T> {
+  install: PluginFunction<T>;
+  [key: string]: any;
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/index.js	(revision )
@@ -0,0 +1,14 @@
+'use strict';
+module.exports = function (x) {
+	if (typeof x !== 'number') {
+		throw new TypeError('Expected a number');
+	}
+
+	return x === 300 ||
+		x === 301 ||
+		x === 302 ||
+		x === 303 ||
+		x === 305 ||
+		x === 307 ||
+		x === 308;
+};
Index: public/node_modules/vue/src/shared/util.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/shared/util.js	(revision )
+++ public/node_modules/vue/src/shared/util.js	(revision )
@@ -0,0 +1,245 @@
+/* @flow */
+
+/**
+ * Convert a value to a string that is actually rendered.
+ */
+export function _toString (val: any): string {
+  return val == null
+    ? ''
+    : typeof val === 'object'
+      ? JSON.stringify(val, null, 2)
+      : String(val)
+}
+
+/**
+ * Convert a input value to a number for persistence.
+ * If the conversion fails, return original string.
+ */
+export function toNumber (val: string): number | string {
+  const n = parseFloat(val)
+  return isNaN(n) ? val : n
+}
+
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ */
+export function makeMap (
+  str: string,
+  expectsLowerCase?: boolean
+): (key: string) => true | void {
+  const map = Object.create(null)
+  const list: Array<string> = str.split(',')
+  for (let i = 0; i < list.length; i++) {
+    map[list[i]] = true
+  }
+  return expectsLowerCase
+    ? val => map[val.toLowerCase()]
+    : val => map[val]
+}
+
+/**
+ * Check if a tag is a built-in tag.
+ */
+export const isBuiltInTag = makeMap('slot,component', true)
+
+/**
+ * Remove an item from an array
+ */
+export function remove (arr: Array<any>, item: any): Array<any> | void {
+  if (arr.length) {
+    const index = arr.indexOf(item)
+    if (index > -1) {
+      return arr.splice(index, 1)
+    }
+  }
+}
+
+/**
+ * Check whether the object has the property.
+ */
+const hasOwnProperty = Object.prototype.hasOwnProperty
+export function hasOwn (obj: Object, key: string): boolean {
+  return hasOwnProperty.call(obj, key)
+}
+
+/**
+ * Check if value is primitive
+ */
+export function isPrimitive (value: any): boolean {
+  return typeof value === 'string' || typeof value === 'number'
+}
+
+/**
+ * Create a cached version of a pure function.
+ */
+export function cached<F: Function> (fn: F): F {
+  const cache = Object.create(null)
+  return (function cachedFn (str: string) {
+    const hit = cache[str]
+    return hit || (cache[str] = fn(str))
+  }: any)
+}
+
+/**
+ * Camelize a hyphen-delimited string.
+ */
+const camelizeRE = /-(\w)/g
+export const camelize = cached((str: string): string => {
+  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '')
+})
+
+/**
+ * Capitalize a string.
+ */
+export const capitalize = cached((str: string): string => {
+  return str.charAt(0).toUpperCase() + str.slice(1)
+})
+
+/**
+ * Hyphenate a camelCase string.
+ */
+const hyphenateRE = /([^-])([A-Z])/g
+export const hyphenate = cached((str: string): string => {
+  return str
+    .replace(hyphenateRE, '$1-$2')
+    .replace(hyphenateRE, '$1-$2')
+    .toLowerCase()
+})
+
+/**
+ * Simple bind, faster than native
+ */
+export function bind (fn: Function, ctx: Object): Function {
+  function boundFn (a) {
+    const l: number = arguments.length
+    return l
+      ? l > 1
+        ? fn.apply(ctx, arguments)
+        : fn.call(ctx, a)
+      : fn.call(ctx)
+  }
+  // record original fn length
+  boundFn._length = fn.length
+  return boundFn
+}
+
+/**
+ * Convert an Array-like object to a real Array.
+ */
+export function toArray (list: any, start?: number): Array<any> {
+  start = start || 0
+  let i = list.length - start
+  const ret: Array<any> = new Array(i)
+  while (i--) {
+    ret[i] = list[i + start]
+  }
+  return ret
+}
+
+/**
+ * Mix properties into target object.
+ */
+export function extend (to: Object, _from: ?Object): Object {
+  for (const key in _from) {
+    to[key] = _from[key]
+  }
+  return to
+}
+
+/**
+ * Quick object check - this is primarily used to tell
+ * Objects from primitive values when we know the value
+ * is a JSON-compliant type.
+ */
+export function isObject (obj: mixed): boolean {
+  return obj !== null && typeof obj === 'object'
+}
+
+/**
+ * Strict object type check. Only returns true
+ * for plain JavaScript objects.
+ */
+const toString = Object.prototype.toString
+const OBJECT_STRING = '[object Object]'
+export function isPlainObject (obj: any): boolean {
+  return toString.call(obj) === OBJECT_STRING
+}
+
+/**
+ * Merge an Array of Objects into a single Object.
+ */
+export function toObject (arr: Array<any>): Object {
+  const res = {}
+  for (let i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i])
+    }
+  }
+  return res
+}
+
+/**
+ * Perform no operation.
+ */
+export function noop () {}
+
+/**
+ * Always return false.
+ */
+export const no = () => false
+
+/**
+ * Return same value
+ */
+export const identity = (_: any) => _
+
+/**
+ * Generate a static keys string from compiler modules.
+ */
+export function genStaticKeys (modules: Array<ModuleOptions>): string {
+  return modules.reduce((keys, m) => {
+    return keys.concat(m.staticKeys || [])
+  }, []).join(',')
+}
+
+/**
+ * Check if two values are loosely equal - that is,
+ * if they are plain objects, do they have the same shape?
+ */
+export function looseEqual (a: mixed, b: mixed): boolean {
+  const isObjectA = isObject(a)
+  const isObjectB = isObject(b)
+  if (isObjectA && isObjectB) {
+    try {
+      return JSON.stringify(a) === JSON.stringify(b)
+    } catch (e) {
+      // possible circular reference
+      return a === b
+    }
+  } else if (!isObjectA && !isObjectB) {
+    return String(a) === String(b)
+  } else {
+    return false
+  }
+}
+
+export function looseIndexOf (arr: Array<mixed>, val: mixed): number {
+  for (let i = 0; i < arr.length; i++) {
+    if (looseEqual(arr[i], val)) return i
+  }
+  return -1
+}
+
+/**
+ * Ensure a function is called only once.
+ */
+export function once (fn: Function): Function {
+  let called = false
+  return () => {
+    if (!called) {
+      called = true
+      fn()
+    }
+  }
+}
Index: public/node_modules/vue-select2/gulpfile.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/gulpfile.js	(revision )
+++ public/node_modules/vue-select2/gulpfile.js	(revision )
@@ -0,0 +1,105 @@
+//  Gulp building scripts
+var gulp = require("gulp");
+var del = require("del");
+var gutil = require("gulp-util");
+var webpack = require("webpack");
+var webpackConfig = require("./webpack.config.js");
+var runSequence = require("run-sequence");
+var Server = require('karma').Server;
+var pkg = require("./package.json");
+var dirs = pkg.configs.directories;
+
+// ---------------------------------------------------------------------
+// | Helper tasks                                                      |
+// ---------------------------------------------------------------------
+
+gulp.task("clean", function (done) {
+  del([ dirs.dist, dirs.coverage ]);
+  done();
+});
+
+gulp.task("webpack-dev", function(done) {
+  // modify some webpack config options
+  var webpackDevConfig = Object.create(webpackConfig);
+  webpackDevConfig.devtool = "sourcemap";
+  webpackDevConfig.debug = true;
+  // create a single instance of the compiler to allow caching
+  var webpackDevCompiler = webpack(webpackDevConfig);
+  // run webpack
+  webpackDevCompiler.run(function(err, stats) {
+    if(err) throw new gutil.PluginError("webpack:build-dev", err);
+    gutil.log("[webpack:build-dev]", stats.toString({
+      colors: true
+    }));
+    done();
+  });
+});
+
+gulp.task("webpack", function(done) {
+  // modify some webpack config options
+  var webpackProdConfig = Object.create(webpackConfig);
+  webpackProdConfig.plugins.push(new webpack.DefinePlugin({
+    "process.env": {
+      // This has effect on the react lib size
+      "NODE_ENV": JSON.stringify("production")
+    }
+  }), new webpack.optimize.UglifyJsPlugin());
+  webpackProdConfig.output.filename = "[name].min.js";
+  // run webpack
+  webpack(webpackProdConfig, function(err, stats) {
+    if(err) throw new gutil.PluginError("webpack:build", err);
+    gutil.log("[webpack:build]", stats.toString({
+      colors: true
+    }));
+    done();
+  });
+});
+
+gulp.task('test', function(done) {
+  // Be sure to return the stream
+  new Server({
+    configFile: __dirname + '/karma.conf.js',
+    singleRun: true
+  }, done).start();
+});
+
+gulp.task('test:coverage', function(done) {
+  // Be sure to return the stream
+  process.env.TEST_TYPE = "coverage";
+  new Server({
+    configFile: __dirname + '/karma.conf.js',
+    singleRun: true
+  }, done).start();
+});
+
+gulp.task('test:coveralls', function(done) {
+  // Be sure to return the stream
+  process.env.TEST_TYPE = "coveralls";
+  new Server({
+    configFile: __dirname + '/karma.conf.js',
+    singleRun: true
+  }, done).start();
+});
+
+// ---------------------------------------------------------------------
+// | Main tasks                                                        |
+// ---------------------------------------------------------------------
+
+gulp.task("build-dev", function (done) {
+  runSequence(
+    "clean",
+    "test:coverage",
+    "webpack-dev",
+  done);
+});
+
+gulp.task("build", function (done) {
+  runSequence(
+    "clean",
+    "test:coveralls",
+    "webpack-dev",
+    "webpack",
+  done);
+});
+
+gulp.task("default", ["build"]);
\ No newline at end of file
Index: public/node_modules/vue/src/core/instance/init.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/init.js	(revision )
+++ public/node_modules/vue/src/core/instance/init.js	(revision )
@@ -0,0 +1,139 @@
+/* @flow */
+
+import config from '../config'
+import { perf } from '../util/perf'
+import { initProxy } from './proxy'
+import { initState } from './state'
+import { initRender } from './render'
+import { initEvents } from './events'
+import { initLifecycle, callHook } from './lifecycle'
+import { initProvide, initInjections } from './inject'
+import { extend, mergeOptions, formatComponentName } from '../util/index'
+
+let uid = 0
+
+export function initMixin (Vue: Class<Component>) {
+  Vue.prototype._init = function (options?: Object) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      perf.mark('init')
+    }
+
+    const vm: Component = this
+    // a uid
+    vm._uid = uid++
+    // a flag to avoid this being observed
+    vm._isVue = true
+    // merge options
+    if (options && options._isComponent) {
+      // optimize internal component instantiation
+      // since dynamic options merging is pretty slow, and none of the
+      // internal component options needs special treatment.
+      initInternalComponent(vm, options)
+    } else {
+      vm.$options = mergeOptions(
+        resolveConstructorOptions(vm.constructor),
+        options || {},
+        vm
+      )
+    }
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      initProxy(vm)
+    } else {
+      vm._renderProxy = vm
+    }
+    // expose real self
+    vm._self = vm
+    initLifecycle(vm)
+    initEvents(vm)
+    initRender(vm)
+    callHook(vm, 'beforeCreate')
+    initInjections(vm) // resolve injections before data/props
+    initState(vm)
+    initProvide(vm) // resolve provide after data/props
+    callHook(vm, 'created')
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      vm._name = formatComponentName(vm, false)
+      perf.mark('init end')
+      perf.measure(`${vm._name} init`, 'init', 'init end')
+    }
+
+    if (vm.$options.el) {
+      vm.$mount(vm.$options.el)
+    }
+  }
+}
+
+function initInternalComponent (vm: Component, options: InternalComponentOptions) {
+  const opts = vm.$options = Object.create(vm.constructor.options)
+  // doing this because it's faster than dynamic enumeration.
+  opts.parent = options.parent
+  opts.propsData = options.propsData
+  opts._parentVnode = options._parentVnode
+  opts._parentListeners = options._parentListeners
+  opts._renderChildren = options._renderChildren
+  opts._componentTag = options._componentTag
+  opts._parentElm = options._parentElm
+  opts._refElm = options._refElm
+  if (options.render) {
+    opts.render = options.render
+    opts.staticRenderFns = options.staticRenderFns
+  }
+}
+
+export function resolveConstructorOptions (Ctor: Class<Component>) {
+  let options = Ctor.options
+  if (Ctor.super) {
+    const superOptions = resolveConstructorOptions(Ctor.super)
+    const cachedSuperOptions = Ctor.superOptions
+    if (superOptions !== cachedSuperOptions) {
+      // super option changed,
+      // need to resolve new options.
+      Ctor.superOptions = superOptions
+      // check if there are any late-modified/attached options (#4976)
+      const modifiedOptions = resolveModifiedOptions(Ctor)
+      // update base extend options
+      if (modifiedOptions) {
+        extend(Ctor.extendOptions, modifiedOptions)
+      }
+      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
+      if (options.name) {
+        options.components[options.name] = Ctor
+      }
+    }
+  }
+  return options
+}
+
+function resolveModifiedOptions (Ctor: Class<Component>): ?Object {
+  let modified
+  const latest = Ctor.options
+  const sealed = Ctor.sealedOptions
+  for (const key in latest) {
+    if (latest[key] !== sealed[key]) {
+      if (!modified) modified = {}
+      modified[key] = dedupe(latest[key], sealed[key])
+    }
+  }
+  return modified
+}
+
+function dedupe (latest, sealed) {
+  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
+  // between merges
+  if (Array.isArray(latest)) {
+    const res = []
+    sealed = Array.isArray(sealed) ? sealed : [sealed]
+    for (let i = 0; i < latest.length; i++) {
+      if (sealed.indexOf(latest[i]) < 0) {
+        res.push(latest[i])
+      }
+    }
+    return res
+  } else {
+    return latest
+  }
+}
Index: public/node_modules/vue-resource/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/README.md	(revision )
+++ public/node_modules/vue-resource/README.md	(revision )
@@ -0,0 +1,63 @@
+# vue-resource [![Version](https://img.shields.io/npm/v/vue-resource.svg)](https://www.npmjs.com/package/vue-resource) [![License](https://img.shields.io/npm/l/vue-resource.svg)](https://www.npmjs.com/package/vue-resource) [![Downloads](https://img.shields.io/npm/dt/vue-resource.svg)](https://www.npmjs.com/package/vue-resource)
+
+The plugin for [Vue.js](http://vuejs.org) provides services for making web requests and handle responses using a [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) or JSONP.
+
+## Features
+
+- Supports the [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API and [URI Templates](https://medialize.github.io/URI.js/uri-template.html)
+- Supports [interceptors](docs/http.md#interceptors) for request and response
+- Supports latest Firefox, Chrome, Safari, Opera and IE9+
+- Compact size 14KB (5.3KB gzipped)
+
+## Installation
+
+### NPM
+```
+$ npm install vue-resource
+```
+
+### Bower
+```
+$ bower install vue-resource
+```
+
+### CDN
+Available on [jsdelivr](https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js), [cdnjs](https://cdnjs.com/libraries/vue-resource) or [unpkg](https://unpkg.com/vue-resource@1.2.1/dist/vue-resource.min.js).
+```html
+<script src="https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js"></script>
+```
+
+## Example
+```js
+{
+  // GET /someUrl
+  this.$http.get('/someUrl').then(response => {
+
+    // get body data
+    this.someData = response.body;
+
+  }, response => {
+    // error callback
+  });
+}
+```
+
+## Documentation
+
+- [Configuration](docs/config.md)
+- [HTTP Requests/Response](docs/http.md)
+- [Creating Resources](docs/resource.md)
+- [Code Recipes](docs/recipes.md)
+- [API Reference](docs/api.md)
+
+## Changelog
+
+Details changes for each release are documented in the [release notes](https://github.com/vuejs/vue-resource/releases).
+
+## Contribution
+
+If you find a bug or want to contribute to the code or documentation, you can help by submitting an [issue](https://github.com/vuejs/vue-resource/issues) or a [pull request](https://github.com/vuejs/vue-resource/pulls).
+
+## License
+
+[MIT](http://opensource.org/licenses/MIT)
Index: public/node_modules/vue-resource/test/data/invalid.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/data/invalid.json	(revision )
+++ public/node_modules/vue-resource/test/data/invalid.json	(revision )
@@ -0,0 +1,1 @@
+invalid
\ No newline at end of file
Index: public/node_modules/vue/src/platforms/weex/runtime/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/index.js	(revision )
@@ -0,0 +1,40 @@
+/* @flow */
+
+import Vue from 'core/index'
+import { patch } from 'weex/runtime/patch'
+import { mountComponent } from 'core/instance/lifecycle'
+import platformDirectives from 'weex/runtime/directives/index'
+import platformComponents from 'weex/runtime/components/index'
+
+import {
+  query,
+  mustUseProp,
+  isReservedTag,
+  isUnknownElement
+} from 'weex/util/index'
+
+// install platform specific utils
+Vue.config.mustUseProp = mustUseProp
+Vue.config.isReservedTag = isReservedTag
+Vue.config.isUnknownElement = isUnknownElement
+
+// install platform runtime directives and components
+Vue.options.directives = platformDirectives
+Vue.options.components = platformComponents
+
+// install platform patch function
+Vue.prototype.__patch__ = patch
+
+// wrap mount
+Vue.prototype.$mount = function (
+  el?: any,
+  hydrating?: boolean
+): Component {
+  return mountComponent(
+    this,
+    el && query(el, this.$document),
+    hydrating
+  )
+}
+
+export default Vue
Index: public/node_modules/vue/dist/vue.esm.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.esm.js	(revision )
+++ public/node_modules/vue/dist/vue.esm.js	(revision )
@@ -0,0 +1,9191 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+/*  */
+
+/**
+ * Convert a value to a string that is actually rendered.
+ */
+function _toString (val) {
+  return val == null
+    ? ''
+    : typeof val === 'object'
+      ? JSON.stringify(val, null, 2)
+      : String(val)
+}
+
+/**
+ * Convert a input value to a number for persistence.
+ * If the conversion fails, return original string.
+ */
+function toNumber (val) {
+  var n = parseFloat(val);
+  return isNaN(n) ? val : n
+}
+
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ */
+function makeMap (
+  str,
+  expectsLowerCase
+) {
+  var map = Object.create(null);
+  var list = str.split(',');
+  for (var i = 0; i < list.length; i++) {
+    map[list[i]] = true;
+  }
+  return expectsLowerCase
+    ? function (val) { return map[val.toLowerCase()]; }
+    : function (val) { return map[val]; }
+}
+
+/**
+ * Check if a tag is a built-in tag.
+ */
+var isBuiltInTag = makeMap('slot,component', true);
+
+/**
+ * Remove an item from an array
+ */
+function remove (arr, item) {
+  if (arr.length) {
+    var index = arr.indexOf(item);
+    if (index > -1) {
+      return arr.splice(index, 1)
+    }
+  }
+}
+
+/**
+ * Check whether the object has the property.
+ */
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+function hasOwn (obj, key) {
+  return hasOwnProperty.call(obj, key)
+}
+
+/**
+ * Check if value is primitive
+ */
+function isPrimitive (value) {
+  return typeof value === 'string' || typeof value === 'number'
+}
+
+/**
+ * Create a cached version of a pure function.
+ */
+function cached (fn) {
+  var cache = Object.create(null);
+  return (function cachedFn (str) {
+    var hit = cache[str];
+    return hit || (cache[str] = fn(str))
+  })
+}
+
+/**
+ * Camelize a hyphen-delimited string.
+ */
+var camelizeRE = /-(\w)/g;
+var camelize = cached(function (str) {
+  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
+});
+
+/**
+ * Capitalize a string.
+ */
+var capitalize = cached(function (str) {
+  return str.charAt(0).toUpperCase() + str.slice(1)
+});
+
+/**
+ * Hyphenate a camelCase string.
+ */
+var hyphenateRE = /([^-])([A-Z])/g;
+var hyphenate = cached(function (str) {
+  return str
+    .replace(hyphenateRE, '$1-$2')
+    .replace(hyphenateRE, '$1-$2')
+    .toLowerCase()
+});
+
+/**
+ * Simple bind, faster than native
+ */
+function bind (fn, ctx) {
+  function boundFn (a) {
+    var l = arguments.length;
+    return l
+      ? l > 1
+        ? fn.apply(ctx, arguments)
+        : fn.call(ctx, a)
+      : fn.call(ctx)
+  }
+  // record original fn length
+  boundFn._length = fn.length;
+  return boundFn
+}
+
+/**
+ * Convert an Array-like object to a real Array.
+ */
+function toArray (list, start) {
+  start = start || 0;
+  var i = list.length - start;
+  var ret = new Array(i);
+  while (i--) {
+    ret[i] = list[i + start];
+  }
+  return ret
+}
+
+/**
+ * Mix properties into target object.
+ */
+function extend (to, _from) {
+  for (var key in _from) {
+    to[key] = _from[key];
+  }
+  return to
+}
+
+/**
+ * Quick object check - this is primarily used to tell
+ * Objects from primitive values when we know the value
+ * is a JSON-compliant type.
+ */
+function isObject (obj) {
+  return obj !== null && typeof obj === 'object'
+}
+
+/**
+ * Strict object type check. Only returns true
+ * for plain JavaScript objects.
+ */
+var toString = Object.prototype.toString;
+var OBJECT_STRING = '[object Object]';
+function isPlainObject (obj) {
+  return toString.call(obj) === OBJECT_STRING
+}
+
+/**
+ * Merge an Array of Objects into a single Object.
+ */
+function toObject (arr) {
+  var res = {};
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i]);
+    }
+  }
+  return res
+}
+
+/**
+ * Perform no operation.
+ */
+function noop () {}
+
+/**
+ * Always return false.
+ */
+var no = function () { return false; };
+
+/**
+ * Return same value
+ */
+var identity = function (_) { return _; };
+
+/**
+ * Generate a static keys string from compiler modules.
+ */
+function genStaticKeys (modules) {
+  return modules.reduce(function (keys, m) {
+    return keys.concat(m.staticKeys || [])
+  }, []).join(',')
+}
+
+/**
+ * Check if two values are loosely equal - that is,
+ * if they are plain objects, do they have the same shape?
+ */
+function looseEqual (a, b) {
+  var isObjectA = isObject(a);
+  var isObjectB = isObject(b);
+  if (isObjectA && isObjectB) {
+    try {
+      return JSON.stringify(a) === JSON.stringify(b)
+    } catch (e) {
+      // possible circular reference
+      return a === b
+    }
+  } else if (!isObjectA && !isObjectB) {
+    return String(a) === String(b)
+  } else {
+    return false
+  }
+}
+
+function looseIndexOf (arr, val) {
+  for (var i = 0; i < arr.length; i++) {
+    if (looseEqual(arr[i], val)) { return i }
+  }
+  return -1
+}
+
+/**
+ * Ensure a function is called only once.
+ */
+function once (fn) {
+  var called = false;
+  return function () {
+    if (!called) {
+      called = true;
+      fn();
+    }
+  }
+}
+
+/*  */
+
+var config = {
+  /**
+   * Option merge strategies (used in core/util/options)
+   */
+  optionMergeStrategies: Object.create(null),
+
+  /**
+   * Whether to suppress warnings.
+   */
+  silent: false,
+
+  /**
+   * Show production mode tip message on boot?
+   */
+  productionTip: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to enable devtools
+   */
+  devtools: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to record perf
+   */
+  performance: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Error handler for watcher errors
+   */
+  errorHandler: null,
+
+  /**
+   * Ignore certain custom elements
+   */
+  ignoredElements: [],
+
+  /**
+   * Custom user key aliases for v-on
+   */
+  keyCodes: Object.create(null),
+
+  /**
+   * Check if a tag is reserved so that it cannot be registered as a
+   * component. This is platform-dependent and may be overwritten.
+   */
+  isReservedTag: no,
+
+  /**
+   * Check if a tag is an unknown element.
+   * Platform-dependent.
+   */
+  isUnknownElement: no,
+
+  /**
+   * Get the namespace of an element
+   */
+  getTagNamespace: noop,
+
+  /**
+   * Parse the real tag name for the specific platform.
+   */
+  parsePlatformTagName: identity,
+
+  /**
+   * Check if an attribute must be bound using property, e.g. value
+   * Platform-dependent.
+   */
+  mustUseProp: no,
+
+  /**
+   * List of asset types that a component can own.
+   */
+  _assetTypes: [
+    'component',
+    'directive',
+    'filter'
+  ],
+
+  /**
+   * List of lifecycle hooks.
+   */
+  _lifecycleHooks: [
+    'beforeCreate',
+    'created',
+    'beforeMount',
+    'mounted',
+    'beforeUpdate',
+    'updated',
+    'beforeDestroy',
+    'destroyed',
+    'activated',
+    'deactivated'
+  ],
+
+  /**
+   * Max circular updates allowed in a scheduler flush cycle.
+   */
+  _maxUpdateCount: 100
+};
+
+/*  */
+/* globals MutationObserver */
+
+// can we use __proto__?
+var hasProto = '__proto__' in {};
+
+// Browser environment sniffing
+var inBrowser = typeof window !== 'undefined';
+var UA = inBrowser && window.navigator.userAgent.toLowerCase();
+var isIE = UA && /msie|trident/.test(UA);
+var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
+var isEdge = UA && UA.indexOf('edge/') > 0;
+var isAndroid = UA && UA.indexOf('android') > 0;
+var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
+var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
+
+// this needs to be lazy-evaled because vue may be required before
+// vue-server-renderer can set VUE_ENV
+var _isServer;
+var isServerRendering = function () {
+  if (_isServer === undefined) {
+    /* istanbul ignore if */
+    if (!inBrowser && typeof global !== 'undefined') {
+      // detect presence of vue-server-renderer and avoid
+      // Webpack shimming the process
+      _isServer = global['process'].env.VUE_ENV === 'server';
+    } else {
+      _isServer = false;
+    }
+  }
+  return _isServer
+};
+
+// detect devtools
+var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
+
+/* istanbul ignore next */
+function isNative (Ctor) {
+  return /native code/.test(Ctor.toString())
+}
+
+var hasSymbol =
+  typeof Symbol !== 'undefined' && isNative(Symbol) &&
+  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
+
+/**
+ * Defer a task to execute it asynchronously.
+ */
+var nextTick = (function () {
+  var callbacks = [];
+  var pending = false;
+  var timerFunc;
+
+  function nextTickHandler () {
+    pending = false;
+    var copies = callbacks.slice(0);
+    callbacks.length = 0;
+    for (var i = 0; i < copies.length; i++) {
+      copies[i]();
+    }
+  }
+
+  // the nextTick behavior leverages the microtask queue, which can be accessed
+  // via either native Promise.then or MutationObserver.
+  // MutationObserver has wider support, however it is seriously bugged in
+  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
+  // completely stops working after triggering a few times... so, if native
+  // Promise is available, we will use it:
+  /* istanbul ignore if */
+  if (typeof Promise !== 'undefined' && isNative(Promise)) {
+    var p = Promise.resolve();
+    var logError = function (err) { console.error(err); };
+    timerFunc = function () {
+      p.then(nextTickHandler).catch(logError);
+      // in problematic UIWebViews, Promise.then doesn't completely break, but
+      // it can get stuck in a weird state where callbacks are pushed into the
+      // microtask queue but the queue isn't being flushed, until the browser
+      // needs to do some other work, e.g. handle a timer. Therefore we can
+      // "force" the microtask queue to be flushed by adding an empty timer.
+      if (isIOS) { setTimeout(noop); }
+    };
+  } else if (typeof MutationObserver !== 'undefined' && (
+    isNative(MutationObserver) ||
+    // PhantomJS and iOS 7.x
+    MutationObserver.toString() === '[object MutationObserverConstructor]'
+  )) {
+    // use MutationObserver where native Promise is not available,
+    // e.g. PhantomJS IE11, iOS7, Android 4.4
+    var counter = 1;
+    var observer = new MutationObserver(nextTickHandler);
+    var textNode = document.createTextNode(String(counter));
+    observer.observe(textNode, {
+      characterData: true
+    });
+    timerFunc = function () {
+      counter = (counter + 1) % 2;
+      textNode.data = String(counter);
+    };
+  } else {
+    // fallback to setTimeout
+    /* istanbul ignore next */
+    timerFunc = function () {
+      setTimeout(nextTickHandler, 0);
+    };
+  }
+
+  return function queueNextTick (cb, ctx) {
+    var _resolve;
+    callbacks.push(function () {
+      if (cb) { cb.call(ctx); }
+      if (_resolve) { _resolve(ctx); }
+    });
+    if (!pending) {
+      pending = true;
+      timerFunc();
+    }
+    if (!cb && typeof Promise !== 'undefined') {
+      return new Promise(function (resolve) {
+        _resolve = resolve;
+      })
+    }
+  }
+})();
+
+var _Set;
+/* istanbul ignore if */
+if (typeof Set !== 'undefined' && isNative(Set)) {
+  // use native Set when available.
+  _Set = Set;
+} else {
+  // a non-standard Set polyfill that only works with primitive keys.
+  _Set = (function () {
+    function Set () {
+      this.set = Object.create(null);
+    }
+    Set.prototype.has = function has (key) {
+      return this.set[key] === true
+    };
+    Set.prototype.add = function add (key) {
+      this.set[key] = true;
+    };
+    Set.prototype.clear = function clear () {
+      this.set = Object.create(null);
+    };
+
+    return Set;
+  }());
+}
+
+var perf;
+
+if (process.env.NODE_ENV !== 'production') {
+  perf = inBrowser && window.performance;
+  if (perf && (!perf.mark || !perf.measure)) {
+    perf = undefined;
+  }
+}
+
+/*  */
+
+var emptyObject = Object.freeze({});
+
+/**
+ * Check if a string starts with $ or _
+ */
+function isReserved (str) {
+  var c = (str + '').charCodeAt(0);
+  return c === 0x24 || c === 0x5F
+}
+
+/**
+ * Define a property.
+ */
+function def (obj, key, val, enumerable) {
+  Object.defineProperty(obj, key, {
+    value: val,
+    enumerable: !!enumerable,
+    writable: true,
+    configurable: true
+  });
+}
+
+/**
+ * Parse simple path.
+ */
+var bailRE = /[^\w.$]/;
+function parsePath (path) {
+  if (bailRE.test(path)) {
+    return
+  }
+  var segments = path.split('.');
+  return function (obj) {
+    for (var i = 0; i < segments.length; i++) {
+      if (!obj) { return }
+      obj = obj[segments[i]];
+    }
+    return obj
+  }
+}
+
+var warn = noop;
+var tip = noop;
+var formatComponentName;
+
+if (process.env.NODE_ENV !== 'production') {
+  var hasConsole = typeof console !== 'undefined';
+  var classifyRE = /(?:^|[-_])(\w)/g;
+  var classify = function (str) { return str
+    .replace(classifyRE, function (c) { return c.toUpperCase(); })
+    .replace(/[-_]/g, ''); };
+
+  warn = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.error("[Vue warn]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  tip = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.warn("[Vue tip]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  formatComponentName = function (vm, includeFile) {
+    if (vm.$root === vm) {
+      return '<Root>'
+    }
+    var name = vm._isVue
+      ? vm.$options.name || vm.$options._componentTag
+      : vm.name;
+
+    var file = vm._isVue && vm.$options.__file;
+    if (!name && file) {
+      var match = file.match(/([^/\\]+)\.vue$/);
+      name = match && match[1];
+    }
+
+    return (
+      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
+      (file && includeFile !== false ? (" at " + file) : '')
+    )
+  };
+
+  var formatLocation = function (str) {
+    if (str === "<Anonymous>") {
+      str += " - use the \"name\" option for better debugging messages.";
+    }
+    return ("\n(found in " + str + ")")
+  };
+}
+
+/*  */
+
+
+var uid$1 = 0;
+
+/**
+ * A dep is an observable that can have multiple
+ * directives subscribing to it.
+ */
+var Dep = function Dep () {
+  this.id = uid$1++;
+  this.subs = [];
+};
+
+Dep.prototype.addSub = function addSub (sub) {
+  this.subs.push(sub);
+};
+
+Dep.prototype.removeSub = function removeSub (sub) {
+  remove(this.subs, sub);
+};
+
+Dep.prototype.depend = function depend () {
+  if (Dep.target) {
+    Dep.target.addDep(this);
+  }
+};
+
+Dep.prototype.notify = function notify () {
+  // stabilize the subscriber list first
+  var subs = this.subs.slice();
+  for (var i = 0, l = subs.length; i < l; i++) {
+    subs[i].update();
+  }
+};
+
+// the current target watcher being evaluated.
+// this is globally unique because there could be only one
+// watcher being evaluated at any time.
+Dep.target = null;
+var targetStack = [];
+
+function pushTarget (_target) {
+  if (Dep.target) { targetStack.push(Dep.target); }
+  Dep.target = _target;
+}
+
+function popTarget () {
+  Dep.target = targetStack.pop();
+}
+
+/*
+ * not type checking this file because flow doesn't play well with
+ * dynamically accessing methods on Array prototype
+ */
+
+var arrayProto = Array.prototype;
+var arrayMethods = Object.create(arrayProto);[
+  'push',
+  'pop',
+  'shift',
+  'unshift',
+  'splice',
+  'sort',
+  'reverse'
+]
+.forEach(function (method) {
+  // cache original method
+  var original = arrayProto[method];
+  def(arrayMethods, method, function mutator () {
+    var arguments$1 = arguments;
+
+    // avoid leaking arguments:
+    // http://jsperf.com/closure-with-arguments
+    var i = arguments.length;
+    var args = new Array(i);
+    while (i--) {
+      args[i] = arguments$1[i];
+    }
+    var result = original.apply(this, args);
+    var ob = this.__ob__;
+    var inserted;
+    switch (method) {
+      case 'push':
+        inserted = args;
+        break
+      case 'unshift':
+        inserted = args;
+        break
+      case 'splice':
+        inserted = args.slice(2);
+        break
+    }
+    if (inserted) { ob.observeArray(inserted); }
+    // notify change
+    ob.dep.notify();
+    return result
+  });
+});
+
+/*  */
+
+var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
+
+/**
+ * By default, when a reactive property is set, the new value is
+ * also converted to become reactive. However when passing down props,
+ * we don't want to force conversion because the value may be a nested value
+ * under a frozen data structure. Converting it would defeat the optimization.
+ */
+var observerState = {
+  shouldConvert: true,
+  isSettingProps: false
+};
+
+/**
+ * Observer class that are attached to each observed
+ * object. Once attached, the observer converts target
+ * object's property keys into getter/setters that
+ * collect dependencies and dispatches updates.
+ */
+var Observer = function Observer (value) {
+  this.value = value;
+  this.dep = new Dep();
+  this.vmCount = 0;
+  def(value, '__ob__', this);
+  if (Array.isArray(value)) {
+    var augment = hasProto
+      ? protoAugment
+      : copyAugment;
+    augment(value, arrayMethods, arrayKeys);
+    this.observeArray(value);
+  } else {
+    this.walk(value);
+  }
+};
+
+/**
+ * Walk through each property and convert them into
+ * getter/setters. This method should only be called when
+ * value type is Object.
+ */
+Observer.prototype.walk = function walk (obj) {
+  var keys = Object.keys(obj);
+  for (var i = 0; i < keys.length; i++) {
+    defineReactive$$1(obj, keys[i], obj[keys[i]]);
+  }
+};
+
+/**
+ * Observe a list of Array items.
+ */
+Observer.prototype.observeArray = function observeArray (items) {
+  for (var i = 0, l = items.length; i < l; i++) {
+    observe(items[i]);
+  }
+};
+
+// helpers
+
+/**
+ * Augment an target Object or Array by intercepting
+ * the prototype chain using __proto__
+ */
+function protoAugment (target, src) {
+  /* eslint-disable no-proto */
+  target.__proto__ = src;
+  /* eslint-enable no-proto */
+}
+
+/**
+ * Augment an target Object or Array by defining
+ * hidden properties.
+ */
+/* istanbul ignore next */
+function copyAugment (target, src, keys) {
+  for (var i = 0, l = keys.length; i < l; i++) {
+    var key = keys[i];
+    def(target, key, src[key]);
+  }
+}
+
+/**
+ * Attempt to create an observer instance for a value,
+ * returns the new observer if successfully observed,
+ * or the existing observer if the value already has one.
+ */
+function observe (value, asRootData) {
+  if (!isObject(value)) {
+    return
+  }
+  var ob;
+  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+    ob = value.__ob__;
+  } else if (
+    observerState.shouldConvert &&
+    !isServerRendering() &&
+    (Array.isArray(value) || isPlainObject(value)) &&
+    Object.isExtensible(value) &&
+    !value._isVue
+  ) {
+    ob = new Observer(value);
+  }
+  if (asRootData && ob) {
+    ob.vmCount++;
+  }
+  return ob
+}
+
+/**
+ * Define a reactive property on an Object.
+ */
+function defineReactive$$1 (
+  obj,
+  key,
+  val,
+  customSetter
+) {
+  var dep = new Dep();
+
+  var property = Object.getOwnPropertyDescriptor(obj, key);
+  if (property && property.configurable === false) {
+    return
+  }
+
+  // cater for pre-defined getter/setters
+  var getter = property && property.get;
+  var setter = property && property.set;
+
+  var childOb = observe(val);
+  Object.defineProperty(obj, key, {
+    enumerable: true,
+    configurable: true,
+    get: function reactiveGetter () {
+      var value = getter ? getter.call(obj) : val;
+      if (Dep.target) {
+        dep.depend();
+        if (childOb) {
+          childOb.dep.depend();
+        }
+        if (Array.isArray(value)) {
+          dependArray(value);
+        }
+      }
+      return value
+    },
+    set: function reactiveSetter (newVal) {
+      var value = getter ? getter.call(obj) : val;
+      /* eslint-disable no-self-compare */
+      if (newVal === value || (newVal !== newVal && value !== value)) {
+        return
+      }
+      /* eslint-enable no-self-compare */
+      if (process.env.NODE_ENV !== 'production' && customSetter) {
+        customSetter();
+      }
+      if (setter) {
+        setter.call(obj, newVal);
+      } else {
+        val = newVal;
+      }
+      childOb = observe(newVal);
+      dep.notify();
+    }
+  });
+}
+
+/**
+ * Set a property on an object. Adds the new property and
+ * triggers change notification if the property doesn't
+ * already exist.
+ */
+function set (target, key, val) {
+  if (Array.isArray(target)) {
+    target.length = Math.max(target.length, key);
+    target.splice(key, 1, val);
+    return val
+  }
+  if (hasOwn(target, key)) {
+    target[key] = val;
+    return val
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid adding reactive properties to a Vue instance or its root $data ' +
+      'at runtime - declare it upfront in the data option.'
+    );
+    return val
+  }
+  if (!ob) {
+    target[key] = val;
+    return val
+  }
+  defineReactive$$1(ob.value, key, val);
+  ob.dep.notify();
+  return val
+}
+
+/**
+ * Delete a property and trigger change if necessary.
+ */
+function del (target, key) {
+  if (Array.isArray(target)) {
+    target.splice(key, 1);
+    return
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid deleting properties on a Vue instance or its root $data ' +
+      '- just set it to null.'
+    );
+    return
+  }
+  if (!hasOwn(target, key)) {
+    return
+  }
+  delete target[key];
+  if (!ob) {
+    return
+  }
+  ob.dep.notify();
+}
+
+/**
+ * Collect dependencies on array elements when the array is touched, since
+ * we cannot intercept array element access like property getters.
+ */
+function dependArray (value) {
+  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
+    e = value[i];
+    e && e.__ob__ && e.__ob__.dep.depend();
+    if (Array.isArray(e)) {
+      dependArray(e);
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Option overwriting strategies are functions that handle
+ * how to merge a parent option value and a child option
+ * value into the final value.
+ */
+var strats = config.optionMergeStrategies;
+
+/**
+ * Options with restrictions
+ */
+if (process.env.NODE_ENV !== 'production') {
+  strats.el = strats.propsData = function (parent, child, vm, key) {
+    if (!vm) {
+      warn(
+        "option \"" + key + "\" can only be used during instance " +
+        'creation with the `new` keyword.'
+      );
+    }
+    return defaultStrat(parent, child)
+  };
+}
+
+/**
+ * Helper that recursively merges two data objects together.
+ */
+function mergeData (to, from) {
+  if (!from) { return to }
+  var key, toVal, fromVal;
+  var keys = Object.keys(from);
+  for (var i = 0; i < keys.length; i++) {
+    key = keys[i];
+    toVal = to[key];
+    fromVal = from[key];
+    if (!hasOwn(to, key)) {
+      set(to, key, fromVal);
+    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
+      mergeData(toVal, fromVal);
+    }
+  }
+  return to
+}
+
+/**
+ * Data
+ */
+strats.data = function (
+  parentVal,
+  childVal,
+  vm
+) {
+  if (!vm) {
+    // in a Vue.extend merge, both should be functions
+    if (!childVal) {
+      return parentVal
+    }
+    if (typeof childVal !== 'function') {
+      process.env.NODE_ENV !== 'production' && warn(
+        'The "data" option should be a function ' +
+        'that returns a per-instance value in component ' +
+        'definitions.',
+        vm
+      );
+      return parentVal
+    }
+    if (!parentVal) {
+      return childVal
+    }
+    // when parentVal & childVal are both present,
+    // we need to return a function that returns the
+    // merged result of both functions... no need to
+    // check if parentVal is a function here because
+    // it has to be a function to pass previous merges.
+    return function mergedDataFn () {
+      return mergeData(
+        childVal.call(this),
+        parentVal.call(this)
+      )
+    }
+  } else if (parentVal || childVal) {
+    return function mergedInstanceDataFn () {
+      // instance merge
+      var instanceData = typeof childVal === 'function'
+        ? childVal.call(vm)
+        : childVal;
+      var defaultData = typeof parentVal === 'function'
+        ? parentVal.call(vm)
+        : undefined;
+      if (instanceData) {
+        return mergeData(instanceData, defaultData)
+      } else {
+        return defaultData
+      }
+    }
+  }
+};
+
+/**
+ * Hooks and props are merged as arrays.
+ */
+function mergeHook (
+  parentVal,
+  childVal
+) {
+  return childVal
+    ? parentVal
+      ? parentVal.concat(childVal)
+      : Array.isArray(childVal)
+        ? childVal
+        : [childVal]
+    : parentVal
+}
+
+config._lifecycleHooks.forEach(function (hook) {
+  strats[hook] = mergeHook;
+});
+
+/**
+ * Assets
+ *
+ * When a vm is present (instance creation), we need to do
+ * a three-way merge between constructor options, instance
+ * options and parent options.
+ */
+function mergeAssets (parentVal, childVal) {
+  var res = Object.create(parentVal || null);
+  return childVal
+    ? extend(res, childVal)
+    : res
+}
+
+config._assetTypes.forEach(function (type) {
+  strats[type + 's'] = mergeAssets;
+});
+
+/**
+ * Watchers.
+ *
+ * Watchers hashes should not overwrite one
+ * another, so we merge them as arrays.
+ */
+strats.watch = function (parentVal, childVal) {
+  /* istanbul ignore if */
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = {};
+  extend(ret, parentVal);
+  for (var key in childVal) {
+    var parent = ret[key];
+    var child = childVal[key];
+    if (parent && !Array.isArray(parent)) {
+      parent = [parent];
+    }
+    ret[key] = parent
+      ? parent.concat(child)
+      : [child];
+  }
+  return ret
+};
+
+/**
+ * Other object hashes.
+ */
+strats.props =
+strats.methods =
+strats.computed = function (parentVal, childVal) {
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = Object.create(null);
+  extend(ret, parentVal);
+  extend(ret, childVal);
+  return ret
+};
+
+/**
+ * Default strategy.
+ */
+var defaultStrat = function (parentVal, childVal) {
+  return childVal === undefined
+    ? parentVal
+    : childVal
+};
+
+/**
+ * Validate component names
+ */
+function checkComponents (options) {
+  for (var key in options.components) {
+    var lower = key.toLowerCase();
+    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
+      warn(
+        'Do not use built-in or reserved HTML elements as component ' +
+        'id: ' + key
+      );
+    }
+  }
+}
+
+/**
+ * Ensure all props option syntax are normalized into the
+ * Object-based format.
+ */
+function normalizeProps (options) {
+  var props = options.props;
+  if (!props) { return }
+  var res = {};
+  var i, val, name;
+  if (Array.isArray(props)) {
+    i = props.length;
+    while (i--) {
+      val = props[i];
+      if (typeof val === 'string') {
+        name = camelize(val);
+        res[name] = { type: null };
+      } else if (process.env.NODE_ENV !== 'production') {
+        warn('props must be strings when using array syntax.');
+      }
+    }
+  } else if (isPlainObject(props)) {
+    for (var key in props) {
+      val = props[key];
+      name = camelize(key);
+      res[name] = isPlainObject(val)
+        ? val
+        : { type: val };
+    }
+  }
+  options.props = res;
+}
+
+/**
+ * Normalize raw function directives into object format.
+ */
+function normalizeDirectives (options) {
+  var dirs = options.directives;
+  if (dirs) {
+    for (var key in dirs) {
+      var def = dirs[key];
+      if (typeof def === 'function') {
+        dirs[key] = { bind: def, update: def };
+      }
+    }
+  }
+}
+
+/**
+ * Merge two option objects into a new one.
+ * Core utility used in both instantiation and inheritance.
+ */
+function mergeOptions (
+  parent,
+  child,
+  vm
+) {
+  if (process.env.NODE_ENV !== 'production') {
+    checkComponents(child);
+  }
+  normalizeProps(child);
+  normalizeDirectives(child);
+  var extendsFrom = child.extends;
+  if (extendsFrom) {
+    parent = typeof extendsFrom === 'function'
+      ? mergeOptions(parent, extendsFrom.options, vm)
+      : mergeOptions(parent, extendsFrom, vm);
+  }
+  if (child.mixins) {
+    for (var i = 0, l = child.mixins.length; i < l; i++) {
+      var mixin = child.mixins[i];
+      if (mixin.prototype instanceof Vue$3) {
+        mixin = mixin.options;
+      }
+      parent = mergeOptions(parent, mixin, vm);
+    }
+  }
+  var options = {};
+  var key;
+  for (key in parent) {
+    mergeField(key);
+  }
+  for (key in child) {
+    if (!hasOwn(parent, key)) {
+      mergeField(key);
+    }
+  }
+  function mergeField (key) {
+    var strat = strats[key] || defaultStrat;
+    options[key] = strat(parent[key], child[key], vm, key);
+  }
+  return options
+}
+
+/**
+ * Resolve an asset.
+ * This function is used because child instances need access
+ * to assets defined in its ancestor chain.
+ */
+function resolveAsset (
+  options,
+  type,
+  id,
+  warnMissing
+) {
+  /* istanbul ignore if */
+  if (typeof id !== 'string') {
+    return
+  }
+  var assets = options[type];
+  // check local registration variations first
+  if (hasOwn(assets, id)) { return assets[id] }
+  var camelizedId = camelize(id);
+  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
+  var PascalCaseId = capitalize(camelizedId);
+  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
+  // fallback to prototype chain
+  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
+  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
+    warn(
+      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
+      options
+    );
+  }
+  return res
+}
+
+/*  */
+
+function validateProp (
+  key,
+  propOptions,
+  propsData,
+  vm
+) {
+  var prop = propOptions[key];
+  var absent = !hasOwn(propsData, key);
+  var value = propsData[key];
+  // handle boolean props
+  if (isType(Boolean, prop.type)) {
+    if (absent && !hasOwn(prop, 'default')) {
+      value = false;
+    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
+      value = true;
+    }
+  }
+  // check default value
+  if (value === undefined) {
+    value = getPropDefaultValue(vm, prop, key);
+    // since the default value is a fresh copy,
+    // make sure to observe it.
+    var prevShouldConvert = observerState.shouldConvert;
+    observerState.shouldConvert = true;
+    observe(value);
+    observerState.shouldConvert = prevShouldConvert;
+  }
+  if (process.env.NODE_ENV !== 'production') {
+    assertProp(prop, key, value, vm, absent);
+  }
+  return value
+}
+
+/**
+ * Get the default value of a prop.
+ */
+function getPropDefaultValue (vm, prop, key) {
+  // no default, return undefined
+  if (!hasOwn(prop, 'default')) {
+    return undefined
+  }
+  var def = prop.default;
+  // warn against non-factory defaults for Object & Array
+  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
+    warn(
+      'Invalid default value for prop "' + key + '": ' +
+      'Props with type Object/Array must use a factory function ' +
+      'to return the default value.',
+      vm
+    );
+  }
+  // the raw prop value was also undefined from previous render,
+  // return previous default value to avoid unnecessary watcher trigger
+  if (vm && vm.$options.propsData &&
+    vm.$options.propsData[key] === undefined &&
+    vm._props[key] !== undefined) {
+    return vm._props[key]
+  }
+  // call factory function for non-Function types
+  // a value is Function if its prototype is function even across different execution context
+  return typeof def === 'function' && getType(prop.type) !== 'Function'
+    ? def.call(vm)
+    : def
+}
+
+/**
+ * Assert whether a prop is valid.
+ */
+function assertProp (
+  prop,
+  name,
+  value,
+  vm,
+  absent
+) {
+  if (prop.required && absent) {
+    warn(
+      'Missing required prop: "' + name + '"',
+      vm
+    );
+    return
+  }
+  if (value == null && !prop.required) {
+    return
+  }
+  var type = prop.type;
+  var valid = !type || type === true;
+  var expectedTypes = [];
+  if (type) {
+    if (!Array.isArray(type)) {
+      type = [type];
+    }
+    for (var i = 0; i < type.length && !valid; i++) {
+      var assertedType = assertType(value, type[i]);
+      expectedTypes.push(assertedType.expectedType || '');
+      valid = assertedType.valid;
+    }
+  }
+  if (!valid) {
+    warn(
+      'Invalid prop: type check failed for prop "' + name + '".' +
+      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
+      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
+      vm
+    );
+    return
+  }
+  var validator = prop.validator;
+  if (validator) {
+    if (!validator(value)) {
+      warn(
+        'Invalid prop: custom validator check failed for prop "' + name + '".',
+        vm
+      );
+    }
+  }
+}
+
+/**
+ * Assert the type of a value
+ */
+function assertType (value, type) {
+  var valid;
+  var expectedType = getType(type);
+  if (expectedType === 'String') {
+    valid = typeof value === (expectedType = 'string');
+  } else if (expectedType === 'Number') {
+    valid = typeof value === (expectedType = 'number');
+  } else if (expectedType === 'Boolean') {
+    valid = typeof value === (expectedType = 'boolean');
+  } else if (expectedType === 'Function') {
+    valid = typeof value === (expectedType = 'function');
+  } else if (expectedType === 'Object') {
+    valid = isPlainObject(value);
+  } else if (expectedType === 'Array') {
+    valid = Array.isArray(value);
+  } else {
+    valid = value instanceof type;
+  }
+  return {
+    valid: valid,
+    expectedType: expectedType
+  }
+}
+
+/**
+ * Use function string name to check built-in types,
+ * because a simple equality check will fail when running
+ * across different vms / iframes.
+ */
+function getType (fn) {
+  var match = fn && fn.toString().match(/^\s*function (\w+)/);
+  return match && match[1]
+}
+
+function isType (type, fn) {
+  if (!Array.isArray(fn)) {
+    return getType(fn) === getType(type)
+  }
+  for (var i = 0, len = fn.length; i < len; i++) {
+    if (getType(fn[i]) === getType(type)) {
+      return true
+    }
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function handleError (err, vm, info) {
+  if (config.errorHandler) {
+    config.errorHandler.call(null, err, vm, info);
+  } else {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Error in " + info + ":"), vm);
+    }
+    /* istanbul ignore else */
+    if (inBrowser && typeof console !== 'undefined') {
+      console.error(err);
+    } else {
+      throw err
+    }
+  }
+}
+
+/* not type checking this file because flow doesn't play well with Proxy */
+
+var initProxy;
+
+if (process.env.NODE_ENV !== 'production') {
+  var allowedGlobals = makeMap(
+    'Infinity,undefined,NaN,isFinite,isNaN,' +
+    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
+    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
+    'require' // for Webpack/Browserify
+  );
+
+  var warnNonPresent = function (target, key) {
+    warn(
+      "Property or method \"" + key + "\" is not defined on the instance but " +
+      "referenced during render. Make sure to declare reactive data " +
+      "properties in the data option.",
+      target
+    );
+  };
+
+  var hasProxy =
+    typeof Proxy !== 'undefined' &&
+    Proxy.toString().match(/native code/);
+
+  if (hasProxy) {
+    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
+    config.keyCodes = new Proxy(config.keyCodes, {
+      set: function set (target, key, value) {
+        if (isBuiltInModifier(key)) {
+          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
+          return false
+        } else {
+          target[key] = value;
+          return true
+        }
+      }
+    });
+  }
+
+  var hasHandler = {
+    has: function has (target, key) {
+      var has = key in target;
+      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
+      if (!has && !isAllowed) {
+        warnNonPresent(target, key);
+      }
+      return has || !isAllowed
+    }
+  };
+
+  var getHandler = {
+    get: function get (target, key) {
+      if (typeof key === 'string' && !(key in target)) {
+        warnNonPresent(target, key);
+      }
+      return target[key]
+    }
+  };
+
+  initProxy = function initProxy (vm) {
+    if (hasProxy) {
+      // determine which proxy handler to use
+      var options = vm.$options;
+      var handlers = options.render && options.render._withStripped
+        ? getHandler
+        : hasHandler;
+      vm._renderProxy = new Proxy(vm, handlers);
+    } else {
+      vm._renderProxy = vm;
+    }
+  };
+}
+
+/*  */
+
+var VNode = function VNode (
+  tag,
+  data,
+  children,
+  text,
+  elm,
+  context,
+  componentOptions
+) {
+  this.tag = tag;
+  this.data = data;
+  this.children = children;
+  this.text = text;
+  this.elm = elm;
+  this.ns = undefined;
+  this.context = context;
+  this.functionalContext = undefined;
+  this.key = data && data.key;
+  this.componentOptions = componentOptions;
+  this.componentInstance = undefined;
+  this.parent = undefined;
+  this.raw = false;
+  this.isStatic = false;
+  this.isRootInsert = true;
+  this.isComment = false;
+  this.isCloned = false;
+  this.isOnce = false;
+};
+
+var prototypeAccessors = { child: {} };
+
+// DEPRECATED: alias for componentInstance for backwards compat.
+/* istanbul ignore next */
+prototypeAccessors.child.get = function () {
+  return this.componentInstance
+};
+
+Object.defineProperties( VNode.prototype, prototypeAccessors );
+
+var createEmptyVNode = function () {
+  var node = new VNode();
+  node.text = '';
+  node.isComment = true;
+  return node
+};
+
+function createTextVNode (val) {
+  return new VNode(undefined, undefined, undefined, String(val))
+}
+
+// optimized shallow clone
+// used for static nodes and slot nodes because they may be reused across
+// multiple renders, cloning them avoids errors when DOM manipulations rely
+// on their elm reference.
+function cloneVNode (vnode) {
+  var cloned = new VNode(
+    vnode.tag,
+    vnode.data,
+    vnode.children,
+    vnode.text,
+    vnode.elm,
+    vnode.context,
+    vnode.componentOptions
+  );
+  cloned.ns = vnode.ns;
+  cloned.isStatic = vnode.isStatic;
+  cloned.key = vnode.key;
+  cloned.isCloned = true;
+  return cloned
+}
+
+function cloneVNodes (vnodes) {
+  var len = vnodes.length;
+  var res = new Array(len);
+  for (var i = 0; i < len; i++) {
+    res[i] = cloneVNode(vnodes[i]);
+  }
+  return res
+}
+
+/*  */
+
+var normalizeEvent = cached(function (name) {
+  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
+  name = once$$1 ? name.slice(1) : name;
+  var capture = name.charAt(0) === '!';
+  name = capture ? name.slice(1) : name;
+  return {
+    name: name,
+    once: once$$1,
+    capture: capture
+  }
+});
+
+function createFnInvoker (fns) {
+  function invoker () {
+    var arguments$1 = arguments;
+
+    var fns = invoker.fns;
+    if (Array.isArray(fns)) {
+      for (var i = 0; i < fns.length; i++) {
+        fns[i].apply(null, arguments$1);
+      }
+    } else {
+      // return handler return value for single handlers
+      return fns.apply(null, arguments)
+    }
+  }
+  invoker.fns = fns;
+  return invoker
+}
+
+function updateListeners (
+  on,
+  oldOn,
+  add,
+  remove$$1,
+  vm
+) {
+  var name, cur, old, event;
+  for (name in on) {
+    cur = on[name];
+    old = oldOn[name];
+    event = normalizeEvent(name);
+    if (!cur) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
+        vm
+      );
+    } else if (!old) {
+      if (!cur.fns) {
+        cur = on[name] = createFnInvoker(cur);
+      }
+      add(event.name, cur, event.once, event.capture);
+    } else if (cur !== old) {
+      old.fns = cur;
+      on[name] = old;
+    }
+  }
+  for (name in oldOn) {
+    if (!on[name]) {
+      event = normalizeEvent(name);
+      remove$$1(event.name, oldOn[name], event.capture);
+    }
+  }
+}
+
+/*  */
+
+function mergeVNodeHook (def, hookKey, hook) {
+  var invoker;
+  var oldHook = def[hookKey];
+
+  function wrappedHook () {
+    hook.apply(this, arguments);
+    // important: remove merged hook to ensure it's called only once
+    // and prevent memory leak
+    remove(invoker.fns, wrappedHook);
+  }
+
+  if (!oldHook) {
+    // no existing hook
+    invoker = createFnInvoker([wrappedHook]);
+  } else {
+    /* istanbul ignore if */
+    if (oldHook.fns && oldHook.merged) {
+      // already a merged invoker
+      invoker = oldHook;
+      invoker.fns.push(wrappedHook);
+    } else {
+      // existing plain hook
+      invoker = createFnInvoker([oldHook, wrappedHook]);
+    }
+  }
+
+  invoker.merged = true;
+  def[hookKey] = invoker;
+}
+
+/*  */
+
+// The template compiler attempts to minimize the need for normalization by
+// statically analyzing the template at compile time.
+//
+// For plain HTML markup, normalization can be completely skipped because the
+// generated render function is guaranteed to return Array<VNode>. There are
+// two cases where extra normalization is needed:
+
+// 1. When the children contains components - because a functional component
+// may return an Array instead of a single root. In this case, just a simple
+// normalization is needed - if any child is an Array, we flatten the whole
+// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
+// because functional components already normalize their own children.
+function simpleNormalizeChildren (children) {
+  for (var i = 0; i < children.length; i++) {
+    if (Array.isArray(children[i])) {
+      return Array.prototype.concat.apply([], children)
+    }
+  }
+  return children
+}
+
+// 2. When the children contains constructs that always generated nested Arrays,
+// e.g. <template>, <slot>, v-for, or when the children is provided by user
+// with hand-written render functions / JSX. In such cases a full normalization
+// is needed to cater to all possible types of children values.
+function normalizeChildren (children) {
+  return isPrimitive(children)
+    ? [createTextVNode(children)]
+    : Array.isArray(children)
+      ? normalizeArrayChildren(children)
+      : undefined
+}
+
+function normalizeArrayChildren (children, nestedIndex) {
+  var res = [];
+  var i, c, last;
+  for (i = 0; i < children.length; i++) {
+    c = children[i];
+    if (c == null || typeof c === 'boolean') { continue }
+    last = res[res.length - 1];
+    //  nested
+    if (Array.isArray(c)) {
+      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
+    } else if (isPrimitive(c)) {
+      if (last && last.text) {
+        last.text += String(c);
+      } else if (c !== '') {
+        // convert primitive to vnode
+        res.push(createTextVNode(c));
+      }
+    } else {
+      if (c.text && last && last.text) {
+        res[res.length - 1] = createTextVNode(last.text + c.text);
+      } else {
+        // default key for nested array children (likely generated by v-for)
+        if (c.tag && c.key == null && nestedIndex != null) {
+          c.key = "__vlist" + nestedIndex + "_" + i + "__";
+        }
+        res.push(c);
+      }
+    }
+  }
+  return res
+}
+
+/*  */
+
+function getFirstComponentChild (children) {
+  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
+}
+
+/*  */
+
+function initEvents (vm) {
+  vm._events = Object.create(null);
+  vm._hasHookEvent = false;
+  // init parent attached events
+  var listeners = vm.$options._parentListeners;
+  if (listeners) {
+    updateComponentListeners(vm, listeners);
+  }
+}
+
+var target;
+
+function add (event, fn, once$$1) {
+  if (once$$1) {
+    target.$once(event, fn);
+  } else {
+    target.$on(event, fn);
+  }
+}
+
+function remove$1 (event, fn) {
+  target.$off(event, fn);
+}
+
+function updateComponentListeners (
+  vm,
+  listeners,
+  oldListeners
+) {
+  target = vm;
+  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
+}
+
+function eventsMixin (Vue) {
+  var hookRE = /^hook:/;
+  Vue.prototype.$on = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    if (Array.isArray(event)) {
+      for (var i = 0, l = event.length; i < l; i++) {
+        this$1.$on(event[i], fn);
+      }
+    } else {
+      (vm._events[event] || (vm._events[event] = [])).push(fn);
+      // optimize hook:event cost by using a boolean flag marked at registration
+      // instead of a hash lookup
+      if (hookRE.test(event)) {
+        vm._hasHookEvent = true;
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$once = function (event, fn) {
+    var vm = this;
+    function on () {
+      vm.$off(event, on);
+      fn.apply(vm, arguments);
+    }
+    on.fn = fn;
+    vm.$on(event, on);
+    return vm
+  };
+
+  Vue.prototype.$off = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    // all
+    if (!arguments.length) {
+      vm._events = Object.create(null);
+      return vm
+    }
+    // array of events
+    if (Array.isArray(event)) {
+      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
+        this$1.$off(event[i$1], fn);
+      }
+      return vm
+    }
+    // specific event
+    var cbs = vm._events[event];
+    if (!cbs) {
+      return vm
+    }
+    if (arguments.length === 1) {
+      vm._events[event] = null;
+      return vm
+    }
+    // specific handler
+    var cb;
+    var i = cbs.length;
+    while (i--) {
+      cb = cbs[i];
+      if (cb === fn || cb.fn === fn) {
+        cbs.splice(i, 1);
+        break
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$emit = function (event) {
+    var vm = this;
+    var cbs = vm._events[event];
+    if (cbs) {
+      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
+      var args = toArray(arguments, 1);
+      for (var i = 0, l = cbs.length; i < l; i++) {
+        cbs[i].apply(vm, args);
+      }
+    }
+    return vm
+  };
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving raw children VNodes into a slot object.
+ */
+function resolveSlots (
+  children,
+  context
+) {
+  var slots = {};
+  if (!children) {
+    return slots
+  }
+  var defaultSlot = [];
+  var name, child;
+  for (var i = 0, l = children.length; i < l; i++) {
+    child = children[i];
+    // named slots should only be respected if the vnode was rendered in the
+    // same context.
+    if ((child.context === context || child.functionalContext === context) &&
+        child.data && (name = child.data.slot)) {
+      var slot = (slots[name] || (slots[name] = []));
+      if (child.tag === 'template') {
+        slot.push.apply(slot, child.children);
+      } else {
+        slot.push(child);
+      }
+    } else {
+      defaultSlot.push(child);
+    }
+  }
+  // ignore whitespace
+  if (!defaultSlot.every(isWhitespace)) {
+    slots.default = defaultSlot;
+  }
+  return slots
+}
+
+function isWhitespace (node) {
+  return node.isComment || node.text === ' '
+}
+
+function resolveScopedSlots (
+  fns
+) {
+  var res = {};
+  for (var i = 0; i < fns.length; i++) {
+    res[fns[i][0]] = fns[i][1];
+  }
+  return res
+}
+
+/*  */
+
+var activeInstance = null;
+
+function initLifecycle (vm) {
+  var options = vm.$options;
+
+  // locate first non-abstract parent
+  var parent = options.parent;
+  if (parent && !options.abstract) {
+    while (parent.$options.abstract && parent.$parent) {
+      parent = parent.$parent;
+    }
+    parent.$children.push(vm);
+  }
+
+  vm.$parent = parent;
+  vm.$root = parent ? parent.$root : vm;
+
+  vm.$children = [];
+  vm.$refs = {};
+
+  vm._watcher = null;
+  vm._inactive = null;
+  vm._directInactive = false;
+  vm._isMounted = false;
+  vm._isDestroyed = false;
+  vm._isBeingDestroyed = false;
+}
+
+function lifecycleMixin (Vue) {
+  Vue.prototype._update = function (vnode, hydrating) {
+    var vm = this;
+    if (vm._isMounted) {
+      callHook(vm, 'beforeUpdate');
+    }
+    var prevEl = vm.$el;
+    var prevVnode = vm._vnode;
+    var prevActiveInstance = activeInstance;
+    activeInstance = vm;
+    vm._vnode = vnode;
+    // Vue.prototype.__patch__ is injected in entry points
+    // based on the rendering backend used.
+    if (!prevVnode) {
+      // initial render
+      vm.$el = vm.__patch__(
+        vm.$el, vnode, hydrating, false /* removeOnly */,
+        vm.$options._parentElm,
+        vm.$options._refElm
+      );
+    } else {
+      // updates
+      vm.$el = vm.__patch__(prevVnode, vnode);
+    }
+    activeInstance = prevActiveInstance;
+    // update __vue__ reference
+    if (prevEl) {
+      prevEl.__vue__ = null;
+    }
+    if (vm.$el) {
+      vm.$el.__vue__ = vm;
+    }
+    // if parent is an HOC, update its $el as well
+    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
+      vm.$parent.$el = vm.$el;
+    }
+    // updated hook is called by the scheduler to ensure that children are
+    // updated in a parent's updated hook.
+  };
+
+  Vue.prototype.$forceUpdate = function () {
+    var vm = this;
+    if (vm._watcher) {
+      vm._watcher.update();
+    }
+  };
+
+  Vue.prototype.$destroy = function () {
+    var vm = this;
+    if (vm._isBeingDestroyed) {
+      return
+    }
+    callHook(vm, 'beforeDestroy');
+    vm._isBeingDestroyed = true;
+    // remove self from parent
+    var parent = vm.$parent;
+    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
+      remove(parent.$children, vm);
+    }
+    // teardown watchers
+    if (vm._watcher) {
+      vm._watcher.teardown();
+    }
+    var i = vm._watchers.length;
+    while (i--) {
+      vm._watchers[i].teardown();
+    }
+    // remove reference from data ob
+    // frozen object may not have observer.
+    if (vm._data.__ob__) {
+      vm._data.__ob__.vmCount--;
+    }
+    // call the last hook...
+    vm._isDestroyed = true;
+    callHook(vm, 'destroyed');
+    // turn off all instance listeners.
+    vm.$off();
+    // remove __vue__ reference
+    if (vm.$el) {
+      vm.$el.__vue__ = null;
+    }
+    // invoke destroy hooks on current rendered tree
+    vm.__patch__(vm._vnode, null);
+  };
+}
+
+function mountComponent (
+  vm,
+  el,
+  hydrating
+) {
+  vm.$el = el;
+  if (!vm.$options.render) {
+    vm.$options.render = createEmptyVNode;
+    if (process.env.NODE_ENV !== 'production') {
+      /* istanbul ignore if */
+      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
+        vm.$options.el || el) {
+        warn(
+          'You are using the runtime-only build of Vue where the template ' +
+          'compiler is not available. Either pre-compile the templates into ' +
+          'render functions, or use the compiler-included build.',
+          vm
+        );
+      } else {
+        warn(
+          'Failed to mount component: template or render function not defined.',
+          vm
+        );
+      }
+    }
+  }
+  callHook(vm, 'beforeMount');
+
+  var updateComponent;
+  /* istanbul ignore if */
+  if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+    updateComponent = function () {
+      var name = vm._name;
+      var startTag = "start " + name;
+      var endTag = "end " + name;
+      perf.mark(startTag);
+      var vnode = vm._render();
+      perf.mark(endTag);
+      perf.measure((name + " render"), startTag, endTag);
+      perf.mark(startTag);
+      vm._update(vnode, hydrating);
+      perf.mark(endTag);
+      perf.measure((name + " patch"), startTag, endTag);
+    };
+  } else {
+    updateComponent = function () {
+      vm._update(vm._render(), hydrating);
+    };
+  }
+
+  vm._watcher = new Watcher(vm, updateComponent, noop);
+  hydrating = false;
+
+  // manually mounted instance, call mounted on self
+  // mounted is called for render-created child components in its inserted hook
+  if (vm.$vnode == null) {
+    vm._isMounted = true;
+    callHook(vm, 'mounted');
+  }
+  return vm
+}
+
+function updateChildComponent (
+  vm,
+  propsData,
+  listeners,
+  parentVnode,
+  renderChildren
+) {
+  // determine whether component has slot children
+  // we need to do this before overwriting $options._renderChildren
+  var hasChildren = !!(
+    renderChildren ||               // has new static slots
+    vm.$options._renderChildren ||  // has old static slots
+    parentVnode.data.scopedSlots || // has new scoped slots
+    vm.$scopedSlots !== emptyObject // has old scoped slots
+  );
+
+  vm.$options._parentVnode = parentVnode;
+  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
+  if (vm._vnode) { // update child tree's parent
+    vm._vnode.parent = parentVnode;
+  }
+  vm.$options._renderChildren = renderChildren;
+
+  // update props
+  if (propsData && vm.$options.props) {
+    observerState.shouldConvert = false;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = true;
+    }
+    var props = vm._props;
+    var propKeys = vm.$options._propKeys || [];
+    for (var i = 0; i < propKeys.length; i++) {
+      var key = propKeys[i];
+      props[key] = validateProp(key, vm.$options.props, propsData, vm);
+    }
+    observerState.shouldConvert = true;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = false;
+    }
+    // keep a copy of raw propsData
+    vm.$options.propsData = propsData;
+  }
+  // update listeners
+  if (listeners) {
+    var oldListeners = vm.$options._parentListeners;
+    vm.$options._parentListeners = listeners;
+    updateComponentListeners(vm, listeners, oldListeners);
+  }
+  // resolve slots + force update if has children
+  if (hasChildren) {
+    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
+    vm.$forceUpdate();
+  }
+}
+
+function isInInactiveTree (vm) {
+  while (vm && (vm = vm.$parent)) {
+    if (vm._inactive) { return true }
+  }
+  return false
+}
+
+function activateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = false;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  } else if (vm._directInactive) {
+    return
+  }
+  if (vm._inactive || vm._inactive == null) {
+    vm._inactive = false;
+    for (var i = 0; i < vm.$children.length; i++) {
+      activateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'activated');
+  }
+}
+
+function deactivateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = true;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  }
+  if (!vm._inactive) {
+    vm._inactive = true;
+    for (var i = 0; i < vm.$children.length; i++) {
+      deactivateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'deactivated');
+  }
+}
+
+function callHook (vm, hook) {
+  var handlers = vm.$options[hook];
+  if (handlers) {
+    for (var i = 0, j = handlers.length; i < j; i++) {
+      try {
+        handlers[i].call(vm);
+      } catch (e) {
+        handleError(e, vm, (hook + " hook"));
+      }
+    }
+  }
+  if (vm._hasHookEvent) {
+    vm.$emit('hook:' + hook);
+  }
+}
+
+/*  */
+
+
+var queue = [];
+var has = {};
+var circular = {};
+var waiting = false;
+var flushing = false;
+var index = 0;
+
+/**
+ * Reset the scheduler's state.
+ */
+function resetSchedulerState () {
+  queue.length = 0;
+  has = {};
+  if (process.env.NODE_ENV !== 'production') {
+    circular = {};
+  }
+  waiting = flushing = false;
+}
+
+/**
+ * Flush both queues and run the watchers.
+ */
+function flushSchedulerQueue () {
+  flushing = true;
+  var watcher, id, vm;
+
+  // Sort queue before flush.
+  // This ensures that:
+  // 1. Components are updated from parent to child. (because parent is always
+  //    created before the child)
+  // 2. A component's user watchers are run before its render watcher (because
+  //    user watchers are created before the render watcher)
+  // 3. If a component is destroyed during a parent component's watcher run,
+  //    its watchers can be skipped.
+  queue.sort(function (a, b) { return a.id - b.id; });
+
+  // do not cache length because more watchers might be pushed
+  // as we run existing watchers
+  for (index = 0; index < queue.length; index++) {
+    watcher = queue[index];
+    id = watcher.id;
+    has[id] = null;
+    watcher.run();
+    // in dev build, check and stop circular updates.
+    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
+      circular[id] = (circular[id] || 0) + 1;
+      if (circular[id] > config._maxUpdateCount) {
+        warn(
+          'You may have an infinite update loop ' + (
+            watcher.user
+              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
+              : "in a component render function."
+          ),
+          watcher.vm
+        );
+        break
+      }
+    }
+  }
+
+  // call updated hooks
+  index = queue.length;
+  while (index--) {
+    watcher = queue[index];
+    vm = watcher.vm;
+    if (vm._watcher === watcher && vm._isMounted) {
+      callHook(vm, 'updated');
+    }
+  }
+
+  // devtool hook
+  /* istanbul ignore if */
+  if (devtools && config.devtools) {
+    devtools.emit('flush');
+  }
+
+  resetSchedulerState();
+}
+
+/**
+ * Push a watcher into the watcher queue.
+ * Jobs with duplicate IDs will be skipped unless it's
+ * pushed when the queue is being flushed.
+ */
+function queueWatcher (watcher) {
+  var id = watcher.id;
+  if (has[id] == null) {
+    has[id] = true;
+    if (!flushing) {
+      queue.push(watcher);
+    } else {
+      // if already flushing, splice the watcher based on its id
+      // if already past its id, it will be run next immediately.
+      var i = queue.length - 1;
+      while (i >= 0 && queue[i].id > watcher.id) {
+        i--;
+      }
+      queue.splice(Math.max(i, index) + 1, 0, watcher);
+    }
+    // queue the flush
+    if (!waiting) {
+      waiting = true;
+      nextTick(flushSchedulerQueue);
+    }
+  }
+}
+
+/*  */
+
+var uid$2 = 0;
+
+/**
+ * A watcher parses an expression, collects dependencies,
+ * and fires callback when the expression value changes.
+ * This is used for both the $watch() api and directives.
+ */
+var Watcher = function Watcher (
+  vm,
+  expOrFn,
+  cb,
+  options
+) {
+  this.vm = vm;
+  vm._watchers.push(this);
+  // options
+  if (options) {
+    this.deep = !!options.deep;
+    this.user = !!options.user;
+    this.lazy = !!options.lazy;
+    this.sync = !!options.sync;
+  } else {
+    this.deep = this.user = this.lazy = this.sync = false;
+  }
+  this.cb = cb;
+  this.id = ++uid$2; // uid for batching
+  this.active = true;
+  this.dirty = this.lazy; // for lazy watchers
+  this.deps = [];
+  this.newDeps = [];
+  this.depIds = new _Set();
+  this.newDepIds = new _Set();
+  this.expression = process.env.NODE_ENV !== 'production'
+    ? expOrFn.toString()
+    : '';
+  // parse expression for getter
+  if (typeof expOrFn === 'function') {
+    this.getter = expOrFn;
+  } else {
+    this.getter = parsePath(expOrFn);
+    if (!this.getter) {
+      this.getter = function () {};
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed watching path: \"" + expOrFn + "\" " +
+        'Watcher only accepts simple dot-delimited paths. ' +
+        'For full control, use a function instead.',
+        vm
+      );
+    }
+  }
+  this.value = this.lazy
+    ? undefined
+    : this.get();
+};
+
+/**
+ * Evaluate the getter, and re-collect dependencies.
+ */
+Watcher.prototype.get = function get () {
+  pushTarget(this);
+  var value;
+  var vm = this.vm;
+  if (this.user) {
+    try {
+      value = this.getter.call(vm, vm);
+    } catch (e) {
+      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
+    }
+  } else {
+    value = this.getter.call(vm, vm);
+  }
+  // "touch" every property so they are all tracked as
+  // dependencies for deep watching
+  if (this.deep) {
+    traverse(value);
+  }
+  popTarget();
+  this.cleanupDeps();
+  return value
+};
+
+/**
+ * Add a dependency to this directive.
+ */
+Watcher.prototype.addDep = function addDep (dep) {
+  var id = dep.id;
+  if (!this.newDepIds.has(id)) {
+    this.newDepIds.add(id);
+    this.newDeps.push(dep);
+    if (!this.depIds.has(id)) {
+      dep.addSub(this);
+    }
+  }
+};
+
+/**
+ * Clean up for dependency collection.
+ */
+Watcher.prototype.cleanupDeps = function cleanupDeps () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    var dep = this$1.deps[i];
+    if (!this$1.newDepIds.has(dep.id)) {
+      dep.removeSub(this$1);
+    }
+  }
+  var tmp = this.depIds;
+  this.depIds = this.newDepIds;
+  this.newDepIds = tmp;
+  this.newDepIds.clear();
+  tmp = this.deps;
+  this.deps = this.newDeps;
+  this.newDeps = tmp;
+  this.newDeps.length = 0;
+};
+
+/**
+ * Subscriber interface.
+ * Will be called when a dependency changes.
+ */
+Watcher.prototype.update = function update () {
+  /* istanbul ignore else */
+  if (this.lazy) {
+    this.dirty = true;
+  } else if (this.sync) {
+    this.run();
+  } else {
+    queueWatcher(this);
+  }
+};
+
+/**
+ * Scheduler job interface.
+ * Will be called by the scheduler.
+ */
+Watcher.prototype.run = function run () {
+  if (this.active) {
+    var value = this.get();
+    if (
+      value !== this.value ||
+      // Deep watchers and watchers on Object/Arrays should fire even
+      // when the value is the same, because the value may
+      // have mutated.
+      isObject(value) ||
+      this.deep
+    ) {
+      // set new value
+      var oldValue = this.value;
+      this.value = value;
+      if (this.user) {
+        try {
+          this.cb.call(this.vm, value, oldValue);
+        } catch (e) {
+          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
+        }
+      } else {
+        this.cb.call(this.vm, value, oldValue);
+      }
+    }
+  }
+};
+
+/**
+ * Evaluate the value of the watcher.
+ * This only gets called for lazy watchers.
+ */
+Watcher.prototype.evaluate = function evaluate () {
+  this.value = this.get();
+  this.dirty = false;
+};
+
+/**
+ * Depend on all deps collected by this watcher.
+ */
+Watcher.prototype.depend = function depend () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    this$1.deps[i].depend();
+  }
+};
+
+/**
+ * Remove self from all dependencies' subscriber list.
+ */
+Watcher.prototype.teardown = function teardown () {
+    var this$1 = this;
+
+  if (this.active) {
+    // remove self from vm's watcher list
+    // this is a somewhat expensive operation so we skip it
+    // if the vm is being destroyed.
+    if (!this.vm._isBeingDestroyed) {
+      remove(this.vm._watchers, this);
+    }
+    var i = this.deps.length;
+    while (i--) {
+      this$1.deps[i].removeSub(this$1);
+    }
+    this.active = false;
+  }
+};
+
+/**
+ * Recursively traverse an object to evoke all converted
+ * getters, so that every nested property inside the object
+ * is collected as a "deep" dependency.
+ */
+var seenObjects = new _Set();
+function traverse (val) {
+  seenObjects.clear();
+  _traverse(val, seenObjects);
+}
+
+function _traverse (val, seen) {
+  var i, keys;
+  var isA = Array.isArray(val);
+  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
+    return
+  }
+  if (val.__ob__) {
+    var depId = val.__ob__.dep.id;
+    if (seen.has(depId)) {
+      return
+    }
+    seen.add(depId);
+  }
+  if (isA) {
+    i = val.length;
+    while (i--) { _traverse(val[i], seen); }
+  } else {
+    keys = Object.keys(val);
+    i = keys.length;
+    while (i--) { _traverse(val[keys[i]], seen); }
+  }
+}
+
+/*  */
+
+var sharedPropertyDefinition = {
+  enumerable: true,
+  configurable: true,
+  get: noop,
+  set: noop
+};
+
+function proxy (target, sourceKey, key) {
+  sharedPropertyDefinition.get = function proxyGetter () {
+    return this[sourceKey][key]
+  };
+  sharedPropertyDefinition.set = function proxySetter (val) {
+    this[sourceKey][key] = val;
+  };
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function initState (vm) {
+  vm._watchers = [];
+  var opts = vm.$options;
+  if (opts.props) { initProps(vm, opts.props); }
+  if (opts.methods) { initMethods(vm, opts.methods); }
+  if (opts.data) {
+    initData(vm);
+  } else {
+    observe(vm._data = {}, true /* asRootData */);
+  }
+  if (opts.computed) { initComputed(vm, opts.computed); }
+  if (opts.watch) { initWatch(vm, opts.watch); }
+}
+
+var isReservedProp = { key: 1, ref: 1, slot: 1 };
+
+function initProps (vm, propsOptions) {
+  var propsData = vm.$options.propsData || {};
+  var props = vm._props = {};
+  // cache prop keys so that future props updates can iterate using Array
+  // instead of dynamic object key enumeration.
+  var keys = vm.$options._propKeys = [];
+  var isRoot = !vm.$parent;
+  // root instance props should be converted
+  observerState.shouldConvert = isRoot;
+  var loop = function ( key ) {
+    keys.push(key);
+    var value = validateProp(key, propsOptions, propsData, vm);
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      if (isReservedProp[key]) {
+        warn(
+          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
+          vm
+        );
+      }
+      defineReactive$$1(props, key, value, function () {
+        if (vm.$parent && !observerState.isSettingProps) {
+          warn(
+            "Avoid mutating a prop directly since the value will be " +
+            "overwritten whenever the parent component re-renders. " +
+            "Instead, use a data or computed property based on the prop's " +
+            "value. Prop being mutated: \"" + key + "\"",
+            vm
+          );
+        }
+      });
+    } else {
+      defineReactive$$1(props, key, value);
+    }
+    // static props are already proxied on the component's prototype
+    // during Vue.extend(). We only need to proxy props defined at
+    // instantiation here.
+    if (!(key in vm)) {
+      proxy(vm, "_props", key);
+    }
+  };
+
+  for (var key in propsOptions) loop( key );
+  observerState.shouldConvert = true;
+}
+
+function initData (vm) {
+  var data = vm.$options.data;
+  data = vm._data = typeof data === 'function'
+    ? data.call(vm)
+    : data || {};
+  if (!isPlainObject(data)) {
+    data = {};
+    process.env.NODE_ENV !== 'production' && warn(
+      'data functions should return an object:\n' +
+      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
+      vm
+    );
+  }
+  // proxy data on instance
+  var keys = Object.keys(data);
+  var props = vm.$options.props;
+  var i = keys.length;
+  while (i--) {
+    if (props && hasOwn(props, keys[i])) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
+        "Use prop default value instead.",
+        vm
+      );
+    } else if (!isReserved(keys[i])) {
+      proxy(vm, "_data", keys[i]);
+    }
+  }
+  // observe data
+  observe(data, true /* asRootData */);
+}
+
+var computedWatcherOptions = { lazy: true };
+
+function initComputed (vm, computed) {
+  var watchers = vm._computedWatchers = Object.create(null);
+
+  for (var key in computed) {
+    var userDef = computed[key];
+    var getter = typeof userDef === 'function' ? userDef : userDef.get;
+    // create internal watcher for the computed property.
+    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);
+
+    // component-defined computed properties are already defined on the
+    // component prototype. We only need to define computed properties defined
+    // at instantiation here.
+    if (!(key in vm)) {
+      defineComputed(vm, key, userDef);
+    }
+  }
+}
+
+function defineComputed (target, key, userDef) {
+  if (typeof userDef === 'function') {
+    sharedPropertyDefinition.get = createComputedGetter(key);
+    sharedPropertyDefinition.set = noop;
+  } else {
+    sharedPropertyDefinition.get = userDef.get
+      ? userDef.cache !== false
+        ? createComputedGetter(key)
+        : userDef.get
+      : noop;
+    sharedPropertyDefinition.set = userDef.set
+      ? userDef.set
+      : noop;
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function createComputedGetter (key) {
+  return function computedGetter () {
+    var watcher = this._computedWatchers && this._computedWatchers[key];
+    if (watcher) {
+      if (watcher.dirty) {
+        watcher.evaluate();
+      }
+      if (Dep.target) {
+        watcher.depend();
+      }
+      return watcher.value
+    }
+  }
+}
+
+function initMethods (vm, methods) {
+  var props = vm.$options.props;
+  for (var key in methods) {
+    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
+    if (process.env.NODE_ENV !== 'production') {
+      if (methods[key] == null) {
+        warn(
+          "method \"" + key + "\" has an undefined value in the component definition. " +
+          "Did you reference the function correctly?",
+          vm
+        );
+      }
+      if (props && hasOwn(props, key)) {
+        warn(
+          ("method \"" + key + "\" has already been defined as a prop."),
+          vm
+        );
+      }
+    }
+  }
+}
+
+function initWatch (vm, watch) {
+  for (var key in watch) {
+    var handler = watch[key];
+    if (Array.isArray(handler)) {
+      for (var i = 0; i < handler.length; i++) {
+        createWatcher(vm, key, handler[i]);
+      }
+    } else {
+      createWatcher(vm, key, handler);
+    }
+  }
+}
+
+function createWatcher (vm, key, handler) {
+  var options;
+  if (isPlainObject(handler)) {
+    options = handler;
+    handler = handler.handler;
+  }
+  if (typeof handler === 'string') {
+    handler = vm[handler];
+  }
+  vm.$watch(key, handler, options);
+}
+
+function stateMixin (Vue) {
+  // flow somehow has problems with directly declared definition object
+  // when using Object.defineProperty, so we have to procedurally build up
+  // the object here.
+  var dataDef = {};
+  dataDef.get = function () { return this._data };
+  var propsDef = {};
+  propsDef.get = function () { return this._props };
+  if (process.env.NODE_ENV !== 'production') {
+    dataDef.set = function (newData) {
+      warn(
+        'Avoid replacing instance root $data. ' +
+        'Use nested data properties instead.',
+        this
+      );
+    };
+    propsDef.set = function () {
+      warn("$props is readonly.", this);
+    };
+  }
+  Object.defineProperty(Vue.prototype, '$data', dataDef);
+  Object.defineProperty(Vue.prototype, '$props', propsDef);
+
+  Vue.prototype.$set = set;
+  Vue.prototype.$delete = del;
+
+  Vue.prototype.$watch = function (
+    expOrFn,
+    cb,
+    options
+  ) {
+    var vm = this;
+    options = options || {};
+    options.user = true;
+    var watcher = new Watcher(vm, expOrFn, cb, options);
+    if (options.immediate) {
+      cb.call(vm, watcher.value);
+    }
+    return function unwatchFn () {
+      watcher.teardown();
+    }
+  };
+}
+
+/*  */
+
+var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy };
+var hooksToMerge = Object.keys(hooks);
+
+function createComponent (
+  Ctor,
+  data,
+  context,
+  children,
+  tag
+) {
+  if (!Ctor) {
+    return
+  }
+
+  var baseCtor = context.$options._base;
+  if (isObject(Ctor)) {
+    Ctor = baseCtor.extend(Ctor);
+  }
+
+  if (typeof Ctor !== 'function') {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Invalid Component definition: " + (String(Ctor))), context);
+    }
+    return
+  }
+
+  // async component
+  if (!Ctor.cid) {
+    if (Ctor.resolved) {
+      Ctor = Ctor.resolved;
+    } else {
+      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
+        // it's ok to queue this on every render because
+        // $forceUpdate is buffered by the scheduler.
+        context.$forceUpdate();
+      });
+      if (!Ctor) {
+        // return nothing if this is indeed an async component
+        // wait for the callback to trigger parent update.
+        return
+      }
+    }
+  }
+
+  // resolve constructor options in case global mixins are applied after
+  // component constructor creation
+  resolveConstructorOptions(Ctor);
+
+  data = data || {};
+
+  // transform component v-model data into props & events
+  if (data.model) {
+    transformModel(Ctor.options, data);
+  }
+
+  // extract props
+  var propsData = extractProps(data, Ctor);
+
+  // functional component
+  if (Ctor.options.functional) {
+    return createFunctionalComponent(Ctor, propsData, data, context, children)
+  }
+
+  // extract listeners, since these needs to be treated as
+  // child component listeners instead of DOM listeners
+  var listeners = data.on;
+  // replace with listeners with .native modifier
+  data.on = data.nativeOn;
+
+  if (Ctor.options.abstract) {
+    // abstract components do not keep anything
+    // other than props & listeners
+    data = {};
+  }
+
+  // merge component management hooks onto the placeholder node
+  mergeHooks(data);
+
+  // return a placeholder vnode
+  var name = Ctor.options.name || tag;
+  var vnode = new VNode(
+    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
+    data, undefined, undefined, undefined, context,
+    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
+  );
+  return vnode
+}
+
+function createFunctionalComponent (
+  Ctor,
+  propsData,
+  data,
+  context,
+  children
+) {
+  var props = {};
+  var propOptions = Ctor.options.props;
+  if (propOptions) {
+    for (var key in propOptions) {
+      props[key] = validateProp(key, propOptions, propsData);
+    }
+  }
+  // ensure the createElement function in functional components
+  // gets a unique context - this is necessary for correct named slot check
+  var _context = Object.create(context);
+  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
+  var vnode = Ctor.options.render.call(null, h, {
+    props: props,
+    data: data,
+    parent: context,
+    children: children,
+    slots: function () { return resolveSlots(children, context); }
+  });
+  if (vnode instanceof VNode) {
+    vnode.functionalContext = context;
+    if (data.slot) {
+      (vnode.data || (vnode.data = {})).slot = data.slot;
+    }
+  }
+  return vnode
+}
+
+function createComponentInstanceForVnode (
+  vnode, // we know it's MountedComponentVNode but flow doesn't
+  parent, // activeInstance in lifecycle state
+  parentElm,
+  refElm
+) {
+  var vnodeComponentOptions = vnode.componentOptions;
+  var options = {
+    _isComponent: true,
+    parent: parent,
+    propsData: vnodeComponentOptions.propsData,
+    _componentTag: vnodeComponentOptions.tag,
+    _parentVnode: vnode,
+    _parentListeners: vnodeComponentOptions.listeners,
+    _renderChildren: vnodeComponentOptions.children,
+    _parentElm: parentElm || null,
+    _refElm: refElm || null
+  };
+  // check inline-template render functions
+  var inlineTemplate = vnode.data.inlineTemplate;
+  if (inlineTemplate) {
+    options.render = inlineTemplate.render;
+    options.staticRenderFns = inlineTemplate.staticRenderFns;
+  }
+  return new vnodeComponentOptions.Ctor(options)
+}
+
+function init (
+  vnode,
+  hydrating,
+  parentElm,
+  refElm
+) {
+  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
+    var child = vnode.componentInstance = createComponentInstanceForVnode(
+      vnode,
+      activeInstance,
+      parentElm,
+      refElm
+    );
+    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
+  } else if (vnode.data.keepAlive) {
+    // kept-alive components, treat as a patch
+    var mountedNode = vnode; // work around flow
+    prepatch(mountedNode, mountedNode);
+  }
+}
+
+function prepatch (
+  oldVnode,
+  vnode
+) {
+  var options = vnode.componentOptions;
+  var child = vnode.componentInstance = oldVnode.componentInstance;
+  updateChildComponent(
+    child,
+    options.propsData, // updated props
+    options.listeners, // updated listeners
+    vnode, // new parent vnode
+    options.children // new children
+  );
+}
+
+function insert (vnode) {
+  if (!vnode.componentInstance._isMounted) {
+    vnode.componentInstance._isMounted = true;
+    callHook(vnode.componentInstance, 'mounted');
+  }
+  if (vnode.data.keepAlive) {
+    activateChildComponent(vnode.componentInstance, true /* direct */);
+  }
+}
+
+function destroy (vnode) {
+  if (!vnode.componentInstance._isDestroyed) {
+    if (!vnode.data.keepAlive) {
+      vnode.componentInstance.$destroy();
+    } else {
+      deactivateChildComponent(vnode.componentInstance, true /* direct */);
+    }
+  }
+}
+
+function resolveAsyncComponent (
+  factory,
+  baseCtor,
+  cb
+) {
+  if (factory.requested) {
+    // pool callbacks
+    factory.pendingCallbacks.push(cb);
+  } else {
+    factory.requested = true;
+    var cbs = factory.pendingCallbacks = [cb];
+    var sync = true;
+
+    var resolve = function (res) {
+      if (isObject(res)) {
+        res = baseCtor.extend(res);
+      }
+      // cache resolved
+      factory.resolved = res;
+      // invoke callbacks only if this is not a synchronous resolve
+      // (async resolves are shimmed as synchronous during SSR)
+      if (!sync) {
+        for (var i = 0, l = cbs.length; i < l; i++) {
+          cbs[i](res);
+        }
+      }
+    };
+
+    var reject = function (reason) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed to resolve async component: " + (String(factory)) +
+        (reason ? ("\nReason: " + reason) : '')
+      );
+    };
+
+    var res = factory(resolve, reject);
+
+    // handle promise
+    if (res && typeof res.then === 'function' && !factory.resolved) {
+      res.then(resolve, reject);
+    }
+
+    sync = false;
+    // return in case resolved synchronously
+    return factory.resolved
+  }
+}
+
+function extractProps (data, Ctor) {
+  // we are only extracting raw values here.
+  // validation and default values are handled in the child
+  // component itself.
+  var propOptions = Ctor.options.props;
+  if (!propOptions) {
+    return
+  }
+  var res = {};
+  var attrs = data.attrs;
+  var props = data.props;
+  var domProps = data.domProps;
+  if (attrs || props || domProps) {
+    for (var key in propOptions) {
+      var altKey = hyphenate(key);
+      checkProp(res, props, key, altKey, true) ||
+      checkProp(res, attrs, key, altKey) ||
+      checkProp(res, domProps, key, altKey);
+    }
+  }
+  return res
+}
+
+function checkProp (
+  res,
+  hash,
+  key,
+  altKey,
+  preserve
+) {
+  if (hash) {
+    if (hasOwn(hash, key)) {
+      res[key] = hash[key];
+      if (!preserve) {
+        delete hash[key];
+      }
+      return true
+    } else if (hasOwn(hash, altKey)) {
+      res[key] = hash[altKey];
+      if (!preserve) {
+        delete hash[altKey];
+      }
+      return true
+    }
+  }
+  return false
+}
+
+function mergeHooks (data) {
+  if (!data.hook) {
+    data.hook = {};
+  }
+  for (var i = 0; i < hooksToMerge.length; i++) {
+    var key = hooksToMerge[i];
+    var fromParent = data.hook[key];
+    var ours = hooks[key];
+    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
+  }
+}
+
+function mergeHook$1 (one, two) {
+  return function (a, b, c, d) {
+    one(a, b, c, d);
+    two(a, b, c, d);
+  }
+}
+
+// transform component v-model info (value and callback) into
+// prop and event handler respectively.
+function transformModel (options, data) {
+  var prop = (options.model && options.model.prop) || 'value';
+  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
+  var on = data.on || (data.on = {});
+  if (on[event]) {
+    on[event] = [data.model.callback].concat(on[event]);
+  } else {
+    on[event] = data.model.callback;
+  }
+}
+
+/*  */
+
+var SIMPLE_NORMALIZE = 1;
+var ALWAYS_NORMALIZE = 2;
+
+// wrapper function for providing a more flexible interface
+// without getting yelled at by flow
+function createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType,
+  alwaysNormalize
+) {
+  if (Array.isArray(data) || isPrimitive(data)) {
+    normalizationType = children;
+    children = data;
+    data = undefined;
+  }
+  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
+  return _createElement(context, tag, data, children, normalizationType)
+}
+
+function _createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType
+) {
+  if (data && data.__ob__) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
+      'Always create fresh vnode data objects in each render!',
+      context
+    );
+    return createEmptyVNode()
+  }
+  if (!tag) {
+    // in case of component :is set to falsy value
+    return createEmptyVNode()
+  }
+  // support single function children as default scoped slot
+  if (Array.isArray(children) &&
+      typeof children[0] === 'function') {
+    data = data || {};
+    data.scopedSlots = { default: children[0] };
+    children.length = 0;
+  }
+  if (normalizationType === ALWAYS_NORMALIZE) {
+    children = normalizeChildren(children);
+  } else if (normalizationType === SIMPLE_NORMALIZE) {
+    children = simpleNormalizeChildren(children);
+  }
+  var vnode, ns;
+  if (typeof tag === 'string') {
+    var Ctor;
+    ns = config.getTagNamespace(tag);
+    if (config.isReservedTag(tag)) {
+      // platform built-in elements
+      vnode = new VNode(
+        config.parsePlatformTagName(tag), data, children,
+        undefined, undefined, context
+      );
+    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
+      // component
+      vnode = createComponent(Ctor, data, context, children, tag);
+    } else {
+      // unknown or unlisted namespaced elements
+      // check at runtime because it may get assigned a namespace when its
+      // parent normalizes children
+      vnode = new VNode(
+        tag, data, children,
+        undefined, undefined, context
+      );
+    }
+  } else {
+    // direct component options / constructor
+    vnode = createComponent(tag, data, context, children);
+  }
+  if (vnode) {
+    if (ns) { applyNS(vnode, ns); }
+    return vnode
+  } else {
+    return createEmptyVNode()
+  }
+}
+
+function applyNS (vnode, ns) {
+  vnode.ns = ns;
+  if (vnode.tag === 'foreignObject') {
+    // use default namespace inside foreignObject
+    return
+  }
+  if (vnode.children) {
+    for (var i = 0, l = vnode.children.length; i < l; i++) {
+      var child = vnode.children[i];
+      if (child.tag && !child.ns) {
+        applyNS(child, ns);
+      }
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering v-for lists.
+ */
+function renderList (
+  val,
+  render
+) {
+  var ret, i, l, keys, key;
+  if (Array.isArray(val) || typeof val === 'string') {
+    ret = new Array(val.length);
+    for (i = 0, l = val.length; i < l; i++) {
+      ret[i] = render(val[i], i);
+    }
+  } else if (typeof val === 'number') {
+    ret = new Array(val);
+    for (i = 0; i < val; i++) {
+      ret[i] = render(i + 1, i);
+    }
+  } else if (isObject(val)) {
+    keys = Object.keys(val);
+    ret = new Array(keys.length);
+    for (i = 0, l = keys.length; i < l; i++) {
+      key = keys[i];
+      ret[i] = render(val[key], key, i);
+    }
+  }
+  return ret
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering <slot>
+ */
+function renderSlot (
+  name,
+  fallback,
+  props,
+  bindObject
+) {
+  var scopedSlotFn = this.$scopedSlots[name];
+  if (scopedSlotFn) { // scoped slot
+    props = props || {};
+    if (bindObject) {
+      extend(props, bindObject);
+    }
+    return scopedSlotFn(props) || fallback
+  } else {
+    var slotNodes = this.$slots[name];
+    // warn duplicate slot usage
+    if (slotNodes && process.env.NODE_ENV !== 'production') {
+      slotNodes._rendered && warn(
+        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
+        "- this will likely cause render errors.",
+        this
+      );
+      slotNodes._rendered = true;
+    }
+    return slotNodes || fallback
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving filters
+ */
+function resolveFilter (id) {
+  return resolveAsset(this.$options, 'filters', id, true) || identity
+}
+
+/*  */
+
+/**
+ * Runtime helper for checking keyCodes from config.
+ */
+function checkKeyCodes (
+  eventKeyCode,
+  key,
+  builtInAlias
+) {
+  var keyCodes = config.keyCodes[key] || builtInAlias;
+  if (Array.isArray(keyCodes)) {
+    return keyCodes.indexOf(eventKeyCode) === -1
+  } else {
+    return keyCodes !== eventKeyCode
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for merging v-bind="object" into a VNode's data.
+ */
+function bindObjectProps (
+  data,
+  tag,
+  value,
+  asProp
+) {
+  if (value) {
+    if (!isObject(value)) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'v-bind without argument expects an Object or Array value',
+        this
+      );
+    } else {
+      if (Array.isArray(value)) {
+        value = toObject(value);
+      }
+      for (var key in value) {
+        if (key === 'class' || key === 'style') {
+          data[key] = value[key];
+        } else {
+          var type = data.attrs && data.attrs.type;
+          var hash = asProp || config.mustUseProp(tag, type, key)
+            ? data.domProps || (data.domProps = {})
+            : data.attrs || (data.attrs = {});
+          hash[key] = value[key];
+        }
+      }
+    }
+  }
+  return data
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering static trees.
+ */
+function renderStatic (
+  index,
+  isInFor
+) {
+  var tree = this._staticTrees[index];
+  // if has already-rendered static tree and not inside v-for,
+  // we can reuse the same tree by doing a shallow clone.
+  if (tree && !isInFor) {
+    return Array.isArray(tree)
+      ? cloneVNodes(tree)
+      : cloneVNode(tree)
+  }
+  // otherwise, render a fresh tree.
+  tree = this._staticTrees[index] =
+    this.$options.staticRenderFns[index].call(this._renderProxy);
+  markStatic(tree, ("__static__" + index), false);
+  return tree
+}
+
+/**
+ * Runtime helper for v-once.
+ * Effectively it means marking the node as static with a unique key.
+ */
+function markOnce (
+  tree,
+  index,
+  key
+) {
+  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
+  return tree
+}
+
+function markStatic (
+  tree,
+  key,
+  isOnce
+) {
+  if (Array.isArray(tree)) {
+    for (var i = 0; i < tree.length; i++) {
+      if (tree[i] && typeof tree[i] !== 'string') {
+        markStaticNode(tree[i], (key + "_" + i), isOnce);
+      }
+    }
+  } else {
+    markStaticNode(tree, key, isOnce);
+  }
+}
+
+function markStaticNode (node, key, isOnce) {
+  node.isStatic = true;
+  node.key = key;
+  node.isOnce = isOnce;
+}
+
+/*  */
+
+function initRender (vm) {
+  vm.$vnode = null; // the placeholder node in parent tree
+  vm._vnode = null; // the root of the child tree
+  vm._staticTrees = null;
+  var parentVnode = vm.$options._parentVnode;
+  var renderContext = parentVnode && parentVnode.context;
+  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
+  vm.$scopedSlots = emptyObject;
+  // bind the createElement fn to this instance
+  // so that we get proper render context inside it.
+  // args order: tag, data, children, normalizationType, alwaysNormalize
+  // internal version is used by render functions compiled from templates
+  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
+  // normalization is always applied for the public version, used in
+  // user-written render functions.
+  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
+}
+
+function renderMixin (Vue) {
+  Vue.prototype.$nextTick = function (fn) {
+    return nextTick(fn, this)
+  };
+
+  Vue.prototype._render = function () {
+    var vm = this;
+    var ref = vm.$options;
+    var render = ref.render;
+    var staticRenderFns = ref.staticRenderFns;
+    var _parentVnode = ref._parentVnode;
+
+    if (vm._isMounted) {
+      // clone slot nodes on re-renders
+      for (var key in vm.$slots) {
+        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
+      }
+    }
+
+    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;
+
+    if (staticRenderFns && !vm._staticTrees) {
+      vm._staticTrees = [];
+    }
+    // set parent vnode. this allows render functions to have access
+    // to the data on the placeholder node.
+    vm.$vnode = _parentVnode;
+    // render self
+    var vnode;
+    try {
+      vnode = render.call(vm._renderProxy, vm.$createElement);
+    } catch (e) {
+      handleError(e, vm, "render function");
+      // return error render result,
+      // or previous vnode to prevent render error causing blank component
+      /* istanbul ignore else */
+      if (process.env.NODE_ENV !== 'production') {
+        vnode = vm.$options.renderError
+          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
+          : vm._vnode;
+      } else {
+        vnode = vm._vnode;
+      }
+    }
+    // return empty vnode in case the render function errored out
+    if (!(vnode instanceof VNode)) {
+      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
+        warn(
+          'Multiple root nodes returned from render function. Render function ' +
+          'should return a single root node.',
+          vm
+        );
+      }
+      vnode = createEmptyVNode();
+    }
+    // set parent
+    vnode.parent = _parentVnode;
+    return vnode
+  };
+
+  // internal render helpers.
+  // these are exposed on the instance prototype to reduce generated render
+  // code size.
+  Vue.prototype._o = markOnce;
+  Vue.prototype._n = toNumber;
+  Vue.prototype._s = _toString;
+  Vue.prototype._l = renderList;
+  Vue.prototype._t = renderSlot;
+  Vue.prototype._q = looseEqual;
+  Vue.prototype._i = looseIndexOf;
+  Vue.prototype._m = renderStatic;
+  Vue.prototype._f = resolveFilter;
+  Vue.prototype._k = checkKeyCodes;
+  Vue.prototype._b = bindObjectProps;
+  Vue.prototype._v = createTextVNode;
+  Vue.prototype._e = createEmptyVNode;
+  Vue.prototype._u = resolveScopedSlots;
+}
+
+/*  */
+
+function initProvide (vm) {
+  var provide = vm.$options.provide;
+  if (provide) {
+    vm._provided = typeof provide === 'function'
+      ? provide.call(vm)
+      : provide;
+  }
+}
+
+function initInjections (vm) {
+  var inject = vm.$options.inject;
+  if (inject) {
+    // inject is :any because flow is not smart enough to figure out cached
+    // isArray here
+    var isArray = Array.isArray(inject);
+    var keys = isArray
+      ? inject
+      : hasSymbol
+        ? Reflect.ownKeys(inject)
+        : Object.keys(inject);
+
+    for (var i = 0; i < keys.length; i++) {
+      var key = keys[i];
+      var provideKey = isArray ? key : inject[key];
+      var source = vm;
+      while (source) {
+        if (source._provided && provideKey in source._provided) {
+          vm[key] = source._provided[provideKey];
+          break
+        }
+        source = source.$parent;
+      }
+    }
+  }
+}
+
+/*  */
+
+var uid = 0;
+
+function initMixin (Vue) {
+  Vue.prototype._init = function (options) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      perf.mark('init');
+    }
+
+    var vm = this;
+    // a uid
+    vm._uid = uid++;
+    // a flag to avoid this being observed
+    vm._isVue = true;
+    // merge options
+    if (options && options._isComponent) {
+      // optimize internal component instantiation
+      // since dynamic options merging is pretty slow, and none of the
+      // internal component options needs special treatment.
+      initInternalComponent(vm, options);
+    } else {
+      vm.$options = mergeOptions(
+        resolveConstructorOptions(vm.constructor),
+        options || {},
+        vm
+      );
+    }
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      initProxy(vm);
+    } else {
+      vm._renderProxy = vm;
+    }
+    // expose real self
+    vm._self = vm;
+    initLifecycle(vm);
+    initEvents(vm);
+    initRender(vm);
+    callHook(vm, 'beforeCreate');
+    initInjections(vm); // resolve injections before data/props
+    initState(vm);
+    initProvide(vm); // resolve provide after data/props
+    callHook(vm, 'created');
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      vm._name = formatComponentName(vm, false);
+      perf.mark('init end');
+      perf.measure(((vm._name) + " init"), 'init', 'init end');
+    }
+
+    if (vm.$options.el) {
+      vm.$mount(vm.$options.el);
+    }
+  };
+}
+
+function initInternalComponent (vm, options) {
+  var opts = vm.$options = Object.create(vm.constructor.options);
+  // doing this because it's faster than dynamic enumeration.
+  opts.parent = options.parent;
+  opts.propsData = options.propsData;
+  opts._parentVnode = options._parentVnode;
+  opts._parentListeners = options._parentListeners;
+  opts._renderChildren = options._renderChildren;
+  opts._componentTag = options._componentTag;
+  opts._parentElm = options._parentElm;
+  opts._refElm = options._refElm;
+  if (options.render) {
+    opts.render = options.render;
+    opts.staticRenderFns = options.staticRenderFns;
+  }
+}
+
+function resolveConstructorOptions (Ctor) {
+  var options = Ctor.options;
+  if (Ctor.super) {
+    var superOptions = resolveConstructorOptions(Ctor.super);
+    var cachedSuperOptions = Ctor.superOptions;
+    if (superOptions !== cachedSuperOptions) {
+      // super option changed,
+      // need to resolve new options.
+      Ctor.superOptions = superOptions;
+      // check if there are any late-modified/attached options (#4976)
+      var modifiedOptions = resolveModifiedOptions(Ctor);
+      // update base extend options
+      if (modifiedOptions) {
+        extend(Ctor.extendOptions, modifiedOptions);
+      }
+      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
+      if (options.name) {
+        options.components[options.name] = Ctor;
+      }
+    }
+  }
+  return options
+}
+
+function resolveModifiedOptions (Ctor) {
+  var modified;
+  var latest = Ctor.options;
+  var sealed = Ctor.sealedOptions;
+  for (var key in latest) {
+    if (latest[key] !== sealed[key]) {
+      if (!modified) { modified = {}; }
+      modified[key] = dedupe(latest[key], sealed[key]);
+    }
+  }
+  return modified
+}
+
+function dedupe (latest, sealed) {
+  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
+  // between merges
+  if (Array.isArray(latest)) {
+    var res = [];
+    sealed = Array.isArray(sealed) ? sealed : [sealed];
+    for (var i = 0; i < latest.length; i++) {
+      if (sealed.indexOf(latest[i]) < 0) {
+        res.push(latest[i]);
+      }
+    }
+    return res
+  } else {
+    return latest
+  }
+}
+
+function Vue$3 (options) {
+  if (process.env.NODE_ENV !== 'production' &&
+    !(this instanceof Vue$3)) {
+    warn('Vue is a constructor and should be called with the `new` keyword');
+  }
+  this._init(options);
+}
+
+initMixin(Vue$3);
+stateMixin(Vue$3);
+eventsMixin(Vue$3);
+lifecycleMixin(Vue$3);
+renderMixin(Vue$3);
+
+/*  */
+
+function initUse (Vue) {
+  Vue.use = function (plugin) {
+    /* istanbul ignore if */
+    if (plugin.installed) {
+      return
+    }
+    // additional parameters
+    var args = toArray(arguments, 1);
+    args.unshift(this);
+    if (typeof plugin.install === 'function') {
+      plugin.install.apply(plugin, args);
+    } else if (typeof plugin === 'function') {
+      plugin.apply(null, args);
+    }
+    plugin.installed = true;
+    return this
+  };
+}
+
+/*  */
+
+function initMixin$1 (Vue) {
+  Vue.mixin = function (mixin) {
+    this.options = mergeOptions(this.options, mixin);
+  };
+}
+
+/*  */
+
+function initExtend (Vue) {
+  /**
+   * Each instance constructor, including Vue, has a unique
+   * cid. This enables us to create wrapped "child
+   * constructors" for prototypal inheritance and cache them.
+   */
+  Vue.cid = 0;
+  var cid = 1;
+
+  /**
+   * Class inheritance
+   */
+  Vue.extend = function (extendOptions) {
+    extendOptions = extendOptions || {};
+    var Super = this;
+    var SuperId = Super.cid;
+    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
+    if (cachedCtors[SuperId]) {
+      return cachedCtors[SuperId]
+    }
+
+    var name = extendOptions.name || Super.options.name;
+    if (process.env.NODE_ENV !== 'production') {
+      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+        warn(
+          'Invalid component name: "' + name + '". Component names ' +
+          'can only contain alphanumeric characters and the hyphen, ' +
+          'and must start with a letter.'
+        );
+      }
+    }
+
+    var Sub = function VueComponent (options) {
+      this._init(options);
+    };
+    Sub.prototype = Object.create(Super.prototype);
+    Sub.prototype.constructor = Sub;
+    Sub.cid = cid++;
+    Sub.options = mergeOptions(
+      Super.options,
+      extendOptions
+    );
+    Sub['super'] = Super;
+
+    // For props and computed properties, we define the proxy getters on
+    // the Vue instances at extension time, on the extended prototype. This
+    // avoids Object.defineProperty calls for each instance created.
+    if (Sub.options.props) {
+      initProps$1(Sub);
+    }
+    if (Sub.options.computed) {
+      initComputed$1(Sub);
+    }
+
+    // allow further extension/mixin/plugin usage
+    Sub.extend = Super.extend;
+    Sub.mixin = Super.mixin;
+    Sub.use = Super.use;
+
+    // create asset registers, so extended classes
+    // can have their private assets too.
+    config._assetTypes.forEach(function (type) {
+      Sub[type] = Super[type];
+    });
+    // enable recursive self-lookup
+    if (name) {
+      Sub.options.components[name] = Sub;
+    }
+
+    // keep a reference to the super options at extension time.
+    // later at instantiation we can check if Super's options have
+    // been updated.
+    Sub.superOptions = Super.options;
+    Sub.extendOptions = extendOptions;
+    Sub.sealedOptions = extend({}, Sub.options);
+
+    // cache constructor
+    cachedCtors[SuperId] = Sub;
+    return Sub
+  };
+}
+
+function initProps$1 (Comp) {
+  var props = Comp.options.props;
+  for (var key in props) {
+    proxy(Comp.prototype, "_props", key);
+  }
+}
+
+function initComputed$1 (Comp) {
+  var computed = Comp.options.computed;
+  for (var key in computed) {
+    defineComputed(Comp.prototype, key, computed[key]);
+  }
+}
+
+/*  */
+
+function initAssetRegisters (Vue) {
+  /**
+   * Create asset registration methods.
+   */
+  config._assetTypes.forEach(function (type) {
+    Vue[type] = function (
+      id,
+      definition
+    ) {
+      if (!definition) {
+        return this.options[type + 's'][id]
+      } else {
+        /* istanbul ignore if */
+        if (process.env.NODE_ENV !== 'production') {
+          if (type === 'component' && config.isReservedTag(id)) {
+            warn(
+              'Do not use built-in or reserved HTML elements as component ' +
+              'id: ' + id
+            );
+          }
+        }
+        if (type === 'component' && isPlainObject(definition)) {
+          definition.name = definition.name || id;
+          definition = this.options._base.extend(definition);
+        }
+        if (type === 'directive' && typeof definition === 'function') {
+          definition = { bind: definition, update: definition };
+        }
+        this.options[type + 's'][id] = definition;
+        return definition
+      }
+    };
+  });
+}
+
+/*  */
+
+var patternTypes = [String, RegExp];
+
+function getComponentName (opts) {
+  return opts && (opts.Ctor.options.name || opts.tag)
+}
+
+function matches (pattern, name) {
+  if (typeof pattern === 'string') {
+    return pattern.split(',').indexOf(name) > -1
+  } else if (pattern instanceof RegExp) {
+    return pattern.test(name)
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function pruneCache (cache, filter) {
+  for (var key in cache) {
+    var cachedNode = cache[key];
+    if (cachedNode) {
+      var name = getComponentName(cachedNode.componentOptions);
+      if (name && !filter(name)) {
+        pruneCacheEntry(cachedNode);
+        cache[key] = null;
+      }
+    }
+  }
+}
+
+function pruneCacheEntry (vnode) {
+  if (vnode) {
+    if (!vnode.componentInstance._inactive) {
+      callHook(vnode.componentInstance, 'deactivated');
+    }
+    vnode.componentInstance.$destroy();
+  }
+}
+
+var KeepAlive = {
+  name: 'keep-alive',
+  abstract: true,
+
+  props: {
+    include: patternTypes,
+    exclude: patternTypes
+  },
+
+  created: function created () {
+    this.cache = Object.create(null);
+  },
+
+  destroyed: function destroyed () {
+    var this$1 = this;
+
+    for (var key in this$1.cache) {
+      pruneCacheEntry(this$1.cache[key]);
+    }
+  },
+
+  watch: {
+    include: function include (val) {
+      pruneCache(this.cache, function (name) { return matches(val, name); });
+    },
+    exclude: function exclude (val) {
+      pruneCache(this.cache, function (name) { return !matches(val, name); });
+    }
+  },
+
+  render: function render () {
+    var vnode = getFirstComponentChild(this.$slots.default);
+    var componentOptions = vnode && vnode.componentOptions;
+    if (componentOptions) {
+      // check pattern
+      var name = getComponentName(componentOptions);
+      if (name && (
+        (this.include && !matches(this.include, name)) ||
+        (this.exclude && matches(this.exclude, name))
+      )) {
+        return vnode
+      }
+      var key = vnode.key == null
+        // same constructor may get registered as different local components
+        // so cid alone is not enough (#3269)
+        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
+        : vnode.key;
+      if (this.cache[key]) {
+        vnode.componentInstance = this.cache[key].componentInstance;
+      } else {
+        this.cache[key] = vnode;
+      }
+      vnode.data.keepAlive = true;
+    }
+    return vnode
+  }
+};
+
+var builtInComponents = {
+  KeepAlive: KeepAlive
+};
+
+/*  */
+
+function initGlobalAPI (Vue) {
+  // config
+  var configDef = {};
+  configDef.get = function () { return config; };
+  if (process.env.NODE_ENV !== 'production') {
+    configDef.set = function () {
+      warn(
+        'Do not replace the Vue.config object, set individual fields instead.'
+      );
+    };
+  }
+  Object.defineProperty(Vue, 'config', configDef);
+
+  // exposed util methods.
+  // NOTE: these are not considered part of the public API - avoid relying on
+  // them unless you are aware of the risk.
+  Vue.util = {
+    warn: warn,
+    extend: extend,
+    mergeOptions: mergeOptions,
+    defineReactive: defineReactive$$1
+  };
+
+  Vue.set = set;
+  Vue.delete = del;
+  Vue.nextTick = nextTick;
+
+  Vue.options = Object.create(null);
+  config._assetTypes.forEach(function (type) {
+    Vue.options[type + 's'] = Object.create(null);
+  });
+
+  // this is used to identify the "base" constructor to extend all plain-object
+  // components with in Weex's multi-instance scenarios.
+  Vue.options._base = Vue;
+
+  extend(Vue.options.components, builtInComponents);
+
+  initUse(Vue);
+  initMixin$1(Vue);
+  initExtend(Vue);
+  initAssetRegisters(Vue);
+}
+
+initGlobalAPI(Vue$3);
+
+Object.defineProperty(Vue$3.prototype, '$isServer', {
+  get: isServerRendering
+});
+
+Vue$3.version = '2.2.2';
+
+/*  */
+
+// attributes that should be using props for binding
+var acceptValue = makeMap('input,textarea,option,select');
+var mustUseProp = function (tag, type, attr) {
+  return (
+    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
+    (attr === 'selected' && tag === 'option') ||
+    (attr === 'checked' && tag === 'input') ||
+    (attr === 'muted' && tag === 'video')
+  )
+};
+
+var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
+
+var isBooleanAttr = makeMap(
+  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
+  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
+  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
+  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
+  'required,reversed,scoped,seamless,selected,sortable,translate,' +
+  'truespeed,typemustmatch,visible'
+);
+
+var xlinkNS = 'http://www.w3.org/1999/xlink';
+
+var isXlink = function (name) {
+  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
+};
+
+var getXlinkProp = function (name) {
+  return isXlink(name) ? name.slice(6, name.length) : ''
+};
+
+var isFalsyAttrValue = function (val) {
+  return val == null || val === false
+};
+
+/*  */
+
+function genClassForVnode (vnode) {
+  var data = vnode.data;
+  var parentNode = vnode;
+  var childNode = vnode;
+  while (childNode.componentInstance) {
+    childNode = childNode.componentInstance._vnode;
+    if (childNode.data) {
+      data = mergeClassData(childNode.data, data);
+    }
+  }
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data) {
+      data = mergeClassData(data, parentNode.data);
+    }
+  }
+  return genClassFromData(data)
+}
+
+function mergeClassData (child, parent) {
+  return {
+    staticClass: concat(child.staticClass, parent.staticClass),
+    class: child.class
+      ? [child.class, parent.class]
+      : parent.class
+  }
+}
+
+function genClassFromData (data) {
+  var dynamicClass = data.class;
+  var staticClass = data.staticClass;
+  if (staticClass || dynamicClass) {
+    return concat(staticClass, stringifyClass(dynamicClass))
+  }
+  /* istanbul ignore next */
+  return ''
+}
+
+function concat (a, b) {
+  return a ? b ? (a + ' ' + b) : a : (b || '')
+}
+
+function stringifyClass (value) {
+  var res = '';
+  if (!value) {
+    return res
+  }
+  if (typeof value === 'string') {
+    return value
+  }
+  if (Array.isArray(value)) {
+    var stringified;
+    for (var i = 0, l = value.length; i < l; i++) {
+      if (value[i]) {
+        if ((stringified = stringifyClass(value[i]))) {
+          res += stringified + ' ';
+        }
+      }
+    }
+    return res.slice(0, -1)
+  }
+  if (isObject(value)) {
+    for (var key in value) {
+      if (value[key]) { res += key + ' '; }
+    }
+    return res.slice(0, -1)
+  }
+  /* istanbul ignore next */
+  return res
+}
+
+/*  */
+
+var namespaceMap = {
+  svg: 'http://www.w3.org/2000/svg',
+  math: 'http://www.w3.org/1998/Math/MathML'
+};
+
+var isHTMLTag = makeMap(
+  'html,body,base,head,link,meta,style,title,' +
+  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
+  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
+  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
+  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
+  'embed,object,param,source,canvas,script,noscript,del,ins,' +
+  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
+  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
+  'output,progress,select,textarea,' +
+  'details,dialog,menu,menuitem,summary,' +
+  'content,element,shadow,template'
+);
+
+// this map is intentionally selective, only covering SVG elements that may
+// contain child elements.
+var isSVG = makeMap(
+  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
+  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
+  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
+  true
+);
+
+var isPreTag = function (tag) { return tag === 'pre'; };
+
+var isReservedTag = function (tag) {
+  return isHTMLTag(tag) || isSVG(tag)
+};
+
+function getTagNamespace (tag) {
+  if (isSVG(tag)) {
+    return 'svg'
+  }
+  // basic support for MathML
+  // note it doesn't support other MathML elements being component roots
+  if (tag === 'math') {
+    return 'math'
+  }
+}
+
+var unknownElementCache = Object.create(null);
+function isUnknownElement (tag) {
+  /* istanbul ignore if */
+  if (!inBrowser) {
+    return true
+  }
+  if (isReservedTag(tag)) {
+    return false
+  }
+  tag = tag.toLowerCase();
+  /* istanbul ignore if */
+  if (unknownElementCache[tag] != null) {
+    return unknownElementCache[tag]
+  }
+  var el = document.createElement(tag);
+  if (tag.indexOf('-') > -1) {
+    // http://stackoverflow.com/a/28210364/1070244
+    return (unknownElementCache[tag] = (
+      el.constructor === window.HTMLUnknownElement ||
+      el.constructor === window.HTMLElement
+    ))
+  } else {
+    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
+  }
+}
+
+/*  */
+
+/**
+ * Query an element selector if it's not an element already.
+ */
+function query (el) {
+  if (typeof el === 'string') {
+    var selected = document.querySelector(el);
+    if (!selected) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'Cannot find element: ' + el
+      );
+      return document.createElement('div')
+    }
+    return selected
+  } else {
+    return el
+  }
+}
+
+/*  */
+
+function createElement$1 (tagName, vnode) {
+  var elm = document.createElement(tagName);
+  if (tagName !== 'select') {
+    return elm
+  }
+  // false or null will remove the attribute but undefined will not
+  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
+    elm.setAttribute('multiple', 'multiple');
+  }
+  return elm
+}
+
+function createElementNS (namespace, tagName) {
+  return document.createElementNS(namespaceMap[namespace], tagName)
+}
+
+function createTextNode (text) {
+  return document.createTextNode(text)
+}
+
+function createComment (text) {
+  return document.createComment(text)
+}
+
+function insertBefore (parentNode, newNode, referenceNode) {
+  parentNode.insertBefore(newNode, referenceNode);
+}
+
+function removeChild (node, child) {
+  node.removeChild(child);
+}
+
+function appendChild (node, child) {
+  node.appendChild(child);
+}
+
+function parentNode (node) {
+  return node.parentNode
+}
+
+function nextSibling (node) {
+  return node.nextSibling
+}
+
+function tagName (node) {
+  return node.tagName
+}
+
+function setTextContent (node, text) {
+  node.textContent = text;
+}
+
+function setAttribute (node, key, val) {
+  node.setAttribute(key, val);
+}
+
+
+var nodeOps = Object.freeze({
+	createElement: createElement$1,
+	createElementNS: createElementNS,
+	createTextNode: createTextNode,
+	createComment: createComment,
+	insertBefore: insertBefore,
+	removeChild: removeChild,
+	appendChild: appendChild,
+	parentNode: parentNode,
+	nextSibling: nextSibling,
+	tagName: tagName,
+	setTextContent: setTextContent,
+	setAttribute: setAttribute
+});
+
+/*  */
+
+var ref = {
+  create: function create (_, vnode) {
+    registerRef(vnode);
+  },
+  update: function update (oldVnode, vnode) {
+    if (oldVnode.data.ref !== vnode.data.ref) {
+      registerRef(oldVnode, true);
+      registerRef(vnode);
+    }
+  },
+  destroy: function destroy (vnode) {
+    registerRef(vnode, true);
+  }
+};
+
+function registerRef (vnode, isRemoval) {
+  var key = vnode.data.ref;
+  if (!key) { return }
+
+  var vm = vnode.context;
+  var ref = vnode.componentInstance || vnode.elm;
+  var refs = vm.$refs;
+  if (isRemoval) {
+    if (Array.isArray(refs[key])) {
+      remove(refs[key], ref);
+    } else if (refs[key] === ref) {
+      refs[key] = undefined;
+    }
+  } else {
+    if (vnode.data.refInFor) {
+      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
+        refs[key].push(ref);
+      } else {
+        refs[key] = [ref];
+      }
+    } else {
+      refs[key] = ref;
+    }
+  }
+}
+
+/**
+ * Virtual DOM patching algorithm based on Snabbdom by
+ * Simon Friis Vindum (@paldepind)
+ * Licensed under the MIT License
+ * https://github.com/paldepind/snabbdom/blob/master/LICENSE
+ *
+ * modified by Evan You (@yyx990803)
+ *
+
+/*
+ * Not type-checking this because this file is perf-critical and the cost
+ * of making flow understand it is not worth it.
+ */
+
+var emptyNode = new VNode('', {}, []);
+
+var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];
+
+function isUndef (s) {
+  return s == null
+}
+
+function isDef (s) {
+  return s != null
+}
+
+function sameVnode (vnode1, vnode2) {
+  return (
+    vnode1.key === vnode2.key &&
+    vnode1.tag === vnode2.tag &&
+    vnode1.isComment === vnode2.isComment &&
+    !vnode1.data === !vnode2.data
+  )
+}
+
+function createKeyToOldIdx (children, beginIdx, endIdx) {
+  var i, key;
+  var map = {};
+  for (i = beginIdx; i <= endIdx; ++i) {
+    key = children[i].key;
+    if (isDef(key)) { map[key] = i; }
+  }
+  return map
+}
+
+function createPatchFunction (backend) {
+  var i, j;
+  var cbs = {};
+
+  var modules = backend.modules;
+  var nodeOps = backend.nodeOps;
+
+  for (i = 0; i < hooks$1.length; ++i) {
+    cbs[hooks$1[i]] = [];
+    for (j = 0; j < modules.length; ++j) {
+      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
+    }
+  }
+
+  function emptyNodeAt (elm) {
+    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
+  }
+
+  function createRmCb (childElm, listeners) {
+    function remove$$1 () {
+      if (--remove$$1.listeners === 0) {
+        removeNode(childElm);
+      }
+    }
+    remove$$1.listeners = listeners;
+    return remove$$1
+  }
+
+  function removeNode (el) {
+    var parent = nodeOps.parentNode(el);
+    // element may have already been removed due to v-html / v-text
+    if (parent) {
+      nodeOps.removeChild(parent, el);
+    }
+  }
+
+  var inPre = 0;
+  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
+    vnode.isRootInsert = !nested; // for transition enter check
+    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
+      return
+    }
+
+    var data = vnode.data;
+    var children = vnode.children;
+    var tag = vnode.tag;
+    if (isDef(tag)) {
+      if (process.env.NODE_ENV !== 'production') {
+        if (data && data.pre) {
+          inPre++;
+        }
+        if (
+          !inPre &&
+          !vnode.ns &&
+          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
+          config.isUnknownElement(tag)
+        ) {
+          warn(
+            'Unknown custom element: <' + tag + '> - did you ' +
+            'register the component correctly? For recursive components, ' +
+            'make sure to provide the "name" option.',
+            vnode.context
+          );
+        }
+      }
+      vnode.elm = vnode.ns
+        ? nodeOps.createElementNS(vnode.ns, tag)
+        : nodeOps.createElement(tag, vnode);
+      setScope(vnode);
+
+      /* istanbul ignore if */
+      {
+        createChildren(vnode, children, insertedVnodeQueue);
+        if (isDef(data)) {
+          invokeCreateHooks(vnode, insertedVnodeQueue);
+        }
+        insert(parentElm, vnode.elm, refElm);
+      }
+
+      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
+        inPre--;
+      }
+    } else if (vnode.isComment) {
+      vnode.elm = nodeOps.createComment(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    } else {
+      vnode.elm = nodeOps.createTextNode(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    }
+  }
+
+  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i = vnode.data;
+    if (isDef(i)) {
+      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
+      if (isDef(i = i.hook) && isDef(i = i.init)) {
+        i(vnode, false /* hydrating */, parentElm, refElm);
+      }
+      // after calling the init hook, if the vnode is a child component
+      // it should've created a child instance and mounted it. the child
+      // component also has set the placeholder vnode's elm.
+      // in that case we can just return the element and be done.
+      if (isDef(vnode.componentInstance)) {
+        initComponent(vnode, insertedVnodeQueue);
+        if (isReactivated) {
+          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
+        }
+        return true
+      }
+    }
+  }
+
+  function initComponent (vnode, insertedVnodeQueue) {
+    if (vnode.data.pendingInsert) {
+      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
+    }
+    vnode.elm = vnode.componentInstance.$el;
+    if (isPatchable(vnode)) {
+      invokeCreateHooks(vnode, insertedVnodeQueue);
+      setScope(vnode);
+    } else {
+      // empty component root.
+      // skip all element-related modules except for ref (#3455)
+      registerRef(vnode);
+      // make sure to invoke the insert hook
+      insertedVnodeQueue.push(vnode);
+    }
+  }
+
+  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i;
+    // hack for #4339: a reactivated component with inner transition
+    // does not trigger because the inner node's created hooks are not called
+    // again. It's not ideal to involve module-specific logic in here but
+    // there doesn't seem to be a better way to do it.
+    var innerNode = vnode;
+    while (innerNode.componentInstance) {
+      innerNode = innerNode.componentInstance._vnode;
+      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
+        for (i = 0; i < cbs.activate.length; ++i) {
+          cbs.activate[i](emptyNode, innerNode);
+        }
+        insertedVnodeQueue.push(innerNode);
+        break
+      }
+    }
+    // unlike a newly created component,
+    // a reactivated keep-alive component doesn't insert itself
+    insert(parentElm, vnode.elm, refElm);
+  }
+
+  function insert (parent, elm, ref) {
+    if (parent) {
+      if (ref) {
+        nodeOps.insertBefore(parent, elm, ref);
+      } else {
+        nodeOps.appendChild(parent, elm);
+      }
+    }
+  }
+
+  function createChildren (vnode, children, insertedVnodeQueue) {
+    if (Array.isArray(children)) {
+      for (var i = 0; i < children.length; ++i) {
+        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
+      }
+    } else if (isPrimitive(vnode.text)) {
+      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
+    }
+  }
+
+  function isPatchable (vnode) {
+    while (vnode.componentInstance) {
+      vnode = vnode.componentInstance._vnode;
+    }
+    return isDef(vnode.tag)
+  }
+
+  function invokeCreateHooks (vnode, insertedVnodeQueue) {
+    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
+      cbs.create[i$1](emptyNode, vnode);
+    }
+    i = vnode.data.hook; // Reuse variable
+    if (isDef(i)) {
+      if (i.create) { i.create(emptyNode, vnode); }
+      if (i.insert) { insertedVnodeQueue.push(vnode); }
+    }
+  }
+
+  // set scope id attribute for scoped CSS.
+  // this is implemented as a special case to avoid the overhead
+  // of going through the normal attribute patching process.
+  function setScope (vnode) {
+    var i;
+    var ancestor = vnode;
+    while (ancestor) {
+      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
+        nodeOps.setAttribute(vnode.elm, i, '');
+      }
+      ancestor = ancestor.parent;
+    }
+    // for slot content they should also get the scopeId from the host instance.
+    if (isDef(i = activeInstance) &&
+        i !== vnode.context &&
+        isDef(i = i.$options._scopeId)) {
+      nodeOps.setAttribute(vnode.elm, i, '');
+    }
+  }
+
+  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
+    }
+  }
+
+  function invokeDestroyHook (vnode) {
+    var i, j;
+    var data = vnode.data;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
+      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
+    }
+    if (isDef(i = vnode.children)) {
+      for (j = 0; j < vnode.children.length; ++j) {
+        invokeDestroyHook(vnode.children[j]);
+      }
+    }
+  }
+
+  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      var ch = vnodes[startIdx];
+      if (isDef(ch)) {
+        if (isDef(ch.tag)) {
+          removeAndInvokeRemoveHook(ch);
+          invokeDestroyHook(ch);
+        } else { // Text node
+          removeNode(ch.elm);
+        }
+      }
+    }
+  }
+
+  function removeAndInvokeRemoveHook (vnode, rm) {
+    if (rm || isDef(vnode.data)) {
+      var listeners = cbs.remove.length + 1;
+      if (!rm) {
+        // directly removing
+        rm = createRmCb(vnode.elm, listeners);
+      } else {
+        // we have a recursively passed down rm callback
+        // increase the listeners count
+        rm.listeners += listeners;
+      }
+      // recursively invoke hooks on child component root node
+      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
+        removeAndInvokeRemoveHook(i, rm);
+      }
+      for (i = 0; i < cbs.remove.length; ++i) {
+        cbs.remove[i](vnode, rm);
+      }
+      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
+        i(vnode, rm);
+      } else {
+        rm();
+      }
+    } else {
+      removeNode(vnode.elm);
+    }
+  }
+
+  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
+    var oldStartIdx = 0;
+    var newStartIdx = 0;
+    var oldEndIdx = oldCh.length - 1;
+    var oldStartVnode = oldCh[0];
+    var oldEndVnode = oldCh[oldEndIdx];
+    var newEndIdx = newCh.length - 1;
+    var newStartVnode = newCh[0];
+    var newEndVnode = newCh[newEndIdx];
+    var oldKeyToIdx, idxInOld, elmToMove, refElm;
+
+    // removeOnly is a special flag used only by <transition-group>
+    // to ensure removed elements stay in correct relative positions
+    // during leaving transitions
+    var canMove = !removeOnly;
+
+    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
+      if (isUndef(oldStartVnode)) {
+        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
+      } else if (isUndef(oldEndVnode)) {
+        oldEndVnode = oldCh[--oldEndIdx];
+      } else if (sameVnode(oldStartVnode, newStartVnode)) {
+        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
+        oldStartVnode = oldCh[++oldStartIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else if (sameVnode(oldEndVnode, newEndVnode)) {
+        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
+        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
+        oldStartVnode = oldCh[++oldStartIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
+        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else {
+        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
+        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
+        if (isUndef(idxInOld)) { // New element
+          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+          newStartVnode = newCh[++newStartIdx];
+        } else {
+          elmToMove = oldCh[idxInOld];
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
+            warn(
+              'It seems there are duplicate keys that is causing an update error. ' +
+              'Make sure each v-for item has a unique key.'
+            );
+          }
+          if (sameVnode(elmToMove, newStartVnode)) {
+            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
+            oldCh[idxInOld] = undefined;
+            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          } else {
+            // same key but different element. treat as new element
+            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          }
+        }
+      }
+    }
+    if (oldStartIdx > oldEndIdx) {
+      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
+      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
+    } else if (newStartIdx > newEndIdx) {
+      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
+    }
+  }
+
+  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
+    if (oldVnode === vnode) {
+      return
+    }
+    // reuse element for static trees.
+    // note we only do this if the vnode is cloned -
+    // if the new node is not cloned it means the render functions have been
+    // reset by the hot-reload-api and we need to do a proper re-render.
+    if (vnode.isStatic &&
+        oldVnode.isStatic &&
+        vnode.key === oldVnode.key &&
+        (vnode.isCloned || vnode.isOnce)) {
+      vnode.elm = oldVnode.elm;
+      vnode.componentInstance = oldVnode.componentInstance;
+      return
+    }
+    var i;
+    var data = vnode.data;
+    var hasData = isDef(data);
+    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
+      i(oldVnode, vnode);
+    }
+    var elm = vnode.elm = oldVnode.elm;
+    var oldCh = oldVnode.children;
+    var ch = vnode.children;
+    if (hasData && isPatchable(vnode)) {
+      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
+      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
+    }
+    if (isUndef(vnode.text)) {
+      if (isDef(oldCh) && isDef(ch)) {
+        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
+      } else if (isDef(ch)) {
+        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
+        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
+      } else if (isDef(oldCh)) {
+        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
+      } else if (isDef(oldVnode.text)) {
+        nodeOps.setTextContent(elm, '');
+      }
+    } else if (oldVnode.text !== vnode.text) {
+      nodeOps.setTextContent(elm, vnode.text);
+    }
+    if (hasData) {
+      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
+    }
+  }
+
+  function invokeInsertHook (vnode, queue, initial) {
+    // delay insert hooks for component root nodes, invoke them after the
+    // element is really inserted
+    if (initial && vnode.parent) {
+      vnode.parent.data.pendingInsert = queue;
+    } else {
+      for (var i = 0; i < queue.length; ++i) {
+        queue[i].data.hook.insert(queue[i]);
+      }
+    }
+  }
+
+  var bailed = false;
+  // list of modules that can skip create hook during hydration because they
+  // are already rendered on the client or has no need for initialization
+  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
+
+  // Note: this is a browser-only function so we can assume elms are DOM nodes.
+  function hydrate (elm, vnode, insertedVnodeQueue) {
+    if (process.env.NODE_ENV !== 'production') {
+      if (!assertNodeMatch(elm, vnode)) {
+        return false
+      }
+    }
+    vnode.elm = elm;
+    var tag = vnode.tag;
+    var data = vnode.data;
+    var children = vnode.children;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
+      if (isDef(i = vnode.componentInstance)) {
+        // child component. it should have hydrated its own tree.
+        initComponent(vnode, insertedVnodeQueue);
+        return true
+      }
+    }
+    if (isDef(tag)) {
+      if (isDef(children)) {
+        // empty element, allow client to pick up and populate children
+        if (!elm.hasChildNodes()) {
+          createChildren(vnode, children, insertedVnodeQueue);
+        } else {
+          var childrenMatch = true;
+          var childNode = elm.firstChild;
+          for (var i$1 = 0; i$1 < children.length; i$1++) {
+            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
+              childrenMatch = false;
+              break
+            }
+            childNode = childNode.nextSibling;
+          }
+          // if childNode is not null, it means the actual childNodes list is
+          // longer than the virtual children list.
+          if (!childrenMatch || childNode) {
+            if (process.env.NODE_ENV !== 'production' &&
+                typeof console !== 'undefined' &&
+                !bailed) {
+              bailed = true;
+              console.warn('Parent: ', elm);
+              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
+            }
+            return false
+          }
+        }
+      }
+      if (isDef(data)) {
+        for (var key in data) {
+          if (!isRenderedModule(key)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue);
+            break
+          }
+        }
+      }
+    } else if (elm.data !== vnode.text) {
+      elm.data = vnode.text;
+    }
+    return true
+  }
+
+  function assertNodeMatch (node, vnode) {
+    if (vnode.tag) {
+      return (
+        vnode.tag.indexOf('vue-component') === 0 ||
+        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
+      )
+    } else {
+      return node.nodeType === (vnode.isComment ? 8 : 3)
+    }
+  }
+
+  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
+    if (!vnode) {
+      if (oldVnode) { invokeDestroyHook(oldVnode); }
+      return
+    }
+
+    var isInitialPatch = false;
+    var insertedVnodeQueue = [];
+
+    if (!oldVnode) {
+      // empty mount (likely as component), create new root element
+      isInitialPatch = true;
+      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
+    } else {
+      var isRealElement = isDef(oldVnode.nodeType);
+      if (!isRealElement && sameVnode(oldVnode, vnode)) {
+        // patch existing root node
+        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
+      } else {
+        if (isRealElement) {
+          // mounting to a real element
+          // check if this is server-rendered content and if we can perform
+          // a successful hydration.
+          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
+            oldVnode.removeAttribute('server-rendered');
+            hydrating = true;
+          }
+          if (hydrating) {
+            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
+              invokeInsertHook(vnode, insertedVnodeQueue, true);
+              return oldVnode
+            } else if (process.env.NODE_ENV !== 'production') {
+              warn(
+                'The client-side rendered virtual DOM tree is not matching ' +
+                'server-rendered content. This is likely caused by incorrect ' +
+                'HTML markup, for example nesting block-level elements inside ' +
+                '<p>, or missing <tbody>. Bailing hydration and performing ' +
+                'full client-side render.'
+              );
+            }
+          }
+          // either not server-rendered, or hydration failed.
+          // create an empty node and replace it
+          oldVnode = emptyNodeAt(oldVnode);
+        }
+        // replacing existing element
+        var oldElm = oldVnode.elm;
+        var parentElm$1 = nodeOps.parentNode(oldElm);
+        createElm(
+          vnode,
+          insertedVnodeQueue,
+          // extremely rare edge case: do not insert if old element is in a
+          // leaving transition. Only happens when combining transition +
+          // keep-alive + HOCs. (#4590)
+          oldElm._leaveCb ? null : parentElm$1,
+          nodeOps.nextSibling(oldElm)
+        );
+
+        if (vnode.parent) {
+          // component root element replaced.
+          // update parent placeholder node element, recursively
+          var ancestor = vnode.parent;
+          while (ancestor) {
+            ancestor.elm = vnode.elm;
+            ancestor = ancestor.parent;
+          }
+          if (isPatchable(vnode)) {
+            for (var i = 0; i < cbs.create.length; ++i) {
+              cbs.create[i](emptyNode, vnode.parent);
+            }
+          }
+        }
+
+        if (parentElm$1 !== null) {
+          removeVnodes(parentElm$1, [oldVnode], 0, 0);
+        } else if (isDef(oldVnode.tag)) {
+          invokeDestroyHook(oldVnode);
+        }
+      }
+    }
+
+    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
+    return vnode.elm
+  }
+}
+
+/*  */
+
+var directives = {
+  create: updateDirectives,
+  update: updateDirectives,
+  destroy: function unbindDirectives (vnode) {
+    updateDirectives(vnode, emptyNode);
+  }
+};
+
+function updateDirectives (oldVnode, vnode) {
+  if (oldVnode.data.directives || vnode.data.directives) {
+    _update(oldVnode, vnode);
+  }
+}
+
+function _update (oldVnode, vnode) {
+  var isCreate = oldVnode === emptyNode;
+  var isDestroy = vnode === emptyNode;
+  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
+  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
+
+  var dirsWithInsert = [];
+  var dirsWithPostpatch = [];
+
+  var key, oldDir, dir;
+  for (key in newDirs) {
+    oldDir = oldDirs[key];
+    dir = newDirs[key];
+    if (!oldDir) {
+      // new directive, bind
+      callHook$1(dir, 'bind', vnode, oldVnode);
+      if (dir.def && dir.def.inserted) {
+        dirsWithInsert.push(dir);
+      }
+    } else {
+      // existing directive, update
+      dir.oldValue = oldDir.value;
+      callHook$1(dir, 'update', vnode, oldVnode);
+      if (dir.def && dir.def.componentUpdated) {
+        dirsWithPostpatch.push(dir);
+      }
+    }
+  }
+
+  if (dirsWithInsert.length) {
+    var callInsert = function () {
+      for (var i = 0; i < dirsWithInsert.length; i++) {
+        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
+      }
+    };
+    if (isCreate) {
+      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
+    } else {
+      callInsert();
+    }
+  }
+
+  if (dirsWithPostpatch.length) {
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
+      for (var i = 0; i < dirsWithPostpatch.length; i++) {
+        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
+      }
+    });
+  }
+
+  if (!isCreate) {
+    for (key in oldDirs) {
+      if (!newDirs[key]) {
+        // no longer present, unbind
+        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
+      }
+    }
+  }
+}
+
+var emptyModifiers = Object.create(null);
+
+function normalizeDirectives$1 (
+  dirs,
+  vm
+) {
+  var res = Object.create(null);
+  if (!dirs) {
+    return res
+  }
+  var i, dir;
+  for (i = 0; i < dirs.length; i++) {
+    dir = dirs[i];
+    if (!dir.modifiers) {
+      dir.modifiers = emptyModifiers;
+    }
+    res[getRawDirName(dir)] = dir;
+    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
+  }
+  return res
+}
+
+function getRawDirName (dir) {
+  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
+}
+
+function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
+  var fn = dir.def && dir.def[hook];
+  if (fn) {
+    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
+  }
+}
+
+var baseModules = [
+  ref,
+  directives
+];
+
+/*  */
+
+function updateAttrs (oldVnode, vnode) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  var key, cur, old;
+  var elm = vnode.elm;
+  var oldAttrs = oldVnode.data.attrs || {};
+  var attrs = vnode.data.attrs || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs);
+  }
+
+  for (key in attrs) {
+    cur = attrs[key];
+    old = oldAttrs[key];
+    if (old !== cur) {
+      setAttr(elm, key, cur);
+    }
+  }
+  // #4391: in IE9, setting type can reset value for input[type=radio]
+  /* istanbul ignore if */
+  if (isIE9 && attrs.value !== oldAttrs.value) {
+    setAttr(elm, 'value', attrs.value);
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      if (isXlink(key)) {
+        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
+      } else if (!isEnumeratedAttr(key)) {
+        elm.removeAttribute(key);
+      }
+    }
+  }
+}
+
+function setAttr (el, key, value) {
+  if (isBooleanAttr(key)) {
+    // set attribute for blank value
+    // e.g. <option disabled>Select one</option>
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, key);
+    }
+  } else if (isEnumeratedAttr(key)) {
+    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
+  } else if (isXlink(key)) {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
+    } else {
+      el.setAttributeNS(xlinkNS, key, value);
+    }
+  } else {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, value);
+    }
+  }
+}
+
+var attrs = {
+  create: updateAttrs,
+  update: updateAttrs
+};
+
+/*  */
+
+function updateClass (oldVnode, vnode) {
+  var el = vnode.elm;
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  var cls = genClassForVnode(vnode);
+
+  // handle transition classes
+  var transitionClass = el._transitionClasses;
+  if (transitionClass) {
+    cls = concat(cls, stringifyClass(transitionClass));
+  }
+
+  // set the class
+  if (cls !== el._prevClass) {
+    el.setAttribute('class', cls);
+    el._prevClass = cls;
+  }
+}
+
+var klass = {
+  create: updateClass,
+  update: updateClass
+};
+
+/*  */
+
+var validDivisionCharRE = /[\w).+\-_$\]]/;
+
+function parseFilters (exp) {
+  var inSingle = false;
+  var inDouble = false;
+  var inTemplateString = false;
+  var inRegex = false;
+  var curly = 0;
+  var square = 0;
+  var paren = 0;
+  var lastFilterIndex = 0;
+  var c, prev, i, expression, filters;
+
+  for (i = 0; i < exp.length; i++) {
+    prev = c;
+    c = exp.charCodeAt(i);
+    if (inSingle) {
+      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
+    } else if (inDouble) {
+      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
+    } else if (inTemplateString) {
+      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
+    } else if (inRegex) {
+      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
+    } else if (
+      c === 0x7C && // pipe
+      exp.charCodeAt(i + 1) !== 0x7C &&
+      exp.charCodeAt(i - 1) !== 0x7C &&
+      !curly && !square && !paren
+    ) {
+      if (expression === undefined) {
+        // first filter, end of expression
+        lastFilterIndex = i + 1;
+        expression = exp.slice(0, i).trim();
+      } else {
+        pushFilter();
+      }
+    } else {
+      switch (c) {
+        case 0x22: inDouble = true; break         // "
+        case 0x27: inSingle = true; break         // '
+        case 0x60: inTemplateString = true; break // `
+        case 0x28: paren++; break                 // (
+        case 0x29: paren--; break                 // )
+        case 0x5B: square++; break                // [
+        case 0x5D: square--; break                // ]
+        case 0x7B: curly++; break                 // {
+        case 0x7D: curly--; break                 // }
+      }
+      if (c === 0x2f) { // /
+        var j = i - 1;
+        var p = (void 0);
+        // find first non-whitespace prev char
+        for (; j >= 0; j--) {
+          p = exp.charAt(j);
+          if (p !== ' ') { break }
+        }
+        if (!p || !validDivisionCharRE.test(p)) {
+          inRegex = true;
+        }
+      }
+    }
+  }
+
+  if (expression === undefined) {
+    expression = exp.slice(0, i).trim();
+  } else if (lastFilterIndex !== 0) {
+    pushFilter();
+  }
+
+  function pushFilter () {
+    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
+    lastFilterIndex = i + 1;
+  }
+
+  if (filters) {
+    for (i = 0; i < filters.length; i++) {
+      expression = wrapFilter(expression, filters[i]);
+    }
+  }
+
+  return expression
+}
+
+function wrapFilter (exp, filter) {
+  var i = filter.indexOf('(');
+  if (i < 0) {
+    // _f: resolveFilter
+    return ("_f(\"" + filter + "\")(" + exp + ")")
+  } else {
+    var name = filter.slice(0, i);
+    var args = filter.slice(i + 1);
+    return ("_f(\"" + name + "\")(" + exp + "," + args)
+  }
+}
+
+/*  */
+
+function baseWarn (msg) {
+  console.error(("[Vue compiler]: " + msg));
+}
+
+function pluckModuleFunction (
+  modules,
+  key
+) {
+  return modules
+    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
+    : []
+}
+
+function addProp (el, name, value) {
+  (el.props || (el.props = [])).push({ name: name, value: value });
+}
+
+function addAttr (el, name, value) {
+  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
+}
+
+function addDirective (
+  el,
+  name,
+  rawName,
+  value,
+  arg,
+  modifiers
+) {
+  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
+}
+
+function addHandler (
+  el,
+  name,
+  value,
+  modifiers,
+  important
+) {
+  // check capture modifier
+  if (modifiers && modifiers.capture) {
+    delete modifiers.capture;
+    name = '!' + name; // mark the event as captured
+  }
+  if (modifiers && modifiers.once) {
+    delete modifiers.once;
+    name = '~' + name; // mark the event as once
+  }
+  var events;
+  if (modifiers && modifiers.native) {
+    delete modifiers.native;
+    events = el.nativeEvents || (el.nativeEvents = {});
+  } else {
+    events = el.events || (el.events = {});
+  }
+  var newHandler = { value: value, modifiers: modifiers };
+  var handlers = events[name];
+  /* istanbul ignore if */
+  if (Array.isArray(handlers)) {
+    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
+  } else if (handlers) {
+    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
+  } else {
+    events[name] = newHandler;
+  }
+}
+
+function getBindingAttr (
+  el,
+  name,
+  getStatic
+) {
+  var dynamicValue =
+    getAndRemoveAttr(el, ':' + name) ||
+    getAndRemoveAttr(el, 'v-bind:' + name);
+  if (dynamicValue != null) {
+    return parseFilters(dynamicValue)
+  } else if (getStatic !== false) {
+    var staticValue = getAndRemoveAttr(el, name);
+    if (staticValue != null) {
+      return JSON.stringify(staticValue)
+    }
+  }
+}
+
+function getAndRemoveAttr (el, name) {
+  var val;
+  if ((val = el.attrsMap[name]) != null) {
+    var list = el.attrsList;
+    for (var i = 0, l = list.length; i < l; i++) {
+      if (list[i].name === name) {
+        list.splice(i, 1);
+        break
+      }
+    }
+  }
+  return val
+}
+
+/*  */
+
+/**
+ * Cross-platform code generation for component v-model
+ */
+function genComponentModel (
+  el,
+  value,
+  modifiers
+) {
+  var ref = modifiers || {};
+  var number = ref.number;
+  var trim = ref.trim;
+
+  var baseValueExpression = '$$v';
+  var valueExpression = baseValueExpression;
+  if (trim) {
+    valueExpression =
+      "(typeof " + baseValueExpression + " === 'string'" +
+        "? " + baseValueExpression + ".trim()" +
+        ": " + baseValueExpression + ")";
+  }
+  if (number) {
+    valueExpression = "_n(" + valueExpression + ")";
+  }
+  var assignment = genAssignmentCode(value, valueExpression);
+
+  el.model = {
+    value: ("(" + value + ")"),
+    expression: ("\"" + value + "\""),
+    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
+  };
+}
+
+/**
+ * Cross-platform codegen helper for generating v-model value assignment code.
+ */
+function genAssignmentCode (
+  value,
+  assignment
+) {
+  var modelRs = parseModel(value);
+  if (modelRs.idx === null) {
+    return (value + "=" + assignment)
+  } else {
+    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
+      "if (!Array.isArray($$exp)){" +
+        value + "=" + assignment + "}" +
+      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
+  }
+}
+
+/**
+ * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
+ *
+ * for loop possible cases:
+ *
+ * - test
+ * - test[idx]
+ * - test[test1[idx]]
+ * - test["a"][idx]
+ * - xxx.test[a[a].test1[idx]]
+ * - test.xxx.a["asa"][test1[idx]]
+ *
+ */
+
+var len;
+var str;
+var chr;
+var index$1;
+var expressionPos;
+var expressionEndPos;
+
+function parseModel (val) {
+  str = val;
+  len = str.length;
+  index$1 = expressionPos = expressionEndPos = 0;
+
+  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
+    return {
+      exp: val,
+      idx: null
+    }
+  }
+
+  while (!eof()) {
+    chr = next();
+    /* istanbul ignore if */
+    if (isStringStart(chr)) {
+      parseString(chr);
+    } else if (chr === 0x5B) {
+      parseBracket(chr);
+    }
+  }
+
+  return {
+    exp: val.substring(0, expressionPos),
+    idx: val.substring(expressionPos + 1, expressionEndPos)
+  }
+}
+
+function next () {
+  return str.charCodeAt(++index$1)
+}
+
+function eof () {
+  return index$1 >= len
+}
+
+function isStringStart (chr) {
+  return chr === 0x22 || chr === 0x27
+}
+
+function parseBracket (chr) {
+  var inBracket = 1;
+  expressionPos = index$1;
+  while (!eof()) {
+    chr = next();
+    if (isStringStart(chr)) {
+      parseString(chr);
+      continue
+    }
+    if (chr === 0x5B) { inBracket++; }
+    if (chr === 0x5D) { inBracket--; }
+    if (inBracket === 0) {
+      expressionEndPos = index$1;
+      break
+    }
+  }
+}
+
+function parseString (chr) {
+  var stringQuote = chr;
+  while (!eof()) {
+    chr = next();
+    if (chr === stringQuote) {
+      break
+    }
+  }
+}
+
+/*  */
+
+var warn$1;
+
+// in some cases, the event used has to be determined at runtime
+// so we used some reserved tokens during compile.
+var RANGE_TOKEN = '__r';
+var CHECKBOX_RADIO_TOKEN = '__c';
+
+function model (
+  el,
+  dir,
+  _warn
+) {
+  warn$1 = _warn;
+  var value = dir.value;
+  var modifiers = dir.modifiers;
+  var tag = el.tag;
+  var type = el.attrsMap.type;
+
+  if (process.env.NODE_ENV !== 'production') {
+    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
+    if (tag === 'input' && dynamicType) {
+      warn$1(
+        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
+        "v-model does not support dynamic input types. Use v-if branches instead."
+      );
+    }
+    // inputs with type="file" are read only and setting the input's
+    // value will throw an error.
+    if (tag === 'input' && type === 'file') {
+      warn$1(
+        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
+        "File inputs are read only. Use a v-on:change listener instead."
+      );
+    }
+  }
+
+  if (tag === 'select') {
+    genSelect(el, value, modifiers);
+  } else if (tag === 'input' && type === 'checkbox') {
+    genCheckboxModel(el, value, modifiers);
+  } else if (tag === 'input' && type === 'radio') {
+    genRadioModel(el, value, modifiers);
+  } else if (tag === 'input' || tag === 'textarea') {
+    genDefaultModel(el, value, modifiers);
+  } else if (!config.isReservedTag(tag)) {
+    genComponentModel(el, value, modifiers);
+    // component v-model doesn't need extra runtime
+    return false
+  } else if (process.env.NODE_ENV !== 'production') {
+    warn$1(
+      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
+      "v-model is not supported on this element type. " +
+      'If you are working with contenteditable, it\'s recommended to ' +
+      'wrap a library dedicated for that purpose inside a custom component.'
+    );
+  }
+
+  // ensure runtime directive metadata
+  return true
+}
+
+function genCheckboxModel (
+  el,
+  value,
+  modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var valueBinding = getBindingAttr(el, 'value') || 'null';
+  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
+  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
+  addProp(el, 'checked',
+    "Array.isArray(" + value + ")" +
+      "?_i(" + value + "," + valueBinding + ")>-1" + (
+        trueValueBinding === 'true'
+          ? (":(" + value + ")")
+          : (":_q(" + value + "," + trueValueBinding + ")")
+      )
+  );
+  addHandler(el, CHECKBOX_RADIO_TOKEN,
+    "var $$a=" + value + "," +
+        '$$el=$event.target,' +
+        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
+    'if(Array.isArray($$a)){' +
+      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
+          '$$i=_i($$a,$$v);' +
+      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
+      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
+    "}else{" + value + "=$$c}",
+    null, true
+  );
+}
+
+function genRadioModel (
+    el,
+    value,
+    modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var valueBinding = getBindingAttr(el, 'value') || 'null';
+  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
+  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
+  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
+}
+
+function genSelect (
+    el,
+    value,
+    modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var selectedVal = "Array.prototype.filter" +
+    ".call($event.target.options,function(o){return o.selected})" +
+    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
+    "return " + (number ? '_n(val)' : 'val') + "})";
+
+  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
+  var code = "var $$selectedVal = " + selectedVal + ";";
+  code = code + " " + (genAssignmentCode(value, assignment));
+  addHandler(el, 'change', code, null, true);
+}
+
+function genDefaultModel (
+  el,
+  value,
+  modifiers
+) {
+  var type = el.attrsMap.type;
+  var ref = modifiers || {};
+  var lazy = ref.lazy;
+  var number = ref.number;
+  var trim = ref.trim;
+  var needCompositionGuard = !lazy && type !== 'range';
+  var event = lazy
+    ? 'change'
+    : type === 'range'
+      ? RANGE_TOKEN
+      : 'input';
+
+  var valueExpression = '$event.target.value';
+  if (trim) {
+    valueExpression = "$event.target.value.trim()";
+  }
+  if (number) {
+    valueExpression = "_n(" + valueExpression + ")";
+  }
+
+  var code = genAssignmentCode(value, valueExpression);
+  if (needCompositionGuard) {
+    code = "if($event.target.composing)return;" + code;
+  }
+
+  addProp(el, 'value', ("(" + value + ")"));
+  addHandler(el, event, code, null, true);
+  if (trim || number || type === 'number') {
+    addHandler(el, 'blur', '$forceUpdate()');
+  }
+}
+
+/*  */
+
+// normalize v-model event tokens that can only be determined at runtime.
+// it's important to place the event as the first in the array because
+// the whole point is ensuring the v-model callback gets called before
+// user-attached handlers.
+function normalizeEvents (on) {
+  var event;
+  /* istanbul ignore if */
+  if (on[RANGE_TOKEN]) {
+    // IE input[type=range] only supports `change` event
+    event = isIE ? 'change' : 'input';
+    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
+    delete on[RANGE_TOKEN];
+  }
+  if (on[CHECKBOX_RADIO_TOKEN]) {
+    // Chrome fires microtasks in between click/change, leads to #4521
+    event = isChrome ? 'click' : 'change';
+    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
+    delete on[CHECKBOX_RADIO_TOKEN];
+  }
+}
+
+var target$1;
+
+function add$1 (
+  event,
+  handler,
+  once,
+  capture
+) {
+  if (once) {
+    var oldHandler = handler;
+    var _target = target$1; // save current target element in closure
+    handler = function (ev) {
+      var res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments);
+      if (res !== null) {
+        remove$2(event, handler, capture, _target);
+      }
+    };
+  }
+  target$1.addEventListener(event, handler, capture);
+}
+
+function remove$2 (
+  event,
+  handler,
+  capture,
+  _target
+) {
+  (_target || target$1).removeEventListener(event, handler, capture);
+}
+
+function updateDOMListeners (oldVnode, vnode) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  var on = vnode.data.on || {};
+  var oldOn = oldVnode.data.on || {};
+  target$1 = vnode.elm;
+  normalizeEvents(on);
+  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
+}
+
+var events = {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+};
+
+/*  */
+
+function updateDOMProps (oldVnode, vnode) {
+  if (!oldVnode.data.domProps && !vnode.data.domProps) {
+    return
+  }
+  var key, cur;
+  var elm = vnode.elm;
+  var oldProps = oldVnode.data.domProps || {};
+  var props = vnode.data.domProps || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (props.__ob__) {
+    props = vnode.data.domProps = extend({}, props);
+  }
+
+  for (key in oldProps) {
+    if (props[key] == null) {
+      elm[key] = '';
+    }
+  }
+  for (key in props) {
+    cur = props[key];
+    // ignore children if the node has textContent or innerHTML,
+    // as these will throw away existing DOM nodes and cause removal errors
+    // on subsequent patches (#3360)
+    if (key === 'textContent' || key === 'innerHTML') {
+      if (vnode.children) { vnode.children.length = 0; }
+      if (cur === oldProps[key]) { continue }
+    }
+
+    if (key === 'value') {
+      // store value as _value as well since
+      // non-string values will be stringified
+      elm._value = cur;
+      // avoid resetting cursor position when value is the same
+      var strCur = cur == null ? '' : String(cur);
+      if (shouldUpdateValue(elm, vnode, strCur)) {
+        elm.value = strCur;
+      }
+    } else {
+      elm[key] = cur;
+    }
+  }
+}
+
+// check platforms/web/util/attrs.js acceptValue
+
+
+function shouldUpdateValue (
+  elm,
+  vnode,
+  checkVal
+) {
+  return (!elm.composing && (
+    vnode.tag === 'option' ||
+    isDirty(elm, checkVal) ||
+    isInputChanged(elm, checkVal)
+  ))
+}
+
+function isDirty (elm, checkVal) {
+  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
+  return document.activeElement !== elm && elm.value !== checkVal
+}
+
+function isInputChanged (elm, newVal) {
+  var value = elm.value;
+  var modifiers = elm._vModifiers; // injected by v-model runtime
+  if ((modifiers && modifiers.number) || elm.type === 'number') {
+    return toNumber(value) !== toNumber(newVal)
+  }
+  if (modifiers && modifiers.trim) {
+    return value.trim() !== newVal.trim()
+  }
+  return value !== newVal
+}
+
+var domProps = {
+  create: updateDOMProps,
+  update: updateDOMProps
+};
+
+/*  */
+
+var parseStyleText = cached(function (cssText) {
+  var res = {};
+  var listDelimiter = /;(?![^(]*\))/g;
+  var propertyDelimiter = /:(.+)/;
+  cssText.split(listDelimiter).forEach(function (item) {
+    if (item) {
+      var tmp = item.split(propertyDelimiter);
+      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
+    }
+  });
+  return res
+});
+
+// merge static and dynamic style data on the same vnode
+function normalizeStyleData (data) {
+  var style = normalizeStyleBinding(data.style);
+  // static style is pre-processed into an object during compilation
+  // and is always a fresh object, so it's safe to merge into it
+  return data.staticStyle
+    ? extend(data.staticStyle, style)
+    : style
+}
+
+// normalize possible array / string values into Object
+function normalizeStyleBinding (bindingStyle) {
+  if (Array.isArray(bindingStyle)) {
+    return toObject(bindingStyle)
+  }
+  if (typeof bindingStyle === 'string') {
+    return parseStyleText(bindingStyle)
+  }
+  return bindingStyle
+}
+
+/**
+ * parent component style should be after child's
+ * so that parent component's style could override it
+ */
+function getStyle (vnode, checkChild) {
+  var res = {};
+  var styleData;
+
+  if (checkChild) {
+    var childNode = vnode;
+    while (childNode.componentInstance) {
+      childNode = childNode.componentInstance._vnode;
+      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
+        extend(res, styleData);
+      }
+    }
+  }
+
+  if ((styleData = normalizeStyleData(vnode.data))) {
+    extend(res, styleData);
+  }
+
+  var parentNode = vnode;
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
+      extend(res, styleData);
+    }
+  }
+  return res
+}
+
+/*  */
+
+var cssVarRE = /^--/;
+var importantRE = /\s*!important$/;
+var setProp = function (el, name, val) {
+  /* istanbul ignore if */
+  if (cssVarRE.test(name)) {
+    el.style.setProperty(name, val);
+  } else if (importantRE.test(val)) {
+    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
+  } else {
+    el.style[normalize(name)] = val;
+  }
+};
+
+var prefixes = ['Webkit', 'Moz', 'ms'];
+
+var testEl;
+var normalize = cached(function (prop) {
+  testEl = testEl || document.createElement('div');
+  prop = camelize(prop);
+  if (prop !== 'filter' && (prop in testEl.style)) {
+    return prop
+  }
+  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
+  for (var i = 0; i < prefixes.length; i++) {
+    var prefixed = prefixes[i] + upper;
+    if (prefixed in testEl.style) {
+      return prefixed
+    }
+  }
+});
+
+function updateStyle (oldVnode, vnode) {
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+
+  if (!data.staticStyle && !data.style &&
+      !oldData.staticStyle && !oldData.style) {
+    return
+  }
+
+  var cur, name;
+  var el = vnode.elm;
+  var oldStaticStyle = oldVnode.data.staticStyle;
+  var oldStyleBinding = oldVnode.data.style || {};
+
+  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
+  var oldStyle = oldStaticStyle || oldStyleBinding;
+
+  var style = normalizeStyleBinding(vnode.data.style) || {};
+
+  vnode.data.style = style.__ob__ ? extend({}, style) : style;
+
+  var newStyle = getStyle(vnode, true);
+
+  for (name in oldStyle) {
+    if (newStyle[name] == null) {
+      setProp(el, name, '');
+    }
+  }
+  for (name in newStyle) {
+    cur = newStyle[name];
+    if (cur !== oldStyle[name]) {
+      // ie9 setting to null has no effect, must use empty string
+      setProp(el, name, cur == null ? '' : cur);
+    }
+  }
+}
+
+var style = {
+  create: updateStyle,
+  update: updateStyle
+};
+
+/*  */
+
+/**
+ * Add class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function addClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
+    } else {
+      el.classList.add(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    if (cur.indexOf(' ' + cls + ' ') < 0) {
+      el.setAttribute('class', (cur + cls).trim());
+    }
+  }
+}
+
+/**
+ * Remove class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function removeClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
+    } else {
+      el.classList.remove(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    var tar = ' ' + cls + ' ';
+    while (cur.indexOf(tar) >= 0) {
+      cur = cur.replace(tar, ' ');
+    }
+    el.setAttribute('class', cur.trim());
+  }
+}
+
+/*  */
+
+function resolveTransition (def$$1) {
+  if (!def$$1) {
+    return
+  }
+  /* istanbul ignore else */
+  if (typeof def$$1 === 'object') {
+    var res = {};
+    if (def$$1.css !== false) {
+      extend(res, autoCssTransition(def$$1.name || 'v'));
+    }
+    extend(res, def$$1);
+    return res
+  } else if (typeof def$$1 === 'string') {
+    return autoCssTransition(def$$1)
+  }
+}
+
+var autoCssTransition = cached(function (name) {
+  return {
+    enterClass: (name + "-enter"),
+    enterToClass: (name + "-enter-to"),
+    enterActiveClass: (name + "-enter-active"),
+    leaveClass: (name + "-leave"),
+    leaveToClass: (name + "-leave-to"),
+    leaveActiveClass: (name + "-leave-active")
+  }
+});
+
+var hasTransition = inBrowser && !isIE9;
+var TRANSITION = 'transition';
+var ANIMATION = 'animation';
+
+// Transition property/event sniffing
+var transitionProp = 'transition';
+var transitionEndEvent = 'transitionend';
+var animationProp = 'animation';
+var animationEndEvent = 'animationend';
+if (hasTransition) {
+  /* istanbul ignore if */
+  if (window.ontransitionend === undefined &&
+    window.onwebkittransitionend !== undefined) {
+    transitionProp = 'WebkitTransition';
+    transitionEndEvent = 'webkitTransitionEnd';
+  }
+  if (window.onanimationend === undefined &&
+    window.onwebkitanimationend !== undefined) {
+    animationProp = 'WebkitAnimation';
+    animationEndEvent = 'webkitAnimationEnd';
+  }
+}
+
+// binding to window is necessary to make hot reload work in IE in strict mode
+var raf = inBrowser && window.requestAnimationFrame
+  ? window.requestAnimationFrame.bind(window)
+  : setTimeout;
+
+function nextFrame (fn) {
+  raf(function () {
+    raf(fn);
+  });
+}
+
+function addTransitionClass (el, cls) {
+  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
+  addClass(el, cls);
+}
+
+function removeTransitionClass (el, cls) {
+  if (el._transitionClasses) {
+    remove(el._transitionClasses, cls);
+  }
+  removeClass(el, cls);
+}
+
+function whenTransitionEnds (
+  el,
+  expectedType,
+  cb
+) {
+  var ref = getTransitionInfo(el, expectedType);
+  var type = ref.type;
+  var timeout = ref.timeout;
+  var propCount = ref.propCount;
+  if (!type) { return cb() }
+  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
+  var ended = 0;
+  var end = function () {
+    el.removeEventListener(event, onEnd);
+    cb();
+  };
+  var onEnd = function (e) {
+    if (e.target === el) {
+      if (++ended >= propCount) {
+        end();
+      }
+    }
+  };
+  setTimeout(function () {
+    if (ended < propCount) {
+      end();
+    }
+  }, timeout + 1);
+  el.addEventListener(event, onEnd);
+}
+
+var transformRE = /\b(transform|all)(,|$)/;
+
+function getTransitionInfo (el, expectedType) {
+  var styles = window.getComputedStyle(el);
+  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
+  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
+  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
+  var animationDelays = styles[animationProp + 'Delay'].split(', ');
+  var animationDurations = styles[animationProp + 'Duration'].split(', ');
+  var animationTimeout = getTimeout(animationDelays, animationDurations);
+
+  var type;
+  var timeout = 0;
+  var propCount = 0;
+  /* istanbul ignore if */
+  if (expectedType === TRANSITION) {
+    if (transitionTimeout > 0) {
+      type = TRANSITION;
+      timeout = transitionTimeout;
+      propCount = transitionDurations.length;
+    }
+  } else if (expectedType === ANIMATION) {
+    if (animationTimeout > 0) {
+      type = ANIMATION;
+      timeout = animationTimeout;
+      propCount = animationDurations.length;
+    }
+  } else {
+    timeout = Math.max(transitionTimeout, animationTimeout);
+    type = timeout > 0
+      ? transitionTimeout > animationTimeout
+        ? TRANSITION
+        : ANIMATION
+      : null;
+    propCount = type
+      ? type === TRANSITION
+        ? transitionDurations.length
+        : animationDurations.length
+      : 0;
+  }
+  var hasTransform =
+    type === TRANSITION &&
+    transformRE.test(styles[transitionProp + 'Property']);
+  return {
+    type: type,
+    timeout: timeout,
+    propCount: propCount,
+    hasTransform: hasTransform
+  }
+}
+
+function getTimeout (delays, durations) {
+  /* istanbul ignore next */
+  while (delays.length < durations.length) {
+    delays = delays.concat(delays);
+  }
+
+  return Math.max.apply(null, durations.map(function (d, i) {
+    return toMs(d) + toMs(delays[i])
+  }))
+}
+
+function toMs (s) {
+  return Number(s.slice(0, -1)) * 1000
+}
+
+/*  */
+
+function enter (vnode, toggleDisplay) {
+  var el = vnode.elm;
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true;
+    el._leaveCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var enterClass = data.enterClass;
+  var enterToClass = data.enterToClass;
+  var enterActiveClass = data.enterActiveClass;
+  var appearClass = data.appearClass;
+  var appearToClass = data.appearToClass;
+  var appearActiveClass = data.appearActiveClass;
+  var beforeEnter = data.beforeEnter;
+  var enter = data.enter;
+  var afterEnter = data.afterEnter;
+  var enterCancelled = data.enterCancelled;
+  var beforeAppear = data.beforeAppear;
+  var appear = data.appear;
+  var afterAppear = data.afterAppear;
+  var appearCancelled = data.appearCancelled;
+  var duration = data.duration;
+
+  // activeInstance will always be the <transition> component managing this
+  // transition. One edge case to check is when the <transition> is placed
+  // as the root node of a child component. In that case we need to check
+  // <transition>'s parent for appear check.
+  var context = activeInstance;
+  var transitionNode = activeInstance.$vnode;
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent;
+    context = transitionNode.context;
+  }
+
+  var isAppear = !context._isMounted || !vnode.isRootInsert;
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  var startClass = isAppear && appearClass
+    ? appearClass
+    : enterClass;
+  var activeClass = isAppear && appearActiveClass
+    ? appearActiveClass
+    : enterActiveClass;
+  var toClass = isAppear && appearToClass
+    ? appearToClass
+    : enterToClass;
+
+  var beforeEnterHook = isAppear
+    ? (beforeAppear || beforeEnter)
+    : beforeEnter;
+  var enterHook = isAppear
+    ? (typeof appear === 'function' ? appear : enter)
+    : enter;
+  var afterEnterHook = isAppear
+    ? (afterAppear || afterEnter)
+    : afterEnter;
+  var enterCancelledHook = isAppear
+    ? (appearCancelled || enterCancelled)
+    : enterCancelled;
+
+  var explicitEnterDuration = toNumber(
+    isObject(duration)
+      ? duration.enter
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
+    checkDuration(explicitEnterDuration, 'enter', vnode);
+  }
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(enterHook);
+
+  var cb = el._enterCb = once(function () {
+    if (expectsCSS) {
+      removeTransitionClass(el, toClass);
+      removeTransitionClass(el, activeClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, startClass);
+      }
+      enterCancelledHook && enterCancelledHook(el);
+    } else {
+      afterEnterHook && afterEnterHook(el);
+    }
+    el._enterCb = null;
+  });
+
+  if (!vnode.data.show) {
+    // remove pending leave element on enter by injecting an insert hook
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
+      var parent = el.parentNode;
+      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
+      if (pendingNode &&
+          pendingNode.tag === vnode.tag &&
+          pendingNode.elm._leaveCb) {
+        pendingNode.elm._leaveCb();
+      }
+      enterHook && enterHook(el, cb);
+    });
+  }
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el);
+  if (expectsCSS) {
+    addTransitionClass(el, startClass);
+    addTransitionClass(el, activeClass);
+    nextFrame(function () {
+      addTransitionClass(el, toClass);
+      removeTransitionClass(el, startClass);
+      if (!cb.cancelled && !userWantsControl) {
+        if (isValidDuration(explicitEnterDuration)) {
+          setTimeout(cb, explicitEnterDuration);
+        } else {
+          whenTransitionEnds(el, type, cb);
+        }
+      }
+    });
+  }
+
+  if (vnode.data.show) {
+    toggleDisplay && toggleDisplay();
+    enterHook && enterHook(el, cb);
+  }
+
+  if (!expectsCSS && !userWantsControl) {
+    cb();
+  }
+}
+
+function leave (vnode, rm) {
+  var el = vnode.elm;
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true;
+    el._enterCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return rm()
+  }
+
+  /* istanbul ignore if */
+  if (el._leaveCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var leaveClass = data.leaveClass;
+  var leaveToClass = data.leaveToClass;
+  var leaveActiveClass = data.leaveActiveClass;
+  var beforeLeave = data.beforeLeave;
+  var leave = data.leave;
+  var afterLeave = data.afterLeave;
+  var leaveCancelled = data.leaveCancelled;
+  var delayLeave = data.delayLeave;
+  var duration = data.duration;
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(leave);
+
+  var explicitLeaveDuration = toNumber(
+    isObject(duration)
+      ? duration.leave
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
+    checkDuration(explicitLeaveDuration, 'leave', vnode);
+  }
+
+  var cb = el._leaveCb = once(function () {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null;
+    }
+    if (expectsCSS) {
+      removeTransitionClass(el, leaveToClass);
+      removeTransitionClass(el, leaveActiveClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, leaveClass);
+      }
+      leaveCancelled && leaveCancelled(el);
+    } else {
+      rm();
+      afterLeave && afterLeave(el);
+    }
+    el._leaveCb = null;
+  });
+
+  if (delayLeave) {
+    delayLeave(performLeave);
+  } else {
+    performLeave();
+  }
+
+  function performLeave () {
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
+    }
+    beforeLeave && beforeLeave(el);
+    if (expectsCSS) {
+      addTransitionClass(el, leaveClass);
+      addTransitionClass(el, leaveActiveClass);
+      nextFrame(function () {
+        addTransitionClass(el, leaveToClass);
+        removeTransitionClass(el, leaveClass);
+        if (!cb.cancelled && !userWantsControl) {
+          if (isValidDuration(explicitLeaveDuration)) {
+            setTimeout(cb, explicitLeaveDuration);
+          } else {
+            whenTransitionEnds(el, type, cb);
+          }
+        }
+      });
+    }
+    leave && leave(el, cb);
+    if (!expectsCSS && !userWantsControl) {
+      cb();
+    }
+  }
+}
+
+// only used in dev mode
+function checkDuration (val, name, vnode) {
+  if (typeof val !== 'number') {
+    warn(
+      "<transition> explicit " + name + " duration is not a valid number - " +
+      "got " + (JSON.stringify(val)) + ".",
+      vnode.context
+    );
+  } else if (isNaN(val)) {
+    warn(
+      "<transition> explicit " + name + " duration is NaN - " +
+      'the duration expression might be incorrect.',
+      vnode.context
+    );
+  }
+}
+
+function isValidDuration (val) {
+  return typeof val === 'number' && !isNaN(val)
+}
+
+/**
+ * Normalize a transition hook's argument length. The hook may be:
+ * - a merged hook (invoker) with the original in .fns
+ * - a wrapped component method (check ._length)
+ * - a plain function (.length)
+ */
+function getHookArgumentsLength (fn) {
+  if (!fn) { return false }
+  var invokerFns = fn.fns;
+  if (invokerFns) {
+    // invoker
+    return getHookArgumentsLength(
+      Array.isArray(invokerFns)
+        ? invokerFns[0]
+        : invokerFns
+    )
+  } else {
+    return (fn._length || fn.length) > 1
+  }
+}
+
+function _enter (_, vnode) {
+  if (!vnode.data.show) {
+    enter(vnode);
+  }
+}
+
+var transition = inBrowser ? {
+  create: _enter,
+  activate: _enter,
+  remove: function remove$$1 (vnode, rm) {
+    /* istanbul ignore else */
+    if (!vnode.data.show) {
+      leave(vnode, rm);
+    } else {
+      rm();
+    }
+  }
+} : {};
+
+var platformModules = [
+  attrs,
+  klass,
+  events,
+  domProps,
+  style,
+  transition
+];
+
+/*  */
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+var modules = platformModules.concat(baseModules);
+
+var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
+
+/**
+ * Not type checking this file because flow doesn't like attaching
+ * properties to Elements.
+ */
+
+/* istanbul ignore if */
+if (isIE9) {
+  // http://www.matts411.com/post/internet-explorer-9-oninput/
+  document.addEventListener('selectionchange', function () {
+    var el = document.activeElement;
+    if (el && el.vmodel) {
+      trigger(el, 'input');
+    }
+  });
+}
+
+var model$1 = {
+  inserted: function inserted (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      var cb = function () {
+        setSelected(el, binding, vnode.context);
+      };
+      cb();
+      /* istanbul ignore if */
+      if (isIE || isEdge) {
+        setTimeout(cb, 0);
+      }
+    } else if (vnode.tag === 'textarea' || el.type === 'text') {
+      el._vModifiers = binding.modifiers;
+      if (!binding.modifiers.lazy) {
+        if (!isAndroid) {
+          el.addEventListener('compositionstart', onCompositionStart);
+          el.addEventListener('compositionend', onCompositionEnd);
+        }
+        /* istanbul ignore if */
+        if (isIE9) {
+          el.vmodel = true;
+        }
+      }
+    }
+  },
+  componentUpdated: function componentUpdated (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      setSelected(el, binding, vnode.context);
+      // in case the options rendered by v-for have changed,
+      // it's possible that the value is out-of-sync with the rendered options.
+      // detect such cases and filter out values that no longer has a matching
+      // option in the DOM.
+      var needReset = el.multiple
+        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
+        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
+      if (needReset) {
+        trigger(el, 'change');
+      }
+    }
+  }
+};
+
+function setSelected (el, binding, vm) {
+  var value = binding.value;
+  var isMultiple = el.multiple;
+  if (isMultiple && !Array.isArray(value)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
+      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
+      vm
+    );
+    return
+  }
+  var selected, option;
+  for (var i = 0, l = el.options.length; i < l; i++) {
+    option = el.options[i];
+    if (isMultiple) {
+      selected = looseIndexOf(value, getValue(option)) > -1;
+      if (option.selected !== selected) {
+        option.selected = selected;
+      }
+    } else {
+      if (looseEqual(getValue(option), value)) {
+        if (el.selectedIndex !== i) {
+          el.selectedIndex = i;
+        }
+        return
+      }
+    }
+  }
+  if (!isMultiple) {
+    el.selectedIndex = -1;
+  }
+}
+
+function hasNoMatchingOption (value, options) {
+  for (var i = 0, l = options.length; i < l; i++) {
+    if (looseEqual(getValue(options[i]), value)) {
+      return false
+    }
+  }
+  return true
+}
+
+function getValue (option) {
+  return '_value' in option
+    ? option._value
+    : option.value
+}
+
+function onCompositionStart (e) {
+  e.target.composing = true;
+}
+
+function onCompositionEnd (e) {
+  e.target.composing = false;
+  trigger(e.target, 'input');
+}
+
+function trigger (el, type) {
+  var e = document.createEvent('HTMLEvents');
+  e.initEvent(type, true, true);
+  el.dispatchEvent(e);
+}
+
+/*  */
+
+// recursively search for possible transition defined inside the component root
+function locateNode (vnode) {
+  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
+    ? locateNode(vnode.componentInstance._vnode)
+    : vnode
+}
+
+var show = {
+  bind: function bind (el, ref, vnode) {
+    var value = ref.value;
+
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    var originalDisplay = el.__vOriginalDisplay =
+      el.style.display === 'none' ? '' : el.style.display;
+    if (value && transition && !isIE9) {
+      vnode.data.show = true;
+      enter(vnode, function () {
+        el.style.display = originalDisplay;
+      });
+    } else {
+      el.style.display = value ? originalDisplay : 'none';
+    }
+  },
+
+  update: function update (el, ref, vnode) {
+    var value = ref.value;
+    var oldValue = ref.oldValue;
+
+    /* istanbul ignore if */
+    if (value === oldValue) { return }
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    if (transition && !isIE9) {
+      vnode.data.show = true;
+      if (value) {
+        enter(vnode, function () {
+          el.style.display = el.__vOriginalDisplay;
+        });
+      } else {
+        leave(vnode, function () {
+          el.style.display = 'none';
+        });
+      }
+    } else {
+      el.style.display = value ? el.__vOriginalDisplay : 'none';
+    }
+  },
+
+  unbind: function unbind (
+    el,
+    binding,
+    vnode,
+    oldVnode,
+    isDestroy
+  ) {
+    if (!isDestroy) {
+      el.style.display = el.__vOriginalDisplay;
+    }
+  }
+};
+
+var platformDirectives = {
+  model: model$1,
+  show: show
+};
+
+/*  */
+
+// Provides transition support for a single element/component.
+// supports transition mode (out-in / in-out)
+
+var transitionProps = {
+  name: String,
+  appear: Boolean,
+  css: Boolean,
+  mode: String,
+  type: String,
+  enterClass: String,
+  leaveClass: String,
+  enterToClass: String,
+  leaveToClass: String,
+  enterActiveClass: String,
+  leaveActiveClass: String,
+  appearClass: String,
+  appearActiveClass: String,
+  appearToClass: String,
+  duration: [Number, String, Object]
+};
+
+// in case the child is also an abstract component, e.g. <keep-alive>
+// we want to recursively retrieve the real component to be rendered
+function getRealChild (vnode) {
+  var compOptions = vnode && vnode.componentOptions;
+  if (compOptions && compOptions.Ctor.options.abstract) {
+    return getRealChild(getFirstComponentChild(compOptions.children))
+  } else {
+    return vnode
+  }
+}
+
+function extractTransitionData (comp) {
+  var data = {};
+  var options = comp.$options;
+  // props
+  for (var key in options.propsData) {
+    data[key] = comp[key];
+  }
+  // events.
+  // extract listeners and pass them directly to the transition methods
+  var listeners = options._parentListeners;
+  for (var key$1 in listeners) {
+    data[camelize(key$1)] = listeners[key$1];
+  }
+  return data
+}
+
+function placeholder (h, rawChild) {
+  return /\d-keep-alive$/.test(rawChild.tag)
+    ? h('keep-alive')
+    : null
+}
+
+function hasParentTransition (vnode) {
+  while ((vnode = vnode.parent)) {
+    if (vnode.data.transition) {
+      return true
+    }
+  }
+}
+
+function isSameChild (child, oldChild) {
+  return oldChild.key === child.key && oldChild.tag === child.tag
+}
+
+var Transition = {
+  name: 'transition',
+  props: transitionProps,
+  abstract: true,
+
+  render: function render (h) {
+    var this$1 = this;
+
+    var children = this.$slots.default;
+    if (!children) {
+      return
+    }
+
+    // filter out text nodes (possible whitespaces)
+    children = children.filter(function (c) { return c.tag; });
+    /* istanbul ignore if */
+    if (!children.length) {
+      return
+    }
+
+    // warn multiple elements
+    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
+      warn(
+        '<transition> can only be used on a single element. Use ' +
+        '<transition-group> for lists.',
+        this.$parent
+      );
+    }
+
+    var mode = this.mode;
+
+    // warn invalid mode
+    if (process.env.NODE_ENV !== 'production' &&
+        mode && mode !== 'in-out' && mode !== 'out-in') {
+      warn(
+        'invalid <transition> mode: ' + mode,
+        this.$parent
+      );
+    }
+
+    var rawChild = children[0];
+
+    // if this is a component root node and the component's
+    // parent container node also has transition, skip.
+    if (hasParentTransition(this.$vnode)) {
+      return rawChild
+    }
+
+    // apply transition data to child
+    // use getRealChild() to ignore abstract components e.g. keep-alive
+    var child = getRealChild(rawChild);
+    /* istanbul ignore if */
+    if (!child) {
+      return rawChild
+    }
+
+    if (this._leaving) {
+      return placeholder(h, rawChild)
+    }
+
+    // ensure a key that is unique to the vnode type and to this transition
+    // component instance. This key will be used to remove pending leaving nodes
+    // during entering.
+    var id = "__transition-" + (this._uid) + "-";
+    child.key = child.key == null
+      ? id + child.tag
+      : isPrimitive(child.key)
+        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
+        : child.key;
+
+    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
+    var oldRawChild = this._vnode;
+    var oldChild = getRealChild(oldRawChild);
+
+    // mark v-show
+    // so that the transition module can hand over the control to the directive
+    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
+      child.data.show = true;
+    }
+
+    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
+      // replace old child transition data with fresh one
+      // important for dynamic transitions!
+      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
+      // handle transition mode
+      if (mode === 'out-in') {
+        // return placeholder node and queue update when leave finishes
+        this._leaving = true;
+        mergeVNodeHook(oldData, 'afterLeave', function () {
+          this$1._leaving = false;
+          this$1.$forceUpdate();
+        });
+        return placeholder(h, rawChild)
+      } else if (mode === 'in-out') {
+        var delayedLeave;
+        var performLeave = function () { delayedLeave(); };
+        mergeVNodeHook(data, 'afterEnter', performLeave);
+        mergeVNodeHook(data, 'enterCancelled', performLeave);
+        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
+      }
+    }
+
+    return rawChild
+  }
+};
+
+/*  */
+
+// Provides transition support for list items.
+// supports move transitions using the FLIP technique.
+
+// Because the vdom's children update algorithm is "unstable" - i.e.
+// it doesn't guarantee the relative positioning of removed elements,
+// we force transition-group to update its children into two passes:
+// in the first pass, we remove all nodes that need to be removed,
+// triggering their leaving transition; in the second pass, we insert/move
+// into the final desired state. This way in the second pass removed
+// nodes will remain where they should be.
+
+var props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps);
+
+delete props.mode;
+
+var TransitionGroup = {
+  props: props,
+
+  render: function render (h) {
+    var tag = this.tag || this.$vnode.data.tag || 'span';
+    var map = Object.create(null);
+    var prevChildren = this.prevChildren = this.children;
+    var rawChildren = this.$slots.default || [];
+    var children = this.children = [];
+    var transitionData = extractTransitionData(this);
+
+    for (var i = 0; i < rawChildren.length; i++) {
+      var c = rawChildren[i];
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c);
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData;
+        } else if (process.env.NODE_ENV !== 'production') {
+          var opts = c.componentOptions;
+          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
+          warn(("<transition-group> children must be keyed: <" + name + ">"));
+        }
+      }
+    }
+
+    if (prevChildren) {
+      var kept = [];
+      var removed = [];
+      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
+        var c$1 = prevChildren[i$1];
+        c$1.data.transition = transitionData;
+        c$1.data.pos = c$1.elm.getBoundingClientRect();
+        if (map[c$1.key]) {
+          kept.push(c$1);
+        } else {
+          removed.push(c$1);
+        }
+      }
+      this.kept = h(tag, null, kept);
+      this.removed = removed;
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate: function beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    );
+    this._vnode = this.kept;
+  },
+
+  updated: function updated () {
+    var children = this.prevChildren;
+    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
+    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
+      return
+    }
+
+    // we divide the work into three loops to avoid mixing DOM reads and writes
+    // in each iteration - which helps prevent layout thrashing.
+    children.forEach(callPendingCbs);
+    children.forEach(recordPosition);
+    children.forEach(applyTranslation);
+
+    // force reflow to put everything in position
+    var body = document.body;
+    var f = body.offsetHeight; // eslint-disable-line
+
+    children.forEach(function (c) {
+      if (c.data.moved) {
+        var el = c.elm;
+        var s = el.style;
+        addTransitionClass(el, moveClass);
+        s.transform = s.WebkitTransform = s.transitionDuration = '';
+        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
+          if (!e || /transform$/.test(e.propertyName)) {
+            el.removeEventListener(transitionEndEvent, cb);
+            el._moveCb = null;
+            removeTransitionClass(el, moveClass);
+          }
+        });
+      }
+    });
+  },
+
+  methods: {
+    hasMove: function hasMove (el, moveClass) {
+      /* istanbul ignore if */
+      if (!hasTransition) {
+        return false
+      }
+      if (this._hasMove != null) {
+        return this._hasMove
+      }
+      // Detect whether an element with the move class applied has
+      // CSS transitions. Since the element may be inside an entering
+      // transition at this very moment, we make a clone of it and remove
+      // all other transition classes applied to ensure only the move class
+      // is applied.
+      var clone = el.cloneNode();
+      if (el._transitionClasses) {
+        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
+      }
+      addClass(clone, moveClass);
+      clone.style.display = 'none';
+      this.$el.appendChild(clone);
+      var info = getTransitionInfo(clone);
+      this.$el.removeChild(clone);
+      return (this._hasMove = info.hasTransform)
+    }
+  }
+};
+
+function callPendingCbs (c) {
+  /* istanbul ignore if */
+  if (c.elm._moveCb) {
+    c.elm._moveCb();
+  }
+  /* istanbul ignore if */
+  if (c.elm._enterCb) {
+    c.elm._enterCb();
+  }
+}
+
+function recordPosition (c) {
+  c.data.newPos = c.elm.getBoundingClientRect();
+}
+
+function applyTranslation (c) {
+  var oldPos = c.data.pos;
+  var newPos = c.data.newPos;
+  var dx = oldPos.left - newPos.left;
+  var dy = oldPos.top - newPos.top;
+  if (dx || dy) {
+    c.data.moved = true;
+    var s = c.elm.style;
+    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
+    s.transitionDuration = '0s';
+  }
+}
+
+var platformComponents = {
+  Transition: Transition,
+  TransitionGroup: TransitionGroup
+};
+
+/*  */
+
+// install platform specific utils
+Vue$3.config.mustUseProp = mustUseProp;
+Vue$3.config.isReservedTag = isReservedTag;
+Vue$3.config.getTagNamespace = getTagNamespace;
+Vue$3.config.isUnknownElement = isUnknownElement;
+
+// install platform runtime directives & components
+extend(Vue$3.options.directives, platformDirectives);
+extend(Vue$3.options.components, platformComponents);
+
+// install platform patch function
+Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
+
+// public mount method
+Vue$3.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && inBrowser ? query(el) : undefined;
+  return mountComponent(this, el, hydrating)
+};
+
+// devtools global hook
+/* istanbul ignore next */
+setTimeout(function () {
+  if (config.devtools) {
+    if (devtools) {
+      devtools.emit('init', Vue$3);
+    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
+      console[console.info ? 'info' : 'log'](
+        'Download the Vue Devtools extension for a better development experience:\n' +
+        'https://github.com/vuejs/vue-devtools'
+      );
+    }
+  }
+  if (process.env.NODE_ENV !== 'production' &&
+      config.productionTip !== false &&
+      inBrowser && typeof console !== 'undefined') {
+    console[console.info ? 'info' : 'log'](
+      "You are running Vue in development mode.\n" +
+      "Make sure to turn on production mode when deploying for production.\n" +
+      "See more tips at https://vuejs.org/guide/deployment.html"
+    );
+  }
+}, 0);
+
+/*  */
+
+// check whether current browser encodes a char inside attribute values
+function shouldDecode (content, encoded) {
+  var div = document.createElement('div');
+  div.innerHTML = "<div a=\"" + content + "\">";
+  return div.innerHTML.indexOf(encoded) > 0
+}
+
+// #3663
+// IE encodes newlines inside attribute values while other browsers don't
+var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;
+
+/*  */
+
+var isUnaryTag = makeMap(
+  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
+  'link,meta,param,source,track,wbr'
+);
+
+// Elements that you can, intentionally, leave open
+// (and which close themselves)
+var canBeLeftOpenTag = makeMap(
+  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
+);
+
+// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
+// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
+var isNonPhrasingTag = makeMap(
+  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
+  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
+  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
+  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
+  'title,tr,track'
+);
+
+/*  */
+
+var decoder;
+
+function decode (html) {
+  decoder = decoder || document.createElement('div');
+  decoder.innerHTML = html;
+  return decoder.textContent
+}
+
+/**
+ * Not type-checking this file because it's mostly vendor code.
+ */
+
+/*!
+ * HTML Parser By John Resig (ejohn.org)
+ * Modified by Juriy "kangax" Zaytsev
+ * Original code by Erik Arvidsson, Mozilla Public License
+ * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
+ */
+
+// Regular Expressions for parsing tags and attributes
+var singleAttrIdentifier = /([^\s"'<>/=]+)/;
+var singleAttrAssign = /(?:=)/;
+var singleAttrValues = [
+  // attr value double quotes
+  /"([^"]*)"+/.source,
+  // attr value, single quotes
+  /'([^']*)'+/.source,
+  // attr value, no quotes
+  /([^\s"'=<>`]+)/.source
+];
+var attribute = new RegExp(
+  '^\\s*' + singleAttrIdentifier.source +
+  '(?:\\s*(' + singleAttrAssign.source + ')' +
+  '\\s*(?:' + singleAttrValues.join('|') + '))?'
+);
+
+// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
+// but for Vue templates we can enforce a simple charset
+var ncname = '[a-zA-Z_][\\w\\-\\.]*';
+var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
+var startTagOpen = new RegExp('^<' + qnameCapture);
+var startTagClose = /^\s*(\/?)>/;
+var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
+var doctype = /^<!DOCTYPE [^>]+>/i;
+var comment = /^<!--/;
+var conditionalComment = /^<!\[/;
+
+var IS_REGEX_CAPTURING_BROKEN = false;
+'x'.replace(/x(.)?/g, function (m, g) {
+  IS_REGEX_CAPTURING_BROKEN = g === '';
+});
+
+// Special Elements (can contain anything)
+var isScriptOrStyle = makeMap('script,style', true);
+var reCache = {};
+
+var decodingMap = {
+  '&lt;': '<',
+  '&gt;': '>',
+  '&quot;': '"',
+  '&amp;': '&',
+  '&#10;': '\n'
+};
+var encodedAttr = /&(?:lt|gt|quot|amp);/g;
+var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;
+
+function decodeAttr (value, shouldDecodeNewlines) {
+  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
+  return value.replace(re, function (match) { return decodingMap[match]; })
+}
+
+function parseHTML (html, options) {
+  var stack = [];
+  var expectHTML = options.expectHTML;
+  var isUnaryTag$$1 = options.isUnaryTag || no;
+  var index = 0;
+  var last, lastTag;
+  while (html) {
+    last = html;
+    // Make sure we're not in a script or style element
+    if (!lastTag || !isScriptOrStyle(lastTag)) {
+      var textEnd = html.indexOf('<');
+      if (textEnd === 0) {
+        // Comment:
+        if (comment.test(html)) {
+          var commentEnd = html.indexOf('-->');
+
+          if (commentEnd >= 0) {
+            advance(commentEnd + 3);
+            continue
+          }
+        }
+
+        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
+        if (conditionalComment.test(html)) {
+          var conditionalEnd = html.indexOf(']>');
+
+          if (conditionalEnd >= 0) {
+            advance(conditionalEnd + 2);
+            continue
+          }
+        }
+
+        // Doctype:
+        var doctypeMatch = html.match(doctype);
+        if (doctypeMatch) {
+          advance(doctypeMatch[0].length);
+          continue
+        }
+
+        // End tag:
+        var endTagMatch = html.match(endTag);
+        if (endTagMatch) {
+          var curIndex = index;
+          advance(endTagMatch[0].length);
+          parseEndTag(endTagMatch[1], curIndex, index);
+          continue
+        }
+
+        // Start tag:
+        var startTagMatch = parseStartTag();
+        if (startTagMatch) {
+          handleStartTag(startTagMatch);
+          continue
+        }
+      }
+
+      var text = (void 0), rest$1 = (void 0), next = (void 0);
+      if (textEnd >= 0) {
+        rest$1 = html.slice(textEnd);
+        while (
+          !endTag.test(rest$1) &&
+          !startTagOpen.test(rest$1) &&
+          !comment.test(rest$1) &&
+          !conditionalComment.test(rest$1)
+        ) {
+          // < in plain text, be forgiving and treat it as text
+          next = rest$1.indexOf('<', 1);
+          if (next < 0) { break }
+          textEnd += next;
+          rest$1 = html.slice(textEnd);
+        }
+        text = html.substring(0, textEnd);
+        advance(textEnd);
+      }
+
+      if (textEnd < 0) {
+        text = html;
+        html = '';
+      }
+
+      if (options.chars && text) {
+        options.chars(text);
+      }
+    } else {
+      var stackedTag = lastTag.toLowerCase();
+      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
+      var endTagLength = 0;
+      var rest = html.replace(reStackedTag, function (all, text, endTag) {
+        endTagLength = endTag.length;
+        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
+          text = text
+            .replace(/<!--([\s\S]*?)-->/g, '$1')
+            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
+        }
+        if (options.chars) {
+          options.chars(text);
+        }
+        return ''
+      });
+      index += html.length - rest.length;
+      html = rest;
+      parseEndTag(stackedTag, index - endTagLength, index);
+    }
+
+    if (html === last) {
+      options.chars && options.chars(html);
+      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
+        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
+      }
+      break
+    }
+  }
+
+  // Clean up any remaining tags
+  parseEndTag();
+
+  function advance (n) {
+    index += n;
+    html = html.substring(n);
+  }
+
+  function parseStartTag () {
+    var start = html.match(startTagOpen);
+    if (start) {
+      var match = {
+        tagName: start[1],
+        attrs: [],
+        start: index
+      };
+      advance(start[0].length);
+      var end, attr;
+      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
+        advance(attr[0].length);
+        match.attrs.push(attr);
+      }
+      if (end) {
+        match.unarySlash = end[1];
+        advance(end[0].length);
+        match.end = index;
+        return match
+      }
+    }
+  }
+
+  function handleStartTag (match) {
+    var tagName = match.tagName;
+    var unarySlash = match.unarySlash;
+
+    if (expectHTML) {
+      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
+        parseEndTag(lastTag);
+      }
+      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
+        parseEndTag(tagName);
+      }
+    }
+
+    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;
+
+    var l = match.attrs.length;
+    var attrs = new Array(l);
+    for (var i = 0; i < l; i++) {
+      var args = match.attrs[i];
+      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
+      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
+        if (args[3] === '') { delete args[3]; }
+        if (args[4] === '') { delete args[4]; }
+        if (args[5] === '') { delete args[5]; }
+      }
+      var value = args[3] || args[4] || args[5] || '';
+      attrs[i] = {
+        name: args[1],
+        value: decodeAttr(
+          value,
+          options.shouldDecodeNewlines
+        )
+      };
+    }
+
+    if (!unary) {
+      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
+      lastTag = tagName;
+    }
+
+    if (options.start) {
+      options.start(tagName, attrs, unary, match.start, match.end);
+    }
+  }
+
+  function parseEndTag (tagName, start, end) {
+    var pos, lowerCasedTagName;
+    if (start == null) { start = index; }
+    if (end == null) { end = index; }
+
+    if (tagName) {
+      lowerCasedTagName = tagName.toLowerCase();
+    }
+
+    // Find the closest opened tag of the same type
+    if (tagName) {
+      for (pos = stack.length - 1; pos >= 0; pos--) {
+        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
+          break
+        }
+      }
+    } else {
+      // If no tag name is provided, clean shop
+      pos = 0;
+    }
+
+    if (pos >= 0) {
+      // Close all the open elements, up the stack
+      for (var i = stack.length - 1; i >= pos; i--) {
+        if (process.env.NODE_ENV !== 'production' &&
+            (i > pos || !tagName) &&
+            options.warn) {
+          options.warn(
+            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
+          );
+        }
+        if (options.end) {
+          options.end(stack[i].tag, start, end);
+        }
+      }
+
+      // Remove the open elements from the stack
+      stack.length = pos;
+      lastTag = pos && stack[pos - 1].tag;
+    } else if (lowerCasedTagName === 'br') {
+      if (options.start) {
+        options.start(tagName, [], true, start, end);
+      }
+    } else if (lowerCasedTagName === 'p') {
+      if (options.start) {
+        options.start(tagName, [], false, start, end);
+      }
+      if (options.end) {
+        options.end(tagName, start, end);
+      }
+    }
+  }
+}
+
+/*  */
+
+var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
+var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
+
+var buildRegex = cached(function (delimiters) {
+  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
+  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
+  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
+});
+
+function parseText (
+  text,
+  delimiters
+) {
+  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
+  if (!tagRE.test(text)) {
+    return
+  }
+  var tokens = [];
+  var lastIndex = tagRE.lastIndex = 0;
+  var match, index;
+  while ((match = tagRE.exec(text))) {
+    index = match.index;
+    // push text token
+    if (index > lastIndex) {
+      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
+    }
+    // tag token
+    var exp = parseFilters(match[1].trim());
+    tokens.push(("_s(" + exp + ")"));
+    lastIndex = index + match[0].length;
+  }
+  if (lastIndex < text.length) {
+    tokens.push(JSON.stringify(text.slice(lastIndex)));
+  }
+  return tokens.join('+')
+}
+
+/*  */
+
+var dirRE = /^v-|^@|^:/;
+var onRE = /^@|^v-on:/;
+var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
+var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
+var bindRE = /^:|^v-bind:/;
+var argRE = /:(.*)$/;
+var modifierRE = /\.[^.]+/g;
+
+var decodeHTMLCached = cached(decode);
+
+// configurable state
+var warn$2;
+var platformGetTagNamespace;
+var platformMustUseProp;
+var platformIsPreTag;
+var preTransforms;
+var transforms;
+var postTransforms;
+var delimiters;
+
+/**
+ * Convert HTML string to AST.
+ */
+function parse (
+  template,
+  options
+) {
+  warn$2 = options.warn || baseWarn;
+  platformGetTagNamespace = options.getTagNamespace || no;
+  platformMustUseProp = options.mustUseProp || no;
+  platformIsPreTag = options.isPreTag || no;
+  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
+  transforms = pluckModuleFunction(options.modules, 'transformNode');
+  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
+  delimiters = options.delimiters;
+
+  var stack = [];
+  var preserveWhitespace = options.preserveWhitespace !== false;
+  var root;
+  var currentParent;
+  var inVPre = false;
+  var inPre = false;
+  var warned = false;
+
+  function endPre (element) {
+    // check pre state
+    if (element.pre) {
+      inVPre = false;
+    }
+    if (platformIsPreTag(element.tag)) {
+      inPre = false;
+    }
+  }
+
+  parseHTML(template, {
+    warn: warn$2,
+    expectHTML: options.expectHTML,
+    isUnaryTag: options.isUnaryTag,
+    shouldDecodeNewlines: options.shouldDecodeNewlines,
+    start: function start (tag, attrs, unary) {
+      // check namespace.
+      // inherit parent ns if there is one
+      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);
+
+      // handle IE svg bug
+      /* istanbul ignore if */
+      if (isIE && ns === 'svg') {
+        attrs = guardIESVGBug(attrs);
+      }
+
+      var element = {
+        type: 1,
+        tag: tag,
+        attrsList: attrs,
+        attrsMap: makeAttrsMap(attrs),
+        parent: currentParent,
+        children: []
+      };
+      if (ns) {
+        element.ns = ns;
+      }
+
+      if (isForbiddenTag(element) && !isServerRendering()) {
+        element.forbidden = true;
+        process.env.NODE_ENV !== 'production' && warn$2(
+          'Templates should only be responsible for mapping the state to the ' +
+          'UI. Avoid placing tags with side-effects in your templates, such as ' +
+          "<" + tag + ">" + ', as they will not be parsed.'
+        );
+      }
+
+      // apply pre-transforms
+      for (var i = 0; i < preTransforms.length; i++) {
+        preTransforms[i](element, options);
+      }
+
+      if (!inVPre) {
+        processPre(element);
+        if (element.pre) {
+          inVPre = true;
+        }
+      }
+      if (platformIsPreTag(element.tag)) {
+        inPre = true;
+      }
+      if (inVPre) {
+        processRawAttrs(element);
+      } else {
+        processFor(element);
+        processIf(element);
+        processOnce(element);
+        processKey(element);
+
+        // determine whether this is a plain element after
+        // removing structural attributes
+        element.plain = !element.key && !attrs.length;
+
+        processRef(element);
+        processSlot(element);
+        processComponent(element);
+        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
+          transforms[i$1](element, options);
+        }
+        processAttrs(element);
+      }
+
+      function checkRootConstraints (el) {
+        if (process.env.NODE_ENV !== 'production' && !warned) {
+          if (el.tag === 'slot' || el.tag === 'template') {
+            warned = true;
+            warn$2(
+              "Cannot use <" + (el.tag) + "> as component root element because it may " +
+              'contain multiple nodes.'
+            );
+          }
+          if (el.attrsMap.hasOwnProperty('v-for')) {
+            warned = true;
+            warn$2(
+              'Cannot use v-for on stateful component root element because ' +
+              'it renders multiple elements.'
+            );
+          }
+        }
+      }
+
+      // tree management
+      if (!root) {
+        root = element;
+        checkRootConstraints(root);
+      } else if (!stack.length) {
+        // allow root elements with v-if, v-else-if and v-else
+        if (root.if && (element.elseif || element.else)) {
+          checkRootConstraints(element);
+          addIfCondition(root, {
+            exp: element.elseif,
+            block: element
+          });
+        } else if (process.env.NODE_ENV !== 'production' && !warned) {
+          warned = true;
+          warn$2(
+            "Component template should contain exactly one root element. " +
+            "If you are using v-if on multiple elements, " +
+            "use v-else-if to chain them instead."
+          );
+        }
+      }
+      if (currentParent && !element.forbidden) {
+        if (element.elseif || element.else) {
+          processIfConditions(element, currentParent);
+        } else if (element.slotScope) { // scoped slot
+          currentParent.plain = false;
+          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
+        } else {
+          currentParent.children.push(element);
+          element.parent = currentParent;
+        }
+      }
+      if (!unary) {
+        currentParent = element;
+        stack.push(element);
+      } else {
+        endPre(element);
+      }
+      // apply post-transforms
+      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
+        postTransforms[i$2](element, options);
+      }
+    },
+
+    end: function end () {
+      // remove trailing whitespace
+      var element = stack[stack.length - 1];
+      var lastNode = element.children[element.children.length - 1];
+      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
+        element.children.pop();
+      }
+      // pop stack
+      stack.length -= 1;
+      currentParent = stack[stack.length - 1];
+      endPre(element);
+    },
+
+    chars: function chars (text) {
+      if (!currentParent) {
+        if (process.env.NODE_ENV !== 'production' && !warned && text === template) {
+          warned = true;
+          warn$2(
+            'Component template requires a root element, rather than just text.'
+          );
+        }
+        return
+      }
+      // IE textarea placeholder bug
+      /* istanbul ignore if */
+      if (isIE &&
+          currentParent.tag === 'textarea' &&
+          currentParent.attrsMap.placeholder === text) {
+        return
+      }
+      var children = currentParent.children;
+      text = inPre || text.trim()
+        ? decodeHTMLCached(text)
+        // only preserve whitespace if its not right after a starting tag
+        : preserveWhitespace && children.length ? ' ' : '';
+      if (text) {
+        var expression;
+        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
+          children.push({
+            type: 2,
+            expression: expression,
+            text: text
+          });
+        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
+          children.push({
+            type: 3,
+            text: text
+          });
+        }
+      }
+    }
+  });
+  return root
+}
+
+function processPre (el) {
+  if (getAndRemoveAttr(el, 'v-pre') != null) {
+    el.pre = true;
+  }
+}
+
+function processRawAttrs (el) {
+  var l = el.attrsList.length;
+  if (l) {
+    var attrs = el.attrs = new Array(l);
+    for (var i = 0; i < l; i++) {
+      attrs[i] = {
+        name: el.attrsList[i].name,
+        value: JSON.stringify(el.attrsList[i].value)
+      };
+    }
+  } else if (!el.pre) {
+    // non root node in pre blocks with no attributes
+    el.plain = true;
+  }
+}
+
+function processKey (el) {
+  var exp = getBindingAttr(el, 'key');
+  if (exp) {
+    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
+      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
+    }
+    el.key = exp;
+  }
+}
+
+function processRef (el) {
+  var ref = getBindingAttr(el, 'ref');
+  if (ref) {
+    el.ref = ref;
+    el.refInFor = checkInFor(el);
+  }
+}
+
+function processFor (el) {
+  var exp;
+  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
+    var inMatch = exp.match(forAliasRE);
+    if (!inMatch) {
+      process.env.NODE_ENV !== 'production' && warn$2(
+        ("Invalid v-for expression: " + exp)
+      );
+      return
+    }
+    el.for = inMatch[2].trim();
+    var alias = inMatch[1].trim();
+    var iteratorMatch = alias.match(forIteratorRE);
+    if (iteratorMatch) {
+      el.alias = iteratorMatch[1].trim();
+      el.iterator1 = iteratorMatch[2].trim();
+      if (iteratorMatch[3]) {
+        el.iterator2 = iteratorMatch[3].trim();
+      }
+    } else {
+      el.alias = alias;
+    }
+  }
+}
+
+function processIf (el) {
+  var exp = getAndRemoveAttr(el, 'v-if');
+  if (exp) {
+    el.if = exp;
+    addIfCondition(el, {
+      exp: exp,
+      block: el
+    });
+  } else {
+    if (getAndRemoveAttr(el, 'v-else') != null) {
+      el.else = true;
+    }
+    var elseif = getAndRemoveAttr(el, 'v-else-if');
+    if (elseif) {
+      el.elseif = elseif;
+    }
+  }
+}
+
+function processIfConditions (el, parent) {
+  var prev = findPrevElement(parent.children);
+  if (prev && prev.if) {
+    addIfCondition(prev, {
+      exp: el.elseif,
+      block: el
+    });
+  } else if (process.env.NODE_ENV !== 'production') {
+    warn$2(
+      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
+      "used on element <" + (el.tag) + "> without corresponding v-if."
+    );
+  }
+}
+
+function findPrevElement (children) {
+  var i = children.length;
+  while (i--) {
+    if (children[i].type === 1) {
+      return children[i]
+    } else {
+      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
+        warn$2(
+          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
+          "will be ignored."
+        );
+      }
+      children.pop();
+    }
+  }
+}
+
+function addIfCondition (el, condition) {
+  if (!el.ifConditions) {
+    el.ifConditions = [];
+  }
+  el.ifConditions.push(condition);
+}
+
+function processOnce (el) {
+  var once$$1 = getAndRemoveAttr(el, 'v-once');
+  if (once$$1 != null) {
+    el.once = true;
+  }
+}
+
+function processSlot (el) {
+  if (el.tag === 'slot') {
+    el.slotName = getBindingAttr(el, 'name');
+    if (process.env.NODE_ENV !== 'production' && el.key) {
+      warn$2(
+        "`key` does not work on <slot> because slots are abstract outlets " +
+        "and can possibly expand into multiple elements. " +
+        "Use the key on a wrapping element instead."
+      );
+    }
+  } else {
+    var slotTarget = getBindingAttr(el, 'slot');
+    if (slotTarget) {
+      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
+    }
+    if (el.tag === 'template') {
+      el.slotScope = getAndRemoveAttr(el, 'scope');
+    }
+  }
+}
+
+function processComponent (el) {
+  var binding;
+  if ((binding = getBindingAttr(el, 'is'))) {
+    el.component = binding;
+  }
+  if (getAndRemoveAttr(el, 'inline-template') != null) {
+    el.inlineTemplate = true;
+  }
+}
+
+function processAttrs (el) {
+  var list = el.attrsList;
+  var i, l, name, rawName, value, arg, modifiers, isProp;
+  for (i = 0, l = list.length; i < l; i++) {
+    name = rawName = list[i].name;
+    value = list[i].value;
+    if (dirRE.test(name)) {
+      // mark element as dynamic
+      el.hasBindings = true;
+      // modifiers
+      modifiers = parseModifiers(name);
+      if (modifiers) {
+        name = name.replace(modifierRE, '');
+      }
+      if (bindRE.test(name)) { // v-bind
+        name = name.replace(bindRE, '');
+        value = parseFilters(value);
+        isProp = false;
+        if (modifiers) {
+          if (modifiers.prop) {
+            isProp = true;
+            name = camelize(name);
+            if (name === 'innerHtml') { name = 'innerHTML'; }
+          }
+          if (modifiers.camel) {
+            name = camelize(name);
+          }
+        }
+        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
+          addProp(el, name, value);
+        } else {
+          addAttr(el, name, value);
+        }
+      } else if (onRE.test(name)) { // v-on
+        name = name.replace(onRE, '');
+        addHandler(el, name, value, modifiers);
+      } else { // normal directives
+        name = name.replace(dirRE, '');
+        // parse arg
+        var argMatch = name.match(argRE);
+        if (argMatch && (arg = argMatch[1])) {
+          name = name.slice(0, -(arg.length + 1));
+        }
+        addDirective(el, name, rawName, value, arg, modifiers);
+        if (process.env.NODE_ENV !== 'production' && name === 'model') {
+          checkForAliasModel(el, value);
+        }
+      }
+    } else {
+      // literal attribute
+      if (process.env.NODE_ENV !== 'production') {
+        var expression = parseText(value, delimiters);
+        if (expression) {
+          warn$2(
+            name + "=\"" + value + "\": " +
+            'Interpolation inside attributes has been removed. ' +
+            'Use v-bind or the colon shorthand instead. For example, ' +
+            'instead of <div id="{{ val }}">, use <div :id="val">.'
+          );
+        }
+      }
+      addAttr(el, name, JSON.stringify(value));
+    }
+  }
+}
+
+function checkInFor (el) {
+  var parent = el;
+  while (parent) {
+    if (parent.for !== undefined) {
+      return true
+    }
+    parent = parent.parent;
+  }
+  return false
+}
+
+function parseModifiers (name) {
+  var match = name.match(modifierRE);
+  if (match) {
+    var ret = {};
+    match.forEach(function (m) { ret[m.slice(1)] = true; });
+    return ret
+  }
+}
+
+function makeAttrsMap (attrs) {
+  var map = {};
+  for (var i = 0, l = attrs.length; i < l; i++) {
+    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
+      warn$2('duplicate attribute: ' + attrs[i].name);
+    }
+    map[attrs[i].name] = attrs[i].value;
+  }
+  return map
+}
+
+function isForbiddenTag (el) {
+  return (
+    el.tag === 'style' ||
+    (el.tag === 'script' && (
+      !el.attrsMap.type ||
+      el.attrsMap.type === 'text/javascript'
+    ))
+  )
+}
+
+var ieNSBug = /^xmlns:NS\d+/;
+var ieNSPrefix = /^NS\d+:/;
+
+/* istanbul ignore next */
+function guardIESVGBug (attrs) {
+  var res = [];
+  for (var i = 0; i < attrs.length; i++) {
+    var attr = attrs[i];
+    if (!ieNSBug.test(attr.name)) {
+      attr.name = attr.name.replace(ieNSPrefix, '');
+      res.push(attr);
+    }
+  }
+  return res
+}
+
+function checkForAliasModel (el, value) {
+  var _el = el;
+  while (_el) {
+    if (_el.for && _el.alias === value) {
+      warn$2(
+        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
+        "You are binding v-model directly to a v-for iteration alias. " +
+        "This will not be able to modify the v-for source array because " +
+        "writing to the alias is like modifying a function local variable. " +
+        "Consider using an array of objects and use v-model on an object property instead."
+      );
+    }
+    _el = _el.parent;
+  }
+}
+
+/*  */
+
+var isStaticKey;
+var isPlatformReservedTag;
+
+var genStaticKeysCached = cached(genStaticKeys$1);
+
+/**
+ * Goal of the optimizer: walk the generated template AST tree
+ * and detect sub-trees that are purely static, i.e. parts of
+ * the DOM that never needs to change.
+ *
+ * Once we detect these sub-trees, we can:
+ *
+ * 1. Hoist them into constants, so that we no longer need to
+ *    create fresh nodes for them on each re-render;
+ * 2. Completely skip them in the patching process.
+ */
+function optimize (root, options) {
+  if (!root) { return }
+  isStaticKey = genStaticKeysCached(options.staticKeys || '');
+  isPlatformReservedTag = options.isReservedTag || no;
+  // first pass: mark all non-static nodes.
+  markStatic$1(root);
+  // second pass: mark static roots.
+  markStaticRoots(root, false);
+}
+
+function genStaticKeys$1 (keys) {
+  return makeMap(
+    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
+    (keys ? ',' + keys : '')
+  )
+}
+
+function markStatic$1 (node) {
+  node.static = isStatic(node);
+  if (node.type === 1) {
+    // do not make component slot content static. this avoids
+    // 1. components not able to mutate slot nodes
+    // 2. static slot content fails for hot-reloading
+    if (
+      !isPlatformReservedTag(node.tag) &&
+      node.tag !== 'slot' &&
+      node.attrsMap['inline-template'] == null
+    ) {
+      return
+    }
+    for (var i = 0, l = node.children.length; i < l; i++) {
+      var child = node.children[i];
+      markStatic$1(child);
+      if (!child.static) {
+        node.static = false;
+      }
+    }
+  }
+}
+
+function markStaticRoots (node, isInFor) {
+  if (node.type === 1) {
+    if (node.static || node.once) {
+      node.staticInFor = isInFor;
+    }
+    // For a node to qualify as a static root, it should have children that
+    // are not just static text. Otherwise the cost of hoisting out will
+    // outweigh the benefits and it's better off to just always render it fresh.
+    if (node.static && node.children.length && !(
+      node.children.length === 1 &&
+      node.children[0].type === 3
+    )) {
+      node.staticRoot = true;
+      return
+    } else {
+      node.staticRoot = false;
+    }
+    if (node.children) {
+      for (var i = 0, l = node.children.length; i < l; i++) {
+        markStaticRoots(node.children[i], isInFor || !!node.for);
+      }
+    }
+    if (node.ifConditions) {
+      walkThroughConditionsBlocks(node.ifConditions, isInFor);
+    }
+  }
+}
+
+function walkThroughConditionsBlocks (conditionBlocks, isInFor) {
+  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
+    markStaticRoots(conditionBlocks[i].block, isInFor);
+  }
+}
+
+function isStatic (node) {
+  if (node.type === 2) { // expression
+    return false
+  }
+  if (node.type === 3) { // text
+    return true
+  }
+  return !!(node.pre || (
+    !node.hasBindings && // no dynamic bindings
+    !node.if && !node.for && // not v-if or v-for or v-else
+    !isBuiltInTag(node.tag) && // not a built-in
+    isPlatformReservedTag(node.tag) && // not a component
+    !isDirectChildOfTemplateFor(node) &&
+    Object.keys(node).every(isStaticKey)
+  ))
+}
+
+function isDirectChildOfTemplateFor (node) {
+  while (node.parent) {
+    node = node.parent;
+    if (node.tag !== 'template') {
+      return false
+    }
+    if (node.for) {
+      return true
+    }
+  }
+  return false
+}
+
+/*  */
+
+var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
+var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
+
+// keyCode aliases
+var keyCodes = {
+  esc: 27,
+  tab: 9,
+  enter: 13,
+  space: 32,
+  up: 38,
+  left: 37,
+  right: 39,
+  down: 40,
+  'delete': [8, 46]
+};
+
+// #4868: modifiers that prevent the execution of the listener
+// need to explicitly return null so that we can determine whether to remove
+// the listener for .once
+var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };
+
+var modifierCode = {
+  stop: '$event.stopPropagation();',
+  prevent: '$event.preventDefault();',
+  self: genGuard("$event.target !== $event.currentTarget"),
+  ctrl: genGuard("!$event.ctrlKey"),
+  shift: genGuard("!$event.shiftKey"),
+  alt: genGuard("!$event.altKey"),
+  meta: genGuard("!$event.metaKey"),
+  left: genGuard("'button' in $event && $event.button !== 0"),
+  middle: genGuard("'button' in $event && $event.button !== 1"),
+  right: genGuard("'button' in $event && $event.button !== 2")
+};
+
+function genHandlers (events, native) {
+  var res = native ? 'nativeOn:{' : 'on:{';
+  for (var name in events) {
+    res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
+  }
+  return res.slice(0, -1) + '}'
+}
+
+function genHandler (
+  name,
+  handler
+) {
+  if (!handler) {
+    return 'function(){}'
+  }
+
+  if (Array.isArray(handler)) {
+    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
+  }
+
+  var isMethodPath = simplePathRE.test(handler.value);
+  var isFunctionExpression = fnExpRE.test(handler.value);
+
+  if (!handler.modifiers) {
+    return isMethodPath || isFunctionExpression
+      ? handler.value
+      : ("function($event){" + (handler.value) + "}") // inline statement
+  } else {
+    var code = '';
+    var keys = [];
+    for (var key in handler.modifiers) {
+      if (modifierCode[key]) {
+        code += modifierCode[key];
+        // left/right
+        if (keyCodes[key]) {
+          keys.push(key);
+        }
+      } else {
+        keys.push(key);
+      }
+    }
+    if (keys.length) {
+      code += genKeyFilter(keys);
+    }
+    var handlerCode = isMethodPath
+      ? handler.value + '($event)'
+      : isFunctionExpression
+        ? ("(" + (handler.value) + ")($event)")
+        : handler.value;
+    return ("function($event){" + code + handlerCode + "}")
+  }
+}
+
+function genKeyFilter (keys) {
+  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
+}
+
+function genFilterCode (key) {
+  var keyVal = parseInt(key, 10);
+  if (keyVal) {
+    return ("$event.keyCode!==" + keyVal)
+  }
+  var alias = keyCodes[key];
+  return ("_k($event.keyCode," + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + ")")
+}
+
+/*  */
+
+function bind$1 (el, dir) {
+  el.wrapData = function (code) {
+    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
+  };
+}
+
+/*  */
+
+var baseDirectives = {
+  bind: bind$1,
+  cloak: noop
+};
+
+/*  */
+
+// configurable state
+var warn$3;
+var transforms$1;
+var dataGenFns;
+var platformDirectives$1;
+var isPlatformReservedTag$1;
+var staticRenderFns;
+var onceCount;
+var currentOptions;
+
+function generate (
+  ast,
+  options
+) {
+  // save previous staticRenderFns so generate calls can be nested
+  var prevStaticRenderFns = staticRenderFns;
+  var currentStaticRenderFns = staticRenderFns = [];
+  var prevOnceCount = onceCount;
+  onceCount = 0;
+  currentOptions = options;
+  warn$3 = options.warn || baseWarn;
+  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
+  dataGenFns = pluckModuleFunction(options.modules, 'genData');
+  platformDirectives$1 = options.directives || {};
+  isPlatformReservedTag$1 = options.isReservedTag || no;
+  var code = ast ? genElement(ast) : '_c("div")';
+  staticRenderFns = prevStaticRenderFns;
+  onceCount = prevOnceCount;
+  return {
+    render: ("with(this){return " + code + "}"),
+    staticRenderFns: currentStaticRenderFns
+  }
+}
+
+function genElement (el) {
+  if (el.staticRoot && !el.staticProcessed) {
+    return genStatic(el)
+  } else if (el.once && !el.onceProcessed) {
+    return genOnce(el)
+  } else if (el.for && !el.forProcessed) {
+    return genFor(el)
+  } else if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.tag === 'template' && !el.slotTarget) {
+    return genChildren(el) || 'void 0'
+  } else if (el.tag === 'slot') {
+    return genSlot(el)
+  } else {
+    // component or element
+    var code;
+    if (el.component) {
+      code = genComponent(el.component, el);
+    } else {
+      var data = el.plain ? undefined : genData(el);
+
+      var children = el.inlineTemplate ? null : genChildren(el, true);
+      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
+    }
+    // module transforms
+    for (var i = 0; i < transforms$1.length; i++) {
+      code = transforms$1[i](el, code);
+    }
+    return code
+  }
+}
+
+// hoist static sub-trees out
+function genStatic (el) {
+  el.staticProcessed = true;
+  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
+  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
+}
+
+// v-once
+function genOnce (el) {
+  el.onceProcessed = true;
+  if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.staticInFor) {
+    var key = '';
+    var parent = el.parent;
+    while (parent) {
+      if (parent.for) {
+        key = parent.key;
+        break
+      }
+      parent = parent.parent;
+    }
+    if (!key) {
+      process.env.NODE_ENV !== 'production' && warn$3(
+        "v-once can only be used inside v-for that is keyed. "
+      );
+      return genElement(el)
+    }
+    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
+  } else {
+    return genStatic(el)
+  }
+}
+
+function genIf (el) {
+  el.ifProcessed = true; // avoid recursion
+  return genIfConditions(el.ifConditions.slice())
+}
+
+function genIfConditions (conditions) {
+  if (!conditions.length) {
+    return '_e()'
+  }
+
+  var condition = conditions.shift();
+  if (condition.exp) {
+    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions)))
+  } else {
+    return ("" + (genTernaryExp(condition.block)))
+  }
+
+  // v-if with v-once should generate code like (a)?_m(0):_m(1)
+  function genTernaryExp (el) {
+    return el.once ? genOnce(el) : genElement(el)
+  }
+}
+
+function genFor (el) {
+  var exp = el.for;
+  var alias = el.alias;
+  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
+  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
+
+  if (
+    process.env.NODE_ENV !== 'production' &&
+    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key
+  ) {
+    warn$3(
+      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
+      "v-for should have explicit keys. " +
+      "See https://vuejs.org/guide/list.html#key for more info.",
+      true /* tip */
+    );
+  }
+
+  el.forProcessed = true; // avoid recursion
+  return "_l((" + exp + ")," +
+    "function(" + alias + iterator1 + iterator2 + "){" +
+      "return " + (genElement(el)) +
+    '})'
+}
+
+function genData (el) {
+  var data = '{';
+
+  // directives first.
+  // directives may mutate the el's other properties before they are generated.
+  var dirs = genDirectives(el);
+  if (dirs) { data += dirs + ','; }
+
+  // key
+  if (el.key) {
+    data += "key:" + (el.key) + ",";
+  }
+  // ref
+  if (el.ref) {
+    data += "ref:" + (el.ref) + ",";
+  }
+  if (el.refInFor) {
+    data += "refInFor:true,";
+  }
+  // pre
+  if (el.pre) {
+    data += "pre:true,";
+  }
+  // record original tag name for components using "is" attribute
+  if (el.component) {
+    data += "tag:\"" + (el.tag) + "\",";
+  }
+  // module data generation functions
+  for (var i = 0; i < dataGenFns.length; i++) {
+    data += dataGenFns[i](el);
+  }
+  // attributes
+  if (el.attrs) {
+    data += "attrs:{" + (genProps(el.attrs)) + "},";
+  }
+  // DOM props
+  if (el.props) {
+    data += "domProps:{" + (genProps(el.props)) + "},";
+  }
+  // event handlers
+  if (el.events) {
+    data += (genHandlers(el.events)) + ",";
+  }
+  if (el.nativeEvents) {
+    data += (genHandlers(el.nativeEvents, true)) + ",";
+  }
+  // slot target
+  if (el.slotTarget) {
+    data += "slot:" + (el.slotTarget) + ",";
+  }
+  // scoped slots
+  if (el.scopedSlots) {
+    data += (genScopedSlots(el.scopedSlots)) + ",";
+  }
+  // component v-model
+  if (el.model) {
+    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
+  }
+  // inline-template
+  if (el.inlineTemplate) {
+    var inlineTemplate = genInlineTemplate(el);
+    if (inlineTemplate) {
+      data += inlineTemplate + ",";
+    }
+  }
+  data = data.replace(/,$/, '') + '}';
+  // v-bind data wrap
+  if (el.wrapData) {
+    data = el.wrapData(data);
+  }
+  return data
+}
+
+function genDirectives (el) {
+  var dirs = el.directives;
+  if (!dirs) { return }
+  var res = 'directives:[';
+  var hasRuntime = false;
+  var i, l, dir, needRuntime;
+  for (i = 0, l = dirs.length; i < l; i++) {
+    dir = dirs[i];
+    needRuntime = true;
+    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
+    if (gen) {
+      // compile-time directive that manipulates AST.
+      // returns true if it also needs a runtime counterpart.
+      needRuntime = !!gen(el, dir, warn$3);
+    }
+    if (needRuntime) {
+      hasRuntime = true;
+      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
+    }
+  }
+  if (hasRuntime) {
+    return res.slice(0, -1) + ']'
+  }
+}
+
+function genInlineTemplate (el) {
+  var ast = el.children[0];
+  if (process.env.NODE_ENV !== 'production' && (
+    el.children.length > 1 || ast.type !== 1
+  )) {
+    warn$3('Inline-template components must have exactly one child element.');
+  }
+  if (ast.type === 1) {
+    var inlineRenderFns = generate(ast, currentOptions);
+    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
+  }
+}
+
+function genScopedSlots (slots) {
+  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + "])")
+}
+
+function genScopedSlot (key, el) {
+  return "[" + key + ",function(" + (String(el.attrsMap.scope)) + "){" +
+    "return " + (el.tag === 'template'
+      ? genChildren(el) || 'void 0'
+      : genElement(el)) + "}]"
+}
+
+function genChildren (el, checkSkip) {
+  var children = el.children;
+  if (children.length) {
+    var el$1 = children[0];
+    // optimize single v-for
+    if (children.length === 1 &&
+        el$1.for &&
+        el$1.tag !== 'template' &&
+        el$1.tag !== 'slot') {
+      return genElement(el$1)
+    }
+    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
+    return ("[" + (children.map(genNode).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
+  }
+}
+
+// determine the normalization needed for the children array.
+// 0: no normalization needed
+// 1: simple normalization needed (possible 1-level deep nested array)
+// 2: full normalization needed
+function getNormalizationType (children) {
+  var res = 0;
+  for (var i = 0; i < children.length; i++) {
+    var el = children[i];
+    if (el.type !== 1) {
+      continue
+    }
+    if (needsNormalization(el) ||
+        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
+      res = 2;
+      break
+    }
+    if (maybeComponent(el) ||
+        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
+      res = 1;
+    }
+  }
+  return res
+}
+
+function needsNormalization (el) {
+  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
+}
+
+function maybeComponent (el) {
+  return !isPlatformReservedTag$1(el.tag)
+}
+
+function genNode (node) {
+  if (node.type === 1) {
+    return genElement(node)
+  } else {
+    return genText(node)
+  }
+}
+
+function genText (text) {
+  return ("_v(" + (text.type === 2
+    ? text.expression // no need for () because already wrapped in _s()
+    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
+}
+
+function genSlot (el) {
+  var slotName = el.slotName || '"default"';
+  var children = genChildren(el);
+  var res = "_t(" + slotName + (children ? ("," + children) : '');
+  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
+  var bind$$1 = el.attrsMap['v-bind'];
+  if ((attrs || bind$$1) && !children) {
+    res += ",null";
+  }
+  if (attrs) {
+    res += "," + attrs;
+  }
+  if (bind$$1) {
+    res += (attrs ? '' : ',null') + "," + bind$$1;
+  }
+  return res + ')'
+}
+
+// componentName is el.component, take it as argument to shun flow's pessimistic refinement
+function genComponent (componentName, el) {
+  var children = el.inlineTemplate ? null : genChildren(el, true);
+  return ("_c(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
+}
+
+function genProps (props) {
+  var res = '';
+  for (var i = 0; i < props.length; i++) {
+    var prop = props[i];
+    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
+  }
+  return res.slice(0, -1)
+}
+
+// #3895, #4268
+function transformSpecialNewlines (text) {
+  return text
+    .replace(/\u2028/g, '\\u2028')
+    .replace(/\u2029/g, '\\u2029')
+}
+
+/*  */
+
+// these keywords should not appear inside expressions, but operators like
+// typeof, instanceof and in are allowed
+var prohibitedKeywordRE = new RegExp('\\b' + (
+  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
+  'super,throw,while,yield,delete,export,import,return,switch,default,' +
+  'extends,finally,continue,debugger,function,arguments'
+).split(',').join('\\b|\\b') + '\\b');
+
+// these unary operators should not be used as property/method names
+var unaryOperatorsRE = new RegExp('\\b' + (
+  'delete,typeof,void'
+).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');
+
+// check valid identifier for v-for
+var identRE = /[A-Za-z_$][\w$]*/;
+
+// strip strings in expressions
+var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
+
+// detect problematic expressions in a template
+function detectErrors (ast) {
+  var errors = [];
+  if (ast) {
+    checkNode(ast, errors);
+  }
+  return errors
+}
+
+function checkNode (node, errors) {
+  if (node.type === 1) {
+    for (var name in node.attrsMap) {
+      if (dirRE.test(name)) {
+        var value = node.attrsMap[name];
+        if (value) {
+          if (name === 'v-for') {
+            checkFor(node, ("v-for=\"" + value + "\""), errors);
+          } else if (onRE.test(name)) {
+            checkEvent(value, (name + "=\"" + value + "\""), errors);
+          } else {
+            checkExpression(value, (name + "=\"" + value + "\""), errors);
+          }
+        }
+      }
+    }
+    if (node.children) {
+      for (var i = 0; i < node.children.length; i++) {
+        checkNode(node.children[i], errors);
+      }
+    }
+  } else if (node.type === 2) {
+    checkExpression(node.expression, node.text, errors);
+  }
+}
+
+function checkEvent (exp, text, errors) {
+  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
+  if (keywordMatch) {
+    errors.push(
+      "avoid using JavaScript unary operator as property name: " +
+      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
+    );
+  }
+  checkExpression(exp, text, errors);
+}
+
+function checkFor (node, text, errors) {
+  checkExpression(node.for || '', text, errors);
+  checkIdentifier(node.alias, 'v-for alias', text, errors);
+  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
+  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
+}
+
+function checkIdentifier (ident, type, text, errors) {
+  if (typeof ident === 'string' && !identRE.test(ident)) {
+    errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
+  }
+}
+
+function checkExpression (exp, text, errors) {
+  try {
+    new Function(("return " + exp));
+  } catch (e) {
+    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
+    if (keywordMatch) {
+      errors.push(
+        "avoid using JavaScript keyword as property name: " +
+        "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
+      );
+    } else {
+      errors.push(("invalid expression: " + (text.trim())));
+    }
+  }
+}
+
+/*  */
+
+function baseCompile (
+  template,
+  options
+) {
+  var ast = parse(template.trim(), options);
+  optimize(ast, options);
+  var code = generate(ast, options);
+  return {
+    ast: ast,
+    render: code.render,
+    staticRenderFns: code.staticRenderFns
+  }
+}
+
+function makeFunction (code, errors) {
+  try {
+    return new Function(code)
+  } catch (err) {
+    errors.push({ err: err, code: code });
+    return noop
+  }
+}
+
+function createCompiler (baseOptions) {
+  var functionCompileCache = Object.create(null);
+
+  function compile (
+    template,
+    options
+  ) {
+    var finalOptions = Object.create(baseOptions);
+    var errors = [];
+    var tips = [];
+    finalOptions.warn = function (msg, tip$$1) {
+      (tip$$1 ? tips : errors).push(msg);
+    };
+
+    if (options) {
+      // merge custom modules
+      if (options.modules) {
+        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
+      }
+      // merge custom directives
+      if (options.directives) {
+        finalOptions.directives = extend(
+          Object.create(baseOptions.directives),
+          options.directives
+        );
+      }
+      // copy other options
+      for (var key in options) {
+        if (key !== 'modules' && key !== 'directives') {
+          finalOptions[key] = options[key];
+        }
+      }
+    }
+
+    var compiled = baseCompile(template, finalOptions);
+    if (process.env.NODE_ENV !== 'production') {
+      errors.push.apply(errors, detectErrors(compiled.ast));
+    }
+    compiled.errors = errors;
+    compiled.tips = tips;
+    return compiled
+  }
+
+  function compileToFunctions (
+    template,
+    options,
+    vm
+  ) {
+    options = options || {};
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      // detect possible CSP restriction
+      try {
+        new Function('return 1');
+      } catch (e) {
+        if (e.toString().match(/unsafe-eval|CSP/)) {
+          warn(
+            'It seems you are using the standalone build of Vue.js in an ' +
+            'environment with Content Security Policy that prohibits unsafe-eval. ' +
+            'The template compiler cannot work in this environment. Consider ' +
+            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
+            'templates into render functions.'
+          );
+        }
+      }
+    }
+
+    // check cache
+    var key = options.delimiters
+      ? String(options.delimiters) + template
+      : template;
+    if (functionCompileCache[key]) {
+      return functionCompileCache[key]
+    }
+
+    // compile
+    var compiled = compile(template, options);
+
+    // check compilation errors/tips
+    if (process.env.NODE_ENV !== 'production') {
+      if (compiled.errors && compiled.errors.length) {
+        warn(
+          "Error compiling template:\n\n" + template + "\n\n" +
+          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
+          vm
+        );
+      }
+      if (compiled.tips && compiled.tips.length) {
+        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
+      }
+    }
+
+    // turn code into functions
+    var res = {};
+    var fnGenErrors = [];
+    res.render = makeFunction(compiled.render, fnGenErrors);
+    var l = compiled.staticRenderFns.length;
+    res.staticRenderFns = new Array(l);
+    for (var i = 0; i < l; i++) {
+      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
+    }
+
+    // check function generation errors.
+    // this should only happen if there is a bug in the compiler itself.
+    // mostly for codegen development use
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
+        warn(
+          "Failed to generate render function:\n\n" +
+          fnGenErrors.map(function (ref) {
+            var err = ref.err;
+            var code = ref.code;
+
+            return ((err.toString()) + " in\n\n" + code + "\n");
+        }).join('\n'),
+          vm
+        );
+      }
+    }
+
+    return (functionCompileCache[key] = res)
+  }
+
+  return {
+    compile: compile,
+    compileToFunctions: compileToFunctions
+  }
+}
+
+/*  */
+
+function transformNode (el, options) {
+  var warn = options.warn || baseWarn;
+  var staticClass = getAndRemoveAttr(el, 'class');
+  if (process.env.NODE_ENV !== 'production' && staticClass) {
+    var expression = parseText(staticClass, options.delimiters);
+    if (expression) {
+      warn(
+        "class=\"" + staticClass + "\": " +
+        'Interpolation inside attributes has been removed. ' +
+        'Use v-bind or the colon shorthand instead. For example, ' +
+        'instead of <div class="{{ val }}">, use <div :class="val">.'
+      );
+    }
+  }
+  if (staticClass) {
+    el.staticClass = JSON.stringify(staticClass);
+  }
+  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
+  if (classBinding) {
+    el.classBinding = classBinding;
+  }
+}
+
+function genData$1 (el) {
+  var data = '';
+  if (el.staticClass) {
+    data += "staticClass:" + (el.staticClass) + ",";
+  }
+  if (el.classBinding) {
+    data += "class:" + (el.classBinding) + ",";
+  }
+  return data
+}
+
+var klass$1 = {
+  staticKeys: ['staticClass'],
+  transformNode: transformNode,
+  genData: genData$1
+};
+
+/*  */
+
+function transformNode$1 (el, options) {
+  var warn = options.warn || baseWarn;
+  var staticStyle = getAndRemoveAttr(el, 'style');
+  if (staticStyle) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      var expression = parseText(staticStyle, options.delimiters);
+      if (expression) {
+        warn(
+          "style=\"" + staticStyle + "\": " +
+          'Interpolation inside attributes has been removed. ' +
+          'Use v-bind or the colon shorthand instead. For example, ' +
+          'instead of <div style="{{ val }}">, use <div :style="val">.'
+        );
+      }
+    }
+    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
+  }
+
+  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
+  if (styleBinding) {
+    el.styleBinding = styleBinding;
+  }
+}
+
+function genData$2 (el) {
+  var data = '';
+  if (el.staticStyle) {
+    data += "staticStyle:" + (el.staticStyle) + ",";
+  }
+  if (el.styleBinding) {
+    data += "style:(" + (el.styleBinding) + "),";
+  }
+  return data
+}
+
+var style$1 = {
+  staticKeys: ['staticStyle'],
+  transformNode: transformNode$1,
+  genData: genData$2
+};
+
+var modules$1 = [
+  klass$1,
+  style$1
+];
+
+/*  */
+
+function text (el, dir) {
+  if (dir.value) {
+    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
+  }
+}
+
+/*  */
+
+function html (el, dir) {
+  if (dir.value) {
+    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
+  }
+}
+
+var directives$1 = {
+  model: model,
+  text: text,
+  html: html
+};
+
+/*  */
+
+var baseOptions = {
+  expectHTML: true,
+  modules: modules$1,
+  directives: directives$1,
+  isPreTag: isPreTag,
+  isUnaryTag: isUnaryTag,
+  mustUseProp: mustUseProp,
+  isReservedTag: isReservedTag,
+  getTagNamespace: getTagNamespace,
+  staticKeys: genStaticKeys(modules$1)
+};
+
+var ref$1 = createCompiler(baseOptions);
+var compileToFunctions = ref$1.compileToFunctions;
+
+/*  */
+
+var idToTemplate = cached(function (id) {
+  var el = query(id);
+  return el && el.innerHTML
+});
+
+var mount = Vue$3.prototype.$mount;
+Vue$3.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && query(el);
+
+  /* istanbul ignore if */
+  if (el === document.body || el === document.documentElement) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
+    );
+    return this
+  }
+
+  var options = this.$options;
+  // resolve template/el and convert to render function
+  if (!options.render) {
+    var template = options.template;
+    if (template) {
+      if (typeof template === 'string') {
+        if (template.charAt(0) === '#') {
+          template = idToTemplate(template);
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !template) {
+            warn(
+              ("Template element not found or is empty: " + (options.template)),
+              this
+            );
+          }
+        }
+      } else if (template.nodeType) {
+        template = template.innerHTML;
+      } else {
+        if (process.env.NODE_ENV !== 'production') {
+          warn('invalid template option:' + template, this);
+        }
+        return this
+      }
+    } else if (el) {
+      template = getOuterHTML(el);
+    }
+    if (template) {
+      /* istanbul ignore if */
+      if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+        perf.mark('compile');
+      }
+
+      var ref = compileToFunctions(template, {
+        shouldDecodeNewlines: shouldDecodeNewlines,
+        delimiters: options.delimiters
+      }, this);
+      var render = ref.render;
+      var staticRenderFns = ref.staticRenderFns;
+      options.render = render;
+      options.staticRenderFns = staticRenderFns;
+
+      /* istanbul ignore if */
+      if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+        perf.mark('compile end');
+        perf.measure(((this._name) + " compile"), 'compile', 'compile end');
+      }
+    }
+  }
+  return mount.call(this, el, hydrating)
+};
+
+/**
+ * Get outerHTML of elements, taking care
+ * of SVG elements in IE as well.
+ */
+function getOuterHTML (el) {
+  if (el.outerHTML) {
+    return el.outerHTML
+  } else {
+    var container = document.createElement('div');
+    container.appendChild(el.cloneNode(true));
+    return container.innerHTML
+  }
+}
+
+Vue$3.compile = compileToFunctions;
+
+export default Vue$3;
Index: public/node_modules/vue/src/platforms/web/compiler/directives/text.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/directives/text.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/directives/text.js	(revision )
@@ -0,0 +1,9 @@
+/* @flow */
+
+import { addProp } from 'compiler/helpers'
+
+export default function text (el: ASTElement, dir: ASTDirective) {
+  if (dir.value) {
+    addProp(el, 'textContent', `_s(${dir.value})`)
+  }
+}
Index: public/node_modules/vue/src/core/util/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/index.js	(revision )
+++ public/node_modules/vue/src/core/util/index.js	(revision )
@@ -0,0 +1,8 @@
+export * from 'shared/util'
+export * from './lang'
+export * from './env'
+export * from './options'
+export * from './debug'
+export * from './props'
+export * from './error'
+export { defineReactive } from '../observer/index'
Index: public/node_modules/vue/src/platforms/web/compiler/directives/model.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/directives/model.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/directives/model.js	(revision )
@@ -0,0 +1,160 @@
+/* @flow */
+
+import config from 'core/config'
+import { addHandler, addProp, getBindingAttr } from 'compiler/helpers'
+import { genComponentModel, genAssignmentCode } from 'compiler/directives/model'
+
+let warn
+
+// in some cases, the event used has to be determined at runtime
+// so we used some reserved tokens during compile.
+export const RANGE_TOKEN = '__r'
+export const CHECKBOX_RADIO_TOKEN = '__c'
+
+export default function model (
+  el: ASTElement,
+  dir: ASTDirective,
+  _warn: Function
+): ?boolean {
+  warn = _warn
+  const value = dir.value
+  const modifiers = dir.modifiers
+  const tag = el.tag
+  const type = el.attrsMap.type
+
+  if (process.env.NODE_ENV !== 'production') {
+    const dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type']
+    if (tag === 'input' && dynamicType) {
+      warn(
+        `<input :type="${dynamicType}" v-model="${value}">:\n` +
+        `v-model does not support dynamic input types. Use v-if branches instead.`
+      )
+    }
+    // inputs with type="file" are read only and setting the input's
+    // value will throw an error.
+    if (tag === 'input' && type === 'file') {
+      warn(
+        `<${el.tag} v-model="${value}" type="file">:\n` +
+        `File inputs are read only. Use a v-on:change listener instead.`
+      )
+    }
+  }
+
+  if (tag === 'select') {
+    genSelect(el, value, modifiers)
+  } else if (tag === 'input' && type === 'checkbox') {
+    genCheckboxModel(el, value, modifiers)
+  } else if (tag === 'input' && type === 'radio') {
+    genRadioModel(el, value, modifiers)
+  } else if (tag === 'input' || tag === 'textarea') {
+    genDefaultModel(el, value, modifiers)
+  } else if (!config.isReservedTag(tag)) {
+    genComponentModel(el, value, modifiers)
+    // component v-model doesn't need extra runtime
+    return false
+  } else if (process.env.NODE_ENV !== 'production') {
+    warn(
+      `<${el.tag} v-model="${value}">: ` +
+      `v-model is not supported on this element type. ` +
+      'If you are working with contenteditable, it\'s recommended to ' +
+      'wrap a library dedicated for that purpose inside a custom component.'
+    )
+  }
+
+  // ensure runtime directive metadata
+  return true
+}
+
+function genCheckboxModel (
+  el: ASTElement,
+  value: string,
+  modifiers: ?ASTModifiers
+) {
+  const number = modifiers && modifiers.number
+  const valueBinding = getBindingAttr(el, 'value') || 'null'
+  const trueValueBinding = getBindingAttr(el, 'true-value') || 'true'
+  const falseValueBinding = getBindingAttr(el, 'false-value') || 'false'
+  addProp(el, 'checked',
+    `Array.isArray(${value})` +
+      `?_i(${value},${valueBinding})>-1` + (
+        trueValueBinding === 'true'
+          ? `:(${value})`
+          : `:_q(${value},${trueValueBinding})`
+      )
+  )
+  addHandler(el, CHECKBOX_RADIO_TOKEN,
+    `var $$a=${value},` +
+        '$$el=$event.target,' +
+        `$$c=$$el.checked?(${trueValueBinding}):(${falseValueBinding});` +
+    'if(Array.isArray($$a)){' +
+      `var $$v=${number ? '_n(' + valueBinding + ')' : valueBinding},` +
+          '$$i=_i($$a,$$v);' +
+      `if($$c){$$i<0&&(${value}=$$a.concat($$v))}` +
+      `else{$$i>-1&&(${value}=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}` +
+    `}else{${value}=$$c}`,
+    null, true
+  )
+}
+
+function genRadioModel (
+    el: ASTElement,
+    value: string,
+    modifiers: ?ASTModifiers
+) {
+  const number = modifiers && modifiers.number
+  let valueBinding = getBindingAttr(el, 'value') || 'null'
+  valueBinding = number ? `_n(${valueBinding})` : valueBinding
+  addProp(el, 'checked', `_q(${value},${valueBinding})`)
+  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true)
+}
+
+function genSelect (
+    el: ASTElement,
+    value: string,
+    modifiers: ?ASTModifiers
+) {
+  const number = modifiers && modifiers.number
+  const selectedVal = `Array.prototype.filter` +
+    `.call($event.target.options,function(o){return o.selected})` +
+    `.map(function(o){var val = "_value" in o ? o._value : o.value;` +
+    `return ${number ? '_n(val)' : 'val'}})`
+
+  const assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]'
+  let code = `var $$selectedVal = ${selectedVal};`
+  code = `${code} ${genAssignmentCode(value, assignment)}`
+  addHandler(el, 'change', code, null, true)
+}
+
+function genDefaultModel (
+  el: ASTElement,
+  value: string,
+  modifiers: ?ASTModifiers
+): ?boolean {
+  const type = el.attrsMap.type
+  const { lazy, number, trim } = modifiers || {}
+  const needCompositionGuard = !lazy && type !== 'range'
+  const event = lazy
+    ? 'change'
+    : type === 'range'
+      ? RANGE_TOKEN
+      : 'input'
+
+  let valueExpression = '$event.target.value'
+  if (trim) {
+    valueExpression = `$event.target.value.trim()`
+  }
+  if (number) {
+    valueExpression = `_n(${valueExpression})`
+  }
+
+  let code = genAssignmentCode(value, valueExpression)
+  if (needCompositionGuard) {
+    code = `if($event.target.composing)return;${code}`
+  }
+
+  addProp(el, 'value', `(${value})`)
+  addHandler(el, event, code, null, true)
+  if (trim || number || type === 'number') {
+    addHandler(el, 'blur', '$forceUpdate()')
+  }
+}
Index: public/node_modules/vue/src/platforms/weex/compiler/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/index.js	(revision )
@@ -0,0 +1,28 @@
+/* @flow */
+
+import { genStaticKeys } from 'shared/util'
+import { createCompiler } from 'compiler/index'
+
+import modules from './modules/index'
+import directives from './directives/index'
+
+import {
+  isUnaryTag,
+  mustUseProp,
+  isReservedTag,
+  getTagNamespace
+} from '../util/index'
+
+export const baseOptions: CompilerOptions = {
+  modules,
+  directives,
+  isUnaryTag,
+  mustUseProp,
+  isReservedTag,
+  getTagNamespace,
+  preserveWhitespace: false,
+  staticKeys: genStaticKeys(modules)
+}
+
+const { compile, compileToFunctions } = createCompiler(baseOptions)
+export { compile, compileToFunctions }
Index: public/node_modules/vue/types/vnode.d.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/types/vnode.d.ts	(revision )
+++ public/node_modules/vue/types/vnode.d.ts	(revision )
@@ -0,0 +1,69 @@
+import { Vue } from "./vue";
+
+export type ScopedSlot = (props: any) => VNodeChildrenArrayContents | string;
+
+export type VNodeChildren = VNodeChildrenArrayContents | [ScopedSlot] | string;
+export interface VNodeChildrenArrayContents {
+  [x: number]: VNode | string | VNodeChildren;
+}
+
+export interface VNode {
+  tag?: string;
+  data?: VNodeData;
+  children?: VNode[];
+  text?: string;
+  elm?: Node;
+  ns?: string;
+  context?: Vue;
+  key?: string | number;
+  componentOptions?: VNodeComponentOptions;
+  componentInstance?: Vue;
+  parent?: VNode;
+  raw?: boolean;
+  isStatic?: boolean;
+  isRootInsert: boolean;
+  isComment: boolean;
+}
+
+export interface VNodeComponentOptions {
+  Ctor: typeof Vue;
+  propsData?: Object;
+  listeners?: Object;
+  children?: VNodeChildren;
+  tag?: string;
+}
+
+export interface VNodeData {
+  key?: string | number;
+  slot?: string;
+  scopedSlots?: { [key: string]: ScopedSlot };
+  ref?: string;
+  tag?: string;
+  staticClass?: string;
+  class?: any;
+  staticStyle?: { [key: string]: any };
+  style?: Object[] | Object;
+  props?: { [key: string]: any };
+  attrs?: { [key: string]: any };
+  domProps?: { [key: string]: any };
+  hook?: { [key: string]: Function };
+  on?: { [key: string]: Function | Function[] };
+  nativeOn?: { [key: string]: Function | Function[] };
+  transition?: Object;
+  show?: boolean;
+  inlineTemplate?: {
+    render: Function;
+    staticRenderFns: Function[];
+  };
+  directives?: VNodeDirective[];
+  keepAlive?: boolean;
+}
+
+export interface VNodeDirective {
+  readonly name: string;
+  readonly value: any;
+  readonly oldValue: any;
+  readonly expression: any;
+  readonly arg: string;
+  readonly modifiers: { [key: string]: boolean };
+}
Index: app/User.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/User.php	(revision 3d426e1c0d52d26cb969fee1b80a5af3508614bb)
+++ app/User.php	(revision )
@@ -30,6 +30,11 @@
         //
         return $this->belongsToMany('App\Form', 'form_admin', 'user_id', 'form_id')->wherePivot('handle', true);
     }
+    public function ownForms()
+    {
+        //
+        return $this->hasMany('App\Form', 'creator');
+    }
 
     /**
      * 
Index: public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/package.json	(revision )
@@ -0,0 +1,62 @@
+{
+  "name": "get-stream",
+  "version": "3.0.0",
+  "description": "Get a stream as a string, buffer, or array",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/get-stream"
+  },
+  "author": {
+    "name": "Sindre Sorhus",
+    "email": "sindresorhus@gmail.com",
+    "url": "sindresorhus.com"
+  },
+  "engines": {
+    "node": ">=4"
+  },
+  "scripts": {
+    "test": "xo && ava"
+  },
+  "files": [
+    "index.js",
+    "buffer-stream.js"
+  ],
+  "keywords": [
+    "get",
+    "stream",
+    "promise",
+    "concat",
+    "string",
+    "str",
+    "text",
+    "buffer",
+    "read",
+    "data",
+    "consume",
+    "readable",
+    "readablestream",
+    "array",
+    "object",
+    "obj"
+  ],
+  "devDependencies": {
+    "ava": "*",
+    "into-stream": "^3.0.0",
+    "xo": "*"
+  },
+  "xo": {
+    "esnext": true
+  },
+  "readme": "# get-stream [![Build Status](https://travis-ci.org/sindresorhus/get-stream.svg?branch=master)](https://travis-ci.org/sindresorhus/get-stream)\n\n> Get a stream as a string, buffer, or array\n\n\n## Install\n\n```\n$ npm install --save get-stream\n```\n\n\n## Usage\n\n```js\nconst fs = require('fs');\nconst getStream = require('get-stream');\nconst stream = fs.createReadStream('unicorn.txt');\n\ngetStream(stream).then(str => {\n\tconsole.log(str);\n\t/*\n\t              ,,))))))));,\n\t           __)))))))))))))),\n\t\\|/       -\\(((((''''((((((((.\n\t-*-==//////((''  .     `)))))),\n\t/|\\      ))| o    ;-.    '(((((                                  ,(,\n\t         ( `|    /  )    ;))))'                               ,_))^;(~\n\t            |   |   |   ,))((((_     _____------~~~-.        %,;(;(>';'~\n\t            o_);   ;    )))(((` ~---~  `::           \\      %%~~)(v;(`('~\n\t                  ;    ''''````         `:       `:::|\\,__,%%    );`'; ~\n\t                 |   _                )     /      `:|`----'     `-'\n\t           ______/\\/~    |                 /        /\n\t         /~;;.____/;;'  /          ___--,-(   `;;;/\n\t        / //  _;______;'------~~~~~    /;;/\\    /\n\t       //  | |                        / ;   \\;;,\\\n\t      (<_  | ;                      /',/-----'  _>\n\t       \\_| ||_                     //~;~~~~~~~~~\n\t           `\\_|                   (,~~\n\t                                   \\~\\\n\t                                    ~~\n\t*/\n});\n```\n\n\n## API\n\nThe methods returns a promise that resolves when the `end` event fires on the stream, indicating that there is no more data to be read. The stream is switched to flowing mode.\n\n### getStream(stream, [options])\n\nGet the `stream` as a string.\n\n#### options\n\n##### encoding\n\nType: `string`<br>\nDefault: `utf8`\n\n[Encoding](https://nodejs.org/api/buffer.html#buffer_buffer) of the incoming stream.\n\n##### maxBuffer\n\nType: `number`<br>\nDefault: `Infinity`\n\nMaximum length of the returned string. If it exceeds this value before the stream ends, the promise will be rejected.\n\n### getStream.buffer(stream, [options])\n\nGet the `stream` as a buffer.\n\nIt honors the `maxBuffer` option as above, but it refers to byte length rather than string length.\n\n### getStream.array(stream, [options])\n\nGet the `stream` as an array of values.\n\nIt honors both the `maxBuffer` and `encoding` options. The behavior changes slightly based on the encoding chosen:\n\n- When `encoding` is unset, it assumes an [object mode stream](https://nodesource.com/blog/understanding-object-streams/) and collects values emitted from `stream` unmodified. In this case `maxBuffer` refers to the number of items in the array (not the sum of their sizes).\n\n- When `encoding` is set to `buffer`, it collects an array of buffers. `maxBuffer` refers to the summed byte lengths of every buffer in the array.\n\n- When `encoding` is set to anything else, it collects an array of strings. `maxBuffer` refers to the summed character lengths of every string in the array.\n\n\n## Errors\n\nIf the input stream emits an `error` event, the promise will be rejected with the error. The buffered data will be attached to the `bufferedData` property of the error.\n\n```js\ngetStream(streamThatErrorsAtTheEnd('unicorn'))\n\t.catch(err => {\n\t\tconsole.log(err.bufferedData);\n\t\t//=> 'unicorn'\n\t});\n```\n\n\n## FAQ\n\n### How is this different from [`concat-stream`](https://github.com/maxogden/concat-stream)?\n\nThis module accepts a stream instead of being one and returns a promise instead of using a callback. The API is simpler and it only supports returning a string, buffer, or array. It doesn't have a fragile type inference. You explicitly choose what you want. And it doesn't depend on the huge `readable-stream` package.\n\n\n## Related\n\n- [get-stdin](https://github.com/sindresorhus/get-stdin) - Get stdin as a string or buffer\n\n\n## License\n\nMIT  [Sindre Sorhus](https://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/get-stream/issues"
+  },
+  "_id": "get-stream@3.0.0",
+  "dist": {
+    "shasum": "cee998747a9d553a02e889a94c886aca79258178"
+  },
+  "_from": "get-stream@^3.0.0",
+  "_resolved": "https://registry.npmjs.org/get-stream/-/get-stream-3.0.0.tgz"
+}
Index: public/node_modules/vue-resource/src/http/client/jsonp.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/client/jsonp.js	(revision )
+++ public/node_modules/vue-resource/src/http/client/jsonp.js	(revision )
@@ -0,0 +1,53 @@
+/**
+ * JSONP client (Browser).
+ */
+
+import Promise from '../../promise';
+
+export default function (request) {
+    return new Promise(resolve => {
+
+        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;
+
+        handler = ({type}) => {
+
+            var status = 0;
+
+            if (type === 'load' && body !== null) {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            if (status && window[callback]) {
+                delete window[callback];
+                document.body.removeChild(script);
+            }
+
+            resolve(request.respondWith(body, {status}));
+        };
+
+        window[callback] = result => {
+            body = JSON.stringify(result);
+        };
+
+        request.abort = () => {
+            handler({type: 'abort'});
+        };
+
+        request.params[name] = callback;
+
+        if (request.timeout) {
+            setTimeout(request.abort, request.timeout);
+        }
+
+        script = document.createElement('script');
+        script.src = request.getUrl();
+        script.type = 'text/javascript';
+        script.async = true;
+        script.onload = handler;
+        script.onerror = handler;
+
+        document.body.appendChild(script);
+    });
+}
Index: public/node_modules/vue-resource/test/url.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/url.js	(revision )
+++ public/node_modules/vue-resource/test/url.js	(revision )
@@ -0,0 +1,33 @@
+import Vue from 'vue';
+
+describe('Vue.url', function () {
+
+    it('data{/id}', function () {
+
+        expect(Vue.url('data{/id}')).toBe('data');
+        expect(Vue.url('data{/id}', {id: 1})).toBe('data/1');
+
+    });
+
+    it('data{/array}', function () {
+
+        expect(Vue.url('data{?array}')).toBe('data');
+        expect(Vue.url('data{?array}', {array: [1,2,3]})).toBe('data?array=1,2,3');
+
+    });
+
+    it('{+path}data', function () {
+
+        expect(Vue.url('{+path}data')).toBe('data');
+        expect(Vue.url('{+path}data', {path: 'path1/path2/'})).toBe('path1/path2/data');
+
+    });
+
+    it('{+base}data', function () {
+
+        Vue.url.options.params.base = 'base/path/';
+        expect(Vue.url('{+base}data')).toBe('base/path/data');
+
+    });
+
+});
Index: public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/browser.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/browser.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/browser.js	(revision )
@@ -0,0 +1,1 @@
+module.exports = require('buffer')
Index: public/node_modules/vue/src/platforms/web/server/modules/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/modules/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/modules/index.js	(revision )
@@ -0,0 +1,11 @@
+import attrs from './attrs'
+import domProps from './dom-props'
+import klass from './class'
+import style from './style'
+
+export default [
+  attrs,
+  domProps,
+  klass,
+  style
+]
Index: public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/package.json	(revision )
@@ -0,0 +1,49 @@
+{
+  "name": "prepend-http",
+  "version": "1.0.4",
+  "description": "Prepend `http://` to humanized URLs like todomvc.com and localhost",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/prepend-http"
+  },
+  "author": {
+    "name": "Sindre Sorhus",
+    "email": "sindresorhus@gmail.com",
+    "url": "sindresorhus.com"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "xo && ava"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "prepend",
+    "protocol",
+    "scheme",
+    "url",
+    "uri",
+    "http",
+    "https",
+    "humanized"
+  ],
+  "devDependencies": {
+    "ava": "*",
+    "xo": "*"
+  },
+  "readme": "# prepend-http [![Build Status](https://travis-ci.org/sindresorhus/prepend-http.svg?branch=master)](https://travis-ci.org/sindresorhus/prepend-http)\n\n> Prepend `http://` to humanized URLs like `todomvc.com` and `localhost`\n\n\n## Install\n\n```\n$ npm install --save prepend-http\n```\n\n\n## Usage\n\n```js\nconst prependHttp = require('prepend-http');\n\nprependHttp('todomvc.com');\n//=> 'http://todomvc.com'\n\nprependHttp('localhost');\n//=> 'http://localhost'\n\nprependHttp('http://todomvc.com');\n//=> 'http://todomvc.com'\n```\n\n\n## License\n\nMIT  [Sindre Sorhus](https://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/prepend-http/issues"
+  },
+  "_id": "prepend-http@1.0.4",
+  "dist": {
+    "shasum": "f54e7f4fc361b8580c846a7bd189fa70a909796c"
+  },
+  "_from": "prepend-http@^1.0.1",
+  "_resolved": "https://registry.npmjs.org/prepend-http/-/prepend-http-1.0.4.tgz"
+}
Index: public/node_modules/vue-resource/src/http/client/node.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/client/node.js	(revision )
+++ public/node_modules/vue-resource/src/http/client/node.js	(revision )
@@ -0,0 +1,39 @@
+/**
+ * Http client (Node).
+ */
+
+import Promise from '../../promise';
+import { each, trim } from '../../util';
+
+export default function (request) {
+
+    const client = require('got');
+
+    return new Promise(resolve => {
+
+        var url = request.getUrl();
+        var body = request.getBody();
+        var method = request.method;
+        var headers = {}, handler;
+
+        request.headers.forEach((value, name) => {
+            headers[name] = value;
+        });
+
+        client(url, {body, method, headers}).then(handler = (resp) => {
+
+            var response = request.respondWith(resp.body, {
+                    status: resp.statusCode,
+                    statusText: trim(resp.statusMessage)
+                }
+            );
+
+            each(resp.headers, (value, name) => {
+                response.headers.set(name, value);
+            });
+
+            resolve(response);
+
+        }, error => handler(error.response));
+    });
+}
Index: public/node_modules/vue-resource/test/http.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/http.js	(revision )
+++ public/node_modules/vue-resource/test/http.js	(revision )
@@ -0,0 +1,197 @@
+import Vue from 'vue';
+
+describe('Vue.http', function () {
+
+    it('get("data/text.txt")', done => {
+
+        Vue.http.get('data/text.txt').then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(res.body).toBe('text');
+            expect(res.headers.get('Content-Type')).toBe('text/plain');
+            expect(res.headers.get('Content-Length')).toBe('4');
+
+            done();
+        });
+
+    });
+
+    it('get("data/valid.json")', done => {
+
+        Vue.http.get('data/valid.json').then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(typeof res.body).toBe('object');
+            expect(res.body.foo).toBe('bar');
+
+            done();
+        });
+
+    });
+
+    it('get("data/invalid.json")', done => {
+
+        Vue.http.get('data/invalid.json').then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(res.body).toBeNull();
+
+            done();
+        });
+
+    });
+
+    it('get("github.com/avatar")', done => {
+
+        Vue.http.get('https://avatars1.githubusercontent.com/u/6128107').then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(res.body instanceof Blob).toBe(true);
+            expect(res.body.type).toBe('image/png');
+
+            done();
+        });
+
+    });
+
+    it('get("cors-api.appspot.com")', done => {
+
+        Vue.http.get('http://server.cors-api.appspot.com/server?id=1&enable=true').then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(typeof res.body).toBe('object');
+            expect(res.body.shift().requestType).toBe('cors');
+            expect(res.headers.get('Content-Type')).toBe('application/json');
+
+            done();
+        });
+
+    });
+
+    it('jsonp("jsfiddle.net/jsonp")', done => {
+
+        Vue.http.jsonp('http://jsfiddle.net/echo/jsonp/', {params: {foo: 'bar'}}).then(res => {
+
+            expect(res.ok).toBe(true);
+            expect(res.status).toBe(200);
+            expect(typeof res.body).toBe('object');
+            expect(res.body.foo).toBe('bar');
+
+            done();
+        });
+
+    });
+
+});
+
+describe('this.$http', function () {
+
+    it('get("data/valid.json")', done => {
+
+        var vm = new Vue({
+
+            created() {
+
+                this.$http.get('data/valid.json').then(res => {
+
+                    expect(this).toBe(vm);
+                    expect(res.ok).toBe(true);
+                    expect(res.status).toBe(200);
+                    expect(typeof res.body).toBe('object');
+                    expect(res.body.foo).toBe('bar');
+
+                    done();
+
+                });
+
+            }
+
+        });
+
+    });
+
+    it('get("data/valid.json") with timeout', done => {
+
+        var vm = new Vue({
+
+            created() {
+
+                var random = Math.random().toString(36).substr(2);
+
+                this.$http.get(`data/valid.json?${random}`, {timeout: 1}).then(res => {
+
+                    fail('Callback has been called');
+
+                }, res => {
+
+                    expect(res.ok).toBe(false);
+                    expect(res.status).toBe(0);
+
+                    done();
+
+                });
+
+            }
+
+        });
+
+    });
+
+    it('get("data/valid.json") with abort()', done => {
+
+        var vm = new Vue({
+
+            created() {
+
+                var random = Math.random().toString(36).substr(2);
+
+                this.$http.get(`data/valid.json?${random}`, {
+
+                    before(req) {
+                        setTimeout(() => {
+
+                            expect(typeof req.abort).toBe('function');
+
+                            req.abort();
+
+                        }, 0);
+                    }
+
+                }).then(res => {
+                    fail('Callback has been called');
+                }, res => {
+                    done();
+                });
+            }
+
+        });
+
+    });
+
+    it('get("data/notfound.json") using catch()', done => {
+
+        var vm = new Vue({
+
+            created() {
+
+                this.$http.get('data/notfound.json').catch(res => {
+
+                    expect(this).toBe(vm);
+                    expect(res.ok).toBe(false);
+                    expect(res.status).toBe(404);
+
+                    done();
+                });
+
+            }
+
+        });
+
+    });
+
+});
\ No newline at end of file
Index: app/Http/Controllers/Pub/TestController.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/Http/Controllers/Pub/TestController.php	(revision 3d426e1c0d52d26cb969fee1b80a5af3508614bb)
+++ app/Http/Controllers/Pub/TestController.php	(revision )
@@ -17,6 +17,6 @@
 {
     public function index()
     {
-        echo cdnAsset('/bower_components/flat-ui/dist/css/vendor/bootstrap/css/bootstrap.min.css');
+        echo json_encode(Auth::user()->ownForms);
     }
 }
Index: public/node_modules/vue-resource/src/lib/promise.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/lib/promise.js	(revision )
+++ public/node_modules/vue-resource/src/lib/promise.js	(revision )
@@ -0,0 +1,177 @@
+/**
+ * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
+ */
+
+const RESOLVED = 0;
+const REJECTED = 1;
+const PENDING  = 2;
+
+import { nextTick } from '../util';
+
+export default function Promise(executor) {
+
+    this.state = PENDING;
+    this.value = undefined;
+    this.deferred = [];
+
+    var promise = this;
+
+    try {
+        executor(function (x) {
+            promise.resolve(x);
+        }, function (r) {
+            promise.reject(r);
+        });
+    } catch (e) {
+        promise.reject(e);
+    }
+}
+
+Promise.reject = function (r) {
+    return new Promise(function (resolve, reject) {
+        reject(r);
+    });
+};
+
+Promise.resolve = function (x) {
+    return new Promise(function (resolve, reject) {
+        resolve(x);
+    });
+};
+
+Promise.all = function all(iterable) {
+    return new Promise(function (resolve, reject) {
+        var count = 0, result = [];
+
+        if (iterable.length === 0) {
+            resolve(result);
+        }
+
+        function resolver(i) {
+            return function (x) {
+                result[i] = x;
+                count += 1;
+
+                if (count === iterable.length) {
+                    resolve(result);
+                }
+            };
+        }
+
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise.resolve(iterable[i]).then(resolver(i), reject);
+        }
+    });
+};
+
+Promise.race = function race(iterable) {
+    return new Promise(function (resolve, reject) {
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise.resolve(iterable[i]).then(resolve, reject);
+        }
+    });
+};
+
+var p = Promise.prototype;
+
+p.resolve = function resolve(x) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (x === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        var called = false;
+
+        try {
+            var then = x && x['then'];
+
+            if (x !== null && typeof x === 'object' && typeof then === 'function') {
+                then.call(x, function (x) {
+                    if (!called) {
+                        promise.resolve(x);
+                    }
+                    called = true;
+
+                }, function (r) {
+                    if (!called) {
+                        promise.reject(r);
+                    }
+                    called = true;
+                });
+                return;
+            }
+        } catch (e) {
+            if (!called) {
+                promise.reject(e);
+            }
+            return;
+        }
+
+        promise.state = RESOLVED;
+        promise.value = x;
+        promise.notify();
+    }
+};
+
+p.reject = function reject(reason) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (reason === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        promise.state = REJECTED;
+        promise.value = reason;
+        promise.notify();
+    }
+};
+
+p.notify = function notify() {
+    var promise = this;
+
+    nextTick(function () {
+        if (promise.state !== PENDING) {
+            while (promise.deferred.length) {
+                var deferred = promise.deferred.shift(),
+                    onResolved = deferred[0],
+                    onRejected = deferred[1],
+                    resolve = deferred[2],
+                    reject = deferred[3];
+
+                try {
+                    if (promise.state === RESOLVED) {
+                        if (typeof onResolved === 'function') {
+                            resolve(onResolved.call(undefined, promise.value));
+                        } else {
+                            resolve(promise.value);
+                        }
+                    } else if (promise.state === REJECTED) {
+                        if (typeof onRejected === 'function') {
+                            resolve(onRejected.call(undefined, promise.value));
+                        } else {
+                            reject(promise.value);
+                        }
+                    }
+                } catch (e) {
+                    reject(e);
+                }
+            }
+        }
+    });
+};
+
+p.then = function then(onResolved, onRejected) {
+    var promise = this;
+
+    return new Promise(function (resolve, reject) {
+        promise.deferred.push([onResolved, onRejected, resolve, reject]);
+        promise.notify();
+    });
+};
+
+p.catch = function (onRejected) {
+    return this.then(undefined, onRejected);
+};
Index: public/node_modules/vue/src/platforms/weex/runtime/directives/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/directives/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/directives/index.js	(revision )
@@ -0,0 +1,2 @@
+export default {
+}
Index: app/Http/routes.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/Http/routes.php	(revision 3d426e1c0d52d26cb969fee1b80a5af3508614bb)
+++ app/Http/routes.php	(revision )
@@ -83,6 +83,7 @@
     Route::post('admin/handle', 'FormAdminController@handle')->name('web.handle');
     Route::get('admin/inviteMsgNum', 'FormAdminController@inviteMsgNum')->name('web.inviteMsgNum');
     Route::any('admin/getExceptUsers', 'FormAdminController@getExceptUsers');
+    Route::get('admin/getOwnForms', 'FormAdminController@getOwnForms');
     Route::resource('admin', 'FormAdminController');
 
     Route::get('wechat/test', 'WechatController@test')->name('web.wechat.test');
Index: public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/readme.md	(revision )
@@ -0,0 +1,31 @@
+# prepend-http [![Build Status](https://travis-ci.org/sindresorhus/prepend-http.svg?branch=master)](https://travis-ci.org/sindresorhus/prepend-http)
+
+> Prepend `http://` to humanized URLs like `todomvc.com` and `localhost`
+
+
+## Install
+
+```
+$ npm install --save prepend-http
+```
+
+
+## Usage
+
+```js
+const prependHttp = require('prepend-http');
+
+prependHttp('todomvc.com');
+//=> 'http://todomvc.com'
+
+prependHttp('localhost');
+//=> 'http://localhost'
+
+prependHttp('http://todomvc.com');
+//=> 'http://todomvc.com'
+```
+
+
+## License
+
+MIT  [Sindre Sorhus](https://sindresorhus.com)
Index: public/node_modules/vue-resource/node_modules/got/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/package.json	(revision )
@@ -0,0 +1,92 @@
+{
+  "name": "got",
+  "version": "6.7.1",
+  "description": "Simplified HTTP requests",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/got"
+  },
+  "maintainers": [
+    {
+      "name": "Sindre Sorhus",
+      "email": "sindresorhus@gmail.com",
+      "url": "sindresorhus.com"
+    },
+    {
+      "name": "Vsevolod Strukchinsky",
+      "email": "floatdrop@gmail.com",
+      "url": "github.com/floatdrop"
+    }
+  ],
+  "engines": {
+    "node": ">=4"
+  },
+  "browser": {
+    "unzip-response": false
+  },
+  "scripts": {
+    "test": "xo && nyc ava",
+    "coveralls": "nyc report --reporter=text-lcov | coveralls"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "http",
+    "https",
+    "get",
+    "got",
+    "url",
+    "uri",
+    "request",
+    "util",
+    "utility",
+    "simple",
+    "curl",
+    "wget",
+    "fetch"
+  ],
+  "dependencies": {
+    "create-error-class": "^3.0.0",
+    "duplexer3": "^0.1.4",
+    "get-stream": "^3.0.0",
+    "is-redirect": "^1.0.0",
+    "is-retry-allowed": "^1.0.0",
+    "is-stream": "^1.0.0",
+    "lowercase-keys": "^1.0.0",
+    "safe-buffer": "^5.0.1",
+    "timed-out": "^4.0.0",
+    "unzip-response": "^2.0.1",
+    "url-parse-lax": "^1.0.0"
+  },
+  "devDependencies": {
+    "ava": "^0.17.0",
+    "coveralls": "^2.11.4",
+    "form-data": "^2.1.1",
+    "get-port": "^2.0.0",
+    "into-stream": "^3.0.0",
+    "nyc": "^10.0.0",
+    "pem": "^1.4.4",
+    "pify": "^2.3.0",
+    "tempfile": "^1.1.1",
+    "xo": "*"
+  },
+  "xo": {
+    "esnext": true
+  },
+  "ava": {
+    "concurrency": 4
+  },
+  "readme": "<h1 align=\"center\">\n\t<br>\n\t<img width=\"360\" src=\"https://rawgit.com/sindresorhus/got/master/media/logo.svg\" alt=\"got\">\n\t<br>\n\t<br>\n\t<br>\n</h1>\n\n> Simplified HTTP requests\n\n[![Build Status](https://travis-ci.org/sindresorhus/got.svg?branch=master)](https://travis-ci.org/sindresorhus/got) [![Coverage Status](https://coveralls.io/repos/github/sindresorhus/got/badge.svg?branch=master)](https://coveralls.io/github/sindresorhus/got?branch=master) [![Downloads](https://img.shields.io/npm/dm/got.svg)](https://npmjs.com/got)\n\nA nicer interface to the built-in [`http`](http://nodejs.org/api/http.html) module.\n\nIt supports following redirects, promises, streams, retries, automagically handling gzip/deflate and some convenience options.\n\nCreated because [`request`](https://github.com/request/request) is bloated *(several megabytes!)*.\n\n\n## Install\n\n**WARNING: Node.js 4 or higher is required for got@6 and above.** For older Node.js versions use [got@5](https://github.com/sindresorhus/got/tree/v5.x).\n\n```\n$ npm install --save got\n```\n\n\n## Usage\n\n```js\nconst fs = require('fs');\nconst got = require('got');\n\ngot('todomvc.com')\n\t.then(response => {\n\t\tconsole.log(response.body);\n\t\t//=> '<!doctype html> ...'\n\t})\n\t.catch(error => {\n\t\tconsole.log(error.response.body);\n\t\t//=> 'Internal server error ...'\n\t});\n\n// Streams\ngot.stream('todomvc.com').pipe(fs.createWriteStream('index.html'));\n\n// For POST, PUT and PATCH methods got.stream returns a WritableStream\nfs.createReadStream('index.html').pipe(got.stream.post('todomvc.com'));\n```\n\n\n### API\n\nIt's a `GET` request by default, but can be changed in `options`.\n\n#### got(url, [options])\n\nReturns a Promise for a `response` object with a `body` property, a `url` property with the request URL or the final URL after redirects, and a `requestUrl` property with the original request URL.\n\n##### url\n\nType: `string`, `object`\n\nThe URL to request or a [`http.request` options](https://nodejs.org/api/http.html#http_http_request_options_callback) object.\n\nProperties from `options` will override properties in the parsed `url`.\n\n##### options\n\nType: `object`\n\nAny of the [`http.request`](http://nodejs.org/api/http.html#http_http_request_options_callback) options.\n\n###### body\n\nType: `string`, `buffer`, `readableStream`, `object`\n\n*This is mutually exclusive with stream mode.*\n\nBody that will be sent with a `POST` request.\n\nIf present in `options` and `options.method` is not set, `options.method` will be set to `POST`.\n\nIf `content-length` or `transfer-encoding` is not set in `options.headers` and `body` is a string or buffer, `content-length` will be set to the body length.\n\nIf `body` is a plain object, it will be stringified with [`querystring.stringify`](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options) and sent as `application/x-www-form-urlencoded`.\n\n###### encoding\n\nType: `string`, `null`<br>\nDefault: `'utf8'`\n\nEncoding to be used on `setEncoding` of the response data. If `null`, the body is returned as a Buffer.\n\n###### json\n\nType: `boolean`<br>\nDefault: `false`\n\n*This is mutually exclusive with stream mode.*\n\nParse response body with `JSON.parse` and set `accept` header to `application/json`.\n\n###### query\n\nType: `string`, `object`<br>\n\nQuery string object that will be added to the request URL. This will override the query string in `url`.\n\n###### timeout\n\nType: `number`, `object`\n\nMilliseconds to wait for a server to send response headers before aborting request with `ETIMEDOUT` error.\n\nOption accepts `object` with separate `connect` and `socket` fields for connection and socket inactivity timeouts.\n\n###### retries\n\nType: `number`, `function`<br>\nDefault: `5`\n\nNumber of request retries when network errors happens. Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 0).\n\nOption accepts `function` with `retry` and `error` arguments. Function must return delay in milliseconds (`0` return value cancels retry).\n\n**Note:** if `retries` is `number`, `ENOTFOUND` and `ENETUNREACH` error will not be retried (see full list in [`is-retry-allowed`](https://github.com/floatdrop/is-retry-allowed/blob/master/index.js#L12) module).\n\n###### followRedirect\n\nType: `boolean`<br>\nDefault: `true`\n\nDefines if redirect responses should be followed automatically.\n\n\n#### Streams\n\n#### got.stream(url, [options])\n\n`stream` method will return Duplex stream with additional events:\n\n##### .on('request', request)\n\n`request` event to get the request object of the request.\n\n**Tip**: You can use `request` event to abort request:\n\n```js\ngot.stream('github.com')\n\t.on('request', req => setTimeout(() => req.abort(), 50));\n```\n\n##### .on('response', response)\n\n`response` event to get the response object of the final request.\n\n##### .on('redirect', response, nextOptions)\n\n`redirect` event to get the response object of a redirect. The second argument is options for the next request to the redirect location.\n\n##### .on('error', error, body, response)\n\n`error` event emitted in case of protocol error (like `ENOTFOUND` etc.) or status error (4xx or 5xx). The second argument is the body of the server response in case of status error. The third argument is response object.\n\n#### got.get(url, [options])\n#### got.post(url, [options])\n#### got.put(url, [options])\n#### got.patch(url, [options])\n#### got.head(url, [options])\n#### got.delete(url, [options])\n\nSets `options.method` to the method name and makes a request.\n\n\n## Errors\n\nEach error contains (if available) `statusCode`, `statusMessage`, `host`, `hostname`, `method` and `path` properties to make debugging easier.\n\nIn Promise mode, the `response` is attached to the error.\n\n#### got.RequestError\n\nWhen a request fails. Contains a `code` property with error class code, like `ECONNREFUSED`.\n\n#### got.ReadError\n\nWhen reading from response stream fails.\n\n#### got.ParseError\n\nWhen `json` option is enabled and `JSON.parse` fails.\n\n#### got.HTTPError\n\nWhen server response code is not 2xx. Contains `statusCode` and `statusMessage`.\n\n#### got.MaxRedirectsError\n\nWhen server redirects you more than 10 times.\n\n\n## Proxies\n\nYou can use the [`tunnel`](https://github.com/koichik/node-tunnel) module with the `agent` option to work with proxies:\n\n```js\nconst got = require('got');\nconst tunnel = require('tunnel');\n\ngot('todomvc.com', {\n\tagent: tunnel.httpOverHttp({\n\t\tproxy: {\n\t\t\thost: 'localhost'\n\t\t}\n\t})\n});\n```\n\n\n## Cookies\n\nYou can use the [`cookie`](https://github.com/jshttp/cookie) module to include cookies in a request:\n\n```js\nconst got = require('got');\nconst cookie = require('cookie');\n\ngot('google.com', {\n\theaders: {\n\t\tcookie: cookie.serialize('foo', 'bar')\n\t}\n});\n```\n\n\n## Form data\n\nYou can use the [`form-data`](https://github.com/form-data/form-data) module to create POST request with form data:\n\n```js\nconst fs = require('fs');\nconst got = require('got');\nconst FormData = require('form-data');\nconst form = new FormData();\n\nform.append('my_file', fs.createReadStream('/foo/bar.jpg'));\n\ngot.post('google.com', {\n\tbody: form\n});\n```\n\n\n## OAuth\n\nYou can use the [`oauth-1.0a`](https://github.com/ddo/oauth-1.0a) module to create a signed OAuth request:\n\n```js\nconst got = require('got');\nconst crypto  = require('crypto');\nconst OAuth = require('oauth-1.0a');\n\nconst oauth = OAuth({\n\tconsumer: {\n\t\tkey: process.env.CONSUMER_KEY,\n\t\tsecret: process.env.CONSUMER_SECRET\n\t},\n\tsignature_method: 'HMAC-SHA1',\n\thash_function: (baseString, key) => crypto.createHmac('sha1', key).update(baseString).digest('base64')\n});\n\nconst token = {\n\tkey: process.env.ACCESS_TOKEN,\n\tsecret: process.env.ACCESS_TOKEN_SECRET\n};\n\nconst url = 'https://api.twitter.com/1.1/statuses/home_timeline.json';\n\ngot(url, {\n\theaders: oauth.toHeader(oauth.authorize({url, method: 'GET'}, token)),\n\tjson: true\n});\n```\n\n\n## Unix Domain Sockets\n\nRequests can also be sent via [unix domain sockets](http://serverfault.com/questions/124517/whats-the-difference-between-unix-socket-and-tcp-ip-socket). Use the following URL scheme: `PROTOCOL://unix:SOCKET:PATH`.\n\n- `PROTOCOL` - `http` or `https` *(optional)*\n- `SOCKET` - absolute path to a unix domain socket, e.g. `/var/run/docker.sock`\n- `PATH` - request path, e.g. `/v2/keys`\n\n```js\ngot('http://unix:/var/run/docker.sock:/containers/json');\n\n// or without protocol (http by default)\ngot('unix:/var/run/docker.sock:/containers/json');\n```\n\n\n## Tip\n\nIt's a good idea to set the `'user-agent'` header so the provider can more easily see how their resource is used. By default, it's the URL to this repo.\n\n```js\nconst got = require('got');\nconst pkg = require('./package.json');\n\ngot('todomvc.com', {\n\theaders: {\n\t\t'user-agent': `my-module/${pkg.version} (https://github.com/username/my-module)`\n\t}\n});\n```\n\n\n## Related\n\n- [gh-got](https://github.com/sindresorhus/gh-got) - Convenience wrapper for interacting with the GitHub API\n- [travis-got](https://github.com/samverschueren/travis-got) - Convenience wrapper for interacting with the Travis API\n\n\n## Created by\n\n[![Sindre Sorhus](https://avatars.githubusercontent.com/u/170270?v=3&s=100)](https://sindresorhus.com) | [![Vsevolod Strukchinsky](https://avatars.githubusercontent.com/u/365089?v=3&s=100)](https://github.com/floatdrop)\n---|---\n[Sindre Sorhus](https://sindresorhus.com) | [Vsevolod Strukchinsky](https://github.com/floatdrop)\n\n\n## License\n\nMIT  [Sindre Sorhus](https://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/got/issues"
+  },
+  "_id": "got@6.7.1",
+  "dist": {
+    "shasum": "13921ca78731ec0f4cb8fad2bddabf8abbe1820c"
+  },
+  "_from": "got@^6.7.1",
+  "_resolved": "https://registry.npmjs.org/got/-/got-6.7.1.tgz"
+}
Index: public/node_modules/vue/src/compiler/directives/model.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/directives/model.js	(revision )
+++ public/node_modules/vue/src/compiler/directives/model.js	(revision )
@@ -0,0 +1,133 @@
+/* @flow */
+
+/**
+ * Cross-platform code generation for component v-model
+ */
+export function genComponentModel (
+  el: ASTElement,
+  value: string,
+  modifiers: ?ASTModifiers
+): ?boolean {
+  const { number, trim } = modifiers || {}
+
+  const baseValueExpression = '$$v'
+  let valueExpression = baseValueExpression
+  if (trim) {
+    valueExpression =
+      `(typeof ${baseValueExpression} === 'string'` +
+        `? ${baseValueExpression}.trim()` +
+        `: ${baseValueExpression})`
+  }
+  if (number) {
+    valueExpression = `_n(${valueExpression})`
+  }
+  const assignment = genAssignmentCode(value, valueExpression)
+
+  el.model = {
+    value: `(${value})`,
+    expression: `"${value}"`,
+    callback: `function (${baseValueExpression}) {${assignment}}`
+  }
+}
+
+/**
+ * Cross-platform codegen helper for generating v-model value assignment code.
+ */
+export function genAssignmentCode (
+  value: string,
+  assignment: string
+): string {
+  const modelRs = parseModel(value)
+  if (modelRs.idx === null) {
+    return `${value}=${assignment}`
+  } else {
+    return `var $$exp = ${modelRs.exp}, $$idx = ${modelRs.idx};` +
+      `if (!Array.isArray($$exp)){` +
+        `${value}=${assignment}}` +
+      `else{$$exp.splice($$idx, 1, ${assignment})}`
+  }
+}
+
+/**
+ * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
+ *
+ * for loop possible cases:
+ *
+ * - test
+ * - test[idx]
+ * - test[test1[idx]]
+ * - test["a"][idx]
+ * - xxx.test[a[a].test1[idx]]
+ * - test.xxx.a["asa"][test1[idx]]
+ *
+ */
+
+let len, str, chr, index, expressionPos, expressionEndPos
+
+export function parseModel (val: string): Object {
+  str = val
+  len = str.length
+  index = expressionPos = expressionEndPos = 0
+
+  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
+    return {
+      exp: val,
+      idx: null
+    }
+  }
+
+  while (!eof()) {
+    chr = next()
+    /* istanbul ignore if */
+    if (isStringStart(chr)) {
+      parseString(chr)
+    } else if (chr === 0x5B) {
+      parseBracket(chr)
+    }
+  }
+
+  return {
+    exp: val.substring(0, expressionPos),
+    idx: val.substring(expressionPos + 1, expressionEndPos)
+  }
+}
+
+function next (): number {
+  return str.charCodeAt(++index)
+}
+
+function eof (): boolean {
+  return index >= len
+}
+
+function isStringStart (chr: number): boolean {
+  return chr === 0x22 || chr === 0x27
+}
+
+function parseBracket (chr: number): void {
+  let inBracket = 1
+  expressionPos = index
+  while (!eof()) {
+    chr = next()
+    if (isStringStart(chr)) {
+      parseString(chr)
+      continue
+    }
+    if (chr === 0x5B) inBracket++
+    if (chr === 0x5D) inBracket--
+    if (inBracket === 0) {
+      expressionEndPos = index
+      break
+    }
+  }
+}
+
+function parseString (chr: number): void {
+  const stringQuote = chr
+  while (!eof()) {
+    chr = next()
+    if (chr === stringQuote) {
+      break
+    }
+  }
+}
Index: public/node_modules/vue/src/platforms/web/runtime/modules/class.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/modules/class.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/modules/class.js	(revision )
@@ -0,0 +1,32 @@
+/* @flow */
+
+import { genClassForVnode, concat, stringifyClass } from 'web/util/index'
+
+function updateClass (oldVnode: any, vnode: any) {
+  const el = vnode.elm
+  const data: VNodeData = vnode.data
+  const oldData: VNodeData = oldVnode.data
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  let cls = genClassForVnode(vnode)
+
+  // handle transition classes
+  const transitionClass = el._transitionClasses
+  if (transitionClass) {
+    cls = concat(cls, stringifyClass(transitionClass))
+  }
+
+  // set the class
+  if (cls !== el._prevClass) {
+    el.setAttribute('class', cls)
+    el._prevClass = cls
+  }
+}
+
+export default {
+  create: updateClass,
+  update: updateClass
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/package.json	(revision )
@@ -0,0 +1,46 @@
+{
+  "name": "duplexer3",
+  "version": "0.1.4",
+  "description": "Like duplexer but using streams3",
+  "engine": {
+    "node": ">=4"
+  },
+  "files": [
+    "index.js"
+  ],
+  "scripts": {
+    "test": "mocha -R tap"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/floatdrop/duplexer3"
+  },
+  "keywords": [
+    "duplex",
+    "duplexer",
+    "stream",
+    "stream3",
+    "join",
+    "combine"
+  ],
+  "author": {
+    "name": "Conrad Pankoff",
+    "email": "deoxxa@fknsrs.biz",
+    "url": "http://www.fknsrs.biz/"
+  },
+  "license": "BSD-3-Clause",
+  "devDependencies": {
+    "mocha": "^2.2.5"
+  },
+  "readme": "# duplexer3 [![Build Status](https://travis-ci.org/floatdrop/duplexer3.svg?branch=master)](https://travis-ci.org/floatdrop/duplexer3) [![Coverage Status](https://coveralls.io/repos/floatdrop/duplexer3/badge.svg?branch=master&service=github)](https://coveralls.io/github/floatdrop/duplexer3?branch=master)\n\nLike [duplexer2](https://github.com/deoxxa/duplexer2) but using Streams3 without readable-stream dependency\n\n```javascript\nvar stream = require(\"stream\");\n\nvar duplexer3 = require(\"duplexer3\");\n\nvar writable = new stream.Writable({objectMode: true}),\n    readable = new stream.Readable({objectMode: true});\n\nwritable._write = function _write(input, encoding, done) {\n  if (readable.push(input)) {\n    return done();\n  } else {\n    readable.once(\"drain\", done);\n  }\n};\n\nreadable._read = function _read(n) {\n  // no-op\n};\n\n// simulate the readable thing closing after a bit\nwritable.once(\"finish\", function() {\n  setTimeout(function() {\n    readable.push(null);\n  }, 500);\n});\n\nvar duplex = duplexer3(writable, readable);\n\nduplex.on(\"data\", function(e) {\n  console.log(\"got data\", JSON.stringify(e));\n});\n\nduplex.on(\"finish\", function() {\n  console.log(\"got finish event\");\n});\n\nduplex.on(\"end\", function() {\n  console.log(\"got end event\");\n});\n\nduplex.write(\"oh, hi there\", function() {\n  console.log(\"finished writing\");\n});\n\nduplex.end(function() {\n  console.log(\"finished ending\");\n});\n```\n\n```\ngot data \"oh, hi there\"\nfinished writing\ngot finish event\nfinished ending\ngot end event\n```\n\n## Overview\n\nThis is a reimplementation of [duplexer](https://www.npmjs.com/package/duplexer) using the\nStreams3 API which is standard in Node as of v4. Everything largely\nworks the same.\n\n\n\n## Installation\n\n[Available via `npm`](https://docs.npmjs.com/cli/install):\n\n```\n$ npm i duplexer3\n```\n\n## API\n\n### duplexer3\n\nCreates a new `DuplexWrapper` object, which is the actual class that implements\nmost of the fun stuff. All that fun stuff is hidden. DON'T LOOK.\n\n```javascript\nduplexer3([options], writable, readable)\n```\n\n```javascript\nconst duplex = duplexer3(new stream.Writable(), new stream.Readable());\n```\n\nArguments\n\n* __options__ - an object specifying the regular `stream.Duplex` options, as\n  well as the properties described below.\n* __writable__ - a writable stream\n* __readable__ - a readable stream\n\nOptions\n\n* __bubbleErrors__ - a boolean value that specifies whether to bubble errors\n  from the underlying readable/writable streams. Default is `true`.\n\n\n## License\n\n3-clause BSD. [A copy](./LICENSE) is included with the source.\n\n## Contact\n\n* GitHub ([deoxxa](http://github.com/deoxxa))\n* Twitter ([@deoxxa](http://twitter.com/deoxxa))\n* Email ([deoxxa@fknsrs.biz](mailto:deoxxa@fknsrs.biz))\n",
+  "readmeFilename": "README.md",
+  "bugs": {
+    "url": "https://github.com/floatdrop/duplexer3/issues"
+  },
+  "_id": "duplexer3@0.1.4",
+  "dist": {
+    "shasum": "b865e2d07979fe7dae4f34961a4505d83d81648c"
+  },
+  "_from": "duplexer3@^0.1.4",
+  "_resolved": "https://registry.npmjs.org/duplexer3/-/duplexer3-0.1.4.tgz"
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/index.js	(revision )
@@ -0,0 +1,14 @@
+'use strict';
+var url = require('url');
+var prependHttp = require('prepend-http');
+
+module.exports = function (x) {
+	var withProtocol = prependHttp(x);
+	var parsed = url.parse(withProtocol);
+
+	if (withProtocol !== x) {
+		parsed.protocol = null;
+	}
+
+	return parsed;
+};
Index: public/node_modules/vue-resource/src/http/interceptor/cors.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/interceptor/cors.js	(revision )
+++ public/node_modules/vue-resource/src/http/interceptor/cors.js	(revision )
@@ -0,0 +1,30 @@
+/**
+ * CORS Interceptor.
+ */
+
+import Url from '../../url/index';
+import xdrClient from '../client/xdr';
+import { inBrowser } from '../../util';
+
+const SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();
+
+export default function (request, next) {
+
+    if (inBrowser) {
+
+        var orgUrl = Url.parse(location.href);
+        var reqUrl = Url.parse(request.getUrl());
+
+        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {
+
+            request.crossOrigin = true;
+            request.emulateHTTP = false;
+
+            if (!SUPPORTS_CORS) {
+                request.client = xdrClient;
+            }
+        }
+    }
+
+    next();
+}
Index: public/node_modules/vue/src/platforms/web/runtime/directives/model.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/directives/model.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/directives/model.js	(revision )
@@ -0,0 +1,125 @@
+/**
+ * Not type checking this file because flow doesn't like attaching
+ * properties to Elements.
+ */
+
+import { looseEqual, looseIndexOf } from 'shared/util'
+import { warn, isAndroid, isIE9, isIE, isEdge } from 'core/util/index'
+
+/* istanbul ignore if */
+if (isIE9) {
+  // http://www.matts411.com/post/internet-explorer-9-oninput/
+  document.addEventListener('selectionchange', () => {
+    const el = document.activeElement
+    if (el && el.vmodel) {
+      trigger(el, 'input')
+    }
+  })
+}
+
+export default {
+  inserted (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      const cb = () => {
+        setSelected(el, binding, vnode.context)
+      }
+      cb()
+      /* istanbul ignore if */
+      if (isIE || isEdge) {
+        setTimeout(cb, 0)
+      }
+    } else if (vnode.tag === 'textarea' || el.type === 'text') {
+      el._vModifiers = binding.modifiers
+      if (!binding.modifiers.lazy) {
+        if (!isAndroid) {
+          el.addEventListener('compositionstart', onCompositionStart)
+          el.addEventListener('compositionend', onCompositionEnd)
+        }
+        /* istanbul ignore if */
+        if (isIE9) {
+          el.vmodel = true
+        }
+      }
+    }
+  },
+  componentUpdated (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      setSelected(el, binding, vnode.context)
+      // in case the options rendered by v-for have changed,
+      // it's possible that the value is out-of-sync with the rendered options.
+      // detect such cases and filter out values that no longer has a matching
+      // option in the DOM.
+      const needReset = el.multiple
+        ? binding.value.some(v => hasNoMatchingOption(v, el.options))
+        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options)
+      if (needReset) {
+        trigger(el, 'change')
+      }
+    }
+  }
+}
+
+function setSelected (el, binding, vm) {
+  const value = binding.value
+  const isMultiple = el.multiple
+  if (isMultiple && !Array.isArray(value)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      `<select multiple v-model="${binding.expression}"> ` +
+      `expects an Array value for its binding, but got ${
+        Object.prototype.toString.call(value).slice(8, -1)
+      }`,
+      vm
+    )
+    return
+  }
+  let selected, option
+  for (let i = 0, l = el.options.length; i < l; i++) {
+    option = el.options[i]
+    if (isMultiple) {
+      selected = looseIndexOf(value, getValue(option)) > -1
+      if (option.selected !== selected) {
+        option.selected = selected
+      }
+    } else {
+      if (looseEqual(getValue(option), value)) {
+        if (el.selectedIndex !== i) {
+          el.selectedIndex = i
+        }
+        return
+      }
+    }
+  }
+  if (!isMultiple) {
+    el.selectedIndex = -1
+  }
+}
+
+function hasNoMatchingOption (value, options) {
+  for (let i = 0, l = options.length; i < l; i++) {
+    if (looseEqual(getValue(options[i]), value)) {
+      return false
+    }
+  }
+  return true
+}
+
+function getValue (option) {
+  return '_value' in option
+    ? option._value
+    : option.value
+}
+
+function onCompositionStart (e) {
+  e.target.composing = true
+}
+
+function onCompositionEnd (e) {
+  e.target.composing = false
+  trigger(e.target, 'input')
+}
+
+function trigger (el, type) {
+  const e = document.createEvent('HTMLEvents')
+  e.initEvent(type, true, true)
+  el.dispatchEvent(e)
+}
Index: public/node_modules/vue/src/core/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/index.js	(revision )
+++ public/node_modules/vue/src/core/index.js	(revision )
@@ -0,0 +1,13 @@
+import Vue from './instance/index'
+import { initGlobalAPI } from './global-api/index'
+import { isServerRendering } from 'core/util/env'
+
+initGlobalAPI(Vue)
+
+Object.defineProperty(Vue.prototype, '$isServer', {
+  get: isServerRendering
+})
+
+Vue.version = '__VERSION__'
+
+export default Vue
Index: public/node_modules/vue/src/platforms/weex/runtime/modules/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/modules/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/modules/index.js	(revision )
@@ -0,0 +1,13 @@
+import attrs from './attrs'
+import klass from './class'
+import events from './events'
+import style from './style'
+import transition from './transition'
+
+export default [
+  attrs,
+  klass,
+  events,
+  style,
+  transition
+]
Index: public/node_modules/vue/src/core/observer/dep.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/observer/dep.js	(revision )
+++ public/node_modules/vue/src/core/observer/dep.js	(revision )
@@ -0,0 +1,58 @@
+/* @flow */
+
+import type Watcher from './watcher'
+import { remove } from '../util/index'
+
+let uid = 0
+
+/**
+ * A dep is an observable that can have multiple
+ * directives subscribing to it.
+ */
+export default class Dep {
+  static target: ?Watcher;
+  id: number;
+  subs: Array<Watcher>;
+
+  constructor () {
+    this.id = uid++
+    this.subs = []
+  }
+
+  addSub (sub: Watcher) {
+    this.subs.push(sub)
+  }
+
+  removeSub (sub: Watcher) {
+    remove(this.subs, sub)
+  }
+
+  depend () {
+    if (Dep.target) {
+      Dep.target.addDep(this)
+    }
+  }
+
+  notify () {
+    // stabilize the subscriber list first
+    const subs = this.subs.slice()
+    for (let i = 0, l = subs.length; i < l; i++) {
+      subs[i].update()
+    }
+  }
+}
+
+// the current target watcher being evaluated.
+// this is globally unique because there could be only one
+// watcher being evaluated at any time.
+Dep.target = null
+const targetStack = []
+
+export function pushTarget (_target: Watcher) {
+  if (Dep.target) targetStack.push(Dep.target)
+  Dep.target = _target
+}
+
+export function popTarget () {
+  Dep.target = targetStack.pop()
+}
Index: public/node_modules/vue/src/entries/web-runtime-with-compiler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/entries/web-runtime-with-compiler.js	(revision )
+++ public/node_modules/vue/src/entries/web-runtime-with-compiler.js	(revision )
@@ -0,0 +1,97 @@
+/* @flow */
+
+import Vue from './web-runtime'
+import config from 'core/config'
+import { perf } from 'core/util/perf'
+import { query } from 'web/util/index'
+import { warn, cached } from 'core/util/index'
+import { shouldDecodeNewlines } from 'web/util/compat'
+import { compileToFunctions } from 'web/compiler/index'
+
+const idToTemplate = cached(id => {
+  const el = query(id)
+  return el && el.innerHTML
+})
+
+const mount = Vue.prototype.$mount
+Vue.prototype.$mount = function (
+  el?: string | Element,
+  hydrating?: boolean
+): Component {
+  el = el && query(el)
+
+  /* istanbul ignore if */
+  if (el === document.body || el === document.documentElement) {
+    process.env.NODE_ENV !== 'production' && warn(
+      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
+    )
+    return this
+  }
+
+  const options = this.$options
+  // resolve template/el and convert to render function
+  if (!options.render) {
+    let template = options.template
+    if (template) {
+      if (typeof template === 'string') {
+        if (template.charAt(0) === '#') {
+          template = idToTemplate(template)
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !template) {
+            warn(
+              `Template element not found or is empty: ${options.template}`,
+              this
+            )
+          }
+        }
+      } else if (template.nodeType) {
+        template = template.innerHTML
+      } else {
+        if (process.env.NODE_ENV !== 'production') {
+          warn('invalid template option:' + template, this)
+        }
+        return this
+      }
+    } else if (el) {
+      template = getOuterHTML(el)
+    }
+    if (template) {
+      /* istanbul ignore if */
+      if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+        perf.mark('compile')
+      }
+
+      const { render, staticRenderFns } = compileToFunctions(template, {
+        shouldDecodeNewlines,
+        delimiters: options.delimiters
+      }, this)
+      options.render = render
+      options.staticRenderFns = staticRenderFns
+
+      /* istanbul ignore if */
+      if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+        perf.mark('compile end')
+        perf.measure(`${this._name} compile`, 'compile', 'compile end')
+      }
+    }
+  }
+  return mount.call(this, el, hydrating)
+}
+
+/**
+ * Get outerHTML of elements, taking care
+ * of SVG elements in IE as well.
+ */
+function getOuterHTML (el: Element): string {
+  if (el.outerHTML) {
+    return el.outerHTML
+  } else {
+    const container = document.createElement('div')
+    container.appendChild(el.cloneNode(true))
+    return container.innerHTML
+  }
+}
+
+Vue.compile = compileToFunctions
+
+export default Vue
Index: public/node_modules/vue-resource/test/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/index.js	(revision )
+++ public/node_modules/vue-resource/test/index.js	(revision )
@@ -0,0 +1,9 @@
+import Vue from 'vue';
+import VueResource from '../src/index';
+
+Vue.use(VueResource);
+
+require('./url');
+require('./http');
+require('./resource');
+require('./promise');
Index: public/node_modules/vue/src/platforms/weex/runtime/patch.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/patch.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/patch.js	(revision )
@@ -0,0 +1,16 @@
+/* @flow */
+
+import * as nodeOps from 'weex/runtime/node-ops'
+import { createPatchFunction } from 'core/vdom/patch'
+import baseModules from 'core/vdom/modules/index'
+import platformModules from 'weex/runtime/modules/index'
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+const modules = platformModules.concat(baseModules)
+
+export const patch: Function = createPatchFunction({
+  nodeOps,
+  modules,
+  LONG_LIST_THRESHOLD: 10
+})
Index: public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/readme.md	(revision )
@@ -0,0 +1,29 @@
+# unzip-response [![Build Status](https://travis-ci.org/sindresorhus/unzip-response.svg?branch=master)](https://travis-ci.org/sindresorhus/unzip-response)
+
+> Unzip a HTTP response if needed
+
+Unzips the response from [`http.request`](https://nodejs.org/api/http.html#http_http_request_options_callback) if it's gzipped/deflated, otherwise just passes it through.
+
+
+## Install
+
+```
+$ npm install --save unzip-response
+```
+
+
+## Usage
+
+```js
+const http = require('http');
+const unzipResponse = require('unzip-response');
+
+http.get('http://sindresorhus.com', res => {
+	res = unzipResponse(res);
+});
+```
+
+
+## License
+
+MIT  [Sindre Sorhus](https://sindresorhus.com)
Index: public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/index.js	(revision )
@@ -0,0 +1,18 @@
+'use strict';
+
+module.exports = Error.captureStackTrace || function (error) {
+	var container = new Error();
+
+	Object.defineProperty(error, 'stack', {
+		configurable: true,
+		get: function getStack() {
+			var stack = container.stack;
+
+			Object.defineProperty(this, 'stack', {
+				value: stack
+			});
+
+			return stack;
+		}
+	});
+};
Index: public/node_modules/vue/src/compiler/optimizer.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/optimizer.js	(revision )
+++ public/node_modules/vue/src/compiler/optimizer.js	(revision )
@@ -0,0 +1,123 @@
+/* @flow */
+
+import { makeMap, isBuiltInTag, cached, no } from 'shared/util'
+
+let isStaticKey
+let isPlatformReservedTag
+
+const genStaticKeysCached = cached(genStaticKeys)
+
+/**
+ * Goal of the optimizer: walk the generated template AST tree
+ * and detect sub-trees that are purely static, i.e. parts of
+ * the DOM that never needs to change.
+ *
+ * Once we detect these sub-trees, we can:
+ *
+ * 1. Hoist them into constants, so that we no longer need to
+ *    create fresh nodes for them on each re-render;
+ * 2. Completely skip them in the patching process.
+ */
+export function optimize (root: ?ASTElement, options: CompilerOptions) {
+  if (!root) return
+  isStaticKey = genStaticKeysCached(options.staticKeys || '')
+  isPlatformReservedTag = options.isReservedTag || no
+  // first pass: mark all non-static nodes.
+  markStatic(root)
+  // second pass: mark static roots.
+  markStaticRoots(root, false)
+}
+
+function genStaticKeys (keys: string): Function {
+  return makeMap(
+    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
+    (keys ? ',' + keys : '')
+  )
+}
+
+function markStatic (node: ASTNode) {
+  node.static = isStatic(node)
+  if (node.type === 1) {
+    // do not make component slot content static. this avoids
+    // 1. components not able to mutate slot nodes
+    // 2. static slot content fails for hot-reloading
+    if (
+      !isPlatformReservedTag(node.tag) &&
+      node.tag !== 'slot' &&
+      node.attrsMap['inline-template'] == null
+    ) {
+      return
+    }
+    for (let i = 0, l = node.children.length; i < l; i++) {
+      const child = node.children[i]
+      markStatic(child)
+      if (!child.static) {
+        node.static = false
+      }
+    }
+  }
+}
+
+function markStaticRoots (node: ASTNode, isInFor: boolean) {
+  if (node.type === 1) {
+    if (node.static || node.once) {
+      node.staticInFor = isInFor
+    }
+    // For a node to qualify as a static root, it should have children that
+    // are not just static text. Otherwise the cost of hoisting out will
+    // outweigh the benefits and it's better off to just always render it fresh.
+    if (node.static && node.children.length && !(
+      node.children.length === 1 &&
+      node.children[0].type === 3
+    )) {
+      node.staticRoot = true
+      return
+    } else {
+      node.staticRoot = false
+    }
+    if (node.children) {
+      for (let i = 0, l = node.children.length; i < l; i++) {
+        markStaticRoots(node.children[i], isInFor || !!node.for)
+      }
+    }
+    if (node.ifConditions) {
+      walkThroughConditionsBlocks(node.ifConditions, isInFor)
+    }
+  }
+}
+
+function walkThroughConditionsBlocks (conditionBlocks: ASTIfConditions, isInFor: boolean): void {
+  for (let i = 1, len = conditionBlocks.length; i < len; i++) {
+    markStaticRoots(conditionBlocks[i].block, isInFor)
+  }
+}
+
+function isStatic (node: ASTNode): boolean {
+  if (node.type === 2) { // expression
+    return false
+  }
+  if (node.type === 3) { // text
+    return true
+  }
+  return !!(node.pre || (
+    !node.hasBindings && // no dynamic bindings
+    !node.if && !node.for && // not v-if or v-for or v-else
+    !isBuiltInTag(node.tag) && // not a built-in
+    isPlatformReservedTag(node.tag) && // not a component
+    !isDirectChildOfTemplateFor(node) &&
+    Object.keys(node).every(isStaticKey)
+  ))
+}
+
+function isDirectChildOfTemplateFor (node: ASTElement): boolean {
+  while (node.parent) {
+    node = node.parent
+    if (node.tag !== 'template') {
+      return false
+    }
+    if (node.for) {
+      return true
+    }
+  }
+  return false
+}
Index: public/node_modules/vue/src/compiler/parser/html-parser.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/parser/html-parser.js	(revision )
+++ public/node_modules/vue/src/compiler/parser/html-parser.js	(revision )
@@ -0,0 +1,308 @@
+/**
+ * Not type-checking this file because it's mostly vendor code.
+ */
+
+/*!
+ * HTML Parser By John Resig (ejohn.org)
+ * Modified by Juriy "kangax" Zaytsev
+ * Original code by Erik Arvidsson, Mozilla Public License
+ * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
+ */
+
+import { makeMap, no } from 'shared/util'
+import { isNonPhrasingTag, canBeLeftOpenTag } from 'web/compiler/util'
+
+// Regular Expressions for parsing tags and attributes
+const singleAttrIdentifier = /([^\s"'<>/=]+)/
+const singleAttrAssign = /(?:=)/
+const singleAttrValues = [
+  // attr value double quotes
+  /"([^"]*)"+/.source,
+  // attr value, single quotes
+  /'([^']*)'+/.source,
+  // attr value, no quotes
+  /([^\s"'=<>`]+)/.source
+]
+const attribute = new RegExp(
+  '^\\s*' + singleAttrIdentifier.source +
+  '(?:\\s*(' + singleAttrAssign.source + ')' +
+  '\\s*(?:' + singleAttrValues.join('|') + '))?'
+)
+
+// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
+// but for Vue templates we can enforce a simple charset
+const ncname = '[a-zA-Z_][\\w\\-\\.]*'
+const qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')'
+const startTagOpen = new RegExp('^<' + qnameCapture)
+const startTagClose = /^\s*(\/?)>/
+const endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>')
+const doctype = /^<!DOCTYPE [^>]+>/i
+const comment = /^<!--/
+const conditionalComment = /^<!\[/
+
+let IS_REGEX_CAPTURING_BROKEN = false
+'x'.replace(/x(.)?/g, function (m, g) {
+  IS_REGEX_CAPTURING_BROKEN = g === ''
+})
+
+// Special Elements (can contain anything)
+const isScriptOrStyle = makeMap('script,style', true)
+const reCache = {}
+
+const decodingMap = {
+  '&lt;': '<',
+  '&gt;': '>',
+  '&quot;': '"',
+  '&amp;': '&',
+  '&#10;': '\n'
+}
+const encodedAttr = /&(?:lt|gt|quot|amp);/g
+const encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g
+
+function decodeAttr (value, shouldDecodeNewlines) {
+  const re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr
+  return value.replace(re, match => decodingMap[match])
+}
+
+export function parseHTML (html, options) {
+  const stack = []
+  const expectHTML = options.expectHTML
+  const isUnaryTag = options.isUnaryTag || no
+  let index = 0
+  let last, lastTag
+  while (html) {
+    last = html
+    // Make sure we're not in a script or style element
+    if (!lastTag || !isScriptOrStyle(lastTag)) {
+      let textEnd = html.indexOf('<')
+      if (textEnd === 0) {
+        // Comment:
+        if (comment.test(html)) {
+          const commentEnd = html.indexOf('-->')
+
+          if (commentEnd >= 0) {
+            advance(commentEnd + 3)
+            continue
+          }
+        }
+
+        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
+        if (conditionalComment.test(html)) {
+          const conditionalEnd = html.indexOf(']>')
+
+          if (conditionalEnd >= 0) {
+            advance(conditionalEnd + 2)
+            continue
+          }
+        }
+
+        // Doctype:
+        const doctypeMatch = html.match(doctype)
+        if (doctypeMatch) {
+          advance(doctypeMatch[0].length)
+          continue
+        }
+
+        // End tag:
+        const endTagMatch = html.match(endTag)
+        if (endTagMatch) {
+          const curIndex = index
+          advance(endTagMatch[0].length)
+          parseEndTag(endTagMatch[1], curIndex, index)
+          continue
+        }
+
+        // Start tag:
+        const startTagMatch = parseStartTag()
+        if (startTagMatch) {
+          handleStartTag(startTagMatch)
+          continue
+        }
+      }
+
+      let text, rest, next
+      if (textEnd >= 0) {
+        rest = html.slice(textEnd)
+        while (
+          !endTag.test(rest) &&
+          !startTagOpen.test(rest) &&
+          !comment.test(rest) &&
+          !conditionalComment.test(rest)
+        ) {
+          // < in plain text, be forgiving and treat it as text
+          next = rest.indexOf('<', 1)
+          if (next < 0) break
+          textEnd += next
+          rest = html.slice(textEnd)
+        }
+        text = html.substring(0, textEnd)
+        advance(textEnd)
+      }
+
+      if (textEnd < 0) {
+        text = html
+        html = ''
+      }
+
+      if (options.chars && text) {
+        options.chars(text)
+      }
+    } else {
+      var stackedTag = lastTag.toLowerCase()
+      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'))
+      var endTagLength = 0
+      var rest = html.replace(reStackedTag, function (all, text, endTag) {
+        endTagLength = endTag.length
+        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
+          text = text
+            .replace(/<!--([\s\S]*?)-->/g, '$1')
+            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1')
+        }
+        if (options.chars) {
+          options.chars(text)
+        }
+        return ''
+      })
+      index += html.length - rest.length
+      html = rest
+      parseEndTag(stackedTag, index - endTagLength, index)
+    }
+
+    if (html === last) {
+      options.chars && options.chars(html)
+      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
+        options.warn(`Mal-formatted tag at end of template: "${html}"`)
+      }
+      break
+    }
+  }
+
+  // Clean up any remaining tags
+  parseEndTag()
+
+  function advance (n) {
+    index += n
+    html = html.substring(n)
+  }
+
+  function parseStartTag () {
+    const start = html.match(startTagOpen)
+    if (start) {
+      const match = {
+        tagName: start[1],
+        attrs: [],
+        start: index
+      }
+      advance(start[0].length)
+      let end, attr
+      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
+        advance(attr[0].length)
+        match.attrs.push(attr)
+      }
+      if (end) {
+        match.unarySlash = end[1]
+        advance(end[0].length)
+        match.end = index
+        return match
+      }
+    }
+  }
+
+  function handleStartTag (match) {
+    const tagName = match.tagName
+    const unarySlash = match.unarySlash
+
+    if (expectHTML) {
+      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
+        parseEndTag(lastTag)
+      }
+      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
+        parseEndTag(tagName)
+      }
+    }
+
+    const unary = isUnaryTag(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash
+
+    const l = match.attrs.length
+    const attrs = new Array(l)
+    for (let i = 0; i < l; i++) {
+      const args = match.attrs[i]
+      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
+      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
+        if (args[3] === '') { delete args[3] }
+        if (args[4] === '') { delete args[4] }
+        if (args[5] === '') { delete args[5] }
+      }
+      const value = args[3] || args[4] || args[5] || ''
+      attrs[i] = {
+        name: args[1],
+        value: decodeAttr(
+          value,
+          options.shouldDecodeNewlines
+        )
+      }
+    }
+
+    if (!unary) {
+      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs })
+      lastTag = tagName
+    }
+
+    if (options.start) {
+      options.start(tagName, attrs, unary, match.start, match.end)
+    }
+  }
+
+  function parseEndTag (tagName, start, end) {
+    let pos, lowerCasedTagName
+    if (start == null) start = index
+    if (end == null) end = index
+
+    if (tagName) {
+      lowerCasedTagName = tagName.toLowerCase()
+    }
+
+    // Find the closest opened tag of the same type
+    if (tagName) {
+      for (pos = stack.length - 1; pos >= 0; pos--) {
+        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
+          break
+        }
+      }
+    } else {
+      // If no tag name is provided, clean shop
+      pos = 0
+    }
+
+    if (pos >= 0) {
+      // Close all the open elements, up the stack
+      for (let i = stack.length - 1; i >= pos; i--) {
+        if (process.env.NODE_ENV !== 'production' &&
+            (i > pos || !tagName) &&
+            options.warn) {
+          options.warn(
+            `tag <${stack[i].tag}> has no matching end tag.`
+          )
+        }
+        if (options.end) {
+          options.end(stack[i].tag, start, end)
+        }
+      }
+
+      // Remove the open elements from the stack
+      stack.length = pos
+      lastTag = pos && stack[pos - 1].tag
+    } else if (lowerCasedTagName === 'br') {
+      if (options.start) {
+        options.start(tagName, [], true, start, end)
+      }
+    } else if (lowerCasedTagName === 'p') {
+      if (options.start) {
+        options.start(tagName, [], false, start, end)
+      }
+      if (options.end) {
+        options.end(tagName, start, end)
+      }
+    }
+  }
+}
Index: public/node_modules/vue/src/core/vdom/modules/ref.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/modules/ref.js	(revision )
+++ public/node_modules/vue/src/core/vdom/modules/ref.js	(revision )
@@ -0,0 +1,44 @@
+/* @flow */
+
+import { remove } from 'shared/util'
+
+export default {
+  create (_: any, vnode: VNodeWithData) {
+    registerRef(vnode)
+  },
+  update (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+    if (oldVnode.data.ref !== vnode.data.ref) {
+      registerRef(oldVnode, true)
+      registerRef(vnode)
+    }
+  },
+  destroy (vnode: VNodeWithData) {
+    registerRef(vnode, true)
+  }
+}
+
+export function registerRef (vnode: VNodeWithData, isRemoval: ?boolean) {
+  const key = vnode.data.ref
+  if (!key) return
+
+  const vm = vnode.context
+  const ref = vnode.componentInstance || vnode.elm
+  const refs = vm.$refs
+  if (isRemoval) {
+    if (Array.isArray(refs[key])) {
+      remove(refs[key], ref)
+    } else if (refs[key] === ref) {
+      refs[key] = undefined
+    }
+  } else {
+    if (vnode.data.refInFor) {
+      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
+        refs[key].push(ref)
+      } else {
+        refs[key] = [ref]
+      }
+    } else {
+      refs[key] = ref
+    }
+  }
+}
Index: public/node_modules/vue/src/core/instance/render.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render.js	(revision )
+++ public/node_modules/vue/src/core/instance/render.js	(revision )
@@ -0,0 +1,125 @@
+/* @flow */
+
+import {
+  warn,
+  nextTick,
+  toNumber,
+  _toString,
+  looseEqual,
+  emptyObject,
+  handleError,
+  looseIndexOf
+} from '../util/index'
+
+import VNode, {
+  cloneVNodes,
+  createTextVNode,
+  createEmptyVNode
+} from '../vdom/vnode'
+
+import { createElement } from '../vdom/create-element'
+import { renderList } from './render-helpers/render-list'
+import { renderSlot } from './render-helpers/render-slot'
+import { resolveFilter } from './render-helpers/resolve-filter'
+import { checkKeyCodes } from './render-helpers/check-keycodes'
+import { bindObjectProps } from './render-helpers/bind-object-props'
+import { renderStatic, markOnce } from './render-helpers/render-static'
+import { resolveSlots, resolveScopedSlots } from './render-helpers/resolve-slots'
+
+export function initRender (vm: Component) {
+  vm.$vnode = null // the placeholder node in parent tree
+  vm._vnode = null // the root of the child tree
+  vm._staticTrees = null
+  const parentVnode = vm.$options._parentVnode
+  const renderContext = parentVnode && parentVnode.context
+  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext)
+  vm.$scopedSlots = emptyObject
+  // bind the createElement fn to this instance
+  // so that we get proper render context inside it.
+  // args order: tag, data, children, normalizationType, alwaysNormalize
+  // internal version is used by render functions compiled from templates
+  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
+  // normalization is always applied for the public version, used in
+  // user-written render functions.
+  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)
+}
+
+export function renderMixin (Vue: Class<Component>) {
+  Vue.prototype.$nextTick = function (fn: Function) {
+    return nextTick(fn, this)
+  }
+
+  Vue.prototype._render = function (): VNode {
+    const vm: Component = this
+    const {
+      render,
+      staticRenderFns,
+      _parentVnode
+    } = vm.$options
+
+    if (vm._isMounted) {
+      // clone slot nodes on re-renders
+      for (const key in vm.$slots) {
+        vm.$slots[key] = cloneVNodes(vm.$slots[key])
+      }
+    }
+
+    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject
+
+    if (staticRenderFns && !vm._staticTrees) {
+      vm._staticTrees = []
+    }
+    // set parent vnode. this allows render functions to have access
+    // to the data on the placeholder node.
+    vm.$vnode = _parentVnode
+    // render self
+    let vnode
+    try {
+      vnode = render.call(vm._renderProxy, vm.$createElement)
+    } catch (e) {
+      handleError(e, vm, `render function`)
+      // return error render result,
+      // or previous vnode to prevent render error causing blank component
+      /* istanbul ignore else */
+      if (process.env.NODE_ENV !== 'production') {
+        vnode = vm.$options.renderError
+          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
+          : vm._vnode
+      } else {
+        vnode = vm._vnode
+      }
+    }
+    // return empty vnode in case the render function errored out
+    if (!(vnode instanceof VNode)) {
+      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
+        warn(
+          'Multiple root nodes returned from render function. Render function ' +
+          'should return a single root node.',
+          vm
+        )
+      }
+      vnode = createEmptyVNode()
+    }
+    // set parent
+    vnode.parent = _parentVnode
+    return vnode
+  }
+
+  // internal render helpers.
+  // these are exposed on the instance prototype to reduce generated render
+  // code size.
+  Vue.prototype._o = markOnce
+  Vue.prototype._n = toNumber
+  Vue.prototype._s = _toString
+  Vue.prototype._l = renderList
+  Vue.prototype._t = renderSlot
+  Vue.prototype._q = looseEqual
+  Vue.prototype._i = looseIndexOf
+  Vue.prototype._m = renderStatic
+  Vue.prototype._f = resolveFilter
+  Vue.prototype._k = checkKeyCodes
+  Vue.prototype._b = bindObjectProps
+  Vue.prototype._v = createTextVNode
+  Vue.prototype._e = createEmptyVNode
+  Vue.prototype._u = resolveScopedSlots
+}
Index: public/node_modules/vue-select2/demo/demo.all.js.map
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/demo/demo.all.js.map	(revision )
+++ public/node_modules/vue-select2/demo/demo.all.js.map	(revision )
@@ -0,0 +1,1 @@
+{"version":3,"sources":["webpack:///webpack/bootstrap f43bee4295efeed878cd","webpack:///./demo/demo.js","webpack:///vue (bower component)","webpack:///./lib/vue/dist/vue.js","webpack:///./demo/demo.vue","webpack:///demo.vue","webpack:///./src/vue-select.js","webpack:///./src/value-text-matcher.js","webpack:///./demo/demo.vue?4b50"],"names":[],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED;;;;;;;ACbA,yC;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC,oBAAoB;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,WAAW;AACxB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,EAAE;AACf,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA,oCAAmC;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,mBAAmB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA,uCAAsC;AACtC;AACA,6BAA4B;AAC5B,6BAA4B;AAC5B;AACA,+BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAU;AACV;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,6BAA4B,MAAM;AAClC;AACA,6BAA4B,MAAM;AAClC;AACA,qBAAoB,MAAM;AAC1B;AACA,qBAAoB,MAAM;AAC1B;AACA,sBAAqB,MAAM;AAC3B;AACA,sBAAqB,MAAM;AAC3B;AACA,qBAAoB,MAAM;AAC1B;AACA,qBAAoB,MAAM;AAC1B;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH,kCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd,uBAAsB,OAAO;AAC7B,uBAAsB,OAAO;AAC7B,uBAAsB,QAAQ;AAC9B,uBAAsB,QAAQ;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,8BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC,GAAG;AACrC;AACA;AACA,cAAa,MAAM;AACnB,cAAa,IAAI;AACjB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,mBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH,wBAAuB,MAAM;AAC7B,+BAA8B,OAAO;;AAErC;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;AACA,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;AACA,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA,IAAG;AACH,kBAAiB;AACjB;AACA;AACA;AACA,6BAA4B;AAC5B;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB,cAAa,IAAI;AACjB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB,cAAa,IAAI;AACjB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,IAAI;AACjB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB;AACA;AACA,cAAa,SAAS;AACtB,cAAa,IAAI;AACjB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,eAAe;AAC5B,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,KAAK;AAClB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAkD;AAClD;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,KAAK;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;;AAEA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,KAAK;AAClB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,KAAK;AAClB,cAAa,IAAI;AACjB,cAAa,iBAAiB;AAC9B,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB;AAChB;AACA,MAAK;AACL;AACA;AACA,iBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,cAAa,EAAE;AACf,cAAa,IAAI;AACjB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,6BAA4B;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,aAAa;AAC1B,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,UAAU;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;;AAEH;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,EAAE;AACf,eAAc,EAAE;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,aAAa;AAC1B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;;AAEA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,EAAE;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa,aAAa;AAC1B,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,aAAa;AAC1B,cAAa,OAAO;AACpB;;AAEA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf,cAAa,IAAI;AACjB,eAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,EAAE;AACf;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA0B,uBAAuB,EAAE;AACnD,+BAA8B,2BAA2B,EAAE;AAC3D,0BAAyB,sBAAsB,EAAE;AACjD,8BAA6B,0BAA0B,EAAE;AACzD;AACA,iBAAgB,aAAa,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAgB,aAAa;AAC7B,IAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAsB;AACtB,sBAAqB;AACrB,2BAA0B;AAC1B,6BAA4B;;AAE5B;AACA;;AAEA;AACA;;AAEA;AACA,yBAAwB;AACxB,8BAA6B;;AAE7B;AACA;AACA,kCAAiC;AACjC,uCAAsC;AACtC,gCAA+B,WAAW;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,eAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,eAAe;AAC5B,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAmB,2EAA2E,GAAG;AACjG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA,yDAAwD;AACxD;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB;;AAEA;AACA;AACA;AACA,oBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;AACA,WAAU,OAAO;AACjB,WAAU,SAAS;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,gBAAgB;AAC7B,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB,yBAAwB,MAAM;AAC9B,yBAAwB,QAAQ;AAChC,yBAAwB,QAAQ;AAChC,yBAAwB,QAAQ;AAChC,yBAAwB,QAAQ;AAChC,yBAAwB,QAAQ;AAChC,yBAAwB,SAAS;AACjC,yBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA,4BAA2B;AAC3B;AACA;AACA;AACA;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa,KAAK;AAClB,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA,2BAA0B;;AAE1B;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,yBAAyB;AACtC,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf;AACA;AACA;AACA;AACA,8CAA6C,KAAK;AAClD,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB;AACA;AACA,eAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;;AAEA;AACA;AACA,aAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,IAAI;AACjB,cAAa,iBAAiB;AAC9B,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;;AAEA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA,0CAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA;AACA;AACA,0CAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,MAAM;AACrB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,gBAAe,KAAK;AACpB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,KAAK;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,aAAa;AAC1B,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,EAAE;AACf,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,cAAc;AAC3B,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAgC;AAChC;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP,kDAAiD;AACjD,QAAO;AACP,sCAAqC;AACrC;AACA,MAAK;;AAEL;AACA;AACA;AACA,iDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA,yBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,sCAAqC;AACrC;AACA,MAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,4BAA4B;AACzC,eAAc;AACd;;AAEA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB;AACA;AACA;AACA,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;AACA,gBAAe,OAAO;AACtB,iBAAgB,IAAI;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,iBAAgB;AAChB;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,gBAAe,IAAI;AACnB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB,cAAa,IAAI;AACjB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,yBAAyB;AACtC,cAAa,MAAM;AACnB,cAAa,IAAI;AACjB,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,qBAAqB;AACpC,cAAa;AACb;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,EAAE;AACf,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,EAAE;AACf;;AAEA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,EAAE;AACf,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,cAAa,SAAS;AACtB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,eAAc;AACd;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA,YAAW;AACX,UAAS;AACT;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,IAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAoB;AACpB;AACA,MAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,yBAAyB;AACtC,cAAa,OAAO;AACpB,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,IAAI;AACnB,gBAAe,yBAAyB;AACxC,gBAAe,IAAI;AACnB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC,OAAO;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,MAAM;AACnB,cAAa,IAAI;AACjB,cAAa,MAAM;AACnB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,MAAM;AACnB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,KAAK;AAClB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB,eAAc,cAAc;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAsC,OAAO;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,IAAI;AACjB,cAAa,KAAK;AAClB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,cAAc;AAC3B,cAAa,iBAAiB;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA,yCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,gBAAgB;AAC7B,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,MAAM;AACnB,cAAa,OAAO;AACpB,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,mBAAmB;AAChC,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,QAAO;;AAEP;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA,YAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,gBAAe;AACf;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,gBAAgB;AAC/B,gBAAe,MAAM;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB,eAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,MAAM;AACnB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,OAAO;AACpB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,QAAQ;AACrB,cAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,yBAAyB;AACtC,cAAa,QAAQ;AACrB,cAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAgD,OAAO;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,SAAS;AACtB,eAAc;AACd;;AAEA;AACA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT,qJAAoJ;AACpJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iDAAgD,OAAO;AACvD,wCAAuC;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,IAAI;AACnB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,IAAI;AACnB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA0C,OAAO;AACjD;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,IAAI;AACnB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB,gBAAe,uBAAuB;AACtC,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,IAAI;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,IAAI;AACnB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA,6CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,yBAAwB,OAAO;AAC/B,yBAAwB,OAAO;AAC/B,yBAAwB,OAAO;AAC/B,yBAAwB,cAAc;AACtC,yBAAwB,OAAO;AAC/B,yBAAwB,QAAQ;AAChC,yBAAwB,OAAO;AAC/B,yBAAwB,OAAO;AAC/B,yBAAwB,OAAO;AAC/B,yBAAwB,OAAO;AAC/B,yBAAwB,cAAc;AACtC,yBAAwB,QAAQ;AAChC,cAAa,IAAI;AACjB,cAAa,KAAK;AAClB,cAAa,IAAI;AACjB,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK,EAAE;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,EAAE;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa,SAAS;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,SAAS;AACtB,cAAa,QAAQ;AACrB;;AAEA;AACA,6CAA4C;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;;AAEA;AACA;;AAEA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,KAAK;AACpB,gBAAe,IAAI;AACnB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,EAAE;AACjB,gBAAe,EAAE;AACjB,gBAAe,MAAM;AACrB,gBAAe,QAAQ;AACvB,iBAAgB;AAChB;;AAEA;AACA;AACA,sCAAqC,OAAO;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA2C,OAAO;AAClD;AACA;AACA,YAAW;AACX;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,EAAE;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,gBAAgB;AAC/B,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,2BAA0B,QAAQ;AAClC,2BAA0B,QAAQ;AAClC,iBAAgB,SAAS;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,QAAQ;AACvB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,YAAW;AACX;AACA,QAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,SAAS;AACxB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,SAAS;AACxB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,SAAS;AACxB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,SAAS;AACxB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,IAAI;AACnB,gBAAe,QAAQ;AACvB,gBAAe,SAAS;AACxB,gBAAe,QAAQ;AACvB,gBAAe,SAAS;AACxB,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,eAAe;AAC9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,KAAK;AACpB,gBAAe,IAAI;AACnB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,KAAK;AACpB,gBAAe,IAAI;AACnB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,KAAK;AACpB,gBAAe,IAAI;AACnB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,cAAc;AAC7B,iBAAgB,QAAQ;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,wCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,cAAc;AAC7B,gBAAe,KAAK;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB;AACnB;AACA,2CAA0C,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,KAAK;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,IAAI;AACnB,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAe,gCAAgC;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,QAAQ;AACvB,gBAAe,QAAQ;AACvB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,yBAAyB;AACxC,gBAAe,IAAI;AACnB,gBAAe,OAAO;AACtB,gBAAe,SAAS;AACxB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,8BAA8B;AAC3C,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa,EAAE;AACf,cAAa,OAAO;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA,uBAAsB,EAAE;;AAExB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA,gBAAe,SAAS;AACxB,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAqB;AACrB,qBAAoB;AACpB,mBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,iBAAgB;AAChB;;AAEA;AACA;AACA,8EAA6E,sBAAsB;AACnG;AACA;;AAEA;AACA;AACA;AACA,gBAAe,OAAO;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAe,OAAO;AACtB,gBAAe,EAAE;AACjB;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,IAAG;;AAEH;;AAEA,EAAC,G;;;;;;;AC5yTD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAA+F;AAC/F;AACA,aAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,EAAC,I;;;;;;;;ACgCD;;uCAIA;AAFA;yBAGA;;iBAEA,CACA,UACA,UAEA;;eAEA;gBACA;AAFA;eAIA;gBACA;AAFA;eAIA;gBAEA;AAHA;;gBAKA;;iBAEA;kBACA;AAFA;iBAIA;kBACA;AAFA;iBAIA;kBAEA;AAHA;AARA;gBAaA;;iBAEA;kBACA;AAFA;iBAIA;kBACA;AAFA;iBAIA;kBAIA;AALA;AARA;AA5BA;AA0CA;;;iBAGA;eAEA;AAHA;;iBAKA;eAEA;AAHA;;iBAKA;eAGA;AAJA;AATA;AAhDA,G;;;;;;ACvDA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA,UAAS,6BAA6B,GAAG,6BAA6B;AACtE;AACA,UAAS,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACpG,UAAS,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAA+F,KAAK;AACpG,uGAAsG,UAAU;AAChH;AACA,4EAA2E,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAmE,6BAA6B,GAAG,6BAA6B;AAChI;AACA,aAAY,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACvG,aAAY,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA,sBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;;AAEjC;AACA,2CAA0C,QAAQ;AAClD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;ACz4BA,khBAAihB,SAAS,+jBAA+jB,SAAS,wkBAAwkB,SAAS,oD","file":"demo.all.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f43bee4295efeed878cd\n **/","var Vue = require(\"vue\");\n\nvar vm = new Vue({\n  components: {\n    \"demo\": require(\"./demo.vue\")\n  },\n  data: {\n    result1: null,\n    result2: \"value2\",\n    result3: \"value6\"\n  }\n});\n\nvm.$mount(\"#app\");\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/demo.js\n ** module id = 0\n ** module chunks = 0\n **/","module.exports = require(\"./dist/vue.js\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** vue (bower component)\n ** module id = 1\n ** module chunks = 0\n **/","/*!\n * Vue.js v1.0.24\n * (c) 2016 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.Vue = factory());\n}(this, function () { 'use strict';\n\n  function set(obj, key, val) {\n    if (hasOwn(obj, key)) {\n      obj[key] = val;\n      return;\n    }\n    if (obj._isVue) {\n      set(obj._data, key, val);\n      return;\n    }\n    var ob = obj.__ob__;\n    if (!ob) {\n      obj[key] = val;\n      return;\n    }\n    ob.convert(key, val);\n    ob.dep.notify();\n    if (ob.vms) {\n      var i = ob.vms.length;\n      while (i--) {\n        var vm = ob.vms[i];\n        vm._proxy(key);\n        vm._digest();\n      }\n    }\n    return val;\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   *\n   * @param {Object} obj\n   * @param {String} key\n   */\n\n  function del(obj, key) {\n    if (!hasOwn(obj, key)) {\n      return;\n    }\n    delete obj[key];\n    var ob = obj.__ob__;\n    if (!ob) {\n      if (obj._isVue) {\n        delete obj._data[key];\n        obj._digest();\n      }\n      return;\n    }\n    ob.dep.notify();\n    if (ob.vms) {\n      var i = ob.vms.length;\n      while (i--) {\n        var vm = ob.vms[i];\n        vm._unproxy(key);\n        vm._digest();\n      }\n    }\n  }\n\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  /**\n   * Check whether the object has the property.\n   *\n   * @param {Object} obj\n   * @param {String} key\n   * @return {Boolean}\n   */\n\n  function hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  }\n\n  /**\n   * Check if an expression is a literal value.\n   *\n   * @param {String} exp\n   * @return {Boolean}\n   */\n\n  var literalValueRE = /^\\s?(true|false|-?[\\d\\.]+|'[^']*'|\"[^\"]*\")\\s?$/;\n\n  function isLiteral(exp) {\n    return literalValueRE.test(exp);\n  }\n\n  /**\n   * Check if a string starts with $ or _\n   *\n   * @param {String} str\n   * @return {Boolean}\n   */\n\n  function isReserved(str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F;\n  }\n\n  /**\n   * Guard text output, make sure undefined outputs\n   * empty string\n   *\n   * @param {*} value\n   * @return {String}\n   */\n\n  function _toString(value) {\n    return value == null ? '' : value.toString();\n  }\n\n  /**\n   * Check and convert possible numeric strings to numbers\n   * before setting back to data\n   *\n   * @param {*} value\n   * @return {*|Number}\n   */\n\n  function toNumber(value) {\n    if (typeof value !== 'string') {\n      return value;\n    } else {\n      var parsed = Number(value);\n      return isNaN(parsed) ? value : parsed;\n    }\n  }\n\n  /**\n   * Convert string boolean literals into real booleans.\n   *\n   * @param {*} value\n   * @return {*|Boolean}\n   */\n\n  function toBoolean(value) {\n    return value === 'true' ? true : value === 'false' ? false : value;\n  }\n\n  /**\n   * Strip quotes from a string\n   *\n   * @param {String} str\n   * @return {String | false}\n   */\n\n  function stripQuotes(str) {\n    var a = str.charCodeAt(0);\n    var b = str.charCodeAt(str.length - 1);\n    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;\n  }\n\n  /**\n   * Camelize a hyphen-delmited string.\n   *\n   * @param {String} str\n   * @return {String}\n   */\n\n  var camelizeRE = /-(\\w)/g;\n\n  function camelize(str) {\n    return str.replace(camelizeRE, toUpper);\n  }\n\n  function toUpper(_, c) {\n    return c ? c.toUpperCase() : '';\n  }\n\n  /**\n   * Hyphenate a camelCase string.\n   *\n   * @param {String} str\n   * @return {String}\n   */\n\n  var hyphenateRE = /([a-z\\d])([A-Z])/g;\n\n  function hyphenate(str) {\n    return str.replace(hyphenateRE, '$1-$2').toLowerCase();\n  }\n\n  /**\n   * Converts hyphen/underscore/slash delimitered names into\n   * camelized classNames.\n   *\n   * e.g. my-component => MyComponent\n   *      some_else    => SomeElse\n   *      some/comp    => SomeComp\n   *\n   * @param {String} str\n   * @return {String}\n   */\n\n  var classifyRE = /(?:^|[-_\\/])(\\w)/g;\n\n  function classify(str) {\n    return str.replace(classifyRE, toUpper);\n  }\n\n  /**\n   * Simple bind, faster than native\n   *\n   * @param {Function} fn\n   * @param {Object} ctx\n   * @return {Function}\n   */\n\n  function bind(fn, ctx) {\n    return function (a) {\n      var l = arguments.length;\n      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);\n    };\n  }\n\n  /**\n   * Convert an Array-like object to a real Array.\n   *\n   * @param {Array-like} list\n   * @param {Number} [start] - start index\n   * @return {Array}\n   */\n\n  function toArray(list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret;\n  }\n\n  /**\n   * Mix properties into target object.\n   *\n   * @param {Object} to\n   * @param {Object} from\n   */\n\n  function extend(to, from) {\n    var keys = Object.keys(from);\n    var i = keys.length;\n    while (i--) {\n      to[keys[i]] = from[keys[i]];\n    }\n    return to;\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  function isObject(obj) {\n    return obj !== null && typeof obj === 'object';\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  var toString = Object.prototype.toString;\n  var OBJECT_STRING = '[object Object]';\n\n  function isPlainObject(obj) {\n    return toString.call(obj) === OBJECT_STRING;\n  }\n\n  /**\n   * Array type check.\n   *\n   * @param {*} obj\n   * @return {Boolean}\n   */\n\n  var isArray = Array.isArray;\n\n  /**\n   * Define a property.\n   *\n   * @param {Object} obj\n   * @param {String} key\n   * @param {*} val\n   * @param {Boolean} [enumerable]\n   */\n\n  function def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Debounce a function so it only gets called after the\n   * input stops arriving after the given wait period.\n   *\n   * @param {Function} func\n   * @param {Number} wait\n   * @return {Function} - the debounced function\n   */\n\n  function _debounce(func, wait) {\n    var timeout, args, context, timestamp, result;\n    var later = function later() {\n      var last = Date.now() - timestamp;\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      }\n    };\n    return function () {\n      context = this;\n      args = arguments;\n      timestamp = Date.now();\n      if (!timeout) {\n        timeout = setTimeout(later, wait);\n      }\n      return result;\n    };\n  }\n\n  /**\n   * Manual indexOf because it's slightly faster than\n   * native.\n   *\n   * @param {Array} arr\n   * @param {*} obj\n   */\n\n  function indexOf(arr, obj) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === obj) return i;\n    }\n    return -1;\n  }\n\n  /**\n   * Make a cancellable version of an async callback.\n   *\n   * @param {Function} fn\n   * @return {Function}\n   */\n\n  function cancellable(fn) {\n    var cb = function cb() {\n      if (!cb.cancelled) {\n        return fn.apply(this, arguments);\n      }\n    };\n    cb.cancel = function () {\n      cb.cancelled = true;\n    };\n    return cb;\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   *\n   * @param {*} a\n   * @param {*} b\n   * @return {Boolean}\n   */\n\n  function looseEqual(a, b) {\n    /* eslint-disable eqeqeq */\n    return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);\n    /* eslint-enable eqeqeq */\n  }\n\n  var hasProto = ('__proto__' in {});\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  // UA sniffing for working around browser-specific quirks\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isAndroid = UA && UA.indexOf('android') > 0;\n  var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);\n  var isWechat = UA && UA.indexOf('micromessenger') > 0;\n\n  var transitionProp = undefined;\n  var transitionEndEvent = undefined;\n  var animationProp = undefined;\n  var animationEndEvent = undefined;\n\n  // Transition property/event sniffing\n  if (inBrowser && !isIE9) {\n    var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;\n    var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;\n    transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';\n    transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';\n    animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';\n    animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';\n  }\n\n  /**\n   * Defer a task to execute it asynchronously. Ideally this\n   * should be executed as a microtask, so we leverage\n   * MutationObserver if it's available, and fallback to\n   * setTimeout(0).\n   *\n   * @param {Function} cb\n   * @param {Object} ctx\n   */\n\n  var nextTick = (function () {\n    var callbacks = [];\n    var pending = false;\n    var timerFunc;\n    function nextTickHandler() {\n      pending = false;\n      var copies = callbacks.slice(0);\n      callbacks = [];\n      for (var i = 0; i < copies.length; i++) {\n        copies[i]();\n      }\n    }\n\n    /* istanbul ignore if */\n    if (typeof MutationObserver !== 'undefined' && !(isWechat && isIos)) {\n      var counter = 1;\n      var observer = new MutationObserver(nextTickHandler);\n      var textNode = document.createTextNode(counter);\n      observer.observe(textNode, {\n        characterData: true\n      });\n      timerFunc = function () {\n        counter = (counter + 1) % 2;\n        textNode.data = counter;\n      };\n    } else {\n      // webpack attempts to inject a shim for setImmediate\n      // if it is used as a global, so we have to work around that to\n      // avoid bundling unnecessary code.\n      var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};\n      timerFunc = context.setImmediate || setTimeout;\n    }\n    return function (cb, ctx) {\n      var func = ctx ? function () {\n        cb.call(ctx);\n      } : cb;\n      callbacks.push(func);\n      if (pending) return;\n      pending = true;\n      timerFunc(nextTickHandler, 0);\n    };\n  })();\n\n  var _Set = undefined;\n  /* istanbul ignore if */\n  if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = function () {\n      this.set = Object.create(null);\n    };\n    _Set.prototype.has = function (key) {\n      return this.set[key] !== undefined;\n    };\n    _Set.prototype.add = function (key) {\n      this.set[key] = 1;\n    };\n    _Set.prototype.clear = function () {\n      this.set = Object.create(null);\n    };\n  }\n\n  function Cache(limit) {\n    this.size = 0;\n    this.limit = limit;\n    this.head = this.tail = undefined;\n    this._keymap = Object.create(null);\n  }\n\n  var p = Cache.prototype;\n\n  /**\n   * Put <value> into the cache associated with <key>.\n   * Returns the entry which was removed to make room for\n   * the new entry. Otherwise undefined is returned.\n   * (i.e. if there was enough room already).\n   *\n   * @param {String} key\n   * @param {*} value\n   * @return {Entry|undefined}\n   */\n\n  p.put = function (key, value) {\n    var removed;\n    if (this.size === this.limit) {\n      removed = this.shift();\n    }\n\n    var entry = this.get(key, true);\n    if (!entry) {\n      entry = {\n        key: key\n      };\n      this._keymap[key] = entry;\n      if (this.tail) {\n        this.tail.newer = entry;\n        entry.older = this.tail;\n      } else {\n        this.head = entry;\n      }\n      this.tail = entry;\n      this.size++;\n    }\n    entry.value = value;\n\n    return removed;\n  };\n\n  /**\n   * Purge the least recently used (oldest) entry from the\n   * cache. Returns the removed entry or undefined if the\n   * cache was empty.\n   */\n\n  p.shift = function () {\n    var entry = this.head;\n    if (entry) {\n      this.head = this.head.newer;\n      this.head.older = undefined;\n      entry.newer = entry.older = undefined;\n      this._keymap[entry.key] = undefined;\n      this.size--;\n    }\n    return entry;\n  };\n\n  /**\n   * Get and register recent use of <key>. Returns the value\n   * associated with <key> or undefined if not in cache.\n   *\n   * @param {String} key\n   * @param {Boolean} returnEntry\n   * @return {Entry|*}\n   */\n\n  p.get = function (key, returnEntry) {\n    var entry = this._keymap[key];\n    if (entry === undefined) return;\n    if (entry === this.tail) {\n      return returnEntry ? entry : entry.value;\n    }\n    // HEAD--------------TAIL\n    //   <.older   .newer>\n    //  <--- add direction --\n    //   A  B  C  <D>  E\n    if (entry.newer) {\n      if (entry === this.head) {\n        this.head = entry.newer;\n      }\n      entry.newer.older = entry.older; // C <-- E.\n    }\n    if (entry.older) {\n      entry.older.newer = entry.newer; // C. --> E\n    }\n    entry.newer = undefined; // D --x\n    entry.older = this.tail; // D. --> E\n    if (this.tail) {\n      this.tail.newer = entry; // E. <-- D\n    }\n    this.tail = entry;\n    return returnEntry ? entry : entry.value;\n  };\n\n  var cache$1 = new Cache(1000);\n  var filterTokenRE = /[^\\s'\"]+|'[^']*'|\"[^\"]*\"/g;\n  var reservedArgRE = /^in$|^-?\\d+/;\n\n  /**\n   * Parser state\n   */\n\n  var str;\n  var dir;\n  var c;\n  var prev;\n  var i;\n  var l;\n  var lastFilterIndex;\n  var inSingle;\n  var inDouble;\n  var curly;\n  var square;\n  var paren;\n  /**\n   * Push a filter to the current directive object\n   */\n\n  function pushFilter() {\n    var exp = str.slice(lastFilterIndex, i).trim();\n    var filter;\n    if (exp) {\n      filter = {};\n      var tokens = exp.match(filterTokenRE);\n      filter.name = tokens[0];\n      if (tokens.length > 1) {\n        filter.args = tokens.slice(1).map(processFilterArg);\n      }\n    }\n    if (filter) {\n      (dir.filters = dir.filters || []).push(filter);\n    }\n    lastFilterIndex = i + 1;\n  }\n\n  /**\n   * Check if an argument is dynamic and strip quotes.\n   *\n   * @param {String} arg\n   * @return {Object}\n   */\n\n  function processFilterArg(arg) {\n    if (reservedArgRE.test(arg)) {\n      return {\n        value: toNumber(arg),\n        dynamic: false\n      };\n    } else {\n      var stripped = stripQuotes(arg);\n      var dynamic = stripped === arg;\n      return {\n        value: dynamic ? arg : stripped,\n        dynamic: dynamic\n      };\n    }\n  }\n\n  /**\n   * Parse a directive value and extract the expression\n   * and its filters into a descriptor.\n   *\n   * Example:\n   *\n   * \"a + 1 | uppercase\" will yield:\n   * {\n   *   expression: 'a + 1',\n   *   filters: [\n   *     { name: 'uppercase', args: null }\n   *   ]\n   * }\n   *\n   * @param {String} s\n   * @return {Object}\n   */\n\n  function parseDirective(s) {\n    var hit = cache$1.get(s);\n    if (hit) {\n      return hit;\n    }\n\n    // reset parser state\n    str = s;\n    inSingle = inDouble = false;\n    curly = square = paren = 0;\n    lastFilterIndex = 0;\n    dir = {};\n\n    for (i = 0, l = str.length; i < l; i++) {\n      prev = c;\n      c = str.charCodeAt(i);\n      if (inSingle) {\n        // check single quote\n        if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;\n      } else if (inDouble) {\n        // check double quote\n        if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;\n      } else if (c === 0x7C && // pipe\n      str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {\n        if (dir.expression == null) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          dir.expression = str.slice(0, i).trim();\n        } else {\n          // already has filter\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22:\n            inDouble = true;break; // \"\n          case 0x27:\n            inSingle = true;break; // '\n          case 0x28:\n            paren++;break; // (\n          case 0x29:\n            paren--;break; // )\n          case 0x5B:\n            square++;break; // [\n          case 0x5D:\n            square--;break; // ]\n          case 0x7B:\n            curly++;break; // {\n          case 0x7D:\n            curly--;break; // }\n        }\n      }\n    }\n\n    if (dir.expression == null) {\n      dir.expression = str.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    cache$1.put(s, dir);\n    return dir;\n  }\n\nvar directive = Object.freeze({\n    parseDirective: parseDirective\n  });\n\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n  var cache = undefined;\n  var tagRE = undefined;\n  var htmlRE = undefined;\n  /**\n   * Escape a string so it can be used in a RegExp\n   * constructor.\n   *\n   * @param {String} str\n   */\n\n  function escapeRegex(str) {\n    return str.replace(regexEscapeRE, '\\\\$&');\n  }\n\n  function compileRegex() {\n    var open = escapeRegex(config.delimiters[0]);\n    var close = escapeRegex(config.delimiters[1]);\n    var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);\n    var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);\n    tagRE = new RegExp(unsafeOpen + '((?:.|\\\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\\\n)+?)' + close, 'g');\n    htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');\n    // reset cache\n    cache = new Cache(1000);\n  }\n\n  /**\n   * Parse a template text string into an array of tokens.\n   *\n   * @param {String} text\n   * @return {Array<Object> | null}\n   *               - {String} type\n   *               - {String} value\n   *               - {Boolean} [html]\n   *               - {Boolean} [oneTime]\n   */\n\n  function parseText(text) {\n    if (!cache) {\n      compileRegex();\n    }\n    var hit = cache.get(text);\n    if (hit) {\n      return hit;\n    }\n    if (!tagRE.test(text)) {\n      return null;\n    }\n    var tokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, html, value, first, oneTime;\n    /* eslint-disable no-cond-assign */\n    while (match = tagRE.exec(text)) {\n      /* eslint-enable no-cond-assign */\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        tokens.push({\n          value: text.slice(lastIndex, index)\n        });\n      }\n      // tag token\n      html = htmlRE.test(match[0]);\n      value = html ? match[1] : match[2];\n      first = value.charCodeAt(0);\n      oneTime = first === 42; // *\n      value = oneTime ? value.slice(1) : value;\n      tokens.push({\n        tag: true,\n        value: value.trim(),\n        html: html,\n        oneTime: oneTime\n      });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      tokens.push({\n        value: text.slice(lastIndex)\n      });\n    }\n    cache.put(text, tokens);\n    return tokens;\n  }\n\n  /**\n   * Format a list of tokens into an expression.\n   * e.g. tokens parsed from 'a {{b}} c' can be serialized\n   * into one single expression as '\"a \" + b + \" c\"'.\n   *\n   * @param {Array} tokens\n   * @param {Vue} [vm]\n   * @return {String}\n   */\n\n  function tokensToExp(tokens, vm) {\n    if (tokens.length > 1) {\n      return tokens.map(function (token) {\n        return formatToken(token, vm);\n      }).join('+');\n    } else {\n      return formatToken(tokens[0], vm, true);\n    }\n  }\n\n  /**\n   * Format a single token.\n   *\n   * @param {Object} token\n   * @param {Vue} [vm]\n   * @param {Boolean} [single]\n   * @return {String}\n   */\n\n  function formatToken(token, vm, single) {\n    return token.tag ? token.oneTime && vm ? '\"' + vm.$eval(token.value) + '\"' : inlineFilters(token.value, single) : '\"' + token.value + '\"';\n  }\n\n  /**\n   * For an attribute with multiple interpolation tags,\n   * e.g. attr=\"some-{{thing | filter}}\", in order to combine\n   * the whole thing into a single watchable expression, we\n   * have to inline those filters. This function does exactly\n   * that. This is a bit hacky but it avoids heavy changes\n   * to directive parser and watcher mechanism.\n   *\n   * @param {String} exp\n   * @param {Boolean} single\n   * @return {String}\n   */\n\n  var filterRE = /[^|]\\|[^|]/;\n  function inlineFilters(exp, single) {\n    if (!filterRE.test(exp)) {\n      return single ? exp : '(' + exp + ')';\n    } else {\n      var dir = parseDirective(exp);\n      if (!dir.filters) {\n        return '(' + exp + ')';\n      } else {\n        return 'this._applyFilters(' + dir.expression + // value\n        ',null,' + // oldValue (null for read)\n        JSON.stringify(dir.filters) + // filter descriptors\n        ',false)'; // write?\n      }\n    }\n  }\n\nvar text = Object.freeze({\n    compileRegex: compileRegex,\n    parseText: parseText,\n    tokensToExp: tokensToExp\n  });\n\n  var delimiters = ['{{', '}}'];\n  var unsafeDelimiters = ['{{{', '}}}'];\n\n  var config = Object.defineProperties({\n\n    /**\n     * Whether to print debug messages.\n     * Also enables stack trace for warnings.\n     *\n     * @type {Boolean}\n     */\n\n    debug: false,\n\n    /**\n     * Whether to suppress warnings.\n     *\n     * @type {Boolean}\n     */\n\n    silent: false,\n\n    /**\n     * Whether to use async rendering.\n     */\n\n    async: true,\n\n    /**\n     * Whether to warn against errors caught when evaluating\n     * expressions.\n     */\n\n    warnExpressionErrors: true,\n\n    /**\n     * Whether to allow devtools inspection.\n     * Disabled by default in production builds.\n     */\n\n    devtools: 'development' !== 'production',\n\n    /**\n     * Internal flag to indicate the delimiters have been\n     * changed.\n     *\n     * @type {Boolean}\n     */\n\n    _delimitersChanged: true,\n\n    /**\n     * List of asset types that a component can own.\n     *\n     * @type {Array}\n     */\n\n    _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],\n\n    /**\n     * prop binding modes\n     */\n\n    _propBindingModes: {\n      ONE_WAY: 0,\n      TWO_WAY: 1,\n      ONE_TIME: 2\n    },\n\n    /**\n     * Max circular updates allowed in a batcher flush cycle.\n     */\n\n    _maxUpdateCount: 100\n\n  }, {\n    delimiters: { /**\n                   * Interpolation delimiters. Changing these would trigger\n                   * the text parser to re-compile the regular expressions.\n                   *\n                   * @type {Array<String>}\n                   */\n\n      get: function get() {\n        return delimiters;\n      },\n      set: function set(val) {\n        delimiters = val;\n        compileRegex();\n      },\n      configurable: true,\n      enumerable: true\n    },\n    unsafeDelimiters: {\n      get: function get() {\n        return unsafeDelimiters;\n      },\n      set: function set(val) {\n        unsafeDelimiters = val;\n        compileRegex();\n      },\n      configurable: true,\n      enumerable: true\n    }\n  });\n\n  var warn = undefined;\n  var formatComponentName = undefined;\n\n  if ('development' !== 'production') {\n    (function () {\n      var hasConsole = typeof console !== 'undefined';\n\n      warn = function (msg, vm) {\n        if (hasConsole && !config.silent) {\n          console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));\n        }\n      };\n\n      formatComponentName = function (vm) {\n        var name = vm._isVue ? vm.$options.name : vm.name;\n        return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';\n      };\n    })();\n  }\n\n  /**\n   * Append with transition.\n   *\n   * @param {Element} el\n   * @param {Element} target\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function appendWithTransition(el, target, vm, cb) {\n    applyTransition(el, 1, function () {\n      target.appendChild(el);\n    }, vm, cb);\n  }\n\n  /**\n   * InsertBefore with transition.\n   *\n   * @param {Element} el\n   * @param {Element} target\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function beforeWithTransition(el, target, vm, cb) {\n    applyTransition(el, 1, function () {\n      before(el, target);\n    }, vm, cb);\n  }\n\n  /**\n   * Remove with transition.\n   *\n   * @param {Element} el\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function removeWithTransition(el, vm, cb) {\n    applyTransition(el, -1, function () {\n      remove(el);\n    }, vm, cb);\n  }\n\n  /**\n   * Apply transitions with an operation callback.\n   *\n   * @param {Element} el\n   * @param {Number} direction\n   *                  1: enter\n   *                 -1: leave\n   * @param {Function} op - the actual DOM operation\n   * @param {Vue} vm\n   * @param {Function} [cb]\n   */\n\n  function applyTransition(el, direction, op, vm, cb) {\n    var transition = el.__v_trans;\n    if (!transition ||\n    // skip if there are no js hooks and CSS transition is\n    // not supported\n    !transition.hooks && !transitionEndEvent ||\n    // skip transitions for initial compile\n    !vm._isCompiled ||\n    // if the vm is being manipulated by a parent directive\n    // during the parent's compilation phase, skip the\n    // animation.\n    vm.$parent && !vm.$parent._isCompiled) {\n      op();\n      if (cb) cb();\n      return;\n    }\n    var action = direction > 0 ? 'enter' : 'leave';\n    transition[action](op, cb);\n  }\n\nvar transition = Object.freeze({\n    appendWithTransition: appendWithTransition,\n    beforeWithTransition: beforeWithTransition,\n    removeWithTransition: removeWithTransition,\n    applyTransition: applyTransition\n  });\n\n  /**\n   * Query an element selector if it's not an element already.\n   *\n   * @param {String|Element} el\n   * @return {Element}\n   */\n\n  function query(el) {\n    if (typeof el === 'string') {\n      var selector = el;\n      el = document.querySelector(el);\n      if (!el) {\n        'development' !== 'production' && warn('Cannot find element: ' + selector);\n      }\n    }\n    return el;\n  }\n\n  /**\n   * Check if a node is in the document.\n   * Note: document.documentElement.contains should work here\n   * but always returns false for comment nodes in phantomjs,\n   * making unit tests difficult. This is fixed by doing the\n   * contains() check on the node's parentNode instead of\n   * the node itself.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function inDoc(node) {\n    if (!node) return false;\n    var doc = node.ownerDocument.documentElement;\n    var parent = node.parentNode;\n    return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));\n  }\n\n  /**\n   * Get and remove an attribute from a node.\n   *\n   * @param {Node} node\n   * @param {String} _attr\n   */\n\n  function getAttr(node, _attr) {\n    var val = node.getAttribute(_attr);\n    if (val !== null) {\n      node.removeAttribute(_attr);\n    }\n    return val;\n  }\n\n  /**\n   * Get an attribute with colon or v-bind: prefix.\n   *\n   * @param {Node} node\n   * @param {String} name\n   * @return {String|null}\n   */\n\n  function getBindAttr(node, name) {\n    var val = getAttr(node, ':' + name);\n    if (val === null) {\n      val = getAttr(node, 'v-bind:' + name);\n    }\n    return val;\n  }\n\n  /**\n   * Check the presence of a bind attribute.\n   *\n   * @param {Node} node\n   * @param {String} name\n   * @return {Boolean}\n   */\n\n  function hasBindAttr(node, name) {\n    return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);\n  }\n\n  /**\n   * Insert el before target\n   *\n   * @param {Element} el\n   * @param {Element} target\n   */\n\n  function before(el, target) {\n    target.parentNode.insertBefore(el, target);\n  }\n\n  /**\n   * Insert el after target\n   *\n   * @param {Element} el\n   * @param {Element} target\n   */\n\n  function after(el, target) {\n    if (target.nextSibling) {\n      before(el, target.nextSibling);\n    } else {\n      target.parentNode.appendChild(el);\n    }\n  }\n\n  /**\n   * Remove el from DOM\n   *\n   * @param {Element} el\n   */\n\n  function remove(el) {\n    el.parentNode.removeChild(el);\n  }\n\n  /**\n   * Prepend el to target\n   *\n   * @param {Element} el\n   * @param {Element} target\n   */\n\n  function prepend(el, target) {\n    if (target.firstChild) {\n      before(el, target.firstChild);\n    } else {\n      target.appendChild(el);\n    }\n  }\n\n  /**\n   * Replace target with el\n   *\n   * @param {Element} target\n   * @param {Element} el\n   */\n\n  function replace(target, el) {\n    var parent = target.parentNode;\n    if (parent) {\n      parent.replaceChild(el, target);\n    }\n  }\n\n  /**\n   * Add event listener shorthand.\n   *\n   * @param {Element} el\n   * @param {String} event\n   * @param {Function} cb\n   * @param {Boolean} [useCapture]\n   */\n\n  function on(el, event, cb, useCapture) {\n    el.addEventListener(event, cb, useCapture);\n  }\n\n  /**\n   * Remove event listener shorthand.\n   *\n   * @param {Element} el\n   * @param {String} event\n   * @param {Function} cb\n   */\n\n  function off(el, event, cb) {\n    el.removeEventListener(event, cb);\n  }\n\n  /**\n   * For IE9 compat: when both class and :class are present\n   * getAttribute('class') returns wrong value...\n   *\n   * @param {Element} el\n   * @return {String}\n   */\n\n  function getClass(el) {\n    var classname = el.className;\n    if (typeof classname === 'object') {\n      classname = classname.baseVal || '';\n    }\n    return classname;\n  }\n\n  /**\n   * In IE9, setAttribute('class') will result in empty class\n   * if the element also has the :class attribute; However in\n   * PhantomJS, setting `className` does not work on SVG elements...\n   * So we have to do a conditional check here.\n   *\n   * @param {Element} el\n   * @param {String} cls\n   */\n\n  function setClass(el, cls) {\n    /* istanbul ignore if */\n    if (isIE9 && !/svg$/.test(el.namespaceURI)) {\n      el.className = cls;\n    } else {\n      el.setAttribute('class', cls);\n    }\n  }\n\n  /**\n   * Add class with compatibility for IE & SVG\n   *\n   * @param {Element} el\n   * @param {String} cls\n   */\n\n  function addClass(el, cls) {\n    if (el.classList) {\n      el.classList.add(cls);\n    } else {\n      var cur = ' ' + getClass(el) + ' ';\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        setClass(el, (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for IE & SVG\n   *\n   * @param {Element} el\n   * @param {String} cls\n   */\n\n  function removeClass(el, cls) {\n    if (el.classList) {\n      el.classList.remove(cls);\n    } else {\n      var cur = ' ' + getClass(el) + ' ';\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      setClass(el, cur.trim());\n    }\n    if (!el.className) {\n      el.removeAttribute('class');\n    }\n  }\n\n  /**\n   * Extract raw content inside an element into a temporary\n   * container div\n   *\n   * @param {Element} el\n   * @param {Boolean} asFragment\n   * @return {Element|DocumentFragment}\n   */\n\n  function extractContent(el, asFragment) {\n    var child;\n    var rawContent;\n    /* istanbul ignore if */\n    if (isTemplate(el) && isFragment(el.content)) {\n      el = el.content;\n    }\n    if (el.hasChildNodes()) {\n      trimNode(el);\n      rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');\n      /* eslint-disable no-cond-assign */\n      while (child = el.firstChild) {\n        /* eslint-enable no-cond-assign */\n        rawContent.appendChild(child);\n      }\n    }\n    return rawContent;\n  }\n\n  /**\n   * Trim possible empty head/tail text and comment\n   * nodes inside a parent.\n   *\n   * @param {Node} node\n   */\n\n  function trimNode(node) {\n    var child;\n    /* eslint-disable no-sequences */\n    while ((child = node.firstChild, isTrimmable(child))) {\n      node.removeChild(child);\n    }\n    while ((child = node.lastChild, isTrimmable(child))) {\n      node.removeChild(child);\n    }\n    /* eslint-enable no-sequences */\n  }\n\n  function isTrimmable(node) {\n    return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);\n  }\n\n  /**\n   * Check if an element is a template tag.\n   * Note if the template appears inside an SVG its tagName\n   * will be in lowercase.\n   *\n   * @param {Element} el\n   */\n\n  function isTemplate(el) {\n    return el.tagName && el.tagName.toLowerCase() === 'template';\n  }\n\n  /**\n   * Create an \"anchor\" for performing dom insertion/removals.\n   * This is used in a number of scenarios:\n   * - fragment instance\n   * - v-html\n   * - v-if\n   * - v-for\n   * - component\n   *\n   * @param {String} content\n   * @param {Boolean} persist - IE trashes empty textNodes on\n   *                            cloneNode(true), so in certain\n   *                            cases the anchor needs to be\n   *                            non-empty to be persisted in\n   *                            templates.\n   * @return {Comment|Text}\n   */\n\n  function createAnchor(content, persist) {\n    var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');\n    anchor.__v_anchor = true;\n    return anchor;\n  }\n\n  /**\n   * Find a component ref attribute that starts with $.\n   *\n   * @param {Element} node\n   * @return {String|undefined}\n   */\n\n  var refRE = /^v-ref:/;\n\n  function findRef(node) {\n    if (node.hasAttributes()) {\n      var attrs = node.attributes;\n      for (var i = 0, l = attrs.length; i < l; i++) {\n        var name = attrs[i].name;\n        if (refRE.test(name)) {\n          return camelize(name.replace(refRE, ''));\n        }\n      }\n    }\n  }\n\n  /**\n   * Map a function to a range of nodes .\n   *\n   * @param {Node} node\n   * @param {Node} end\n   * @param {Function} op\n   */\n\n  function mapNodeRange(node, end, op) {\n    var next;\n    while (node !== end) {\n      next = node.nextSibling;\n      op(node);\n      node = next;\n    }\n    op(end);\n  }\n\n  /**\n   * Remove a range of nodes with transition, store\n   * the nodes in a fragment with correct ordering,\n   * and call callback when done.\n   *\n   * @param {Node} start\n   * @param {Node} end\n   * @param {Vue} vm\n   * @param {DocumentFragment} frag\n   * @param {Function} cb\n   */\n\n  function removeNodeRange(start, end, vm, frag, cb) {\n    var done = false;\n    var removed = 0;\n    var nodes = [];\n    mapNodeRange(start, end, function (node) {\n      if (node === end) done = true;\n      nodes.push(node);\n      removeWithTransition(node, vm, onRemoved);\n    });\n    function onRemoved() {\n      removed++;\n      if (done && removed >= nodes.length) {\n        for (var i = 0; i < nodes.length; i++) {\n          frag.appendChild(nodes[i]);\n        }\n        cb && cb();\n      }\n    }\n  }\n\n  /**\n   * Check if a node is a DocumentFragment.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isFragment(node) {\n    return node && node.nodeType === 11;\n  }\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   *\n   * @param {Element} el\n   * @return {String}\n   */\n\n  function getOuterHTML(el) {\n    if (el.outerHTML) {\n      return el.outerHTML;\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML;\n    }\n  }\n\n  var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;\n  var reservedTagRE = /^(slot|partial|component)$/i;\n\n  var isUnknownElement = undefined;\n  if ('development' !== 'production') {\n    isUnknownElement = function (el, tag) {\n      if (tag.indexOf('-') > -1) {\n        // http://stackoverflow.com/a/28210364/1070244\n        return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;\n      } else {\n        return (/HTMLUnknownElement/.test(el.toString()) &&\n          // Chrome returns unknown for several HTML5 elements.\n          // https://code.google.com/p/chromium/issues/detail?id=540526\n          !/^(data|time|rtc|rb)$/.test(tag)\n        );\n      }\n    };\n  }\n\n  /**\n   * Check if an element is a component, if yes return its\n   * component id.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Object|undefined}\n   */\n\n  function checkComponentAttr(el, options) {\n    var tag = el.tagName.toLowerCase();\n    var hasAttrs = el.hasAttributes();\n    if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {\n      if (resolveAsset(options, 'components', tag)) {\n        return { id: tag };\n      } else {\n        var is = hasAttrs && getIsBinding(el, options);\n        if (is) {\n          return is;\n        } else if ('development' !== 'production') {\n          var expectedTag = options._componentNameMap && options._componentNameMap[tag];\n          if (expectedTag) {\n            warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');\n          } else if (isUnknownElement(el, tag)) {\n            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the \"name\" option.');\n          }\n        }\n      }\n    } else if (hasAttrs) {\n      return getIsBinding(el, options);\n    }\n  }\n\n  /**\n   * Get \"is\" binding from an element.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Object|undefined}\n   */\n\n  function getIsBinding(el, options) {\n    // dynamic syntax\n    var exp = el.getAttribute('is');\n    if (exp != null) {\n      if (resolveAsset(options, 'components', exp)) {\n        el.removeAttribute('is');\n        return { id: exp };\n      }\n    } else {\n      exp = getBindAttr(el, 'is');\n      if (exp != null) {\n        return { id: exp, dynamic: true };\n      }\n    }\n  }\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   *\n   * All strategy functions follow the same signature:\n   *\n   * @param {*} parentVal\n   * @param {*} childVal\n   * @param {Vue} [vm]\n   */\n\n  var strats = config.optionMergeStrategies = Object.create(null);\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n\n  function mergeData(to, from) {\n    var key, toVal, fromVal;\n    for (key in from) {\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (isObject(toVal) && isObject(fromVal)) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to;\n  }\n\n  /**\n   * Data\n   */\n\n  strats.data = function (parentVal, childVal, vm) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal;\n      }\n      if (typeof childVal !== 'function') {\n        'development' !== 'production' && warn('The \"data\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n        return parentVal;\n      }\n      if (!parentVal) {\n        return childVal;\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn() {\n        return mergeData(childVal.call(this), parentVal.call(this));\n      };\n    } else if (parentVal || childVal) {\n      return function mergedInstanceDataFn() {\n        // instance merge\n        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;\n        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData);\n        } else {\n          return defaultData;\n        }\n      };\n    }\n  };\n\n  /**\n   * El\n   */\n\n  strats.el = function (parentVal, childVal, vm) {\n    if (!vm && childVal && typeof childVal !== 'function') {\n      'development' !== 'production' && warn('The \"el\" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);\n      return;\n    }\n    var ret = childVal || parentVal;\n    // invoke the element factory if this is instance merge\n    return vm && typeof ret === 'function' ? ret.call(vm) : ret;\n  };\n\n  /**\n   * Hooks and param attributes are merged as arrays.\n   */\n\n  strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {\n    return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;\n  };\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n\n  function mergeAssets(parentVal, childVal) {\n    var res = Object.create(parentVal || null);\n    return childVal ? extend(res, guardArrayAssets(childVal)) : res;\n  }\n\n  config._assetTypes.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Events & Watchers.\n   *\n   * Events & watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n\n  strats.watch = strats.events = function (parentVal, childVal) {\n    if (!childVal) return parentVal;\n    if (!parentVal) return childVal;\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key in childVal) {\n      var parent = ret[key];\n      var child = childVal[key];\n      if (parent && !isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key] = parent ? parent.concat(child) : [child];\n    }\n    return ret;\n  };\n\n  /**\n   * Other object hashes.\n   */\n\n  strats.props = strats.methods = strats.computed = function (parentVal, childVal) {\n    if (!childVal) return parentVal;\n    if (!parentVal) return childVal;\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    extend(ret, childVal);\n    return ret;\n  };\n\n  /**\n   * Default strategy.\n   */\n\n  var defaultStrat = function defaultStrat(parentVal, childVal) {\n    return childVal === undefined ? parentVal : childVal;\n  };\n\n  /**\n   * Make sure component options get converted to actual\n   * constructors.\n   *\n   * @param {Object} options\n   */\n\n  function guardComponents(options) {\n    if (options.components) {\n      var components = options.components = guardArrayAssets(options.components);\n      var ids = Object.keys(components);\n      var def;\n      if ('development' !== 'production') {\n        var map = options._componentNameMap = {};\n      }\n      for (var i = 0, l = ids.length; i < l; i++) {\n        var key = ids[i];\n        if (commonTagRE.test(key) || reservedTagRE.test(key)) {\n          'development' !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);\n          continue;\n        }\n        // record a all lowercase <-> kebab-case mapping for\n        // possible custom element case error warning\n        if ('development' !== 'production') {\n          map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);\n        }\n        def = components[key];\n        if (isPlainObject(def)) {\n          components[key] = Vue.extend(def);\n        }\n      }\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   *\n   * @param {Object} options\n   */\n\n  function guardProps(options) {\n    var props = options.props;\n    var i, val;\n    if (isArray(props)) {\n      options.props = {};\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          options.props[val] = null;\n        } else if (val.name) {\n          options.props[val.name] = val;\n        }\n      }\n    } else if (isPlainObject(props)) {\n      var keys = Object.keys(props);\n      i = keys.length;\n      while (i--) {\n        val = props[keys[i]];\n        if (typeof val === 'function') {\n          props[keys[i]] = { type: val };\n        }\n      }\n    }\n  }\n\n  /**\n   * Guard an Array-format assets option and converted it\n   * into the key-value Object format.\n   *\n   * @param {Object|Array} assets\n   * @return {Object}\n   */\n\n  function guardArrayAssets(assets) {\n    if (isArray(assets)) {\n      var res = {};\n      var i = assets.length;\n      var asset;\n      while (i--) {\n        asset = assets[i];\n        var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;\n        if (!id) {\n          'development' !== 'production' && warn('Array-syntax assets must provide a \"name\" or \"id\" field.');\n        } else {\n          res[id] = asset;\n        }\n      }\n      return res;\n    }\n    return assets;\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   *\n   * @param {Object} parent\n   * @param {Object} child\n   * @param {Vue} [vm] - if vm is present, indicates this is\n   *                     an instantiation merge.\n   */\n\n  function mergeOptions(parent, child, vm) {\n    guardComponents(child);\n    guardProps(child);\n    if ('development' !== 'production') {\n      if (child.propsData && !vm) {\n        warn('propsData can only be used as an instantiation option.');\n      }\n    }\n    var options = {};\n    var key;\n    if (child['extends']) {\n      parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);\n    }\n    if (child.mixins) {\n      for (var i = 0, l = child.mixins.length; i < l; i++) {\n        parent = mergeOptions(parent, child.mixins[i], vm);\n      }\n    }\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField(key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options;\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   *\n   * @param {Object} options\n   * @param {String} type\n   * @param {String} id\n   * @param {Boolean} warnMissing\n   * @return {Object|Function}\n   */\n\n  function resolveAsset(options, type, id, warnMissing) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return;\n    }\n    var assets = options[type];\n    var camelizedId;\n    var res = assets[id] ||\n    // camelCase ID\n    assets[camelizedId = camelize(id)] ||\n    // Pascal Case ID\n    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];\n    if ('development' !== 'production' && warnMissing && !res) {\n      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);\n    }\n    return res;\n  }\n\n  var uid$1 = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   *\n   * @constructor\n   */\n  function Dep() {\n    this.id = uid$1++;\n    this.subs = [];\n  }\n\n  // the current target watcher being evaluated.\n  // this is globally unique because there could be only one\n  // watcher being evaluated at any time.\n  Dep.target = null;\n\n  /**\n   * Add a directive subscriber.\n   *\n   * @param {Directive} sub\n   */\n\n  Dep.prototype.addSub = function (sub) {\n    this.subs.push(sub);\n  };\n\n  /**\n   * Remove a directive subscriber.\n   *\n   * @param {Directive} sub\n   */\n\n  Dep.prototype.removeSub = function (sub) {\n    this.subs.$remove(sub);\n  };\n\n  /**\n   * Add self as a dependency to the target watcher.\n   */\n\n  Dep.prototype.depend = function () {\n    Dep.target.addDep(this);\n  };\n\n  /**\n   * Notify all subscribers of a new value.\n   */\n\n  Dep.prototype.notify = function () {\n    // stablize the subscriber list first\n    var subs = toArray(this.subs);\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto)\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n\n  ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      // avoid leaking arguments:\n      // http://jsperf.com/closure-with-arguments\n      var i = arguments.length;\n      var args = new Array(i);\n      while (i--) {\n        args[i] = arguments[i];\n      }\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n          inserted = args;\n          break;\n        case 'unshift':\n          inserted = args;\n          break;\n        case 'splice':\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) ob.observeArray(inserted);\n      // notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\n  /**\n   * Swap the element at the given index with a new value\n   * and emits corresponding event.\n   *\n   * @param {Number} index\n   * @param {*} val\n   * @return {*} - replaced element\n   */\n\n  def(arrayProto, '$set', function $set(index, val) {\n    if (index >= this.length) {\n      this.length = Number(index) + 1;\n    }\n    return this.splice(index, 1, val)[0];\n  });\n\n  /**\n   * Convenience method to remove the element at given index or target element reference.\n   *\n   * @param {*} item\n   */\n\n  def(arrayProto, '$remove', function $remove(item) {\n    /* istanbul ignore if */\n    if (!this.length) return;\n    var index = indexOf(this, item);\n    if (index > -1) {\n      return this.splice(index, 1);\n    }\n  });\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * By default, when a reactive property is set, the new value is\n   * also converted to become reactive. However in certain cases, e.g.\n   * v-for scope alias and props, we don't want to force conversion\n   * because the value may be a nested value under a frozen data structure.\n   *\n   * So whenever we want to set a reactive property without forcing\n   * conversion on the new value, we wrap that call inside this function.\n   */\n\n  var shouldConvert = true;\n\n  function withoutConversion(fn) {\n    shouldConvert = false;\n    fn();\n    shouldConvert = true;\n  }\n\n  /**\n   * Observer class that are attached to each observed\n   * object. Once attached, the observer converts target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatches updates.\n   *\n   * @param {Array|Object} value\n   * @constructor\n   */\n\n  function Observer(value) {\n    this.value = value;\n    this.dep = new Dep();\n    def(value, '__ob__', this);\n    if (isArray(value)) {\n      var augment = hasProto ? protoAugment : copyAugment;\n      augment(value, arrayMethods, arrayKeys);\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  }\n\n  // Instance methods\n\n  /**\n   * Walk through each property and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   *\n   * @param {Object} obj\n   */\n\n  Observer.prototype.walk = function (obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0, l = keys.length; i < l; i++) {\n      this.convert(keys[i], obj[keys[i]]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   *\n   * @param {Array} items\n   */\n\n  Observer.prototype.observeArray = function (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  /**\n   * Convert a property into getter/setter so we can emit\n   * the events when the property is accessed/changed.\n   *\n   * @param {String} key\n   * @param {*} val\n   */\n\n  Observer.prototype.convert = function (key, val) {\n    defineReactive(this.value, key, val);\n  };\n\n  /**\n   * Add an owner vm, so that when $set/$delete mutations\n   * happen we can notify owner vms to proxy the keys and\n   * digest the watchers. This is only called when the object\n   * is observed as an instance's root $data.\n   *\n   * @param {Vue} vm\n   */\n\n  Observer.prototype.addVm = function (vm) {\n    (this.vms || (this.vms = [])).push(vm);\n  };\n\n  /**\n   * Remove an owner vm. This is called when the object is\n   * swapped out as an instance's $data object.\n   *\n   * @param {Vue} vm\n   */\n\n  Observer.prototype.removeVm = function (vm) {\n    this.vms.$remove(vm);\n  };\n\n  // helpers\n\n  /**\n   * Augment an target Object or Array by intercepting\n   * the prototype chain using __proto__\n   *\n   * @param {Object|Array} target\n   * @param {Object} src\n   */\n\n  function protoAugment(target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment an target Object or Array by defining\n   * hidden properties.\n   *\n   * @param {Object|Array} target\n   * @param {Object} proto\n   */\n\n  function copyAugment(target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   *\n   * @param {*} value\n   * @param {Vue} [vm]\n   * @return {Observer|undefined}\n   * @static\n   */\n\n  function observe(value, vm) {\n    if (!value || typeof value !== 'object') {\n      return;\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {\n      ob = new Observer(value);\n    }\n    if (ob && vm) {\n      ob.addVm(vm);\n    }\n    return ob;\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   *\n   * @param {Object} obj\n   * @param {String} key\n   * @param {*} val\n   */\n\n  function defineReactive(obj, key, val) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return;\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n\n    var childOb = observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter() {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n          }\n          if (isArray(value)) {\n            for (var e, i = 0, l = value.length; i < l; i++) {\n              e = value[i];\n              e && e.__ob__ && e.__ob__.dep.depend();\n            }\n          }\n        }\n        return value;\n      },\n      set: function reactiveSetter(newVal) {\n        var value = getter ? getter.call(obj) : val;\n        if (newVal === value) {\n          return;\n        }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n\n\n  var util = Object.freeze({\n  \tdefineReactive: defineReactive,\n  \tset: set,\n  \tdel: del,\n  \thasOwn: hasOwn,\n  \tisLiteral: isLiteral,\n  \tisReserved: isReserved,\n  \t_toString: _toString,\n  \ttoNumber: toNumber,\n  \ttoBoolean: toBoolean,\n  \tstripQuotes: stripQuotes,\n  \tcamelize: camelize,\n  \thyphenate: hyphenate,\n  \tclassify: classify,\n  \tbind: bind,\n  \ttoArray: toArray,\n  \textend: extend,\n  \tisObject: isObject,\n  \tisPlainObject: isPlainObject,\n  \tdef: def,\n  \tdebounce: _debounce,\n  \tindexOf: indexOf,\n  \tcancellable: cancellable,\n  \tlooseEqual: looseEqual,\n  \tisArray: isArray,\n  \thasProto: hasProto,\n  \tinBrowser: inBrowser,\n  \tdevtools: devtools,\n  \tisIE9: isIE9,\n  \tisAndroid: isAndroid,\n  \tisIos: isIos,\n  \tisWechat: isWechat,\n  \tget transitionProp () { return transitionProp; },\n  \tget transitionEndEvent () { return transitionEndEvent; },\n  \tget animationProp () { return animationProp; },\n  \tget animationEndEvent () { return animationEndEvent; },\n  \tnextTick: nextTick,\n  \tget _Set () { return _Set; },\n  \tquery: query,\n  \tinDoc: inDoc,\n  \tgetAttr: getAttr,\n  \tgetBindAttr: getBindAttr,\n  \thasBindAttr: hasBindAttr,\n  \tbefore: before,\n  \tafter: after,\n  \tremove: remove,\n  \tprepend: prepend,\n  \treplace: replace,\n  \ton: on,\n  \toff: off,\n  \tsetClass: setClass,\n  \taddClass: addClass,\n  \tremoveClass: removeClass,\n  \textractContent: extractContent,\n  \ttrimNode: trimNode,\n  \tisTemplate: isTemplate,\n  \tcreateAnchor: createAnchor,\n  \tfindRef: findRef,\n  \tmapNodeRange: mapNodeRange,\n  \tremoveNodeRange: removeNodeRange,\n  \tisFragment: isFragment,\n  \tgetOuterHTML: getOuterHTML,\n  \tmergeOptions: mergeOptions,\n  \tresolveAsset: resolveAsset,\n  \tcheckComponentAttr: checkComponentAttr,\n  \tcommonTagRE: commonTagRE,\n  \treservedTagRE: reservedTagRE,\n  \tget warn () { return warn; }\n  });\n\n  var uid = 0;\n\n  function initMixin (Vue) {\n    /**\n     * The main init sequence. This is called for every\n     * instance, including ones that are created from extended\n     * constructors.\n     *\n     * @param {Object} options - this options object should be\n     *                           the result of merging class\n     *                           options and the options passed\n     *                           in to the constructor.\n     */\n\n    Vue.prototype._init = function (options) {\n      options = options || {};\n\n      this.$el = null;\n      this.$parent = options.parent;\n      this.$root = this.$parent ? this.$parent.$root : this;\n      this.$children = [];\n      this.$refs = {}; // child vm references\n      this.$els = {}; // element references\n      this._watchers = []; // all watchers as an array\n      this._directives = []; // all directives\n\n      // a uid\n      this._uid = uid++;\n\n      // a flag to avoid this being observed\n      this._isVue = true;\n\n      // events bookkeeping\n      this._events = {}; // registered callbacks\n      this._eventsCount = {}; // for $broadcast optimization\n\n      // fragment instance properties\n      this._isFragment = false;\n      this._fragment = // @type {DocumentFragment}\n      this._fragmentStart = // @type {Text|Comment}\n      this._fragmentEnd = null; // @type {Text|Comment}\n\n      // lifecycle state\n      this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;\n      this._unlinkFn = null;\n\n      // context:\n      // if this is a transcluded component, context\n      // will be the common parent vm of this instance\n      // and its host.\n      this._context = options._context || this.$parent;\n\n      // scope:\n      // if this is inside an inline v-for, the scope\n      // will be the intermediate scope created for this\n      // repeat fragment. this is used for linking props\n      // and container directives.\n      this._scope = options._scope;\n\n      // fragment:\n      // if this instance is compiled inside a Fragment, it\n      // needs to reigster itself as a child of that fragment\n      // for attach/detach to work properly.\n      this._frag = options._frag;\n      if (this._frag) {\n        this._frag.children.push(this);\n      }\n\n      // push self into parent / transclusion host\n      if (this.$parent) {\n        this.$parent.$children.push(this);\n      }\n\n      // merge options.\n      options = this.$options = mergeOptions(this.constructor.options, options, this);\n\n      // set ref\n      this._updateRef();\n\n      // initialize data as empty object.\n      // it will be filled up in _initData().\n      this._data = {};\n\n      // call init hook\n      this._callHook('init');\n\n      // initialize data observation and scope inheritance.\n      this._initState();\n\n      // setup event system and option events.\n      this._initEvents();\n\n      // call created hook\n      this._callHook('created');\n\n      // if `el` option is passed, start compilation.\n      if (options.el) {\n        this.$mount(options.el);\n      }\n    };\n  }\n\n  var pathCache = new Cache(1000);\n\n  // actions\n  var APPEND = 0;\n  var PUSH = 1;\n  var INC_SUB_PATH_DEPTH = 2;\n  var PUSH_SUB_PATH = 3;\n\n  // states\n  var BEFORE_PATH = 0;\n  var IN_PATH = 1;\n  var BEFORE_IDENT = 2;\n  var IN_IDENT = 3;\n  var IN_SUB_PATH = 4;\n  var IN_SINGLE_QUOTE = 5;\n  var IN_DOUBLE_QUOTE = 6;\n  var AFTER_PATH = 7;\n  var ERROR = 8;\n\n  var pathStateMachine = [];\n\n  pathStateMachine[BEFORE_PATH] = {\n    'ws': [BEFORE_PATH],\n    'ident': [IN_IDENT, APPEND],\n    '[': [IN_SUB_PATH],\n    'eof': [AFTER_PATH]\n  };\n\n  pathStateMachine[IN_PATH] = {\n    'ws': [IN_PATH],\n    '.': [BEFORE_IDENT],\n    '[': [IN_SUB_PATH],\n    'eof': [AFTER_PATH]\n  };\n\n  pathStateMachine[BEFORE_IDENT] = {\n    'ws': [BEFORE_IDENT],\n    'ident': [IN_IDENT, APPEND]\n  };\n\n  pathStateMachine[IN_IDENT] = {\n    'ident': [IN_IDENT, APPEND],\n    '0': [IN_IDENT, APPEND],\n    'number': [IN_IDENT, APPEND],\n    'ws': [IN_PATH, PUSH],\n    '.': [BEFORE_IDENT, PUSH],\n    '[': [IN_SUB_PATH, PUSH],\n    'eof': [AFTER_PATH, PUSH]\n  };\n\n  pathStateMachine[IN_SUB_PATH] = {\n    \"'\": [IN_SINGLE_QUOTE, APPEND],\n    '\"': [IN_DOUBLE_QUOTE, APPEND],\n    '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n    ']': [IN_PATH, PUSH_SUB_PATH],\n    'eof': ERROR,\n    'else': [IN_SUB_PATH, APPEND]\n  };\n\n  pathStateMachine[IN_SINGLE_QUOTE] = {\n    \"'\": [IN_SUB_PATH, APPEND],\n    'eof': ERROR,\n    'else': [IN_SINGLE_QUOTE, APPEND]\n  };\n\n  pathStateMachine[IN_DOUBLE_QUOTE] = {\n    '\"': [IN_SUB_PATH, APPEND],\n    'eof': ERROR,\n    'else': [IN_DOUBLE_QUOTE, APPEND]\n  };\n\n  /**\n   * Determine the type of a character in a keypath.\n   *\n   * @param {Char} ch\n   * @return {String} type\n   */\n\n  function getPathCharType(ch) {\n    if (ch === undefined) {\n      return 'eof';\n    }\n\n    var code = ch.charCodeAt(0);\n\n    switch (code) {\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x2E: // .\n      case 0x22: // \"\n      case 0x27: // '\n      case 0x30:\n        // 0\n        return ch;\n\n      case 0x5F: // _\n      case 0x24:\n        // $\n        return 'ident';\n\n      case 0x20: // Space\n      case 0x09: // Tab\n      case 0x0A: // Newline\n      case 0x0D: // Return\n      case 0xA0: // No-break space\n      case 0xFEFF: // Byte Order Mark\n      case 0x2028: // Line Separator\n      case 0x2029:\n        // Paragraph Separator\n        return 'ws';\n    }\n\n    // a-z, A-Z\n    if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {\n      return 'ident';\n    }\n\n    // 1-9\n    if (code >= 0x31 && code <= 0x39) {\n      return 'number';\n    }\n\n    return 'else';\n  }\n\n  /**\n   * Format a subPath, return its plain form if it is\n   * a literal string or number. Otherwise prepend the\n   * dynamic indicator (*).\n   *\n   * @param {String} path\n   * @return {String}\n   */\n\n  function formatSubPath(path) {\n    var trimmed = path.trim();\n    // invalid leading 0\n    if (path.charAt(0) === '0' && isNaN(path)) {\n      return false;\n    }\n    return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;\n  }\n\n  /**\n   * Parse a string path into an array of segments\n   *\n   * @param {String} path\n   * @return {Array|undefined}\n   */\n\n  function parse(path) {\n    var keys = [];\n    var index = -1;\n    var mode = BEFORE_PATH;\n    var subPathDepth = 0;\n    var c, newChar, key, type, transition, action, typeMap;\n\n    var actions = [];\n\n    actions[PUSH] = function () {\n      if (key !== undefined) {\n        keys.push(key);\n        key = undefined;\n      }\n    };\n\n    actions[APPEND] = function () {\n      if (key === undefined) {\n        key = newChar;\n      } else {\n        key += newChar;\n      }\n    };\n\n    actions[INC_SUB_PATH_DEPTH] = function () {\n      actions[APPEND]();\n      subPathDepth++;\n    };\n\n    actions[PUSH_SUB_PATH] = function () {\n      if (subPathDepth > 0) {\n        subPathDepth--;\n        mode = IN_SUB_PATH;\n        actions[APPEND]();\n      } else {\n        subPathDepth = 0;\n        key = formatSubPath(key);\n        if (key === false) {\n          return false;\n        } else {\n          actions[PUSH]();\n        }\n      }\n    };\n\n    function maybeUnescapeQuote() {\n      var nextChar = path[index + 1];\n      if (mode === IN_SINGLE_QUOTE && nextChar === \"'\" || mode === IN_DOUBLE_QUOTE && nextChar === '\"') {\n        index++;\n        newChar = '\\\\' + nextChar;\n        actions[APPEND]();\n        return true;\n      }\n    }\n\n    while (mode != null) {\n      index++;\n      c = path[index];\n\n      if (c === '\\\\' && maybeUnescapeQuote()) {\n        continue;\n      }\n\n      type = getPathCharType(c);\n      typeMap = pathStateMachine[mode];\n      transition = typeMap[type] || typeMap['else'] || ERROR;\n\n      if (transition === ERROR) {\n        return; // parse error\n      }\n\n      mode = transition[0];\n      action = actions[transition[1]];\n      if (action) {\n        newChar = transition[2];\n        newChar = newChar === undefined ? c : newChar;\n        if (action() === false) {\n          return;\n        }\n      }\n\n      if (mode === AFTER_PATH) {\n        keys.raw = path;\n        return keys;\n      }\n    }\n  }\n\n  /**\n   * External parse that check for a cache hit first\n   *\n   * @param {String} path\n   * @return {Array|undefined}\n   */\n\n  function parsePath(path) {\n    var hit = pathCache.get(path);\n    if (!hit) {\n      hit = parse(path);\n      if (hit) {\n        pathCache.put(path, hit);\n      }\n    }\n    return hit;\n  }\n\n  /**\n   * Get from an object from a path string\n   *\n   * @param {Object} obj\n   * @param {String} path\n   */\n\n  function getPath(obj, path) {\n    return parseExpression(path).get(obj);\n  }\n\n  /**\n   * Warn against setting non-existent root path on a vm.\n   */\n\n  var warnNonExistent;\n  if ('development' !== 'production') {\n    warnNonExistent = function (path, vm) {\n      warn('You are setting a non-existent path \"' + path.raw + '\" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the \"data\" option for more reliable reactivity ' + 'and better performance.', vm);\n    };\n  }\n\n  /**\n   * Set on an object from a path\n   *\n   * @param {Object} obj\n   * @param {String | Array} path\n   * @param {*} val\n   */\n\n  function setPath(obj, path, val) {\n    var original = obj;\n    if (typeof path === 'string') {\n      path = parse(path);\n    }\n    if (!path || !isObject(obj)) {\n      return false;\n    }\n    var last, key;\n    for (var i = 0, l = path.length; i < l; i++) {\n      last = obj;\n      key = path[i];\n      if (key.charAt(0) === '*') {\n        key = parseExpression(key.slice(1)).get.call(original, original);\n      }\n      if (i < l - 1) {\n        obj = obj[key];\n        if (!isObject(obj)) {\n          obj = {};\n          if ('development' !== 'production' && last._isVue) {\n            warnNonExistent(path, last);\n          }\n          set(last, key, obj);\n        }\n      } else {\n        if (isArray(obj)) {\n          obj.$set(key, val);\n        } else if (key in obj) {\n          obj[key] = val;\n        } else {\n          if ('development' !== 'production' && obj._isVue) {\n            warnNonExistent(path, obj);\n          }\n          set(obj, key, val);\n        }\n      }\n    }\n    return true;\n  }\n\nvar path = Object.freeze({\n    parsePath: parsePath,\n    getPath: getPath,\n    setPath: setPath\n  });\n\n  var expressionCache = new Cache(1000);\n\n  var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';\n  var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n  // keywords that don't make sense inside expressions\n  var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';\n  var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\\\b|') + '\\\\b)');\n\n  var wsRE = /\\s/g;\n  var newlineRE = /\\n/g;\n  var saveRE = /[\\{,]\\s*[\\w\\$_]+\\s*:|('(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`)|new |typeof |void /g;\n  var restoreRE = /\"(\\d+)\"/g;\n  var pathTestRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?'\\]|\\[\".*?\"\\]|\\[\\d+\\]|\\[[A-Za-z_$][\\w$]*\\])*$/;\n  var identRE = /[^\\w$\\.](?:[A-Za-z_$][\\w$]*)/g;\n  var booleanLiteralRE = /^(?:true|false)$/;\n\n  /**\n   * Save / Rewrite / Restore\n   *\n   * When rewriting paths found in an expression, it is\n   * possible for the same letter sequences to be found in\n   * strings and Object literal property keys. Therefore we\n   * remove and store these parts in a temporary array, and\n   * restore them after the path rewrite.\n   */\n\n  var saved = [];\n\n  /**\n   * Save replacer\n   *\n   * The save regex can match two possible cases:\n   * 1. An opening object literal\n   * 2. A string\n   * If matched as a plain string, we need to escape its\n   * newlines, since the string needs to be preserved when\n   * generating the function body.\n   *\n   * @param {String} str\n   * @param {String} isString - str if matched as a string\n   * @return {String} - placeholder with index\n   */\n\n  function save(str, isString) {\n    var i = saved.length;\n    saved[i] = isString ? str.replace(newlineRE, '\\\\n') : str;\n    return '\"' + i + '\"';\n  }\n\n  /**\n   * Path rewrite replacer\n   *\n   * @param {String} raw\n   * @return {String}\n   */\n\n  function rewrite(raw) {\n    var c = raw.charAt(0);\n    var path = raw.slice(1);\n    if (allowedKeywordsRE.test(path)) {\n      return raw;\n    } else {\n      path = path.indexOf('\"') > -1 ? path.replace(restoreRE, restore) : path;\n      return c + 'scope.' + path;\n    }\n  }\n\n  /**\n   * Restore replacer\n   *\n   * @param {String} str\n   * @param {String} i - matched save index\n   * @return {String}\n   */\n\n  function restore(str, i) {\n    return saved[i];\n  }\n\n  /**\n   * Rewrite an expression, prefixing all path accessors with\n   * `scope.` and generate getter/setter functions.\n   *\n   * @param {String} exp\n   * @return {Function}\n   */\n\n  function compileGetter(exp) {\n    if (improperKeywordsRE.test(exp)) {\n      'development' !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);\n    }\n    // reset state\n    saved.length = 0;\n    // save strings and object literal keys\n    var body = exp.replace(saveRE, save).replace(wsRE, '');\n    // rewrite all paths\n    // pad 1 space here becaue the regex matches 1 extra char\n    body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);\n    return makeGetterFn(body);\n  }\n\n  /**\n   * Build a getter function. Requires eval.\n   *\n   * We isolate the try/catch so it doesn't affect the\n   * optimization of the parse function when it is not called.\n   *\n   * @param {String} body\n   * @return {Function|undefined}\n   */\n\n  function makeGetterFn(body) {\n    try {\n      /* eslint-disable no-new-func */\n      return new Function('scope', 'return ' + body + ';');\n      /* eslint-enable no-new-func */\n    } catch (e) {\n      'development' !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);\n    }\n  }\n\n  /**\n   * Compile a setter function for the expression.\n   *\n   * @param {String} exp\n   * @return {Function|undefined}\n   */\n\n  function compileSetter(exp) {\n    var path = parsePath(exp);\n    if (path) {\n      return function (scope, val) {\n        setPath(scope, path, val);\n      };\n    } else {\n      'development' !== 'production' && warn('Invalid setter expression: ' + exp);\n    }\n  }\n\n  /**\n   * Parse an expression into re-written getter/setters.\n   *\n   * @param {String} exp\n   * @param {Boolean} needSet\n   * @return {Function}\n   */\n\n  function parseExpression(exp, needSet) {\n    exp = exp.trim();\n    // try cache\n    var hit = expressionCache.get(exp);\n    if (hit) {\n      if (needSet && !hit.set) {\n        hit.set = compileSetter(hit.exp);\n      }\n      return hit;\n    }\n    var res = { exp: exp };\n    res.get = isSimplePath(exp) && exp.indexOf('[') < 0\n    // optimized super simple getter\n    ? makeGetterFn('scope.' + exp)\n    // dynamic getter\n    : compileGetter(exp);\n    if (needSet) {\n      res.set = compileSetter(exp);\n    }\n    expressionCache.put(exp, res);\n    return res;\n  }\n\n  /**\n   * Check if an expression is a simple path.\n   *\n   * @param {String} exp\n   * @return {Boolean}\n   */\n\n  function isSimplePath(exp) {\n    return pathTestRE.test(exp) &&\n    // don't treat true/false as paths\n    !booleanLiteralRE.test(exp) &&\n    // Math constants e.g. Math.PI, Math.E etc.\n    exp.slice(0, 5) !== 'Math.';\n  }\n\nvar expression = Object.freeze({\n    parseExpression: parseExpression,\n    isSimplePath: isSimplePath\n  });\n\n  // we have two separate queues: one for directive updates\n  // and one for user watcher registered via $watch().\n  // we want to guarantee directive updates to be called\n  // before user watchers so that when user watchers are\n  // triggered, the DOM would have already been in updated\n  // state.\n\n  var queue = [];\n  var userQueue = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n\n  /**\n   * Reset the batcher's state.\n   */\n\n  function resetBatcherState() {\n    queue.length = 0;\n    userQueue.length = 0;\n    has = {};\n    circular = {};\n    waiting = false;\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n\n  function flushBatcherQueue() {\n    var _again = true;\n\n    _function: while (_again) {\n      _again = false;\n\n      runBatcherQueue(queue);\n      runBatcherQueue(userQueue);\n      // user watchers triggered more watchers,\n      // keep flushing until it depletes\n      if (queue.length) {\n        _again = true;\n        continue _function;\n      }\n      // dev tool hook\n      /* istanbul ignore if */\n      if (devtools && config.devtools) {\n        devtools.emit('flush');\n      }\n      resetBatcherState();\n    }\n  }\n\n  /**\n   * Run the watchers in a single queue.\n   *\n   * @param {Array} queue\n   */\n\n  function runBatcherQueue(queue) {\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (var i = 0; i < queue.length; i++) {\n      var watcher = queue[i];\n      var id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if ('development' !== 'production' && has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > config._maxUpdateCount) {\n          warn('You may have an infinite update loop for watcher ' + 'with expression \"' + watcher.expression + '\"', watcher.vm);\n          break;\n        }\n      }\n    }\n    queue.length = 0;\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   *\n   * @param {Watcher} watcher\n   *   properties:\n   *   - {Number} id\n   *   - {Function} run\n   */\n\n  function pushWatcher(watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      // push watcher into appropriate queue\n      var q = watcher.user ? userQueue : queue;\n      has[id] = q.length;\n      q.push(watcher);\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n        nextTick(flushBatcherQueue);\n      }\n    }\n  }\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   *\n   * @param {Vue} vm\n   * @param {String|Function} expOrFn\n   * @param {Function} cb\n   * @param {Object} options\n   *                 - {Array} filters\n   *                 - {Boolean} twoWay\n   *                 - {Boolean} deep\n   *                 - {Boolean} user\n   *                 - {Boolean} sync\n   *                 - {Boolean} lazy\n   *                 - {Function} [preProcess]\n   *                 - {Function} [postProcess]\n   * @constructor\n   */\n  function Watcher(vm, expOrFn, cb, options) {\n    // mix in options\n    if (options) {\n      extend(this, options);\n    }\n    var isFn = typeof expOrFn === 'function';\n    this.vm = vm;\n    vm._watchers.push(this);\n    this.expression = expOrFn;\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.prevError = null; // for async error stacks\n    // parse expression for getter/setter\n    if (isFn) {\n      this.getter = expOrFn;\n      this.setter = undefined;\n    } else {\n      var res = parseExpression(expOrFn, this.twoWay);\n      this.getter = res.get;\n      this.setter = res.set;\n    }\n    this.value = this.lazy ? undefined : this.get();\n    // state for avoiding false triggers for deep and Array\n    // watchers during vm._digest()\n    this.queued = this.shallow = false;\n  }\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n\n  Watcher.prototype.get = function () {\n    this.beforeGet();\n    var scope = this.scope || this.vm;\n    var value;\n    try {\n      value = this.getter.call(scope, scope);\n    } catch (e) {\n      if ('development' !== 'production' && config.warnExpressionErrors) {\n        warn('Error when evaluating expression ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n      }\n    }\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    if (this.preProcess) {\n      value = this.preProcess(value);\n    }\n    if (this.filters) {\n      value = scope._applyFilters(value, null, this.filters, false);\n    }\n    if (this.postProcess) {\n      value = this.postProcess(value);\n    }\n    this.afterGet();\n    return value;\n  };\n\n  /**\n   * Set the corresponding value with the setter.\n   *\n   * @param {*} value\n   */\n\n  Watcher.prototype.set = function (value) {\n    var scope = this.scope || this.vm;\n    if (this.filters) {\n      value = scope._applyFilters(value, this.value, this.filters, true);\n    }\n    try {\n      this.setter.call(scope, scope, value);\n    } catch (e) {\n      if ('development' !== 'production' && config.warnExpressionErrors) {\n        warn('Error when evaluating setter ' + '\"' + this.expression + '\": ' + e.toString(), this.vm);\n      }\n    }\n    // two-way sync for v-for alias\n    var forContext = scope.$forContext;\n    if (forContext && forContext.alias === this.expression) {\n      if (forContext.filters) {\n        'development' !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);\n        return;\n      }\n      forContext._withLock(function () {\n        if (scope.$key) {\n          // original is an object\n          forContext.rawValue[scope.$key] = value;\n        } else {\n          forContext.rawValue.$set(scope.$index, value);\n        }\n      });\n    }\n  };\n\n  /**\n   * Prepare for dependency collection.\n   */\n\n  Watcher.prototype.beforeGet = function () {\n    Dep.target = this;\n  };\n\n  /**\n   * Add a dependency to this directive.\n   *\n   * @param {Dep} dep\n   */\n\n  Watcher.prototype.addDep = function (dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n\n  Watcher.prototype.afterGet = function () {\n    Dep.target = null;\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this.deps[i];\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   *\n   * @param {Boolean} shallow\n   */\n\n  Watcher.prototype.update = function (shallow) {\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync || !config.async) {\n      this.run();\n    } else {\n      // if queued, only overwrite shallow with non-shallow,\n      // but not the other way around.\n      this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;\n      this.queued = true;\n      // record before-push error stack in debug mode\n      /* istanbul ignore if */\n      if ('development' !== 'production' && config.debug) {\n        this.prevError = new Error('[vue] async stack trace');\n      }\n      pushWatcher(this);\n    }\n  };\n\n  /**\n   * Batcher job interface.\n   * Will be called by the batcher.\n   */\n\n  Watcher.prototype.run = function () {\n    if (this.active) {\n      var value = this.get();\n      if (value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated; but only do so if this is a\n      // non-shallow update (caused by a vm digest).\n      (isObject(value) || this.deep) && !this.shallow) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        // in debug + async mode, when a watcher callbacks\n        // throws, we also throw the saved before-push error\n        // so the full cross-tick stack trace is available.\n        var prevError = this.prevError;\n        /* istanbul ignore if */\n        if ('development' !== 'production' && config.debug && prevError) {\n          this.prevError = null;\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            nextTick(function () {\n              throw prevError;\n            }, 0);\n            throw e;\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n      this.queued = this.shallow = false;\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n\n  Watcher.prototype.evaluate = function () {\n    // avoid overwriting another watcher that is being\n    // collected.\n    var current = Dep.target;\n    this.value = this.get();\n    this.dirty = false;\n    Dep.target = current;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n\n  Watcher.prototype.depend = function () {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subcriber list.\n   */\n\n  Watcher.prototype.teardown = function () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed or is performing a v-for\n      // re-render (the watcher list is then filtered by v-for).\n      if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n        this.vm._watchers.$remove(this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n      this.active = false;\n      this.vm = this.cb = this.value = null;\n    }\n  };\n\n  /**\n   * Recrusively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   *\n   * @param {*} val\n   */\n\n  var seenObjects = new _Set();\n  function traverse(val, seen) {\n    var i = undefined,\n        keys = undefined;\n    if (!seen) {\n      seen = seenObjects;\n      seen.clear();\n    }\n    var isA = isArray(val);\n    var isO = isObject(val);\n    if (isA || isO) {\n      if (val.__ob__) {\n        var depId = val.__ob__.dep.id;\n        if (seen.has(depId)) {\n          return;\n        } else {\n          seen.add(depId);\n        }\n      }\n      if (isA) {\n        i = val.length;\n        while (i--) traverse(val[i], seen);\n      } else if (isO) {\n        keys = Object.keys(val);\n        i = keys.length;\n        while (i--) traverse(val[keys[i]], seen);\n      }\n    }\n  }\n\n  var text$1 = {\n\n    bind: function bind() {\n      this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';\n    },\n\n    update: function update(value) {\n      this.el[this.attr] = _toString(value);\n    }\n  };\n\n  var templateCache = new Cache(1000);\n  var idSelectorCache = new Cache(1000);\n\n  var map = {\n    efault: [0, '', ''],\n    legend: [1, '<fieldset>', '</fieldset>'],\n    tr: [2, '<table><tbody>', '</tbody></table>'],\n    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']\n  };\n\n  map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];\n\n  map.option = map.optgroup = [1, '<select multiple=\"multiple\">', '</select>'];\n\n  map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];\n\n  map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns=\"http://www.w3.org/2000/svg\" ' + 'xmlns:xlink=\"http://www.w3.org/1999/xlink\" ' + 'xmlns:ev=\"http://www.w3.org/2001/xml-events\"' + 'version=\"1.1\">', '</svg>'];\n\n  /**\n   * Check if a node is a supported template node with a\n   * DocumentFragment content.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isRealTemplate(node) {\n    return isTemplate(node) && isFragment(node.content);\n  }\n\n  var tagRE$1 = /<([\\w:-]+)/;\n  var entityRE = /&#?\\w+?;/;\n\n  /**\n   * Convert a string template to a DocumentFragment.\n   * Determines correct wrapping by tag types. Wrapping\n   * strategy found in jQuery & component/domify.\n   *\n   * @param {String} templateString\n   * @param {Boolean} raw\n   * @return {DocumentFragment}\n   */\n\n  function stringToFragment(templateString, raw) {\n    // try a cache hit first\n    var cacheKey = raw ? templateString : templateString.trim();\n    var hit = templateCache.get(cacheKey);\n    if (hit) {\n      return hit;\n    }\n\n    var frag = document.createDocumentFragment();\n    var tagMatch = templateString.match(tagRE$1);\n    var entityMatch = entityRE.test(templateString);\n\n    if (!tagMatch && !entityMatch) {\n      // text only, return a single text node.\n      frag.appendChild(document.createTextNode(templateString));\n    } else {\n      var tag = tagMatch && tagMatch[1];\n      var wrap = map[tag] || map.efault;\n      var depth = wrap[0];\n      var prefix = wrap[1];\n      var suffix = wrap[2];\n      var node = document.createElement('div');\n\n      node.innerHTML = prefix + templateString + suffix;\n      while (depth--) {\n        node = node.lastChild;\n      }\n\n      var child;\n      /* eslint-disable no-cond-assign */\n      while (child = node.firstChild) {\n        /* eslint-enable no-cond-assign */\n        frag.appendChild(child);\n      }\n    }\n    if (!raw) {\n      trimNode(frag);\n    }\n    templateCache.put(cacheKey, frag);\n    return frag;\n  }\n\n  /**\n   * Convert a template node to a DocumentFragment.\n   *\n   * @param {Node} node\n   * @return {DocumentFragment}\n   */\n\n  function nodeToFragment(node) {\n    // if its a template tag and the browser supports it,\n    // its content is already a document fragment. However, iOS Safari has\n    // bug when using directly cloned template content with touch\n    // events and can cause crashes when the nodes are removed from DOM, so we\n    // have to treat template elements as string templates. (#2805)\n    /* istanbul ignore if */\n    if (isRealTemplate(node)) {\n      return stringToFragment(node.innerHTML);\n    }\n    // script template\n    if (node.tagName === 'SCRIPT') {\n      return stringToFragment(node.textContent);\n    }\n    // normal node, clone it to avoid mutating the original\n    var clonedNode = cloneNode(node);\n    var frag = document.createDocumentFragment();\n    var child;\n    /* eslint-disable no-cond-assign */\n    while (child = clonedNode.firstChild) {\n      /* eslint-enable no-cond-assign */\n      frag.appendChild(child);\n    }\n    trimNode(frag);\n    return frag;\n  }\n\n  // Test for the presence of the Safari template cloning bug\n  // https://bugs.webkit.org/showug.cgi?id=137755\n  var hasBrokenTemplate = (function () {\n    /* istanbul ignore else */\n    if (inBrowser) {\n      var a = document.createElement('div');\n      a.innerHTML = '<template>1</template>';\n      return !a.cloneNode(true).firstChild.innerHTML;\n    } else {\n      return false;\n    }\n  })();\n\n  // Test for IE10/11 textarea placeholder clone bug\n  var hasTextareaCloneBug = (function () {\n    /* istanbul ignore else */\n    if (inBrowser) {\n      var t = document.createElement('textarea');\n      t.placeholder = 't';\n      return t.cloneNode(true).value === 't';\n    } else {\n      return false;\n    }\n  })();\n\n  /**\n   * 1. Deal with Safari cloning nested <template> bug by\n   *    manually cloning all template instances.\n   * 2. Deal with IE10/11 textarea placeholder bug by setting\n   *    the correct value after cloning.\n   *\n   * @param {Element|DocumentFragment} node\n   * @return {Element|DocumentFragment}\n   */\n\n  function cloneNode(node) {\n    /* istanbul ignore if */\n    if (!node.querySelectorAll) {\n      return node.cloneNode();\n    }\n    var res = node.cloneNode(true);\n    var i, original, cloned;\n    /* istanbul ignore if */\n    if (hasBrokenTemplate) {\n      var tempClone = res;\n      if (isRealTemplate(node)) {\n        node = node.content;\n        tempClone = res.content;\n      }\n      original = node.querySelectorAll('template');\n      if (original.length) {\n        cloned = tempClone.querySelectorAll('template');\n        i = cloned.length;\n        while (i--) {\n          cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);\n        }\n      }\n    }\n    /* istanbul ignore if */\n    if (hasTextareaCloneBug) {\n      if (node.tagName === 'TEXTAREA') {\n        res.value = node.value;\n      } else {\n        original = node.querySelectorAll('textarea');\n        if (original.length) {\n          cloned = res.querySelectorAll('textarea');\n          i = cloned.length;\n          while (i--) {\n            cloned[i].value = original[i].value;\n          }\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Process the template option and normalizes it into a\n   * a DocumentFragment that can be used as a partial or a\n   * instance template.\n   *\n   * @param {*} template\n   *        Possible values include:\n   *        - DocumentFragment object\n   *        - Node object of type Template\n   *        - id selector: '#some-template-id'\n   *        - template string: '<div><span>{{msg}}</span></div>'\n   * @param {Boolean} shouldClone\n   * @param {Boolean} raw\n   *        inline HTML interpolation. Do not check for id\n   *        selector and keep whitespace in the string.\n   * @return {DocumentFragment|undefined}\n   */\n\n  function parseTemplate(template, shouldClone, raw) {\n    var node, frag;\n\n    // if the template is already a document fragment,\n    // do nothing\n    if (isFragment(template)) {\n      trimNode(template);\n      return shouldClone ? cloneNode(template) : template;\n    }\n\n    if (typeof template === 'string') {\n      // id selector\n      if (!raw && template.charAt(0) === '#') {\n        // id selector can be cached too\n        frag = idSelectorCache.get(template);\n        if (!frag) {\n          node = document.getElementById(template.slice(1));\n          if (node) {\n            frag = nodeToFragment(node);\n            // save selector to cache\n            idSelectorCache.put(template, frag);\n          }\n        }\n      } else {\n        // normal string template\n        frag = stringToFragment(template, raw);\n      }\n    } else if (template.nodeType) {\n      // a direct node\n      frag = nodeToFragment(template);\n    }\n\n    return frag && shouldClone ? cloneNode(frag) : frag;\n  }\n\nvar template = Object.freeze({\n    cloneNode: cloneNode,\n    parseTemplate: parseTemplate\n  });\n\n  var html = {\n\n    bind: function bind() {\n      // a comment node means this is a binding for\n      // {{{ inline unescaped html }}}\n      if (this.el.nodeType === 8) {\n        // hold nodes\n        this.nodes = [];\n        // replace the placeholder with proper anchor\n        this.anchor = createAnchor('v-html');\n        replace(this.el, this.anchor);\n      }\n    },\n\n    update: function update(value) {\n      value = _toString(value);\n      if (this.nodes) {\n        this.swap(value);\n      } else {\n        this.el.innerHTML = value;\n      }\n    },\n\n    swap: function swap(value) {\n      // remove old nodes\n      var i = this.nodes.length;\n      while (i--) {\n        remove(this.nodes[i]);\n      }\n      // convert new value to a fragment\n      // do not attempt to retrieve from id selector\n      var frag = parseTemplate(value, true, true);\n      // save a reference to these nodes so we can remove later\n      this.nodes = toArray(frag.childNodes);\n      before(frag, this.anchor);\n    }\n  };\n\n  /**\n   * Abstraction for a partially-compiled fragment.\n   * Can optionally compile content with a child scope.\n   *\n   * @param {Function} linker\n   * @param {Vue} vm\n   * @param {DocumentFragment} frag\n   * @param {Vue} [host]\n   * @param {Object} [scope]\n   * @param {Fragment} [parentFrag]\n   */\n  function Fragment(linker, vm, frag, host, scope, parentFrag) {\n    this.children = [];\n    this.childFrags = [];\n    this.vm = vm;\n    this.scope = scope;\n    this.inserted = false;\n    this.parentFrag = parentFrag;\n    if (parentFrag) {\n      parentFrag.childFrags.push(this);\n    }\n    this.unlink = linker(vm, frag, host, scope, this);\n    var single = this.single = frag.childNodes.length === 1 &&\n    // do not go single mode if the only node is an anchor\n    !frag.childNodes[0].__v_anchor;\n    if (single) {\n      this.node = frag.childNodes[0];\n      this.before = singleBefore;\n      this.remove = singleRemove;\n    } else {\n      this.node = createAnchor('fragment-start');\n      this.end = createAnchor('fragment-end');\n      this.frag = frag;\n      prepend(this.node, frag);\n      frag.appendChild(this.end);\n      this.before = multiBefore;\n      this.remove = multiRemove;\n    }\n    this.node.__v_frag = this;\n  }\n\n  /**\n   * Call attach/detach for all components contained within\n   * this fragment. Also do so recursively for all child\n   * fragments.\n   *\n   * @param {Function} hook\n   */\n\n  Fragment.prototype.callHook = function (hook) {\n    var i, l;\n    for (i = 0, l = this.childFrags.length; i < l; i++) {\n      this.childFrags[i].callHook(hook);\n    }\n    for (i = 0, l = this.children.length; i < l; i++) {\n      hook(this.children[i]);\n    }\n  };\n\n  /**\n   * Insert fragment before target, single node version\n   *\n   * @param {Node} target\n   * @param {Boolean} withTransition\n   */\n\n  function singleBefore(target, withTransition) {\n    this.inserted = true;\n    var method = withTransition !== false ? beforeWithTransition : before;\n    method(this.node, target, this.vm);\n    if (inDoc(this.node)) {\n      this.callHook(attach);\n    }\n  }\n\n  /**\n   * Remove fragment, single node version\n   */\n\n  function singleRemove() {\n    this.inserted = false;\n    var shouldCallRemove = inDoc(this.node);\n    var self = this;\n    this.beforeRemove();\n    removeWithTransition(this.node, this.vm, function () {\n      if (shouldCallRemove) {\n        self.callHook(detach);\n      }\n      self.destroy();\n    });\n  }\n\n  /**\n   * Insert fragment before target, multi-nodes version\n   *\n   * @param {Node} target\n   * @param {Boolean} withTransition\n   */\n\n  function multiBefore(target, withTransition) {\n    this.inserted = true;\n    var vm = this.vm;\n    var method = withTransition !== false ? beforeWithTransition : before;\n    mapNodeRange(this.node, this.end, function (node) {\n      method(node, target, vm);\n    });\n    if (inDoc(this.node)) {\n      this.callHook(attach);\n    }\n  }\n\n  /**\n   * Remove fragment, multi-nodes version\n   */\n\n  function multiRemove() {\n    this.inserted = false;\n    var self = this;\n    var shouldCallRemove = inDoc(this.node);\n    this.beforeRemove();\n    removeNodeRange(this.node, this.end, this.vm, this.frag, function () {\n      if (shouldCallRemove) {\n        self.callHook(detach);\n      }\n      self.destroy();\n    });\n  }\n\n  /**\n   * Prepare the fragment for removal.\n   */\n\n  Fragment.prototype.beforeRemove = function () {\n    var i, l;\n    for (i = 0, l = this.childFrags.length; i < l; i++) {\n      // call the same method recursively on child\n      // fragments, depth-first\n      this.childFrags[i].beforeRemove(false);\n    }\n    for (i = 0, l = this.children.length; i < l; i++) {\n      // Call destroy for all contained instances,\n      // with remove:false and defer:true.\n      // Defer is necessary because we need to\n      // keep the children to call detach hooks\n      // on them.\n      this.children[i].$destroy(false, true);\n    }\n    var dirs = this.unlink.dirs;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      // disable the watchers on all the directives\n      // so that the rendered content stays the same\n      // during removal.\n      dirs[i]._watcher && dirs[i]._watcher.teardown();\n    }\n  };\n\n  /**\n   * Destroy the fragment.\n   */\n\n  Fragment.prototype.destroy = function () {\n    if (this.parentFrag) {\n      this.parentFrag.childFrags.$remove(this);\n    }\n    this.node.__v_frag = null;\n    this.unlink();\n  };\n\n  /**\n   * Call attach hook for a Vue instance.\n   *\n   * @param {Vue} child\n   */\n\n  function attach(child) {\n    if (!child._isAttached && inDoc(child.$el)) {\n      child._callHook('attached');\n    }\n  }\n\n  /**\n   * Call detach hook for a Vue instance.\n   *\n   * @param {Vue} child\n   */\n\n  function detach(child) {\n    if (child._isAttached && !inDoc(child.$el)) {\n      child._callHook('detached');\n    }\n  }\n\n  var linkerCache = new Cache(5000);\n\n  /**\n   * A factory that can be used to create instances of a\n   * fragment. Caches the compiled linker if possible.\n   *\n   * @param {Vue} vm\n   * @param {Element|String} el\n   */\n  function FragmentFactory(vm, el) {\n    this.vm = vm;\n    var template;\n    var isString = typeof el === 'string';\n    if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {\n      template = parseTemplate(el, true);\n    } else {\n      template = document.createDocumentFragment();\n      template.appendChild(el);\n    }\n    this.template = template;\n    // linker can be cached, but only for components\n    var linker;\n    var cid = vm.constructor.cid;\n    if (cid > 0) {\n      var cacheId = cid + (isString ? el : getOuterHTML(el));\n      linker = linkerCache.get(cacheId);\n      if (!linker) {\n        linker = compile(template, vm.$options, true);\n        linkerCache.put(cacheId, linker);\n      }\n    } else {\n      linker = compile(template, vm.$options, true);\n    }\n    this.linker = linker;\n  }\n\n  /**\n   * Create a fragment instance with given host and scope.\n   *\n   * @param {Vue} host\n   * @param {Object} scope\n   * @param {Fragment} parentFrag\n   */\n\n  FragmentFactory.prototype.create = function (host, scope, parentFrag) {\n    var frag = cloneNode(this.template);\n    return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);\n  };\n\n  var ON = 700;\n  var MODEL = 800;\n  var BIND = 850;\n  var TRANSITION = 1100;\n  var EL = 1500;\n  var COMPONENT = 1500;\n  var PARTIAL = 1750;\n  var IF = 2100;\n  var FOR = 2200;\n  var SLOT = 2300;\n\n  var uid$3 = 0;\n\n  var vFor = {\n\n    priority: FOR,\n    terminal: true,\n\n    params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],\n\n    bind: function bind() {\n      // support \"item in/of items\" syntax\n      var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);\n      if (inMatch) {\n        var itMatch = inMatch[1].match(/\\((.*),(.*)\\)/);\n        if (itMatch) {\n          this.iterator = itMatch[1].trim();\n          this.alias = itMatch[2].trim();\n        } else {\n          this.alias = inMatch[1].trim();\n        }\n        this.expression = inMatch[2];\n      }\n\n      if (!this.alias) {\n        'development' !== 'production' && warn('Invalid v-for expression \"' + this.descriptor.raw + '\": ' + 'alias is required.', this.vm);\n        return;\n      }\n\n      // uid as a cache identifier\n      this.id = '__v-for__' + ++uid$3;\n\n      // check if this is an option list,\n      // so that we know if we need to update the <select>'s\n      // v-model when the option list has changed.\n      // because v-model has a lower priority than v-for,\n      // the v-model is not bound here yet, so we have to\n      // retrive it in the actual updateModel() function.\n      var tag = this.el.tagName;\n      this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';\n\n      // setup anchor nodes\n      this.start = createAnchor('v-for-start');\n      this.end = createAnchor('v-for-end');\n      replace(this.el, this.end);\n      before(this.start, this.end);\n\n      // cache\n      this.cache = Object.create(null);\n\n      // fragment factory\n      this.factory = new FragmentFactory(this.vm, this.el);\n    },\n\n    update: function update(data) {\n      this.diff(data);\n      this.updateRef();\n      this.updateModel();\n    },\n\n    /**\n     * Diff, based on new data and old data, determine the\n     * minimum amount of DOM manipulations needed to make the\n     * DOM reflect the new data Array.\n     *\n     * The algorithm diffs the new data Array by storing a\n     * hidden reference to an owner vm instance on previously\n     * seen data. This allows us to achieve O(n) which is\n     * better than a levenshtein distance based algorithm,\n     * which is O(m * n).\n     *\n     * @param {Array} data\n     */\n\n    diff: function diff(data) {\n      // check if the Array was converted from an Object\n      var item = data[0];\n      var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');\n\n      var trackByKey = this.params.trackBy;\n      var oldFrags = this.frags;\n      var frags = this.frags = new Array(data.length);\n      var alias = this.alias;\n      var iterator = this.iterator;\n      var start = this.start;\n      var end = this.end;\n      var inDocument = inDoc(start);\n      var init = !oldFrags;\n      var i, l, frag, key, value, primitive;\n\n      // First pass, go through the new Array and fill up\n      // the new frags array. If a piece of data has a cached\n      // instance for it, we reuse it. Otherwise build a new\n      // instance.\n      for (i = 0, l = data.length; i < l; i++) {\n        item = data[i];\n        key = convertedFromObject ? item.$key : null;\n        value = convertedFromObject ? item.$value : item;\n        primitive = !isObject(value);\n        frag = !init && this.getCachedFrag(value, i, key);\n        if (frag) {\n          // reusable fragment\n          frag.reused = true;\n          // update $index\n          frag.scope.$index = i;\n          // update $key\n          if (key) {\n            frag.scope.$key = key;\n          }\n          // update iterator\n          if (iterator) {\n            frag.scope[iterator] = key !== null ? key : i;\n          }\n          // update data for track-by, object repeat &\n          // primitive values.\n          if (trackByKey || convertedFromObject || primitive) {\n            withoutConversion(function () {\n              frag.scope[alias] = value;\n            });\n          }\n        } else {\n          // new isntance\n          frag = this.create(value, alias, i, key);\n          frag.fresh = !init;\n        }\n        frags[i] = frag;\n        if (init) {\n          frag.before(end);\n        }\n      }\n\n      // we're done for the initial render.\n      if (init) {\n        return;\n      }\n\n      // Second pass, go through the old fragments and\n      // destroy those who are not reused (and remove them\n      // from cache)\n      var removalIndex = 0;\n      var totalRemoved = oldFrags.length - frags.length;\n      // when removing a large number of fragments, watcher removal\n      // turns out to be a perf bottleneck, so we batch the watcher\n      // removals into a single filter call!\n      this.vm._vForRemoving = true;\n      for (i = 0, l = oldFrags.length; i < l; i++) {\n        frag = oldFrags[i];\n        if (!frag.reused) {\n          this.deleteCachedFrag(frag);\n          this.remove(frag, removalIndex++, totalRemoved, inDocument);\n        }\n      }\n      this.vm._vForRemoving = false;\n      if (removalIndex) {\n        this.vm._watchers = this.vm._watchers.filter(function (w) {\n          return w.active;\n        });\n      }\n\n      // Final pass, move/insert new fragments into the\n      // right place.\n      var targetPrev, prevEl, currentPrev;\n      var insertionIndex = 0;\n      for (i = 0, l = frags.length; i < l; i++) {\n        frag = frags[i];\n        // this is the frag that we should be after\n        targetPrev = frags[i - 1];\n        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n        if (frag.reused && !frag.staggerCb) {\n          currentPrev = findPrevFrag(frag, start, this.id);\n          if (currentPrev !== targetPrev && (!currentPrev ||\n          // optimization for moving a single item.\n          // thanks to suggestions by @livoras in #1807\n          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n            this.move(frag, prevEl);\n          }\n        } else {\n          // new instance, or still in stagger.\n          // insert with updated stagger index.\n          this.insert(frag, insertionIndex++, prevEl, inDocument);\n        }\n        frag.reused = frag.fresh = false;\n      }\n    },\n\n    /**\n     * Create a new fragment instance.\n     *\n     * @param {*} value\n     * @param {String} alias\n     * @param {Number} index\n     * @param {String} [key]\n     * @return {Fragment}\n     */\n\n    create: function create(value, alias, index, key) {\n      var host = this._host;\n      // create iteration scope\n      var parentScope = this._scope || this.vm;\n      var scope = Object.create(parentScope);\n      // ref holder for the scope\n      scope.$refs = Object.create(parentScope.$refs);\n      scope.$els = Object.create(parentScope.$els);\n      // make sure point $parent to parent scope\n      scope.$parent = parentScope;\n      // for two-way binding on alias\n      scope.$forContext = this;\n      // define scope properties\n      // important: define the scope alias without forced conversion\n      // so that frozen data structures remain non-reactive.\n      withoutConversion(function () {\n        defineReactive(scope, alias, value);\n      });\n      defineReactive(scope, '$index', index);\n      if (key) {\n        defineReactive(scope, '$key', key);\n      } else if (scope.$key) {\n        // avoid accidental fallback\n        def(scope, '$key', null);\n      }\n      if (this.iterator) {\n        defineReactive(scope, this.iterator, key !== null ? key : index);\n      }\n      var frag = this.factory.create(host, scope, this._frag);\n      frag.forId = this.id;\n      this.cacheFrag(value, frag, index, key);\n      return frag;\n    },\n\n    /**\n     * Update the v-ref on owner vm.\n     */\n\n    updateRef: function updateRef() {\n      var ref = this.descriptor.ref;\n      if (!ref) return;\n      var hash = (this._scope || this.vm).$refs;\n      var refs;\n      if (!this.fromObject) {\n        refs = this.frags.map(findVmFromFrag);\n      } else {\n        refs = {};\n        this.frags.forEach(function (frag) {\n          refs[frag.scope.$key] = findVmFromFrag(frag);\n        });\n      }\n      hash[ref] = refs;\n    },\n\n    /**\n     * For option lists, update the containing v-model on\n     * parent <select>.\n     */\n\n    updateModel: function updateModel() {\n      if (this.isOption) {\n        var parent = this.start.parentNode;\n        var model = parent && parent.__v_model;\n        if (model) {\n          model.forceUpdate();\n        }\n      }\n    },\n\n    /**\n     * Insert a fragment. Handles staggering.\n     *\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {Node} prevEl\n     * @param {Boolean} inDocument\n     */\n\n    insert: function insert(frag, index, prevEl, inDocument) {\n      if (frag.staggerCb) {\n        frag.staggerCb.cancel();\n        frag.staggerCb = null;\n      }\n      var staggerAmount = this.getStagger(frag, index, null, 'enter');\n      if (inDocument && staggerAmount) {\n        // create an anchor and insert it synchronously,\n        // so that we can resolve the correct order without\n        // worrying about some elements not inserted yet\n        var anchor = frag.staggerAnchor;\n        if (!anchor) {\n          anchor = frag.staggerAnchor = createAnchor('stagger-anchor');\n          anchor.__v_frag = frag;\n        }\n        after(anchor, prevEl);\n        var op = frag.staggerCb = cancellable(function () {\n          frag.staggerCb = null;\n          frag.before(anchor);\n          remove(anchor);\n        });\n        setTimeout(op, staggerAmount);\n      } else {\n        var target = prevEl.nextSibling;\n        /* istanbul ignore if */\n        if (!target) {\n          // reset end anchor position in case the position was messed up\n          // by an external drag-n-drop library.\n          after(this.end, prevEl);\n          target = this.end;\n        }\n        frag.before(target);\n      }\n    },\n\n    /**\n     * Remove a fragment. Handles staggering.\n     *\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {Number} total\n     * @param {Boolean} inDocument\n     */\n\n    remove: function remove(frag, index, total, inDocument) {\n      if (frag.staggerCb) {\n        frag.staggerCb.cancel();\n        frag.staggerCb = null;\n        // it's not possible for the same frag to be removed\n        // twice, so if we have a pending stagger callback,\n        // it means this frag is queued for enter but removed\n        // before its transition started. Since it is already\n        // destroyed, we can just leave it in detached state.\n        return;\n      }\n      var staggerAmount = this.getStagger(frag, index, total, 'leave');\n      if (inDocument && staggerAmount) {\n        var op = frag.staggerCb = cancellable(function () {\n          frag.staggerCb = null;\n          frag.remove();\n        });\n        setTimeout(op, staggerAmount);\n      } else {\n        frag.remove();\n      }\n    },\n\n    /**\n     * Move a fragment to a new position.\n     * Force no transition.\n     *\n     * @param {Fragment} frag\n     * @param {Node} prevEl\n     */\n\n    move: function move(frag, prevEl) {\n      // fix a common issue with Sortable:\n      // if prevEl doesn't have nextSibling, this means it's\n      // been dragged after the end anchor. Just re-position\n      // the end anchor to the end of the container.\n      /* istanbul ignore if */\n      if (!prevEl.nextSibling) {\n        this.end.parentNode.appendChild(this.end);\n      }\n      frag.before(prevEl.nextSibling, false);\n    },\n\n    /**\n     * Cache a fragment using track-by or the object key.\n     *\n     * @param {*} value\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {String} [key]\n     */\n\n    cacheFrag: function cacheFrag(value, frag, index, key) {\n      var trackByKey = this.params.trackBy;\n      var cache = this.cache;\n      var primitive = !isObject(value);\n      var id;\n      if (key || trackByKey || primitive) {\n        id = getTrackByKey(index, key, value, trackByKey);\n        if (!cache[id]) {\n          cache[id] = frag;\n        } else if (trackByKey !== '$index') {\n          'development' !== 'production' && this.warnDuplicate(value);\n        }\n      } else {\n        id = this.id;\n        if (hasOwn(value, id)) {\n          if (value[id] === null) {\n            value[id] = frag;\n          } else {\n            'development' !== 'production' && this.warnDuplicate(value);\n          }\n        } else if (Object.isExtensible(value)) {\n          def(value, id, frag);\n        } else if ('development' !== 'production') {\n          warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');\n        }\n      }\n      frag.raw = value;\n    },\n\n    /**\n     * Get a cached fragment from the value/index/key\n     *\n     * @param {*} value\n     * @param {Number} index\n     * @param {String} key\n     * @return {Fragment}\n     */\n\n    getCachedFrag: function getCachedFrag(value, index, key) {\n      var trackByKey = this.params.trackBy;\n      var primitive = !isObject(value);\n      var frag;\n      if (key || trackByKey || primitive) {\n        var id = getTrackByKey(index, key, value, trackByKey);\n        frag = this.cache[id];\n      } else {\n        frag = value[this.id];\n      }\n      if (frag && (frag.reused || frag.fresh)) {\n        'development' !== 'production' && this.warnDuplicate(value);\n      }\n      return frag;\n    },\n\n    /**\n     * Delete a fragment from cache.\n     *\n     * @param {Fragment} frag\n     */\n\n    deleteCachedFrag: function deleteCachedFrag(frag) {\n      var value = frag.raw;\n      var trackByKey = this.params.trackBy;\n      var scope = frag.scope;\n      var index = scope.$index;\n      // fix #948: avoid accidentally fall through to\n      // a parent repeater which happens to have $key.\n      var key = hasOwn(scope, '$key') && scope.$key;\n      var primitive = !isObject(value);\n      if (trackByKey || key || primitive) {\n        var id = getTrackByKey(index, key, value, trackByKey);\n        this.cache[id] = null;\n      } else {\n        value[this.id] = null;\n        frag.raw = null;\n      }\n    },\n\n    /**\n     * Get the stagger amount for an insertion/removal.\n     *\n     * @param {Fragment} frag\n     * @param {Number} index\n     * @param {Number} total\n     * @param {String} type\n     */\n\n    getStagger: function getStagger(frag, index, total, type) {\n      type = type + 'Stagger';\n      var trans = frag.node.__v_trans;\n      var hooks = trans && trans.hooks;\n      var hook = hooks && (hooks[type] || hooks.stagger);\n      return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);\n    },\n\n    /**\n     * Pre-process the value before piping it through the\n     * filters. This is passed to and called by the watcher.\n     */\n\n    _preProcess: function _preProcess(value) {\n      // regardless of type, store the un-filtered raw value.\n      this.rawValue = value;\n      return value;\n    },\n\n    /**\n     * Post-process the value after it has been piped through\n     * the filters. This is passed to and called by the watcher.\n     *\n     * It is necessary for this to be called during the\n     * wathcer's dependency collection phase because we want\n     * the v-for to update when the source Object is mutated.\n     */\n\n    _postProcess: function _postProcess(value) {\n      if (isArray(value)) {\n        return value;\n      } else if (isPlainObject(value)) {\n        // convert plain object to array.\n        var keys = Object.keys(value);\n        var i = keys.length;\n        var res = new Array(i);\n        var key;\n        while (i--) {\n          key = keys[i];\n          res[i] = {\n            $key: key,\n            $value: value[key]\n          };\n        }\n        return res;\n      } else {\n        if (typeof value === 'number' && !isNaN(value)) {\n          value = range(value);\n        }\n        return value || [];\n      }\n    },\n\n    unbind: function unbind() {\n      if (this.descriptor.ref) {\n        (this._scope || this.vm).$refs[this.descriptor.ref] = null;\n      }\n      if (this.frags) {\n        var i = this.frags.length;\n        var frag;\n        while (i--) {\n          frag = this.frags[i];\n          this.deleteCachedFrag(frag);\n          frag.destroy();\n        }\n      }\n    }\n  };\n\n  /**\n   * Helper to find the previous element that is a fragment\n   * anchor. This is necessary because a destroyed frag's\n   * element could still be lingering in the DOM before its\n   * leaving transition finishes, but its inserted flag\n   * should have been set to false so we can skip them.\n   *\n   * If this is a block repeat, we want to make sure we only\n   * return frag that is bound to this v-for. (see #929)\n   *\n   * @param {Fragment} frag\n   * @param {Comment|Text} anchor\n   * @param {String} id\n   * @return {Fragment}\n   */\n\n  function findPrevFrag(frag, anchor, id) {\n    var el = frag.node.previousSibling;\n    /* istanbul ignore if */\n    if (!el) return;\n    frag = el.__v_frag;\n    while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {\n      el = el.previousSibling;\n      /* istanbul ignore if */\n      if (!el) return;\n      frag = el.__v_frag;\n    }\n    return frag;\n  }\n\n  /**\n   * Find a vm from a fragment.\n   *\n   * @param {Fragment} frag\n   * @return {Vue|undefined}\n   */\n\n  function findVmFromFrag(frag) {\n    var node = frag.node;\n    // handle multi-node frag\n    if (frag.end) {\n      while (!node.__vue__ && node !== frag.end && node.nextSibling) {\n        node = node.nextSibling;\n      }\n    }\n    return node.__vue__;\n  }\n\n  /**\n   * Create a range array from given number.\n   *\n   * @param {Number} n\n   * @return {Array}\n   */\n\n  function range(n) {\n    var i = -1;\n    var ret = new Array(Math.floor(n));\n    while (++i < n) {\n      ret[i] = i;\n    }\n    return ret;\n  }\n\n  /**\n   * Get the track by key for an item.\n   *\n   * @param {Number} index\n   * @param {String} key\n   * @param {*} value\n   * @param {String} [trackByKey]\n   */\n\n  function getTrackByKey(index, key, value, trackByKey) {\n    return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;\n  }\n\n  if ('development' !== 'production') {\n    vFor.warnDuplicate = function (value) {\n      warn('Duplicate value found in v-for=\"' + this.descriptor.raw + '\": ' + JSON.stringify(value) + '. Use track-by=\"$index\" if ' + 'you are expecting duplicate values.', this.vm);\n    };\n  }\n\n  var vIf = {\n\n    priority: IF,\n    terminal: true,\n\n    bind: function bind() {\n      var el = this.el;\n      if (!el.__vue__) {\n        // check else block\n        var next = el.nextElementSibling;\n        if (next && getAttr(next, 'v-else') !== null) {\n          remove(next);\n          this.elseEl = next;\n        }\n        // check main block\n        this.anchor = createAnchor('v-if');\n        replace(el, this.anchor);\n      } else {\n        'development' !== 'production' && warn('v-if=\"' + this.expression + '\" cannot be ' + 'used on an instance root element.', this.vm);\n        this.invalid = true;\n      }\n    },\n\n    update: function update(value) {\n      if (this.invalid) return;\n      if (value) {\n        if (!this.frag) {\n          this.insert();\n        }\n      } else {\n        this.remove();\n      }\n    },\n\n    insert: function insert() {\n      if (this.elseFrag) {\n        this.elseFrag.remove();\n        this.elseFrag = null;\n      }\n      // lazy init factory\n      if (!this.factory) {\n        this.factory = new FragmentFactory(this.vm, this.el);\n      }\n      this.frag = this.factory.create(this._host, this._scope, this._frag);\n      this.frag.before(this.anchor);\n    },\n\n    remove: function remove() {\n      if (this.frag) {\n        this.frag.remove();\n        this.frag = null;\n      }\n      if (this.elseEl && !this.elseFrag) {\n        if (!this.elseFactory) {\n          this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);\n        }\n        this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);\n        this.elseFrag.before(this.anchor);\n      }\n    },\n\n    unbind: function unbind() {\n      if (this.frag) {\n        this.frag.destroy();\n      }\n      if (this.elseFrag) {\n        this.elseFrag.destroy();\n      }\n    }\n  };\n\n  var show = {\n\n    bind: function bind() {\n      // check else block\n      var next = this.el.nextElementSibling;\n      if (next && getAttr(next, 'v-else') !== null) {\n        this.elseEl = next;\n      }\n    },\n\n    update: function update(value) {\n      this.apply(this.el, value);\n      if (this.elseEl) {\n        this.apply(this.elseEl, !value);\n      }\n    },\n\n    apply: function apply(el, value) {\n      if (inDoc(el)) {\n        applyTransition(el, value ? 1 : -1, toggle, this.vm);\n      } else {\n        toggle();\n      }\n      function toggle() {\n        el.style.display = value ? '' : 'none';\n      }\n    }\n  };\n\n  var text$2 = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n      var isRange = el.type === 'range';\n      var lazy = this.params.lazy;\n      var number = this.params.number;\n      var debounce = this.params.debounce;\n\n      // handle composition events.\n      //   http://blog.evanyou.me/2014/01/03/composition-event/\n      // skip this for Android because it handles composition\n      // events quite differently. Android doesn't trigger\n      // composition events for language input methods e.g.\n      // Chinese, but instead triggers them for spelling\n      // suggestions... (see Discussion/#162)\n      var composing = false;\n      if (!isAndroid && !isRange) {\n        this.on('compositionstart', function () {\n          composing = true;\n        });\n        this.on('compositionend', function () {\n          composing = false;\n          // in IE11 the \"compositionend\" event fires AFTER\n          // the \"input\" event, so the input handler is blocked\n          // at the end... have to call it here.\n          //\n          // #1327: in lazy mode this is unecessary.\n          if (!lazy) {\n            self.listener();\n          }\n        });\n      }\n\n      // prevent messing with the input when user is typing,\n      // and force update on blur.\n      this.focused = false;\n      if (!isRange && !lazy) {\n        this.on('focus', function () {\n          self.focused = true;\n        });\n        this.on('blur', function () {\n          self.focused = false;\n          // do not sync value after fragment removal (#2017)\n          if (!self._frag || self._frag.inserted) {\n            self.rawListener();\n          }\n        });\n      }\n\n      // Now attach the main listener\n      this.listener = this.rawListener = function () {\n        if (composing || !self._bound) {\n          return;\n        }\n        var val = number || isRange ? toNumber(el.value) : el.value;\n        self.set(val);\n        // force update on next tick to avoid lock & same value\n        // also only update when user is not typing\n        nextTick(function () {\n          if (self._bound && !self.focused) {\n            self.update(self._watcher.value);\n          }\n        });\n      };\n\n      // apply debounce\n      if (debounce) {\n        this.listener = _debounce(this.listener, debounce);\n      }\n\n      // Support jQuery events, since jQuery.trigger() doesn't\n      // trigger native events in some cases and some plugins\n      // rely on $.trigger()\n      //\n      // We want to make sure if a listener is attached using\n      // jQuery, it is also removed with jQuery, that's why\n      // we do the check for each directive instance and\n      // store that check result on itself. This also allows\n      // easier test coverage control by unsetting the global\n      // jQuery variable in tests.\n      this.hasjQuery = typeof jQuery === 'function';\n      if (this.hasjQuery) {\n        var method = jQuery.fn.on ? 'on' : 'bind';\n        jQuery(el)[method]('change', this.rawListener);\n        if (!lazy) {\n          jQuery(el)[method]('input', this.listener);\n        }\n      } else {\n        this.on('change', this.rawListener);\n        if (!lazy) {\n          this.on('input', this.listener);\n        }\n      }\n\n      // IE9 doesn't fire input event on backspace/del/cut\n      if (!lazy && isIE9) {\n        this.on('cut', function () {\n          nextTick(self.listener);\n        });\n        this.on('keyup', function (e) {\n          if (e.keyCode === 46 || e.keyCode === 8) {\n            self.listener();\n          }\n        });\n      }\n\n      // set initial value if present\n      if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {\n        this.afterBind = this.listener;\n      }\n    },\n\n    update: function update(value) {\n      this.el.value = _toString(value);\n    },\n\n    unbind: function unbind() {\n      var el = this.el;\n      if (this.hasjQuery) {\n        var method = jQuery.fn.off ? 'off' : 'unbind';\n        jQuery(el)[method]('change', this.listener);\n        jQuery(el)[method]('input', this.listener);\n      }\n    }\n  };\n\n  var radio = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n\n      this.getValue = function () {\n        // value overwrite via v-bind:value\n        if (el.hasOwnProperty('_value')) {\n          return el._value;\n        }\n        var val = el.value;\n        if (self.params.number) {\n          val = toNumber(val);\n        }\n        return val;\n      };\n\n      this.listener = function () {\n        self.set(self.getValue());\n      };\n      this.on('change', this.listener);\n\n      if (el.hasAttribute('checked')) {\n        this.afterBind = this.listener;\n      }\n    },\n\n    update: function update(value) {\n      this.el.checked = looseEqual(value, this.getValue());\n    }\n  };\n\n  var select = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n\n      // method to force update DOM using latest value.\n      this.forceUpdate = function () {\n        if (self._watcher) {\n          self.update(self._watcher.get());\n        }\n      };\n\n      // check if this is a multiple select\n      var multiple = this.multiple = el.hasAttribute('multiple');\n\n      // attach listener\n      this.listener = function () {\n        var value = getValue(el, multiple);\n        value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;\n        self.set(value);\n      };\n      this.on('change', this.listener);\n\n      // if has initial value, set afterBind\n      var initValue = getValue(el, multiple, true);\n      if (multiple && initValue.length || !multiple && initValue !== null) {\n        this.afterBind = this.listener;\n      }\n\n      // All major browsers except Firefox resets\n      // selectedIndex with value -1 to 0 when the element\n      // is appended to a new parent, therefore we have to\n      // force a DOM update whenever that happens...\n      this.vm.$on('hook:attached', this.forceUpdate);\n    },\n\n    update: function update(value) {\n      var el = this.el;\n      el.selectedIndex = -1;\n      var multi = this.multiple && isArray(value);\n      var options = el.options;\n      var i = options.length;\n      var op, val;\n      while (i--) {\n        op = options[i];\n        val = op.hasOwnProperty('_value') ? op._value : op.value;\n        /* eslint-disable eqeqeq */\n        op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);\n        /* eslint-enable eqeqeq */\n      }\n    },\n\n    unbind: function unbind() {\n      /* istanbul ignore next */\n      this.vm.$off('hook:attached', this.forceUpdate);\n    }\n  };\n\n  /**\n   * Get select value\n   *\n   * @param {SelectElement} el\n   * @param {Boolean} multi\n   * @param {Boolean} init\n   * @return {Array|*}\n   */\n\n  function getValue(el, multi, init) {\n    var res = multi ? [] : null;\n    var op, val, selected;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      op = el.options[i];\n      selected = init ? op.hasAttribute('selected') : op.selected;\n      if (selected) {\n        val = op.hasOwnProperty('_value') ? op._value : op.value;\n        if (multi) {\n          res.push(val);\n        } else {\n          return val;\n        }\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Native Array.indexOf uses strict equal, but in this\n   * case we need to match string/numbers with custom equal.\n   *\n   * @param {Array} arr\n   * @param {*} val\n   */\n\n  function indexOf$1(arr, val) {\n    var i = arr.length;\n    while (i--) {\n      if (looseEqual(arr[i], val)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  var checkbox = {\n\n    bind: function bind() {\n      var self = this;\n      var el = this.el;\n\n      this.getValue = function () {\n        return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;\n      };\n\n      function getBooleanValue() {\n        var val = el.checked;\n        if (val && el.hasOwnProperty('_trueValue')) {\n          return el._trueValue;\n        }\n        if (!val && el.hasOwnProperty('_falseValue')) {\n          return el._falseValue;\n        }\n        return val;\n      }\n\n      this.listener = function () {\n        var model = self._watcher.value;\n        if (isArray(model)) {\n          var val = self.getValue();\n          if (el.checked) {\n            if (indexOf(model, val) < 0) {\n              model.push(val);\n            }\n          } else {\n            model.$remove(val);\n          }\n        } else {\n          self.set(getBooleanValue());\n        }\n      };\n\n      this.on('change', this.listener);\n      if (el.hasAttribute('checked')) {\n        this.afterBind = this.listener;\n      }\n    },\n\n    update: function update(value) {\n      var el = this.el;\n      if (isArray(value)) {\n        el.checked = indexOf(value, this.getValue()) > -1;\n      } else {\n        if (el.hasOwnProperty('_trueValue')) {\n          el.checked = looseEqual(value, el._trueValue);\n        } else {\n          el.checked = !!value;\n        }\n      }\n    }\n  };\n\n  var handlers = {\n    text: text$2,\n    radio: radio,\n    select: select,\n    checkbox: checkbox\n  };\n\n  var model = {\n\n    priority: MODEL,\n    twoWay: true,\n    handlers: handlers,\n    params: ['lazy', 'number', 'debounce'],\n\n    /**\n     * Possible elements:\n     *   <select>\n     *   <textarea>\n     *   <input type=\"*\">\n     *     - text\n     *     - checkbox\n     *     - radio\n     *     - number\n     */\n\n    bind: function bind() {\n      // friendly warning...\n      this.checkFilters();\n      if (this.hasRead && !this.hasWrite) {\n        'development' !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model=\"' + this.descriptor.raw + '\". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);\n      }\n      var el = this.el;\n      var tag = el.tagName;\n      var handler;\n      if (tag === 'INPUT') {\n        handler = handlers[el.type] || handlers.text;\n      } else if (tag === 'SELECT') {\n        handler = handlers.select;\n      } else if (tag === 'TEXTAREA') {\n        handler = handlers.text;\n      } else {\n        'development' !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);\n        return;\n      }\n      el.__v_model = this;\n      handler.bind.call(this);\n      this.update = handler.update;\n      this._unbind = handler.unbind;\n    },\n\n    /**\n     * Check read/write filter stats.\n     */\n\n    checkFilters: function checkFilters() {\n      var filters = this.filters;\n      if (!filters) return;\n      var i = filters.length;\n      while (i--) {\n        var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);\n        if (typeof filter === 'function' || filter.read) {\n          this.hasRead = true;\n        }\n        if (filter.write) {\n          this.hasWrite = true;\n        }\n      }\n    },\n\n    unbind: function unbind() {\n      this.el.__v_model = null;\n      this._unbind && this._unbind();\n    }\n  };\n\n  // keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    'delete': [8, 46],\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40\n  };\n\n  function keyFilter(handler, keys) {\n    var codes = keys.map(function (key) {\n      var charCode = key.charCodeAt(0);\n      if (charCode > 47 && charCode < 58) {\n        return parseInt(key, 10);\n      }\n      if (key.length === 1) {\n        charCode = key.toUpperCase().charCodeAt(0);\n        if (charCode > 64 && charCode < 91) {\n          return charCode;\n        }\n      }\n      return keyCodes[key];\n    });\n    codes = [].concat.apply([], codes);\n    return function keyHandler(e) {\n      if (codes.indexOf(e.keyCode) > -1) {\n        return handler.call(this, e);\n      }\n    };\n  }\n\n  function stopFilter(handler) {\n    return function stopHandler(e) {\n      e.stopPropagation();\n      return handler.call(this, e);\n    };\n  }\n\n  function preventFilter(handler) {\n    return function preventHandler(e) {\n      e.preventDefault();\n      return handler.call(this, e);\n    };\n  }\n\n  function selfFilter(handler) {\n    return function selfHandler(e) {\n      if (e.target === e.currentTarget) {\n        return handler.call(this, e);\n      }\n    };\n  }\n\n  var on$1 = {\n\n    priority: ON,\n    acceptStatement: true,\n    keyCodes: keyCodes,\n\n    bind: function bind() {\n      // deal with iframes\n      if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {\n        var self = this;\n        this.iframeBind = function () {\n          on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);\n        };\n        this.on('load', this.iframeBind);\n      }\n    },\n\n    update: function update(handler) {\n      // stub a noop for v-on with no value,\n      // e.g. @mousedown.prevent\n      if (!this.descriptor.raw) {\n        handler = function () {};\n      }\n\n      if (typeof handler !== 'function') {\n        'development' !== 'production' && warn('v-on:' + this.arg + '=\"' + this.expression + '\" expects a function value, ' + 'got ' + handler, this.vm);\n        return;\n      }\n\n      // apply modifiers\n      if (this.modifiers.stop) {\n        handler = stopFilter(handler);\n      }\n      if (this.modifiers.prevent) {\n        handler = preventFilter(handler);\n      }\n      if (this.modifiers.self) {\n        handler = selfFilter(handler);\n      }\n      // key filter\n      var keys = Object.keys(this.modifiers).filter(function (key) {\n        return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';\n      });\n      if (keys.length) {\n        handler = keyFilter(handler, keys);\n      }\n\n      this.reset();\n      this.handler = handler;\n\n      if (this.iframeBind) {\n        this.iframeBind();\n      } else {\n        on(this.el, this.arg, this.handler, this.modifiers.capture);\n      }\n    },\n\n    reset: function reset() {\n      var el = this.iframeBind ? this.el.contentWindow : this.el;\n      if (this.handler) {\n        off(el, this.arg, this.handler);\n      }\n    },\n\n    unbind: function unbind() {\n      this.reset();\n    }\n  };\n\n  var prefixes = ['-webkit-', '-moz-', '-ms-'];\n  var camelPrefixes = ['Webkit', 'Moz', 'ms'];\n  var importantRE = /!important;?$/;\n  var propCache = Object.create(null);\n\n  var testEl = null;\n\n  var style = {\n\n    deep: true,\n\n    update: function update(value) {\n      if (typeof value === 'string') {\n        this.el.style.cssText = value;\n      } else if (isArray(value)) {\n        this.handleObject(value.reduce(extend, {}));\n      } else {\n        this.handleObject(value || {});\n      }\n    },\n\n    handleObject: function handleObject(value) {\n      // cache object styles so that only changed props\n      // are actually updated.\n      var cache = this.cache || (this.cache = {});\n      var name, val;\n      for (name in cache) {\n        if (!(name in value)) {\n          this.handleSingle(name, null);\n          delete cache[name];\n        }\n      }\n      for (name in value) {\n        val = value[name];\n        if (val !== cache[name]) {\n          cache[name] = val;\n          this.handleSingle(name, val);\n        }\n      }\n    },\n\n    handleSingle: function handleSingle(prop, value) {\n      prop = normalize(prop);\n      if (!prop) return; // unsupported prop\n      // cast possible numbers/booleans into strings\n      if (value != null) value += '';\n      if (value) {\n        var isImportant = importantRE.test(value) ? 'important' : '';\n        if (isImportant) {\n          /* istanbul ignore if */\n          if ('development' !== 'production') {\n            warn('It\\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');\n          }\n          value = value.replace(importantRE, '').trim();\n          this.el.style.setProperty(prop.kebab, value, isImportant);\n        } else {\n          this.el.style[prop.camel] = value;\n        }\n      } else {\n        this.el.style[prop.camel] = '';\n      }\n    }\n\n  };\n\n  /**\n   * Normalize a CSS property name.\n   * - cache result\n   * - auto prefix\n   * - camelCase -> dash-case\n   *\n   * @param {String} prop\n   * @return {String}\n   */\n\n  function normalize(prop) {\n    if (propCache[prop]) {\n      return propCache[prop];\n    }\n    var res = prefix(prop);\n    propCache[prop] = propCache[res] = res;\n    return res;\n  }\n\n  /**\n   * Auto detect the appropriate prefix for a CSS property.\n   * https://gist.github.com/paulirish/523692\n   *\n   * @param {String} prop\n   * @return {String}\n   */\n\n  function prefix(prop) {\n    prop = hyphenate(prop);\n    var camel = camelize(prop);\n    var upper = camel.charAt(0).toUpperCase() + camel.slice(1);\n    if (!testEl) {\n      testEl = document.createElement('div');\n    }\n    var i = prefixes.length;\n    var prefixed;\n    if (camel !== 'filter' && camel in testEl.style) {\n      return {\n        kebab: prop,\n        camel: camel\n      };\n    }\n    while (i--) {\n      prefixed = camelPrefixes[i] + upper;\n      if (prefixed in testEl.style) {\n        return {\n          kebab: prefixes[i] + prop,\n          camel: prefixed\n        };\n      }\n    }\n  }\n\n  // xlink\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n  var xlinkRE = /^xlink:/;\n\n  // check for attributes that prohibit interpolations\n  var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;\n  // these attributes should also set their corresponding properties\n  // because they only affect the initial state of the element\n  var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;\n  // these attributes expect enumrated values of \"true\" or \"false\"\n  // but are not boolean attributes\n  var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;\n\n  // these attributes should set a hidden property for\n  // binding v-model to object values\n  var modelProps = {\n    value: '_value',\n    'true-value': '_trueValue',\n    'false-value': '_falseValue'\n  };\n\n  var bind$1 = {\n\n    priority: BIND,\n\n    bind: function bind() {\n      var attr = this.arg;\n      var tag = this.el.tagName;\n      // should be deep watch on object mode\n      if (!attr) {\n        this.deep = true;\n      }\n      // handle interpolation bindings\n      var descriptor = this.descriptor;\n      var tokens = descriptor.interp;\n      if (tokens) {\n        // handle interpolations with one-time tokens\n        if (descriptor.hasOneTime) {\n          this.expression = tokensToExp(tokens, this._scope || this.vm);\n        }\n\n        // only allow binding on native attributes\n        if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {\n          'development' !== 'production' && warn(attr + '=\"' + descriptor.raw + '\": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);\n          this.el.removeAttribute(attr);\n          this.invalid = true;\n        }\n\n        /* istanbul ignore if */\n        if ('development' !== 'production') {\n          var raw = attr + '=\"' + descriptor.raw + '\": ';\n          // warn src\n          if (attr === 'src') {\n            warn(raw + 'interpolation in \"src\" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);\n          }\n\n          // warn style\n          if (attr === 'style') {\n            warn(raw + 'interpolation in \"style\" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);\n          }\n        }\n      }\n    },\n\n    update: function update(value) {\n      if (this.invalid) {\n        return;\n      }\n      var attr = this.arg;\n      if (this.arg) {\n        this.handleSingle(attr, value);\n      } else {\n        this.handleObject(value || {});\n      }\n    },\n\n    // share object handler with v-bind:class\n    handleObject: style.handleObject,\n\n    handleSingle: function handleSingle(attr, value) {\n      var el = this.el;\n      var interp = this.descriptor.interp;\n      if (this.modifiers.camel) {\n        attr = camelize(attr);\n      }\n      if (!interp && attrWithPropsRE.test(attr) && attr in el) {\n        var attrValue = attr === 'value' ? value == null // IE9 will set input.value to \"null\" for null...\n        ? '' : value : value;\n\n        if (el[attr] !== attrValue) {\n          el[attr] = attrValue;\n        }\n      }\n      // set model props\n      var modelProp = modelProps[attr];\n      if (!interp && modelProp) {\n        el[modelProp] = value;\n        // update v-model if present\n        var model = el.__v_model;\n        if (model) {\n          model.listener();\n        }\n      }\n      // do not set value attribute for textarea\n      if (attr === 'value' && el.tagName === 'TEXTAREA') {\n        el.removeAttribute(attr);\n        return;\n      }\n      // update attribute\n      if (enumeratedAttrRE.test(attr)) {\n        el.setAttribute(attr, value ? 'true' : 'false');\n      } else if (value != null && value !== false) {\n        if (attr === 'class') {\n          // handle edge case #1960:\n          // class interpolation should not overwrite Vue transition class\n          if (el.__v_trans) {\n            value += ' ' + el.__v_trans.id + '-transition';\n          }\n          setClass(el, value);\n        } else if (xlinkRE.test(attr)) {\n          el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);\n        } else {\n          el.setAttribute(attr, value === true ? '' : value);\n        }\n      } else {\n        el.removeAttribute(attr);\n      }\n    }\n  };\n\n  var el = {\n\n    priority: EL,\n\n    bind: function bind() {\n      /* istanbul ignore if */\n      if (!this.arg) {\n        return;\n      }\n      var id = this.id = camelize(this.arg);\n      var refs = (this._scope || this.vm).$els;\n      if (hasOwn(refs, id)) {\n        refs[id] = this.el;\n      } else {\n        defineReactive(refs, id, this.el);\n      }\n    },\n\n    unbind: function unbind() {\n      var refs = (this._scope || this.vm).$els;\n      if (refs[this.id] === this.el) {\n        refs[this.id] = null;\n      }\n    }\n  };\n\n  var ref = {\n    bind: function bind() {\n      'development' !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);\n    }\n  };\n\n  var cloak = {\n    bind: function bind() {\n      var el = this.el;\n      this.vm.$once('pre-hook:compiled', function () {\n        el.removeAttribute('v-cloak');\n      });\n    }\n  };\n\n  // must export plain object\n  var directives = {\n    text: text$1,\n    html: html,\n    'for': vFor,\n    'if': vIf,\n    show: show,\n    model: model,\n    on: on$1,\n    bind: bind$1,\n    el: el,\n    ref: ref,\n    cloak: cloak\n  };\n\n  var vClass = {\n\n    deep: true,\n\n    update: function update(value) {\n      if (!value) {\n        this.cleanup();\n      } else if (typeof value === 'string') {\n        this.setClass(value.trim().split(/\\s+/));\n      } else {\n        this.setClass(normalize$1(value));\n      }\n    },\n\n    setClass: function setClass(value) {\n      this.cleanup(value);\n      for (var i = 0, l = value.length; i < l; i++) {\n        var val = value[i];\n        if (val) {\n          apply(this.el, val, addClass);\n        }\n      }\n      this.prevKeys = value;\n    },\n\n    cleanup: function cleanup(value) {\n      var prevKeys = this.prevKeys;\n      if (!prevKeys) return;\n      var i = prevKeys.length;\n      while (i--) {\n        var key = prevKeys[i];\n        if (!value || value.indexOf(key) < 0) {\n          apply(this.el, key, removeClass);\n        }\n      }\n    }\n  };\n\n  /**\n   * Normalize objects and arrays (potentially containing objects)\n   * into array of strings.\n   *\n   * @param {Object|Array<String|Object>} value\n   * @return {Array<String>}\n   */\n\n  function normalize$1(value) {\n    var res = [];\n    if (isArray(value)) {\n      for (var i = 0, l = value.length; i < l; i++) {\n        var _key = value[i];\n        if (_key) {\n          if (typeof _key === 'string') {\n            res.push(_key);\n          } else {\n            for (var k in _key) {\n              if (_key[k]) res.push(k);\n            }\n          }\n        }\n      }\n    } else if (isObject(value)) {\n      for (var key in value) {\n        if (value[key]) res.push(key);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Add or remove a class/classes on an element\n   *\n   * @param {Element} el\n   * @param {String} key The class name. This may or may not\n   *                     contain a space character, in such a\n   *                     case we'll deal with multiple class\n   *                     names at once.\n   * @param {Function} fn\n   */\n\n  function apply(el, key, fn) {\n    key = key.trim();\n    if (key.indexOf(' ') === -1) {\n      fn(el, key);\n      return;\n    }\n    // The key contains one or more space characters.\n    // Since a class name doesn't accept such characters, we\n    // treat it as multiple classes.\n    var keys = key.split(/\\s+/);\n    for (var i = 0, l = keys.length; i < l; i++) {\n      fn(el, keys[i]);\n    }\n  }\n\n  var component = {\n\n    priority: COMPONENT,\n\n    params: ['keep-alive', 'transition-mode', 'inline-template'],\n\n    /**\n     * Setup. Two possible usages:\n     *\n     * - static:\n     *   <comp> or <div v-component=\"comp\">\n     *\n     * - dynamic:\n     *   <component :is=\"view\">\n     */\n\n    bind: function bind() {\n      if (!this.el.__vue__) {\n        // keep-alive cache\n        this.keepAlive = this.params.keepAlive;\n        if (this.keepAlive) {\n          this.cache = {};\n        }\n        // check inline-template\n        if (this.params.inlineTemplate) {\n          // extract inline template as a DocumentFragment\n          this.inlineTemplate = extractContent(this.el, true);\n        }\n        // component resolution related state\n        this.pendingComponentCb = this.Component = null;\n        // transition related state\n        this.pendingRemovals = 0;\n        this.pendingRemovalCb = null;\n        // create a ref anchor\n        this.anchor = createAnchor('v-component');\n        replace(this.el, this.anchor);\n        // remove is attribute.\n        // this is removed during compilation, but because compilation is\n        // cached, when the component is used elsewhere this attribute\n        // will remain at link time.\n        this.el.removeAttribute('is');\n        this.el.removeAttribute(':is');\n        // remove ref, same as above\n        if (this.descriptor.ref) {\n          this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));\n        }\n        // if static, build right now.\n        if (this.literal) {\n          this.setComponent(this.expression);\n        }\n      } else {\n        'development' !== 'production' && warn('cannot mount component \"' + this.expression + '\" ' + 'on already mounted element: ' + this.el);\n      }\n    },\n\n    /**\n     * Public update, called by the watcher in the dynamic\n     * literal scenario, e.g. <component :is=\"view\">\n     */\n\n    update: function update(value) {\n      if (!this.literal) {\n        this.setComponent(value);\n      }\n    },\n\n    /**\n     * Switch dynamic components. May resolve the component\n     * asynchronously, and perform transition based on\n     * specified transition mode. Accepts a few additional\n     * arguments specifically for vue-router.\n     *\n     * The callback is called when the full transition is\n     * finished.\n     *\n     * @param {String} value\n     * @param {Function} [cb]\n     */\n\n    setComponent: function setComponent(value, cb) {\n      this.invalidatePending();\n      if (!value) {\n        // just remove current\n        this.unbuild(true);\n        this.remove(this.childVM, cb);\n        this.childVM = null;\n      } else {\n        var self = this;\n        this.resolveComponent(value, function () {\n          self.mountComponent(cb);\n        });\n      }\n    },\n\n    /**\n     * Resolve the component constructor to use when creating\n     * the child vm.\n     *\n     * @param {String|Function} value\n     * @param {Function} cb\n     */\n\n    resolveComponent: function resolveComponent(value, cb) {\n      var self = this;\n      this.pendingComponentCb = cancellable(function (Component) {\n        self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);\n        self.Component = Component;\n        cb();\n      });\n      this.vm._resolveComponent(value, this.pendingComponentCb);\n    },\n\n    /**\n     * Create a new instance using the current constructor and\n     * replace the existing instance. This method doesn't care\n     * whether the new component and the old one are actually\n     * the same.\n     *\n     * @param {Function} [cb]\n     */\n\n    mountComponent: function mountComponent(cb) {\n      // actual mount\n      this.unbuild(true);\n      var self = this;\n      var activateHooks = this.Component.options.activate;\n      var cached = this.getCached();\n      var newComponent = this.build();\n      if (activateHooks && !cached) {\n        this.waitingFor = newComponent;\n        callActivateHooks(activateHooks, newComponent, function () {\n          if (self.waitingFor !== newComponent) {\n            return;\n          }\n          self.waitingFor = null;\n          self.transition(newComponent, cb);\n        });\n      } else {\n        // update ref for kept-alive component\n        if (cached) {\n          newComponent._updateRef();\n        }\n        this.transition(newComponent, cb);\n      }\n    },\n\n    /**\n     * When the component changes or unbinds before an async\n     * constructor is resolved, we need to invalidate its\n     * pending callback.\n     */\n\n    invalidatePending: function invalidatePending() {\n      if (this.pendingComponentCb) {\n        this.pendingComponentCb.cancel();\n        this.pendingComponentCb = null;\n      }\n    },\n\n    /**\n     * Instantiate/insert a new child vm.\n     * If keep alive and has cached instance, insert that\n     * instance; otherwise build a new one and cache it.\n     *\n     * @param {Object} [extraOptions]\n     * @return {Vue} - the created instance\n     */\n\n    build: function build(extraOptions) {\n      var cached = this.getCached();\n      if (cached) {\n        return cached;\n      }\n      if (this.Component) {\n        // default options\n        var options = {\n          name: this.ComponentName,\n          el: cloneNode(this.el),\n          template: this.inlineTemplate,\n          // make sure to add the child with correct parent\n          // if this is a transcluded component, its parent\n          // should be the transclusion host.\n          parent: this._host || this.vm,\n          // if no inline-template, then the compiled\n          // linker can be cached for better performance.\n          _linkerCachable: !this.inlineTemplate,\n          _ref: this.descriptor.ref,\n          _asComponent: true,\n          _isRouterView: this._isRouterView,\n          // if this is a transcluded component, context\n          // will be the common parent vm of this instance\n          // and its host.\n          _context: this.vm,\n          // if this is inside an inline v-for, the scope\n          // will be the intermediate scope created for this\n          // repeat fragment. this is used for linking props\n          // and container directives.\n          _scope: this._scope,\n          // pass in the owner fragment of this component.\n          // this is necessary so that the fragment can keep\n          // track of its contained components in order to\n          // call attach/detach hooks for them.\n          _frag: this._frag\n        };\n        // extra options\n        // in 1.0.0 this is used by vue-router only\n        /* istanbul ignore if */\n        if (extraOptions) {\n          extend(options, extraOptions);\n        }\n        var child = new this.Component(options);\n        if (this.keepAlive) {\n          this.cache[this.Component.cid] = child;\n        }\n        /* istanbul ignore if */\n        if ('development' !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {\n          warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);\n        }\n        return child;\n      }\n    },\n\n    /**\n     * Try to get a cached instance of the current component.\n     *\n     * @return {Vue|undefined}\n     */\n\n    getCached: function getCached() {\n      return this.keepAlive && this.cache[this.Component.cid];\n    },\n\n    /**\n     * Teardown the current child, but defers cleanup so\n     * that we can separate the destroy and removal steps.\n     *\n     * @param {Boolean} defer\n     */\n\n    unbuild: function unbuild(defer) {\n      if (this.waitingFor) {\n        if (!this.keepAlive) {\n          this.waitingFor.$destroy();\n        }\n        this.waitingFor = null;\n      }\n      var child = this.childVM;\n      if (!child || this.keepAlive) {\n        if (child) {\n          // remove ref\n          child._inactive = true;\n          child._updateRef(true);\n        }\n        return;\n      }\n      // the sole purpose of `deferCleanup` is so that we can\n      // \"deactivate\" the vm right now and perform DOM removal\n      // later.\n      child.$destroy(false, defer);\n    },\n\n    /**\n     * Remove current destroyed child and manually do\n     * the cleanup after removal.\n     *\n     * @param {Function} cb\n     */\n\n    remove: function remove(child, cb) {\n      var keepAlive = this.keepAlive;\n      if (child) {\n        // we may have a component switch when a previous\n        // component is still being transitioned out.\n        // we want to trigger only one lastest insertion cb\n        // when the existing transition finishes. (#1119)\n        this.pendingRemovals++;\n        this.pendingRemovalCb = cb;\n        var self = this;\n        child.$remove(function () {\n          self.pendingRemovals--;\n          if (!keepAlive) child._cleanup();\n          if (!self.pendingRemovals && self.pendingRemovalCb) {\n            self.pendingRemovalCb();\n            self.pendingRemovalCb = null;\n          }\n        });\n      } else if (cb) {\n        cb();\n      }\n    },\n\n    /**\n     * Actually swap the components, depending on the\n     * transition mode. Defaults to simultaneous.\n     *\n     * @param {Vue} target\n     * @param {Function} [cb]\n     */\n\n    transition: function transition(target, cb) {\n      var self = this;\n      var current = this.childVM;\n      // for devtool inspection\n      if (current) current._inactive = true;\n      target._inactive = false;\n      this.childVM = target;\n      switch (self.params.transitionMode) {\n        case 'in-out':\n          target.$before(self.anchor, function () {\n            self.remove(current, cb);\n          });\n          break;\n        case 'out-in':\n          self.remove(current, function () {\n            target.$before(self.anchor, cb);\n          });\n          break;\n        default:\n          self.remove(current);\n          target.$before(self.anchor, cb);\n      }\n    },\n\n    /**\n     * Unbind.\n     */\n\n    unbind: function unbind() {\n      this.invalidatePending();\n      // Do not defer cleanup when unbinding\n      this.unbuild();\n      // destroy all keep-alive cached instances\n      if (this.cache) {\n        for (var key in this.cache) {\n          this.cache[key].$destroy();\n        }\n        this.cache = null;\n      }\n    }\n  };\n\n  /**\n   * Call activate hooks in order (asynchronous)\n   *\n   * @param {Array} hooks\n   * @param {Vue} vm\n   * @param {Function} cb\n   */\n\n  function callActivateHooks(hooks, vm, cb) {\n    var total = hooks.length;\n    var called = 0;\n    hooks[0].call(vm, next);\n    function next() {\n      if (++called >= total) {\n        cb();\n      } else {\n        hooks[called].call(vm, next);\n      }\n    }\n  }\n\n  var propBindingModes = config._propBindingModes;\n  var empty = {};\n\n  // regexes\n  var identRE$1 = /^[$_a-zA-Z]+[\\w$]*$/;\n  var settablePathRE = /^[A-Za-z_$][\\w$]*(\\.[A-Za-z_$][\\w$]*|\\[[^\\[\\]]+\\])*$/;\n\n  /**\n   * Compile props on a root element and return\n   * a props link function.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Array} propOptions\n   * @param {Vue} vm\n   * @return {Function} propsLinkFn\n   */\n\n  function compileProps(el, propOptions, vm) {\n    var props = [];\n    var names = Object.keys(propOptions);\n    var i = names.length;\n    var options, name, attr, value, path, parsed, prop;\n    while (i--) {\n      name = names[i];\n      options = propOptions[name] || empty;\n\n      if ('development' !== 'production' && name === '$data') {\n        warn('Do not use $data as prop.', vm);\n        continue;\n      }\n\n      // props could contain dashes, which will be\n      // interpreted as minus calculations by the parser\n      // so we need to camelize the path here\n      path = camelize(name);\n      if (!identRE$1.test(path)) {\n        'development' !== 'production' && warn('Invalid prop key: \"' + name + '\". Prop keys ' + 'must be valid identifiers.', vm);\n        continue;\n      }\n\n      prop = {\n        name: name,\n        path: path,\n        options: options,\n        mode: propBindingModes.ONE_WAY,\n        raw: null\n      };\n\n      attr = hyphenate(name);\n      // first check dynamic version\n      if ((value = getBindAttr(el, attr)) === null) {\n        if ((value = getBindAttr(el, attr + '.sync')) !== null) {\n          prop.mode = propBindingModes.TWO_WAY;\n        } else if ((value = getBindAttr(el, attr + '.once')) !== null) {\n          prop.mode = propBindingModes.ONE_TIME;\n        }\n      }\n      if (value !== null) {\n        // has dynamic binding!\n        prop.raw = value;\n        parsed = parseDirective(value);\n        value = parsed.expression;\n        prop.filters = parsed.filters;\n        // check binding type\n        if (isLiteral(value) && !parsed.filters) {\n          // for expressions containing literal numbers and\n          // booleans, there's no need to setup a prop binding,\n          // so we can optimize them as a one-time set.\n          prop.optimizedLiteral = true;\n        } else {\n          prop.dynamic = true;\n          // check non-settable path for two-way bindings\n          if ('development' !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {\n            prop.mode = propBindingModes.ONE_WAY;\n            warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);\n          }\n        }\n        prop.parentPath = value;\n\n        // warn required two-way\n        if ('development' !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {\n          warn('Prop \"' + name + '\" expects a two-way binding type.', vm);\n        }\n      } else if ((value = getAttr(el, attr)) !== null) {\n        // has literal binding!\n        prop.raw = value;\n      } else if ('development' !== 'production') {\n        // check possible camelCase prop usage\n        var lowerCaseName = path.toLowerCase();\n        value = /[A-Z\\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));\n        if (value) {\n          warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);\n        } else if (options.required) {\n          // warn missing required\n          warn('Missing required prop: ' + name, vm);\n        }\n      }\n      // push prop\n      props.push(prop);\n    }\n    return makePropsLinkFn(props);\n  }\n\n  /**\n   * Build a function that applies props to a vm.\n   *\n   * @param {Array} props\n   * @return {Function} propsLinkFn\n   */\n\n  function makePropsLinkFn(props) {\n    return function propsLinkFn(vm, scope) {\n      // store resolved props info\n      vm._props = {};\n      var inlineProps = vm.$options.propsData;\n      var i = props.length;\n      var prop, path, options, value, raw;\n      while (i--) {\n        prop = props[i];\n        raw = prop.raw;\n        path = prop.path;\n        options = prop.options;\n        vm._props[path] = prop;\n        if (inlineProps && hasOwn(inlineProps, path)) {\n          initProp(vm, prop, inlineProps[path]);\n        }if (raw === null) {\n          // initialize absent prop\n          initProp(vm, prop, undefined);\n        } else if (prop.dynamic) {\n          // dynamic prop\n          if (prop.mode === propBindingModes.ONE_TIME) {\n            // one time binding\n            value = (scope || vm._context || vm).$get(prop.parentPath);\n            initProp(vm, prop, value);\n          } else {\n            if (vm._context) {\n              // dynamic binding\n              vm._bindDir({\n                name: 'prop',\n                def: propDef,\n                prop: prop\n              }, null, null, scope); // el, host, scope\n            } else {\n                // root instance\n                initProp(vm, prop, vm.$get(prop.parentPath));\n              }\n          }\n        } else if (prop.optimizedLiteral) {\n          // optimized literal, cast it and just set once\n          var stripped = stripQuotes(raw);\n          value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;\n          initProp(vm, prop, value);\n        } else {\n          // string literal, but we need to cater for\n          // Boolean props with no value, or with same\n          // literal value (e.g. disabled=\"disabled\")\n          // see https://github.com/vuejs/vue-loader/issues/182\n          value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;\n          initProp(vm, prop, value);\n        }\n      }\n    };\n  }\n\n  /**\n   * Process a prop with a rawValue, applying necessary coersions,\n   * default values & assertions and call the given callback with\n   * processed value.\n   *\n   * @param {Vue} vm\n   * @param {Object} prop\n   * @param {*} rawValue\n   * @param {Function} fn\n   */\n\n  function processPropValue(vm, prop, rawValue, fn) {\n    var isSimple = prop.dynamic && isSimplePath(prop.parentPath);\n    var value = rawValue;\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop);\n    }\n    value = coerceProp(prop, value);\n    var coerced = value !== rawValue;\n    if (!assertProp(prop, value, vm)) {\n      value = undefined;\n    }\n    if (isSimple && !coerced) {\n      withoutConversion(function () {\n        fn(value);\n      });\n    } else {\n      fn(value);\n    }\n  }\n\n  /**\n   * Set a prop's initial value on a vm and its data object.\n   *\n   * @param {Vue} vm\n   * @param {Object} prop\n   * @param {*} value\n   */\n\n  function initProp(vm, prop, value) {\n    processPropValue(vm, prop, value, function (value) {\n      defineReactive(vm, prop.path, value);\n    });\n  }\n\n  /**\n   * Update a prop's value on a vm.\n   *\n   * @param {Vue} vm\n   * @param {Object} prop\n   * @param {*} value\n   */\n\n  function updateProp(vm, prop, value) {\n    processPropValue(vm, prop, value, function (value) {\n      vm[prop.path] = value;\n    });\n  }\n\n  /**\n   * Get the default value of a prop.\n   *\n   * @param {Vue} vm\n   * @param {Object} prop\n   * @return {*}\n   */\n\n  function getPropDefaultValue(vm, prop) {\n    // no default, return undefined\n    var options = prop.options;\n    if (!hasOwn(options, 'default')) {\n      // absent boolean value defaults to false\n      return options.type === Boolean ? false : undefined;\n    }\n    var def = options['default'];\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      'development' !== 'production' && warn('Invalid default value for prop \"' + prop.name + '\": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);\n    }\n    // call factory function for non-Function types\n    return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   *\n   * @param {Object} prop\n   * @param {*} value\n   * @param {Vue} vm\n   */\n\n  function assertProp(prop, value, vm) {\n    if (!prop.options.required && ( // non-required\n    prop.raw === null || // abscent\n    value == null) // null or undefined\n    ) {\n        return true;\n      }\n    var options = prop.options;\n    var type = options.type;\n    var valid = !type;\n    var expectedTypes = [];\n    if (type) {\n      if (!isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType);\n        valid = assertedType.valid;\n      }\n    }\n    if (!valid) {\n      if ('development' !== 'production') {\n        warn('Invalid prop: type check failed for prop \"' + prop.name + '\".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);\n      }\n      return false;\n    }\n    var validator = options.validator;\n    if (validator) {\n      if (!validator(value)) {\n        'development' !== 'production' && warn('Invalid prop: custom validator check failed for prop \"' + prop.name + '\".', vm);\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Force parsing value with coerce option.\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @return {*}\n   */\n\n  function coerceProp(prop, value) {\n    var coerce = prop.options.coerce;\n    if (!coerce) {\n      return value;\n    }\n    // coerce is a function\n    return coerce(value);\n  }\n\n  /**\n   * Assert the type of a value\n   *\n   * @param {*} value\n   * @param {Function} type\n   * @return {Object}\n   */\n\n  function assertType(value, type) {\n    var valid;\n    var expectedType;\n    if (type === String) {\n      expectedType = 'string';\n      valid = typeof value === expectedType;\n    } else if (type === Number) {\n      expectedType = 'number';\n      valid = typeof value === expectedType;\n    } else if (type === Boolean) {\n      expectedType = 'boolean';\n      valid = typeof value === expectedType;\n    } else if (type === Function) {\n      expectedType = 'function';\n      valid = typeof value === expectedType;\n    } else if (type === Object) {\n      expectedType = 'object';\n      valid = isPlainObject(value);\n    } else if (type === Array) {\n      expectedType = 'array';\n      valid = isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    };\n  }\n\n  /**\n   * Format type for output\n   *\n   * @param {String} type\n   * @return {String}\n   */\n\n  function formatType(type) {\n    return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';\n  }\n\n  /**\n   * Format value\n   *\n   * @param {*} value\n   * @return {String}\n   */\n\n  function formatValue(val) {\n    return Object.prototype.toString.call(val).slice(8, -1);\n  }\n\n  var bindingModes = config._propBindingModes;\n\n  var propDef = {\n\n    bind: function bind() {\n      var child = this.vm;\n      var parent = child._context;\n      // passed in from compiler directly\n      var prop = this.descriptor.prop;\n      var childKey = prop.path;\n      var parentKey = prop.parentPath;\n      var twoWay = prop.mode === bindingModes.TWO_WAY;\n\n      var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {\n        updateProp(child, prop, val);\n      }, {\n        twoWay: twoWay,\n        filters: prop.filters,\n        // important: props need to be observed on the\n        // v-for scope if present\n        scope: this._scope\n      });\n\n      // set the child initial value.\n      initProp(child, prop, parentWatcher.value);\n\n      // setup two-way binding\n      if (twoWay) {\n        // important: defer the child watcher creation until\n        // the created hook (after data observation)\n        var self = this;\n        child.$once('pre-hook:created', function () {\n          self.childWatcher = new Watcher(child, childKey, function (val) {\n            parentWatcher.set(val);\n          }, {\n            // ensure sync upward before parent sync down.\n            // this is necessary in cases e.g. the child\n            // mutates a prop array, then replaces it. (#1683)\n            sync: true\n          });\n        });\n      }\n    },\n\n    unbind: function unbind() {\n      this.parentWatcher.teardown();\n      if (this.childWatcher) {\n        this.childWatcher.teardown();\n      }\n    }\n  };\n\n  var queue$1 = [];\n  var queued = false;\n\n  /**\n   * Push a job into the queue.\n   *\n   * @param {Function} job\n   */\n\n  function pushJob(job) {\n    queue$1.push(job);\n    if (!queued) {\n      queued = true;\n      nextTick(flush);\n    }\n  }\n\n  /**\n   * Flush the queue, and do one forced reflow before\n   * triggering transitions.\n   */\n\n  function flush() {\n    // Force layout\n    var f = document.documentElement.offsetHeight;\n    for (var i = 0; i < queue$1.length; i++) {\n      queue$1[i]();\n    }\n    queue$1 = [];\n    queued = false;\n    // dummy return, so js linters don't complain about\n    // unused variable f\n    return f;\n  }\n\n  var TYPE_TRANSITION = 'transition';\n  var TYPE_ANIMATION = 'animation';\n  var transDurationProp = transitionProp + 'Duration';\n  var animDurationProp = animationProp + 'Duration';\n\n  /**\n   * If a just-entered element is applied the\n   * leave class while its enter transition hasn't started yet,\n   * and the transitioned property has the same value for both\n   * enter/leave, then the leave transition will be skipped and\n   * the transitionend event never fires. This function ensures\n   * its callback to be called after a transition has started\n   * by waiting for double raf.\n   *\n   * It falls back to setTimeout on devices that support CSS\n   * transitions but not raf (e.g. Android 4.2 browser) - since\n   * these environments are usually slow, we are giving it a\n   * relatively large timeout.\n   */\n\n  var raf = inBrowser && window.requestAnimationFrame;\n  var waitForTransitionStart = raf\n  /* istanbul ignore next */\n  ? function (fn) {\n    raf(function () {\n      raf(fn);\n    });\n  } : function (fn) {\n    setTimeout(fn, 50);\n  };\n\n  /**\n   * A Transition object that encapsulates the state and logic\n   * of the transition.\n   *\n   * @param {Element} el\n   * @param {String} id\n   * @param {Object} hooks\n   * @param {Vue} vm\n   */\n  function Transition(el, id, hooks, vm) {\n    this.id = id;\n    this.el = el;\n    this.enterClass = hooks && hooks.enterClass || id + '-enter';\n    this.leaveClass = hooks && hooks.leaveClass || id + '-leave';\n    this.hooks = hooks;\n    this.vm = vm;\n    // async state\n    this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;\n    this.justEntered = false;\n    this.entered = this.left = false;\n    this.typeCache = {};\n    // check css transition type\n    this.type = hooks && hooks.type;\n    /* istanbul ignore if */\n    if ('development' !== 'production') {\n      if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {\n        warn('invalid CSS transition type for transition=\"' + this.id + '\": ' + this.type, vm);\n      }\n    }\n    // bind\n    var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {\n      self[m] = bind(self[m], self);\n    });\n  }\n\n  var p$1 = Transition.prototype;\n\n  /**\n   * Start an entering transition.\n   *\n   * 1. enter transition triggered\n   * 2. call beforeEnter hook\n   * 3. add enter class\n   * 4. insert/show element\n   * 5. call enter hook (with possible explicit js callback)\n   * 6. reflow\n   * 7. based on transition type:\n   *    - transition:\n   *        remove class now, wait for transitionend,\n   *        then done if there's no explicit js callback.\n   *    - animation:\n   *        wait for animationend, remove class,\n   *        then done if there's no explicit js callback.\n   *    - no css transition:\n   *        done now if there's no explicit js callback.\n   * 8. wait for either done or js callback, then call\n   *    afterEnter hook.\n   *\n   * @param {Function} op - insert/show the element\n   * @param {Function} [cb]\n   */\n\n  p$1.enter = function (op, cb) {\n    this.cancelPending();\n    this.callHook('beforeEnter');\n    this.cb = cb;\n    addClass(this.el, this.enterClass);\n    op();\n    this.entered = false;\n    this.callHookWithCb('enter');\n    if (this.entered) {\n      return; // user called done synchronously.\n    }\n    this.cancel = this.hooks && this.hooks.enterCancelled;\n    pushJob(this.enterNextTick);\n  };\n\n  /**\n   * The \"nextTick\" phase of an entering transition, which is\n   * to be pushed into a queue and executed after a reflow so\n   * that removing the class can trigger a CSS transition.\n   */\n\n  p$1.enterNextTick = function () {\n    var _this = this;\n\n    // prevent transition skipping\n    this.justEntered = true;\n    waitForTransitionStart(function () {\n      _this.justEntered = false;\n    });\n    var enterDone = this.enterDone;\n    var type = this.getCssTransitionType(this.enterClass);\n    if (!this.pendingJsCb) {\n      if (type === TYPE_TRANSITION) {\n        // trigger transition by removing enter class now\n        removeClass(this.el, this.enterClass);\n        this.setupCssCb(transitionEndEvent, enterDone);\n      } else if (type === TYPE_ANIMATION) {\n        this.setupCssCb(animationEndEvent, enterDone);\n      } else {\n        enterDone();\n      }\n    } else if (type === TYPE_TRANSITION) {\n      removeClass(this.el, this.enterClass);\n    }\n  };\n\n  /**\n   * The \"cleanup\" phase of an entering transition.\n   */\n\n  p$1.enterDone = function () {\n    this.entered = true;\n    this.cancel = this.pendingJsCb = null;\n    removeClass(this.el, this.enterClass);\n    this.callHook('afterEnter');\n    if (this.cb) this.cb();\n  };\n\n  /**\n   * Start a leaving transition.\n   *\n   * 1. leave transition triggered.\n   * 2. call beforeLeave hook\n   * 3. add leave class (trigger css transition)\n   * 4. call leave hook (with possible explicit js callback)\n   * 5. reflow if no explicit js callback is provided\n   * 6. based on transition type:\n   *    - transition or animation:\n   *        wait for end event, remove class, then done if\n   *        there's no explicit js callback.\n   *    - no css transition:\n   *        done if there's no explicit js callback.\n   * 7. wait for either done or js callback, then call\n   *    afterLeave hook.\n   *\n   * @param {Function} op - remove/hide the element\n   * @param {Function} [cb]\n   */\n\n  p$1.leave = function (op, cb) {\n    this.cancelPending();\n    this.callHook('beforeLeave');\n    this.op = op;\n    this.cb = cb;\n    addClass(this.el, this.leaveClass);\n    this.left = false;\n    this.callHookWithCb('leave');\n    if (this.left) {\n      return; // user called done synchronously.\n    }\n    this.cancel = this.hooks && this.hooks.leaveCancelled;\n    // only need to handle leaveDone if\n    // 1. the transition is already done (synchronously called\n    //    by the user, which causes this.op set to null)\n    // 2. there's no explicit js callback\n    if (this.op && !this.pendingJsCb) {\n      // if a CSS transition leaves immediately after enter,\n      // the transitionend event never fires. therefore we\n      // detect such cases and end the leave immediately.\n      if (this.justEntered) {\n        this.leaveDone();\n      } else {\n        pushJob(this.leaveNextTick);\n      }\n    }\n  };\n\n  /**\n   * The \"nextTick\" phase of a leaving transition.\n   */\n\n  p$1.leaveNextTick = function () {\n    var type = this.getCssTransitionType(this.leaveClass);\n    if (type) {\n      var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;\n      this.setupCssCb(event, this.leaveDone);\n    } else {\n      this.leaveDone();\n    }\n  };\n\n  /**\n   * The \"cleanup\" phase of a leaving transition.\n   */\n\n  p$1.leaveDone = function () {\n    this.left = true;\n    this.cancel = this.pendingJsCb = null;\n    this.op();\n    removeClass(this.el, this.leaveClass);\n    this.callHook('afterLeave');\n    if (this.cb) this.cb();\n    this.op = null;\n  };\n\n  /**\n   * Cancel any pending callbacks from a previously running\n   * but not finished transition.\n   */\n\n  p$1.cancelPending = function () {\n    this.op = this.cb = null;\n    var hasPending = false;\n    if (this.pendingCssCb) {\n      hasPending = true;\n      off(this.el, this.pendingCssEvent, this.pendingCssCb);\n      this.pendingCssEvent = this.pendingCssCb = null;\n    }\n    if (this.pendingJsCb) {\n      hasPending = true;\n      this.pendingJsCb.cancel();\n      this.pendingJsCb = null;\n    }\n    if (hasPending) {\n      removeClass(this.el, this.enterClass);\n      removeClass(this.el, this.leaveClass);\n    }\n    if (this.cancel) {\n      this.cancel.call(this.vm, this.el);\n      this.cancel = null;\n    }\n  };\n\n  /**\n   * Call a user-provided synchronous hook function.\n   *\n   * @param {String} type\n   */\n\n  p$1.callHook = function (type) {\n    if (this.hooks && this.hooks[type]) {\n      this.hooks[type].call(this.vm, this.el);\n    }\n  };\n\n  /**\n   * Call a user-provided, potentially-async hook function.\n   * We check for the length of arguments to see if the hook\n   * expects a `done` callback. If true, the transition's end\n   * will be determined by when the user calls that callback;\n   * otherwise, the end is determined by the CSS transition or\n   * animation.\n   *\n   * @param {String} type\n   */\n\n  p$1.callHookWithCb = function (type) {\n    var hook = this.hooks && this.hooks[type];\n    if (hook) {\n      if (hook.length > 1) {\n        this.pendingJsCb = cancellable(this[type + 'Done']);\n      }\n      hook.call(this.vm, this.el, this.pendingJsCb);\n    }\n  };\n\n  /**\n   * Get an element's transition type based on the\n   * calculated styles.\n   *\n   * @param {String} className\n   * @return {Number}\n   */\n\n  p$1.getCssTransitionType = function (className) {\n    /* istanbul ignore if */\n    if (!transitionEndEvent ||\n    // skip CSS transitions if page is not visible -\n    // this solves the issue of transitionend events not\n    // firing until the page is visible again.\n    // pageVisibility API is supported in IE10+, same as\n    // CSS transitions.\n    document.hidden ||\n    // explicit js-only transition\n    this.hooks && this.hooks.css === false ||\n    // element is hidden\n    isHidden(this.el)) {\n      return;\n    }\n    var type = this.type || this.typeCache[className];\n    if (type) return type;\n    var inlineStyles = this.el.style;\n    var computedStyles = window.getComputedStyle(this.el);\n    var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];\n    if (transDuration && transDuration !== '0s') {\n      type = TYPE_TRANSITION;\n    } else {\n      var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];\n      if (animDuration && animDuration !== '0s') {\n        type = TYPE_ANIMATION;\n      }\n    }\n    if (type) {\n      this.typeCache[className] = type;\n    }\n    return type;\n  };\n\n  /**\n   * Setup a CSS transitionend/animationend callback.\n   *\n   * @param {String} event\n   * @param {Function} cb\n   */\n\n  p$1.setupCssCb = function (event, cb) {\n    this.pendingCssEvent = event;\n    var self = this;\n    var el = this.el;\n    var onEnd = this.pendingCssCb = function (e) {\n      if (e.target === el) {\n        off(el, event, onEnd);\n        self.pendingCssEvent = self.pendingCssCb = null;\n        if (!self.pendingJsCb && cb) {\n          cb();\n        }\n      }\n    };\n    on(el, event, onEnd);\n  };\n\n  /**\n   * Check if an element is hidden - in that case we can just\n   * skip the transition alltogether.\n   *\n   * @param {Element} el\n   * @return {Boolean}\n   */\n\n  function isHidden(el) {\n    if (/svg$/.test(el.namespaceURI)) {\n      // SVG elements do not have offset(Width|Height)\n      // so we need to check the client rect\n      var rect = el.getBoundingClientRect();\n      return !(rect.width || rect.height);\n    } else {\n      return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);\n    }\n  }\n\n  var transition$1 = {\n\n    priority: TRANSITION,\n\n    update: function update(id, oldId) {\n      var el = this.el;\n      // resolve on owner vm\n      var hooks = resolveAsset(this.vm.$options, 'transitions', id);\n      id = id || 'v';\n      el.__v_trans = new Transition(el, id, hooks, this.vm);\n      if (oldId) {\n        removeClass(el, oldId + '-transition');\n      }\n      addClass(el, id + '-transition');\n    }\n  };\n\n  var internalDirectives = {\n    style: style,\n    'class': vClass,\n    component: component,\n    prop: propDef,\n    transition: transition$1\n  };\n\n  // special binding prefixes\n  var bindRE = /^v-bind:|^:/;\n  var onRE = /^v-on:|^@/;\n  var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;\n  var modifierRE = /\\.[^\\.]+/g;\n  var transitionRE = /^(v-bind:|:)?transition$/;\n\n  // default directive priority\n  var DEFAULT_PRIORITY = 1000;\n  var DEFAULT_TERMINAL_PRIORITY = 2000;\n\n  /**\n   * Compile a template and return a reusable composite link\n   * function, which recursively contains more link functions\n   * inside. This top level compile function would normally\n   * be called on instance root nodes, but can also be used\n   * for partial compilation if the partial argument is true.\n   *\n   * The returned composite link function, when called, will\n   * return an unlink function that tearsdown all directives\n   * created during the linking phase.\n   *\n   * @param {Element|DocumentFragment} el\n   * @param {Object} options\n   * @param {Boolean} partial\n   * @return {Function}\n   */\n\n  function compile(el, options, partial) {\n    // link function for the node itself.\n    var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;\n    // link function for the childNodes\n    var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;\n\n    /**\n     * A composite linker function to be called on a already\n     * compiled piece of DOM, which instantiates all directive\n     * instances.\n     *\n     * @param {Vue} vm\n     * @param {Element|DocumentFragment} el\n     * @param {Vue} [host] - host vm of transcluded content\n     * @param {Object} [scope] - v-for scope\n     * @param {Fragment} [frag] - link context fragment\n     * @return {Function|undefined}\n     */\n\n    return function compositeLinkFn(vm, el, host, scope, frag) {\n      // cache childNodes before linking parent, fix #657\n      var childNodes = toArray(el.childNodes);\n      // link\n      var dirs = linkAndCapture(function compositeLinkCapturer() {\n        if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);\n        if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);\n      }, vm);\n      return makeUnlinkFn(vm, dirs);\n    };\n  }\n\n  /**\n   * Apply a linker to a vm/element pair and capture the\n   * directives created during the process.\n   *\n   * @param {Function} linker\n   * @param {Vue} vm\n   */\n\n  function linkAndCapture(linker, vm) {\n    /* istanbul ignore if */\n    if ('development' === 'production') {}\n    var originalDirCount = vm._directives.length;\n    linker();\n    var dirs = vm._directives.slice(originalDirCount);\n    dirs.sort(directiveComparator);\n    for (var i = 0, l = dirs.length; i < l; i++) {\n      dirs[i]._bind();\n    }\n    return dirs;\n  }\n\n  /**\n   * Directive priority sort comparator\n   *\n   * @param {Object} a\n   * @param {Object} b\n   */\n\n  function directiveComparator(a, b) {\n    a = a.descriptor.def.priority || DEFAULT_PRIORITY;\n    b = b.descriptor.def.priority || DEFAULT_PRIORITY;\n    return a > b ? -1 : a === b ? 0 : 1;\n  }\n\n  /**\n   * Linker functions return an unlink function that\n   * tearsdown all directives instances generated during\n   * the process.\n   *\n   * We create unlink functions with only the necessary\n   * information to avoid retaining additional closures.\n   *\n   * @param {Vue} vm\n   * @param {Array} dirs\n   * @param {Vue} [context]\n   * @param {Array} [contextDirs]\n   * @return {Function}\n   */\n\n  function makeUnlinkFn(vm, dirs, context, contextDirs) {\n    function unlink(destroying) {\n      teardownDirs(vm, dirs, destroying);\n      if (context && contextDirs) {\n        teardownDirs(context, contextDirs);\n      }\n    }\n    // expose linked directives\n    unlink.dirs = dirs;\n    return unlink;\n  }\n\n  /**\n   * Teardown partial linked directives.\n   *\n   * @param {Vue} vm\n   * @param {Array} dirs\n   * @param {Boolean} destroying\n   */\n\n  function teardownDirs(vm, dirs, destroying) {\n    var i = dirs.length;\n    while (i--) {\n      dirs[i]._teardown();\n      if ('development' !== 'production' && !destroying) {\n        vm._directives.$remove(dirs[i]);\n      }\n    }\n  }\n\n  /**\n   * Compile link props on an instance.\n   *\n   * @param {Vue} vm\n   * @param {Element} el\n   * @param {Object} props\n   * @param {Object} [scope]\n   * @return {Function}\n   */\n\n  function compileAndLinkProps(vm, el, props, scope) {\n    var propsLinkFn = compileProps(el, props, vm);\n    var propDirs = linkAndCapture(function () {\n      propsLinkFn(vm, scope);\n    }, vm);\n    return makeUnlinkFn(vm, propDirs);\n  }\n\n  /**\n   * Compile the root element of an instance.\n   *\n   * 1. attrs on context container (context scope)\n   * 2. attrs on the component template root node, if\n   *    replace:true (child scope)\n   *\n   * If this is a fragment instance, we only need to compile 1.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @param {Object} contextOptions\n   * @return {Function}\n   */\n\n  function compileRoot(el, options, contextOptions) {\n    var containerAttrs = options._containerAttrs;\n    var replacerAttrs = options._replacerAttrs;\n    var contextLinkFn, replacerLinkFn;\n\n    // only need to compile other attributes for\n    // non-fragment instances\n    if (el.nodeType !== 11) {\n      // for components, container and replacer need to be\n      // compiled separately and linked in different scopes.\n      if (options._asComponent) {\n        // 2. container attributes\n        if (containerAttrs && contextOptions) {\n          contextLinkFn = compileDirectives(containerAttrs, contextOptions);\n        }\n        if (replacerAttrs) {\n          // 3. replacer attributes\n          replacerLinkFn = compileDirectives(replacerAttrs, options);\n        }\n      } else {\n        // non-component, just compile as a normal element.\n        replacerLinkFn = compileDirectives(el.attributes, options);\n      }\n    } else if ('development' !== 'production' && containerAttrs) {\n      // warn container directives for fragment instances\n      var names = containerAttrs.filter(function (attr) {\n        // allow vue-loader/vueify scoped css attributes\n        return attr.name.indexOf('_v-') < 0 &&\n        // allow event listeners\n        !onRE.test(attr.name) &&\n        // allow slots\n        attr.name !== 'slot';\n      }).map(function (attr) {\n        return '\"' + attr.name + '\"';\n      });\n      if (names.length) {\n        var plural = names.length > 1;\n        warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');\n      }\n    }\n\n    options._containerAttrs = options._replacerAttrs = null;\n    return function rootLinkFn(vm, el, scope) {\n      // link context scope dirs\n      var context = vm._context;\n      var contextDirs;\n      if (context && contextLinkFn) {\n        contextDirs = linkAndCapture(function () {\n          contextLinkFn(context, el, null, scope);\n        }, context);\n      }\n\n      // link self\n      var selfDirs = linkAndCapture(function () {\n        if (replacerLinkFn) replacerLinkFn(vm, el);\n      }, vm);\n\n      // return the unlink function that tearsdown context\n      // container directives.\n      return makeUnlinkFn(vm, selfDirs, context, contextDirs);\n    };\n  }\n\n  /**\n   * Compile a node and return a nodeLinkFn based on the\n   * node type.\n   *\n   * @param {Node} node\n   * @param {Object} options\n   * @return {Function|null}\n   */\n\n  function compileNode(node, options) {\n    var type = node.nodeType;\n    if (type === 1 && !isScript(node)) {\n      return compileElement(node, options);\n    } else if (type === 3 && node.data.trim()) {\n      return compileTextNode(node, options);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Compile an element and return a nodeLinkFn.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Function|null}\n   */\n\n  function compileElement(el, options) {\n    // preprocess textareas.\n    // textarea treats its text content as the initial value.\n    // just bind it as an attr directive for value.\n    if (el.tagName === 'TEXTAREA') {\n      var tokens = parseText(el.value);\n      if (tokens) {\n        el.setAttribute(':value', tokensToExp(tokens));\n        el.value = '';\n      }\n    }\n    var linkFn;\n    var hasAttrs = el.hasAttributes();\n    var attrs = hasAttrs && toArray(el.attributes);\n    // check terminal directives (for & if)\n    if (hasAttrs) {\n      linkFn = checkTerminalDirectives(el, attrs, options);\n    }\n    // check element directives\n    if (!linkFn) {\n      linkFn = checkElementDirectives(el, options);\n    }\n    // check component\n    if (!linkFn) {\n      linkFn = checkComponent(el, options);\n    }\n    // normal directives\n    if (!linkFn && hasAttrs) {\n      linkFn = compileDirectives(attrs, options);\n    }\n    return linkFn;\n  }\n\n  /**\n   * Compile a textNode and return a nodeLinkFn.\n   *\n   * @param {TextNode} node\n   * @param {Object} options\n   * @return {Function|null} textNodeLinkFn\n   */\n\n  function compileTextNode(node, options) {\n    // skip marked text nodes\n    if (node._skip) {\n      return removeText;\n    }\n\n    var tokens = parseText(node.wholeText);\n    if (!tokens) {\n      return null;\n    }\n\n    // mark adjacent text nodes as skipped,\n    // because we are using node.wholeText to compile\n    // all adjacent text nodes together. This fixes\n    // issues in IE where sometimes it splits up a single\n    // text node into multiple ones.\n    var next = node.nextSibling;\n    while (next && next.nodeType === 3) {\n      next._skip = true;\n      next = next.nextSibling;\n    }\n\n    var frag = document.createDocumentFragment();\n    var el, token;\n    for (var i = 0, l = tokens.length; i < l; i++) {\n      token = tokens[i];\n      el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);\n      frag.appendChild(el);\n    }\n    return makeTextNodeLinkFn(tokens, frag, options);\n  }\n\n  /**\n   * Linker for an skipped text node.\n   *\n   * @param {Vue} vm\n   * @param {Text} node\n   */\n\n  function removeText(vm, node) {\n    remove(node);\n  }\n\n  /**\n   * Process a single text token.\n   *\n   * @param {Object} token\n   * @param {Object} options\n   * @return {Node}\n   */\n\n  function processTextToken(token, options) {\n    var el;\n    if (token.oneTime) {\n      el = document.createTextNode(token.value);\n    } else {\n      if (token.html) {\n        el = document.createComment('v-html');\n        setTokenType('html');\n      } else {\n        // IE will clean up empty textNodes during\n        // frag.cloneNode(true), so we have to give it\n        // something here...\n        el = document.createTextNode(' ');\n        setTokenType('text');\n      }\n    }\n    function setTokenType(type) {\n      if (token.descriptor) return;\n      var parsed = parseDirective(token.value);\n      token.descriptor = {\n        name: type,\n        def: directives[type],\n        expression: parsed.expression,\n        filters: parsed.filters\n      };\n    }\n    return el;\n  }\n\n  /**\n   * Build a function that processes a textNode.\n   *\n   * @param {Array<Object>} tokens\n   * @param {DocumentFragment} frag\n   */\n\n  function makeTextNodeLinkFn(tokens, frag) {\n    return function textNodeLinkFn(vm, el, host, scope) {\n      var fragClone = frag.cloneNode(true);\n      var childNodes = toArray(fragClone.childNodes);\n      var token, value, node;\n      for (var i = 0, l = tokens.length; i < l; i++) {\n        token = tokens[i];\n        value = token.value;\n        if (token.tag) {\n          node = childNodes[i];\n          if (token.oneTime) {\n            value = (scope || vm).$eval(value);\n            if (token.html) {\n              replace(node, parseTemplate(value, true));\n            } else {\n              node.data = value;\n            }\n          } else {\n            vm._bindDir(token.descriptor, node, host, scope);\n          }\n        }\n      }\n      replace(el, fragClone);\n    };\n  }\n\n  /**\n   * Compile a node list and return a childLinkFn.\n   *\n   * @param {NodeList} nodeList\n   * @param {Object} options\n   * @return {Function|undefined}\n   */\n\n  function compileNodeList(nodeList, options) {\n    var linkFns = [];\n    var nodeLinkFn, childLinkFn, node;\n    for (var i = 0, l = nodeList.length; i < l; i++) {\n      node = nodeList[i];\n      nodeLinkFn = compileNode(node, options);\n      childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;\n      linkFns.push(nodeLinkFn, childLinkFn);\n    }\n    return linkFns.length ? makeChildLinkFn(linkFns) : null;\n  }\n\n  /**\n   * Make a child link function for a node's childNodes.\n   *\n   * @param {Array<Function>} linkFns\n   * @return {Function} childLinkFn\n   */\n\n  function makeChildLinkFn(linkFns) {\n    return function childLinkFn(vm, nodes, host, scope, frag) {\n      var node, nodeLinkFn, childrenLinkFn;\n      for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {\n        node = nodes[n];\n        nodeLinkFn = linkFns[i++];\n        childrenLinkFn = linkFns[i++];\n        // cache childNodes before linking parent, fix #657\n        var childNodes = toArray(node.childNodes);\n        if (nodeLinkFn) {\n          nodeLinkFn(vm, node, host, scope, frag);\n        }\n        if (childrenLinkFn) {\n          childrenLinkFn(vm, childNodes, host, scope, frag);\n        }\n      }\n    };\n  }\n\n  /**\n   * Check for element directives (custom elements that should\n   * be resovled as terminal directives).\n   *\n   * @param {Element} el\n   * @param {Object} options\n   */\n\n  function checkElementDirectives(el, options) {\n    var tag = el.tagName.toLowerCase();\n    if (commonTagRE.test(tag)) {\n      return;\n    }\n    var def = resolveAsset(options, 'elementDirectives', tag);\n    if (def) {\n      return makeTerminalNodeLinkFn(el, tag, '', options, def);\n    }\n  }\n\n  /**\n   * Check if an element is a component. If yes, return\n   * a component link function.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Function|undefined}\n   */\n\n  function checkComponent(el, options) {\n    var component = checkComponentAttr(el, options);\n    if (component) {\n      var ref = findRef(el);\n      var descriptor = {\n        name: 'component',\n        ref: ref,\n        expression: component.id,\n        def: internalDirectives.component,\n        modifiers: {\n          literal: !component.dynamic\n        }\n      };\n      var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {\n        if (ref) {\n          defineReactive((scope || vm).$refs, ref, null);\n        }\n        vm._bindDir(descriptor, el, host, scope, frag);\n      };\n      componentLinkFn.terminal = true;\n      return componentLinkFn;\n    }\n  }\n\n  /**\n   * Check an element for terminal directives in fixed order.\n   * If it finds one, return a terminal link function.\n   *\n   * @param {Element} el\n   * @param {Array} attrs\n   * @param {Object} options\n   * @return {Function} terminalLinkFn\n   */\n\n  function checkTerminalDirectives(el, attrs, options) {\n    // skip v-pre\n    if (getAttr(el, 'v-pre') !== null) {\n      return skip;\n    }\n    // skip v-else block, but only if following v-if\n    if (el.hasAttribute('v-else')) {\n      var prev = el.previousElementSibling;\n      if (prev && prev.hasAttribute('v-if')) {\n        return skip;\n      }\n    }\n\n    var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;\n    for (var i = 0, j = attrs.length; i < j; i++) {\n      attr = attrs[i];\n      name = attr.name.replace(modifierRE, '');\n      if (matched = name.match(dirAttrRE)) {\n        def = resolveAsset(options, 'directives', matched[1]);\n        if (def && def.terminal) {\n          if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {\n            termDef = def;\n            rawName = attr.name;\n            modifiers = parseModifiers(attr.name);\n            value = attr.value;\n            dirName = matched[1];\n            arg = matched[2];\n          }\n        }\n      }\n    }\n\n    if (termDef) {\n      return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);\n    }\n  }\n\n  function skip() {}\n  skip.terminal = true;\n\n  /**\n   * Build a node link function for a terminal directive.\n   * A terminal link function terminates the current\n   * compilation recursion and handles compilation of the\n   * subtree in the directive.\n   *\n   * @param {Element} el\n   * @param {String} dirName\n   * @param {String} value\n   * @param {Object} options\n   * @param {Object} def\n   * @param {String} [rawName]\n   * @param {String} [arg]\n   * @param {Object} [modifiers]\n   * @return {Function} terminalLinkFn\n   */\n\n  function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {\n    var parsed = parseDirective(value);\n    var descriptor = {\n      name: dirName,\n      arg: arg,\n      expression: parsed.expression,\n      filters: parsed.filters,\n      raw: value,\n      attr: rawName,\n      modifiers: modifiers,\n      def: def\n    };\n    // check ref for v-for and router-view\n    if (dirName === 'for' || dirName === 'router-view') {\n      descriptor.ref = findRef(el);\n    }\n    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {\n      if (descriptor.ref) {\n        defineReactive((scope || vm).$refs, descriptor.ref, null);\n      }\n      vm._bindDir(descriptor, el, host, scope, frag);\n    };\n    fn.terminal = true;\n    return fn;\n  }\n\n  /**\n   * Compile the directives on an element and return a linker.\n   *\n   * @param {Array|NamedNodeMap} attrs\n   * @param {Object} options\n   * @return {Function}\n   */\n\n  function compileDirectives(attrs, options) {\n    var i = attrs.length;\n    var dirs = [];\n    var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;\n    while (i--) {\n      attr = attrs[i];\n      name = rawName = attr.name;\n      value = rawValue = attr.value;\n      tokens = parseText(value);\n      // reset arg\n      arg = null;\n      // check modifiers\n      modifiers = parseModifiers(name);\n      name = name.replace(modifierRE, '');\n\n      // attribute interpolations\n      if (tokens) {\n        value = tokensToExp(tokens);\n        arg = name;\n        pushDir('bind', directives.bind, tokens);\n        // warn against mixing mustaches with v-bind\n        if ('development' !== 'production') {\n          if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {\n            return attr.name === ':class' || attr.name === 'v-bind:class';\n          })) {\n            warn('class=\"' + rawValue + '\": Do not mix mustache interpolation ' + 'and v-bind for \"class\" on the same element. Use one or the other.', options);\n          }\n        }\n      } else\n\n        // special attribute: transition\n        if (transitionRE.test(name)) {\n          modifiers.literal = !bindRE.test(name);\n          pushDir('transition', internalDirectives.transition);\n        } else\n\n          // event handlers\n          if (onRE.test(name)) {\n            arg = name.replace(onRE, '');\n            pushDir('on', directives.on);\n          } else\n\n            // attribute bindings\n            if (bindRE.test(name)) {\n              dirName = name.replace(bindRE, '');\n              if (dirName === 'style' || dirName === 'class') {\n                pushDir(dirName, internalDirectives[dirName]);\n              } else {\n                arg = dirName;\n                pushDir('bind', directives.bind);\n              }\n            } else\n\n              // normal directives\n              if (matched = name.match(dirAttrRE)) {\n                dirName = matched[1];\n                arg = matched[2];\n\n                // skip v-else (when used with v-show)\n                if (dirName === 'else') {\n                  continue;\n                }\n\n                dirDef = resolveAsset(options, 'directives', dirName, true);\n                if (dirDef) {\n                  pushDir(dirName, dirDef);\n                }\n              }\n    }\n\n    /**\n     * Push a directive.\n     *\n     * @param {String} dirName\n     * @param {Object|Function} def\n     * @param {Array} [interpTokens]\n     */\n\n    function pushDir(dirName, def, interpTokens) {\n      var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);\n      var parsed = !hasOneTimeToken && parseDirective(value);\n      dirs.push({\n        name: dirName,\n        attr: rawName,\n        raw: rawValue,\n        def: def,\n        arg: arg,\n        modifiers: modifiers,\n        // conversion from interpolation strings with one-time token\n        // to expression is differed until directive bind time so that we\n        // have access to the actual vm context for one-time bindings.\n        expression: parsed && parsed.expression,\n        filters: parsed && parsed.filters,\n        interp: interpTokens,\n        hasOneTime: hasOneTimeToken\n      });\n    }\n\n    if (dirs.length) {\n      return makeNodeLinkFn(dirs);\n    }\n  }\n\n  /**\n   * Parse modifiers from directive attribute name.\n   *\n   * @param {String} name\n   * @return {Object}\n   */\n\n  function parseModifiers(name) {\n    var res = Object.create(null);\n    var match = name.match(modifierRE);\n    if (match) {\n      var i = match.length;\n      while (i--) {\n        res[match[i].slice(1)] = true;\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Build a link function for all directives on a single node.\n   *\n   * @param {Array} directives\n   * @return {Function} directivesLinkFn\n   */\n\n  function makeNodeLinkFn(directives) {\n    return function nodeLinkFn(vm, el, host, scope, frag) {\n      // reverse apply because it's sorted low to high\n      var i = directives.length;\n      while (i--) {\n        vm._bindDir(directives[i], el, host, scope, frag);\n      }\n    };\n  }\n\n  /**\n   * Check if an interpolation string contains one-time tokens.\n   *\n   * @param {Array} tokens\n   * @return {Boolean}\n   */\n\n  function hasOneTime(tokens) {\n    var i = tokens.length;\n    while (i--) {\n      if (tokens[i].oneTime) return true;\n    }\n  }\n\n  function isScript(el) {\n    return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');\n  }\n\n  var specialCharRE = /[^\\w\\-:\\.]/;\n\n  /**\n   * Process an element or a DocumentFragment based on a\n   * instance option object. This allows us to transclude\n   * a template node/fragment before the instance is created,\n   * so the processed fragment can then be cloned and reused\n   * in v-for.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Element|DocumentFragment}\n   */\n\n  function transclude(el, options) {\n    // extract container attributes to pass them down\n    // to compiler, because they need to be compiled in\n    // parent scope. we are mutating the options object here\n    // assuming the same object will be used for compile\n    // right after this.\n    if (options) {\n      options._containerAttrs = extractAttrs(el);\n    }\n    // for template tags, what we want is its content as\n    // a documentFragment (for fragment instances)\n    if (isTemplate(el)) {\n      el = parseTemplate(el);\n    }\n    if (options) {\n      if (options._asComponent && !options.template) {\n        options.template = '<slot></slot>';\n      }\n      if (options.template) {\n        options._content = extractContent(el);\n        el = transcludeTemplate(el, options);\n      }\n    }\n    if (isFragment(el)) {\n      // anchors for fragment instance\n      // passing in `persist: true` to avoid them being\n      // discarded by IE during template cloning\n      prepend(createAnchor('v-start', true), el);\n      el.appendChild(createAnchor('v-end', true));\n    }\n    return el;\n  }\n\n  /**\n   * Process the template option.\n   * If the replace option is true this will swap the $el.\n   *\n   * @param {Element} el\n   * @param {Object} options\n   * @return {Element|DocumentFragment}\n   */\n\n  function transcludeTemplate(el, options) {\n    var template = options.template;\n    var frag = parseTemplate(template, true);\n    if (frag) {\n      var replacer = frag.firstChild;\n      var tag = replacer.tagName && replacer.tagName.toLowerCase();\n      if (options.replace) {\n        /* istanbul ignore if */\n        if (el === document.body) {\n          'development' !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');\n        }\n        // there are many cases where the instance must\n        // become a fragment instance: basically anything that\n        // can create more than 1 root nodes.\n        if (\n        // multi-children template\n        frag.childNodes.length > 1 ||\n        // non-element template\n        replacer.nodeType !== 1 ||\n        // single nested component\n        tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||\n        // element directive\n        resolveAsset(options, 'elementDirectives', tag) ||\n        // for block\n        replacer.hasAttribute('v-for') ||\n        // if block\n        replacer.hasAttribute('v-if')) {\n          return frag;\n        } else {\n          options._replacerAttrs = extractAttrs(replacer);\n          mergeAttrs(el, replacer);\n          return replacer;\n        }\n      } else {\n        el.appendChild(frag);\n        return el;\n      }\n    } else {\n      'development' !== 'production' && warn('Invalid template option: ' + template);\n    }\n  }\n\n  /**\n   * Helper to extract a component container's attributes\n   * into a plain object array.\n   *\n   * @param {Element} el\n   * @return {Array}\n   */\n\n  function extractAttrs(el) {\n    if (el.nodeType === 1 && el.hasAttributes()) {\n      return toArray(el.attributes);\n    }\n  }\n\n  /**\n   * Merge the attributes of two elements, and make sure\n   * the class names are merged properly.\n   *\n   * @param {Element} from\n   * @param {Element} to\n   */\n\n  function mergeAttrs(from, to) {\n    var attrs = from.attributes;\n    var i = attrs.length;\n    var name, value;\n    while (i--) {\n      name = attrs[i].name;\n      value = attrs[i].value;\n      if (!to.hasAttribute(name) && !specialCharRE.test(name)) {\n        to.setAttribute(name, value);\n      } else if (name === 'class' && !parseText(value) && (value = value.trim())) {\n        value.split(/\\s+/).forEach(function (cls) {\n          addClass(to, cls);\n        });\n      }\n    }\n  }\n\n  /**\n   * Scan and determine slot content distribution.\n   * We do this during transclusion instead at compile time so that\n   * the distribution is decoupled from the compilation order of\n   * the slots.\n   *\n   * @param {Element|DocumentFragment} template\n   * @param {Element} content\n   * @param {Vue} vm\n   */\n\n  function resolveSlots(vm, content) {\n    if (!content) {\n      return;\n    }\n    var contents = vm._slotContents = Object.create(null);\n    var el, name;\n    for (var i = 0, l = content.children.length; i < l; i++) {\n      el = content.children[i];\n      /* eslint-disable no-cond-assign */\n      if (name = el.getAttribute('slot')) {\n        (contents[name] || (contents[name] = [])).push(el);\n      }\n      /* eslint-enable no-cond-assign */\n      if ('development' !== 'production' && getBindAttr(el, 'slot')) {\n        warn('The \"slot\" attribute must be static.', vm.$parent);\n      }\n    }\n    for (name in contents) {\n      contents[name] = extractFragment(contents[name], content);\n    }\n    if (content.hasChildNodes()) {\n      var nodes = content.childNodes;\n      if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {\n        return;\n      }\n      contents['default'] = extractFragment(content.childNodes, content);\n    }\n  }\n\n  /**\n   * Extract qualified content nodes from a node list.\n   *\n   * @param {NodeList} nodes\n   * @return {DocumentFragment}\n   */\n\n  function extractFragment(nodes, parent) {\n    var frag = document.createDocumentFragment();\n    nodes = toArray(nodes);\n    for (var i = 0, l = nodes.length; i < l; i++) {\n      var node = nodes[i];\n      if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {\n        parent.removeChild(node);\n        node = parseTemplate(node, true);\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n\n\n  var compiler = Object.freeze({\n  \tcompile: compile,\n  \tcompileAndLinkProps: compileAndLinkProps,\n  \tcompileRoot: compileRoot,\n  \ttransclude: transclude,\n  \tresolveSlots: resolveSlots\n  });\n\n  function stateMixin (Vue) {\n    /**\n     * Accessor for `$data` property, since setting $data\n     * requires observing the new object and updating\n     * proxied properties.\n     */\n\n    Object.defineProperty(Vue.prototype, '$data', {\n      get: function get() {\n        return this._data;\n      },\n      set: function set(newData) {\n        if (newData !== this._data) {\n          this._setData(newData);\n        }\n      }\n    });\n\n    /**\n     * Setup the scope of an instance, which contains:\n     * - observed data\n     * - computed properties\n     * - user methods\n     * - meta properties\n     */\n\n    Vue.prototype._initState = function () {\n      this._initProps();\n      this._initMeta();\n      this._initMethods();\n      this._initData();\n      this._initComputed();\n    };\n\n    /**\n     * Initialize props.\n     */\n\n    Vue.prototype._initProps = function () {\n      var options = this.$options;\n      var el = options.el;\n      var props = options.props;\n      if (props && !el) {\n        'development' !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);\n      }\n      // make sure to convert string selectors into element now\n      el = options.el = query(el);\n      this._propsUnlinkFn = el && el.nodeType === 1 && props\n      // props must be linked in proper scope if inside v-for\n      ? compileAndLinkProps(this, el, props, this._scope) : null;\n    };\n\n    /**\n     * Initialize the data.\n     */\n\n    Vue.prototype._initData = function () {\n      var dataFn = this.$options.data;\n      var data = this._data = dataFn ? dataFn() : {};\n      if (!isPlainObject(data)) {\n        data = {};\n        'development' !== 'production' && warn('data functions should return an object.', this);\n      }\n      var props = this._props;\n      // proxy data on instance\n      var keys = Object.keys(data);\n      var i, key;\n      i = keys.length;\n      while (i--) {\n        key = keys[i];\n        // there are two scenarios where we can proxy a data key:\n        // 1. it's not already defined as a prop\n        // 2. it's provided via a instantiation option AND there are no\n        //    template prop present\n        if (!props || !hasOwn(props, key)) {\n          this._proxy(key);\n        } else if ('development' !== 'production') {\n          warn('Data field \"' + key + '\" is already defined ' + 'as a prop. To provide default value for a prop, use the \"default\" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the \"propsData\" option.', this);\n        }\n      }\n      // observe data\n      observe(data, this);\n    };\n\n    /**\n     * Swap the instance's $data. Called in $data's setter.\n     *\n     * @param {Object} newData\n     */\n\n    Vue.prototype._setData = function (newData) {\n      newData = newData || {};\n      var oldData = this._data;\n      this._data = newData;\n      var keys, key, i;\n      // unproxy keys not present in new data\n      keys = Object.keys(oldData);\n      i = keys.length;\n      while (i--) {\n        key = keys[i];\n        if (!(key in newData)) {\n          this._unproxy(key);\n        }\n      }\n      // proxy keys not already proxied,\n      // and trigger change for changed values\n      keys = Object.keys(newData);\n      i = keys.length;\n      while (i--) {\n        key = keys[i];\n        if (!hasOwn(this, key)) {\n          // new property\n          this._proxy(key);\n        }\n      }\n      oldData.__ob__.removeVm(this);\n      observe(newData, this);\n      this._digest();\n    };\n\n    /**\n     * Proxy a property, so that\n     * vm.prop === vm._data.prop\n     *\n     * @param {String} key\n     */\n\n    Vue.prototype._proxy = function (key) {\n      if (!isReserved(key)) {\n        // need to store ref to self here\n        // because these getter/setters might\n        // be called by child scopes via\n        // prototype inheritance.\n        var self = this;\n        Object.defineProperty(self, key, {\n          configurable: true,\n          enumerable: true,\n          get: function proxyGetter() {\n            return self._data[key];\n          },\n          set: function proxySetter(val) {\n            self._data[key] = val;\n          }\n        });\n      }\n    };\n\n    /**\n     * Unproxy a property.\n     *\n     * @param {String} key\n     */\n\n    Vue.prototype._unproxy = function (key) {\n      if (!isReserved(key)) {\n        delete this[key];\n      }\n    };\n\n    /**\n     * Force update on every watcher in scope.\n     */\n\n    Vue.prototype._digest = function () {\n      for (var i = 0, l = this._watchers.length; i < l; i++) {\n        this._watchers[i].update(true); // shallow updates\n      }\n    };\n\n    /**\n     * Setup computed properties. They are essentially\n     * special getter/setters\n     */\n\n    function noop() {}\n    Vue.prototype._initComputed = function () {\n      var computed = this.$options.computed;\n      if (computed) {\n        for (var key in computed) {\n          var userDef = computed[key];\n          var def = {\n            enumerable: true,\n            configurable: true\n          };\n          if (typeof userDef === 'function') {\n            def.get = makeComputedGetter(userDef, this);\n            def.set = noop;\n          } else {\n            def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;\n            def.set = userDef.set ? bind(userDef.set, this) : noop;\n          }\n          Object.defineProperty(this, key, def);\n        }\n      }\n    };\n\n    function makeComputedGetter(getter, owner) {\n      var watcher = new Watcher(owner, getter, null, {\n        lazy: true\n      });\n      return function computedGetter() {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      };\n    }\n\n    /**\n     * Setup instance methods. Methods must be bound to the\n     * instance since they might be passed down as a prop to\n     * child components.\n     */\n\n    Vue.prototype._initMethods = function () {\n      var methods = this.$options.methods;\n      if (methods) {\n        for (var key in methods) {\n          this[key] = bind(methods[key], this);\n        }\n      }\n    };\n\n    /**\n     * Initialize meta information like $index, $key & $value.\n     */\n\n    Vue.prototype._initMeta = function () {\n      var metas = this.$options._meta;\n      if (metas) {\n        for (var key in metas) {\n          defineReactive(this, key, metas[key]);\n        }\n      }\n    };\n  }\n\n  var eventRE = /^v-on:|^@/;\n\n  function eventsMixin (Vue) {\n    /**\n     * Setup the instance's option events & watchers.\n     * If the value is a string, we pull it from the\n     * instance's methods by name.\n     */\n\n    Vue.prototype._initEvents = function () {\n      var options = this.$options;\n      if (options._asComponent) {\n        registerComponentEvents(this, options.el);\n      }\n      registerCallbacks(this, '$on', options.events);\n      registerCallbacks(this, '$watch', options.watch);\n    };\n\n    /**\n     * Register v-on events on a child component\n     *\n     * @param {Vue} vm\n     * @param {Element} el\n     */\n\n    function registerComponentEvents(vm, el) {\n      var attrs = el.attributes;\n      var name, value, handler;\n      for (var i = 0, l = attrs.length; i < l; i++) {\n        name = attrs[i].name;\n        if (eventRE.test(name)) {\n          name = name.replace(eventRE, '');\n          // force the expression into a statement so that\n          // it always dynamically resolves the method to call (#2670)\n          // kinda ugly hack, but does the job.\n          value = attrs[i].value;\n          if (isSimplePath(value)) {\n            value += '.apply(this, $arguments)';\n          }\n          handler = (vm._scope || vm._context).$eval(value, true);\n          handler._fromParent = true;\n          vm.$on(name.replace(eventRE), handler);\n        }\n      }\n    }\n\n    /**\n     * Register callbacks for option events and watchers.\n     *\n     * @param {Vue} vm\n     * @param {String} action\n     * @param {Object} hash\n     */\n\n    function registerCallbacks(vm, action, hash) {\n      if (!hash) return;\n      var handlers, key, i, j;\n      for (key in hash) {\n        handlers = hash[key];\n        if (isArray(handlers)) {\n          for (i = 0, j = handlers.length; i < j; i++) {\n            register(vm, action, key, handlers[i]);\n          }\n        } else {\n          register(vm, action, key, handlers);\n        }\n      }\n    }\n\n    /**\n     * Helper to register an event/watch callback.\n     *\n     * @param {Vue} vm\n     * @param {String} action\n     * @param {String} key\n     * @param {Function|String|Object} handler\n     * @param {Object} [options]\n     */\n\n    function register(vm, action, key, handler, options) {\n      var type = typeof handler;\n      if (type === 'function') {\n        vm[action](key, handler, options);\n      } else if (type === 'string') {\n        var methods = vm.$options.methods;\n        var method = methods && methods[handler];\n        if (method) {\n          vm[action](key, method, options);\n        } else {\n          'development' !== 'production' && warn('Unknown method: \"' + handler + '\" when ' + 'registering callback for ' + action + ': \"' + key + '\".', vm);\n        }\n      } else if (handler && type === 'object') {\n        register(vm, action, key, handler.handler, handler);\n      }\n    }\n\n    /**\n     * Setup recursive attached/detached calls\n     */\n\n    Vue.prototype._initDOMHooks = function () {\n      this.$on('hook:attached', onAttached);\n      this.$on('hook:detached', onDetached);\n    };\n\n    /**\n     * Callback to recursively call attached hook on children\n     */\n\n    function onAttached() {\n      if (!this._isAttached) {\n        this._isAttached = true;\n        this.$children.forEach(callAttach);\n      }\n    }\n\n    /**\n     * Iterator to call attached hook\n     *\n     * @param {Vue} child\n     */\n\n    function callAttach(child) {\n      if (!child._isAttached && inDoc(child.$el)) {\n        child._callHook('attached');\n      }\n    }\n\n    /**\n     * Callback to recursively call detached hook on children\n     */\n\n    function onDetached() {\n      if (this._isAttached) {\n        this._isAttached = false;\n        this.$children.forEach(callDetach);\n      }\n    }\n\n    /**\n     * Iterator to call detached hook\n     *\n     * @param {Vue} child\n     */\n\n    function callDetach(child) {\n      if (child._isAttached && !inDoc(child.$el)) {\n        child._callHook('detached');\n      }\n    }\n\n    /**\n     * Trigger all handlers for a hook\n     *\n     * @param {String} hook\n     */\n\n    Vue.prototype._callHook = function (hook) {\n      this.$emit('pre-hook:' + hook);\n      var handlers = this.$options[hook];\n      if (handlers) {\n        for (var i = 0, j = handlers.length; i < j; i++) {\n          handlers[i].call(this);\n        }\n      }\n      this.$emit('hook:' + hook);\n    };\n  }\n\n  function noop() {}\n\n  /**\n   * A directive links a DOM element with a piece of data,\n   * which is the result of evaluating an expression.\n   * It registers a watcher with the expression and calls\n   * the DOM update function when a change is triggered.\n   *\n   * @param {Object} descriptor\n   *                 - {String} name\n   *                 - {Object} def\n   *                 - {String} expression\n   *                 - {Array<Object>} [filters]\n   *                 - {Object} [modifiers]\n   *                 - {Boolean} literal\n   *                 - {String} attr\n   *                 - {String} arg\n   *                 - {String} raw\n   *                 - {String} [ref]\n   *                 - {Array<Object>} [interp]\n   *                 - {Boolean} [hasOneTime]\n   * @param {Vue} vm\n   * @param {Node} el\n   * @param {Vue} [host] - transclusion host component\n   * @param {Object} [scope] - v-for scope\n   * @param {Fragment} [frag] - owner fragment\n   * @constructor\n   */\n  function Directive(descriptor, vm, el, host, scope, frag) {\n    this.vm = vm;\n    this.el = el;\n    // copy descriptor properties\n    this.descriptor = descriptor;\n    this.name = descriptor.name;\n    this.expression = descriptor.expression;\n    this.arg = descriptor.arg;\n    this.modifiers = descriptor.modifiers;\n    this.filters = descriptor.filters;\n    this.literal = this.modifiers && this.modifiers.literal;\n    // private\n    this._locked = false;\n    this._bound = false;\n    this._listeners = null;\n    // link context\n    this._host = host;\n    this._scope = scope;\n    this._frag = frag;\n    // store directives on node in dev mode\n    if ('development' !== 'production' && this.el) {\n      this.el._vue_directives = this.el._vue_directives || [];\n      this.el._vue_directives.push(this);\n    }\n  }\n\n  /**\n   * Initialize the directive, mixin definition properties,\n   * setup the watcher, call definition bind() and update()\n   * if present.\n   */\n\n  Directive.prototype._bind = function () {\n    var name = this.name;\n    var descriptor = this.descriptor;\n\n    // remove attribute\n    if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {\n      var attr = descriptor.attr || 'v-' + name;\n      this.el.removeAttribute(attr);\n    }\n\n    // copy def properties\n    var def = descriptor.def;\n    if (typeof def === 'function') {\n      this.update = def;\n    } else {\n      extend(this, def);\n    }\n\n    // setup directive params\n    this._setupParams();\n\n    // initial bind\n    if (this.bind) {\n      this.bind();\n    }\n    this._bound = true;\n\n    if (this.literal) {\n      this.update && this.update(descriptor.raw);\n    } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {\n      // wrapped updater for context\n      var dir = this;\n      if (this.update) {\n        this._update = function (val, oldVal) {\n          if (!dir._locked) {\n            dir.update(val, oldVal);\n          }\n        };\n      } else {\n        this._update = noop;\n      }\n      var preProcess = this._preProcess ? bind(this._preProcess, this) : null;\n      var postProcess = this._postProcess ? bind(this._postProcess, this) : null;\n      var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback\n      {\n        filters: this.filters,\n        twoWay: this.twoWay,\n        deep: this.deep,\n        preProcess: preProcess,\n        postProcess: postProcess,\n        scope: this._scope\n      });\n      // v-model with inital inline value need to sync back to\n      // model instead of update to DOM on init. They would\n      // set the afterBind hook to indicate that.\n      if (this.afterBind) {\n        this.afterBind();\n      } else if (this.update) {\n        this.update(watcher.value);\n      }\n    }\n  };\n\n  /**\n   * Setup all param attributes, e.g. track-by,\n   * transition-mode, etc...\n   */\n\n  Directive.prototype._setupParams = function () {\n    if (!this.params) {\n      return;\n    }\n    var params = this.params;\n    // swap the params array with a fresh object.\n    this.params = Object.create(null);\n    var i = params.length;\n    var key, val, mappedKey;\n    while (i--) {\n      key = hyphenate(params[i]);\n      mappedKey = camelize(key);\n      val = getBindAttr(this.el, key);\n      if (val != null) {\n        // dynamic\n        this._setupParamWatcher(mappedKey, val);\n      } else {\n        // static\n        val = getAttr(this.el, key);\n        if (val != null) {\n          this.params[mappedKey] = val === '' ? true : val;\n        }\n      }\n    }\n  };\n\n  /**\n   * Setup a watcher for a dynamic param.\n   *\n   * @param {String} key\n   * @param {String} expression\n   */\n\n  Directive.prototype._setupParamWatcher = function (key, expression) {\n    var self = this;\n    var called = false;\n    var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {\n      self.params[key] = val;\n      // since we are in immediate mode,\n      // only call the param change callbacks if this is not the first update.\n      if (called) {\n        var cb = self.paramWatchers && self.paramWatchers[key];\n        if (cb) {\n          cb.call(self, val, oldVal);\n        }\n      } else {\n        called = true;\n      }\n    }, {\n      immediate: true,\n      user: false\n    });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);\n  };\n\n  /**\n   * Check if the directive is a function caller\n   * and if the expression is a callable one. If both true,\n   * we wrap up the expression and use it as the event\n   * handler.\n   *\n   * e.g. on-click=\"a++\"\n   *\n   * @return {Boolean}\n   */\n\n  Directive.prototype._checkStatement = function () {\n    var expression = this.expression;\n    if (expression && this.acceptStatement && !isSimplePath(expression)) {\n      var fn = parseExpression(expression).get;\n      var scope = this._scope || this.vm;\n      var handler = function handler(e) {\n        scope.$event = e;\n        fn.call(scope, scope);\n        scope.$event = null;\n      };\n      if (this.filters) {\n        handler = scope._applyFilters(handler, null, this.filters);\n      }\n      this.update(handler);\n      return true;\n    }\n  };\n\n  /**\n   * Set the corresponding value with the setter.\n   * This should only be used in two-way directives\n   * e.g. v-model.\n   *\n   * @param {*} value\n   * @public\n   */\n\n  Directive.prototype.set = function (value) {\n    /* istanbul ignore else */\n    if (this.twoWay) {\n      this._withLock(function () {\n        this._watcher.set(value);\n      });\n    } else if ('development' !== 'production') {\n      warn('Directive.set() can only be used inside twoWay' + 'directives.');\n    }\n  };\n\n  /**\n   * Execute a function while preventing that function from\n   * triggering updates on this directive instance.\n   *\n   * @param {Function} fn\n   */\n\n  Directive.prototype._withLock = function (fn) {\n    var self = this;\n    self._locked = true;\n    fn.call(self);\n    nextTick(function () {\n      self._locked = false;\n    });\n  };\n\n  /**\n   * Convenience method that attaches a DOM event listener\n   * to the directive element and autometically tears it down\n   * during unbind.\n   *\n   * @param {String} event\n   * @param {Function} handler\n   * @param {Boolean} [useCapture]\n   */\n\n  Directive.prototype.on = function (event, handler, useCapture) {\n    on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);\n  };\n\n  /**\n   * Teardown the watcher and call unbind.\n   */\n\n  Directive.prototype._teardown = function () {\n    if (this._bound) {\n      this._bound = false;\n      if (this.unbind) {\n        this.unbind();\n      }\n      if (this._watcher) {\n        this._watcher.teardown();\n      }\n      var listeners = this._listeners;\n      var i;\n      if (listeners) {\n        i = listeners.length;\n        while (i--) {\n          off(this.el, listeners[i][0], listeners[i][1]);\n        }\n      }\n      var unwatchFns = this._paramUnwatchFns;\n      if (unwatchFns) {\n        i = unwatchFns.length;\n        while (i--) {\n          unwatchFns[i]();\n        }\n      }\n      if ('development' !== 'production' && this.el) {\n        this.el._vue_directives.$remove(this);\n      }\n      this.vm = this.el = this._watcher = this._listeners = null;\n    }\n  };\n\n  function lifecycleMixin (Vue) {\n    /**\n     * Update v-ref for component.\n     *\n     * @param {Boolean} remove\n     */\n\n    Vue.prototype._updateRef = function (remove) {\n      var ref = this.$options._ref;\n      if (ref) {\n        var refs = (this._scope || this._context).$refs;\n        if (remove) {\n          if (refs[ref] === this) {\n            refs[ref] = null;\n          }\n        } else {\n          refs[ref] = this;\n        }\n      }\n    };\n\n    /**\n     * Transclude, compile and link element.\n     *\n     * If a pre-compiled linker is available, that means the\n     * passed in element will be pre-transcluded and compiled\n     * as well - all we need to do is to call the linker.\n     *\n     * Otherwise we need to call transclude/compile/link here.\n     *\n     * @param {Element} el\n     */\n\n    Vue.prototype._compile = function (el) {\n      var options = this.$options;\n\n      // transclude and init element\n      // transclude can potentially replace original\n      // so we need to keep reference; this step also injects\n      // the template and caches the original attributes\n      // on the container node and replacer node.\n      var original = el;\n      el = transclude(el, options);\n      this._initElement(el);\n\n      // handle v-pre on root node (#2026)\n      if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {\n        return;\n      }\n\n      // root is always compiled per-instance, because\n      // container attrs and props can be different every time.\n      var contextOptions = this._context && this._context.$options;\n      var rootLinker = compileRoot(el, options, contextOptions);\n\n      // resolve slot distribution\n      resolveSlots(this, options._content);\n\n      // compile and link the rest\n      var contentLinkFn;\n      var ctor = this.constructor;\n      // component compilation can be cached\n      // as long as it's not using inline-template\n      if (options._linkerCachable) {\n        contentLinkFn = ctor.linker;\n        if (!contentLinkFn) {\n          contentLinkFn = ctor.linker = compile(el, options);\n        }\n      }\n\n      // link phase\n      // make sure to link root with prop scope!\n      var rootUnlinkFn = rootLinker(this, el, this._scope);\n      var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);\n\n      // register composite unlink function\n      // to be called during instance destruction\n      this._unlinkFn = function () {\n        rootUnlinkFn();\n        // passing destroying: true to avoid searching and\n        // splicing the directives\n        contentUnlinkFn(true);\n      };\n\n      // finally replace original\n      if (options.replace) {\n        replace(original, el);\n      }\n\n      this._isCompiled = true;\n      this._callHook('compiled');\n    };\n\n    /**\n     * Initialize instance element. Called in the public\n     * $mount() method.\n     *\n     * @param {Element} el\n     */\n\n    Vue.prototype._initElement = function (el) {\n      if (isFragment(el)) {\n        this._isFragment = true;\n        this.$el = this._fragmentStart = el.firstChild;\n        this._fragmentEnd = el.lastChild;\n        // set persisted text anchors to empty\n        if (this._fragmentStart.nodeType === 3) {\n          this._fragmentStart.data = this._fragmentEnd.data = '';\n        }\n        this._fragment = el;\n      } else {\n        this.$el = el;\n      }\n      this.$el.__vue__ = this;\n      this._callHook('beforeCompile');\n    };\n\n    /**\n     * Create and bind a directive to an element.\n     *\n     * @param {Object} descriptor - parsed directive descriptor\n     * @param {Node} node   - target node\n     * @param {Vue} [host] - transclusion host component\n     * @param {Object} [scope] - v-for scope\n     * @param {Fragment} [frag] - owner fragment\n     */\n\n    Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {\n      this._directives.push(new Directive(descriptor, this, node, host, scope, frag));\n    };\n\n    /**\n     * Teardown an instance, unobserves the data, unbind all the\n     * directives, turn off all the event listeners, etc.\n     *\n     * @param {Boolean} remove - whether to remove the DOM node.\n     * @param {Boolean} deferCleanup - if true, defer cleanup to\n     *                                 be called later\n     */\n\n    Vue.prototype._destroy = function (remove, deferCleanup) {\n      if (this._isBeingDestroyed) {\n        if (!deferCleanup) {\n          this._cleanup();\n        }\n        return;\n      }\n\n      var destroyReady;\n      var pendingRemoval;\n\n      var self = this;\n      // Cleanup should be called either synchronously or asynchronoysly as\n      // callback of this.$remove(), or if remove and deferCleanup are false.\n      // In any case it should be called after all other removing, unbinding and\n      // turning of is done\n      var cleanupIfPossible = function cleanupIfPossible() {\n        if (destroyReady && !pendingRemoval && !deferCleanup) {\n          self._cleanup();\n        }\n      };\n\n      // remove DOM element\n      if (remove && this.$el) {\n        pendingRemoval = true;\n        this.$remove(function () {\n          pendingRemoval = false;\n          cleanupIfPossible();\n        });\n      }\n\n      this._callHook('beforeDestroy');\n      this._isBeingDestroyed = true;\n      var i;\n      // remove self from parent. only necessary\n      // if parent is not being destroyed as well.\n      var parent = this.$parent;\n      if (parent && !parent._isBeingDestroyed) {\n        parent.$children.$remove(this);\n        // unregister ref (remove: true)\n        this._updateRef(true);\n      }\n      // destroy all children.\n      i = this.$children.length;\n      while (i--) {\n        this.$children[i].$destroy();\n      }\n      // teardown props\n      if (this._propsUnlinkFn) {\n        this._propsUnlinkFn();\n      }\n      // teardown all directives. this also tearsdown all\n      // directive-owned watchers.\n      if (this._unlinkFn) {\n        this._unlinkFn();\n      }\n      i = this._watchers.length;\n      while (i--) {\n        this._watchers[i].teardown();\n      }\n      // remove reference to self on $el\n      if (this.$el) {\n        this.$el.__vue__ = null;\n      }\n\n      destroyReady = true;\n      cleanupIfPossible();\n    };\n\n    /**\n     * Clean up to ensure garbage collection.\n     * This is called after the leave transition if there\n     * is any.\n     */\n\n    Vue.prototype._cleanup = function () {\n      if (this._isDestroyed) {\n        return;\n      }\n      // remove self from owner fragment\n      // do it in cleanup so that we can call $destroy with\n      // defer right when a fragment is about to be removed.\n      if (this._frag) {\n        this._frag.children.$remove(this);\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (this._data && this._data.__ob__) {\n        this._data.__ob__.removeVm(this);\n      }\n      // Clean up references to private properties and other\n      // instances. preserve reference to _data so that proxy\n      // accessors still work. The only potential side effect\n      // here is that mutating the instance after it's destroyed\n      // may affect the state of other components that are still\n      // observing the same object, but that seems to be a\n      // reasonable responsibility for the user rather than\n      // always throwing an error on them.\n      this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;\n      // call the last hook...\n      this._isDestroyed = true;\n      this._callHook('destroyed');\n      // turn off all instance listeners.\n      this.$off();\n    };\n  }\n\n  function miscMixin (Vue) {\n    /**\n     * Apply a list of filter (descriptors) to a value.\n     * Using plain for loops here because this will be called in\n     * the getter of any watcher with filters so it is very\n     * performance sensitive.\n     *\n     * @param {*} value\n     * @param {*} [oldValue]\n     * @param {Array} filters\n     * @param {Boolean} write\n     * @return {*}\n     */\n\n    Vue.prototype._applyFilters = function (value, oldValue, filters, write) {\n      var filter, fn, args, arg, offset, i, l, j, k;\n      for (i = 0, l = filters.length; i < l; i++) {\n        filter = filters[write ? l - i - 1 : i];\n        fn = resolveAsset(this.$options, 'filters', filter.name, true);\n        if (!fn) continue;\n        fn = write ? fn.write : fn.read || fn;\n        if (typeof fn !== 'function') continue;\n        args = write ? [value, oldValue] : [value];\n        offset = write ? 2 : 1;\n        if (filter.args) {\n          for (j = 0, k = filter.args.length; j < k; j++) {\n            arg = filter.args[j];\n            args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;\n          }\n        }\n        value = fn.apply(this, args);\n      }\n      return value;\n    };\n\n    /**\n     * Resolve a component, depending on whether the component\n     * is defined normally or using an async factory function.\n     * Resolves synchronously if already resolved, otherwise\n     * resolves asynchronously and caches the resolved\n     * constructor on the factory.\n     *\n     * @param {String|Function} value\n     * @param {Function} cb\n     */\n\n    Vue.prototype._resolveComponent = function (value, cb) {\n      var factory;\n      if (typeof value === 'function') {\n        factory = value;\n      } else {\n        factory = resolveAsset(this.$options, 'components', value, true);\n      }\n      /* istanbul ignore if */\n      if (!factory) {\n        return;\n      }\n      // async component factory\n      if (!factory.options) {\n        if (factory.resolved) {\n          // cached\n          cb(factory.resolved);\n        } else if (factory.requested) {\n          // pool callbacks\n          factory.pendingCallbacks.push(cb);\n        } else {\n          factory.requested = true;\n          var cbs = factory.pendingCallbacks = [cb];\n          factory.call(this, function resolve(res) {\n            if (isPlainObject(res)) {\n              res = Vue.extend(res);\n            }\n            // cache resolved\n            factory.resolved = res;\n            // invoke callbacks\n            for (var i = 0, l = cbs.length; i < l; i++) {\n              cbs[i](res);\n            }\n          }, function reject(reason) {\n            'development' !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\\nReason: ' + reason : ''));\n          });\n        }\n      } else {\n        // normal component\n        cb(factory);\n      }\n    };\n  }\n\n  var filterRE$1 = /[^|]\\|[^|]/;\n\n  function dataAPI (Vue) {\n    /**\n     * Get the value from an expression on this vm.\n     *\n     * @param {String} exp\n     * @param {Boolean} [asStatement]\n     * @return {*}\n     */\n\n    Vue.prototype.$get = function (exp, asStatement) {\n      var res = parseExpression(exp);\n      if (res) {\n        if (asStatement) {\n          var self = this;\n          return function statementHandler() {\n            self.$arguments = toArray(arguments);\n            var result = res.get.call(self, self);\n            self.$arguments = null;\n            return result;\n          };\n        } else {\n          try {\n            return res.get.call(this, this);\n          } catch (e) {}\n        }\n      }\n    };\n\n    /**\n     * Set the value from an expression on this vm.\n     * The expression must be a valid left-hand\n     * expression in an assignment.\n     *\n     * @param {String} exp\n     * @param {*} val\n     */\n\n    Vue.prototype.$set = function (exp, val) {\n      var res = parseExpression(exp, true);\n      if (res && res.set) {\n        res.set.call(this, this, val);\n      }\n    };\n\n    /**\n     * Delete a property on the VM\n     *\n     * @param {String} key\n     */\n\n    Vue.prototype.$delete = function (key) {\n      del(this._data, key);\n    };\n\n    /**\n     * Watch an expression, trigger callback when its\n     * value changes.\n     *\n     * @param {String|Function} expOrFn\n     * @param {Function} cb\n     * @param {Object} [options]\n     *                 - {Boolean} deep\n     *                 - {Boolean} immediate\n     * @return {Function} - unwatchFn\n     */\n\n    Vue.prototype.$watch = function (expOrFn, cb, options) {\n      var vm = this;\n      var parsed;\n      if (typeof expOrFn === 'string') {\n        parsed = parseDirective(expOrFn);\n        expOrFn = parsed.expression;\n      }\n      var watcher = new Watcher(vm, expOrFn, cb, {\n        deep: options && options.deep,\n        sync: options && options.sync,\n        filters: parsed && parsed.filters,\n        user: !options || options.user !== false\n      });\n      if (options && options.immediate) {\n        cb.call(vm, watcher.value);\n      }\n      return function unwatchFn() {\n        watcher.teardown();\n      };\n    };\n\n    /**\n     * Evaluate a text directive, including filters.\n     *\n     * @param {String} text\n     * @param {Boolean} [asStatement]\n     * @return {String}\n     */\n\n    Vue.prototype.$eval = function (text, asStatement) {\n      // check for filters.\n      if (filterRE$1.test(text)) {\n        var dir = parseDirective(text);\n        // the filter regex check might give false positive\n        // for pipes inside strings, so it's possible that\n        // we don't get any filters here\n        var val = this.$get(dir.expression, asStatement);\n        return dir.filters ? this._applyFilters(val, null, dir.filters) : val;\n      } else {\n        // no filter\n        return this.$get(text, asStatement);\n      }\n    };\n\n    /**\n     * Interpolate a piece of template text.\n     *\n     * @param {String} text\n     * @return {String}\n     */\n\n    Vue.prototype.$interpolate = function (text) {\n      var tokens = parseText(text);\n      var vm = this;\n      if (tokens) {\n        if (tokens.length === 1) {\n          return vm.$eval(tokens[0].value) + '';\n        } else {\n          return tokens.map(function (token) {\n            return token.tag ? vm.$eval(token.value) : token.value;\n          }).join('');\n        }\n      } else {\n        return text;\n      }\n    };\n\n    /**\n     * Log instance data as a plain JS object\n     * so that it is easier to inspect in console.\n     * This method assumes console is available.\n     *\n     * @param {String} [path]\n     */\n\n    Vue.prototype.$log = function (path) {\n      var data = path ? getPath(this._data, path) : this._data;\n      if (data) {\n        data = clean(data);\n      }\n      // include computed fields\n      if (!path) {\n        var key;\n        for (key in this.$options.computed) {\n          data[key] = clean(this[key]);\n        }\n        if (this._props) {\n          for (key in this._props) {\n            data[key] = clean(this[key]);\n          }\n        }\n      }\n      console.log(data);\n    };\n\n    /**\n     * \"clean\" a getter/setter converted object into a plain\n     * object copy.\n     *\n     * @param {Object} - obj\n     * @return {Object}\n     */\n\n    function clean(obj) {\n      return JSON.parse(JSON.stringify(obj));\n    }\n  }\n\n  function domAPI (Vue) {\n    /**\n     * Convenience on-instance nextTick. The callback is\n     * auto-bound to the instance, and this avoids component\n     * modules having to rely on the global Vue.\n     *\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$nextTick = function (fn) {\n      nextTick(fn, this);\n    };\n\n    /**\n     * Append instance to target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$appendTo = function (target, cb, withTransition) {\n      return insert(this, target, cb, withTransition, append, appendWithTransition);\n    };\n\n    /**\n     * Prepend instance to target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$prependTo = function (target, cb, withTransition) {\n      target = query(target);\n      if (target.hasChildNodes()) {\n        this.$before(target.firstChild, cb, withTransition);\n      } else {\n        this.$appendTo(target, cb, withTransition);\n      }\n      return this;\n    };\n\n    /**\n     * Insert instance before target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$before = function (target, cb, withTransition) {\n      return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);\n    };\n\n    /**\n     * Insert instance after target\n     *\n     * @param {Node} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$after = function (target, cb, withTransition) {\n      target = query(target);\n      if (target.nextSibling) {\n        this.$before(target.nextSibling, cb, withTransition);\n      } else {\n        this.$appendTo(target.parentNode, cb, withTransition);\n      }\n      return this;\n    };\n\n    /**\n     * Remove instance from DOM\n     *\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition] - defaults to true\n     */\n\n    Vue.prototype.$remove = function (cb, withTransition) {\n      if (!this.$el.parentNode) {\n        return cb && cb();\n      }\n      var inDocument = this._isAttached && inDoc(this.$el);\n      // if we are not in document, no need to check\n      // for transitions\n      if (!inDocument) withTransition = false;\n      var self = this;\n      var realCb = function realCb() {\n        if (inDocument) self._callHook('detached');\n        if (cb) cb();\n      };\n      if (this._isFragment) {\n        removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);\n      } else {\n        var op = withTransition === false ? removeWithCb : removeWithTransition;\n        op(this.$el, this, realCb);\n      }\n      return this;\n    };\n\n    /**\n     * Shared DOM insertion function.\n     *\n     * @param {Vue} vm\n     * @param {Element} target\n     * @param {Function} [cb]\n     * @param {Boolean} [withTransition]\n     * @param {Function} op1 - op for non-transition insert\n     * @param {Function} op2 - op for transition insert\n     * @return vm\n     */\n\n    function insert(vm, target, cb, withTransition, op1, op2) {\n      target = query(target);\n      var targetIsDetached = !inDoc(target);\n      var op = withTransition === false || targetIsDetached ? op1 : op2;\n      var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);\n      if (vm._isFragment) {\n        mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {\n          op(node, target, vm);\n        });\n        cb && cb();\n      } else {\n        op(vm.$el, target, vm, cb);\n      }\n      if (shouldCallHook) {\n        vm._callHook('attached');\n      }\n      return vm;\n    }\n\n    /**\n     * Check for selectors\n     *\n     * @param {String|Element} el\n     */\n\n    function query(el) {\n      return typeof el === 'string' ? document.querySelector(el) : el;\n    }\n\n    /**\n     * Append operation that takes a callback.\n     *\n     * @param {Node} el\n     * @param {Node} target\n     * @param {Vue} vm - unused\n     * @param {Function} [cb]\n     */\n\n    function append(el, target, vm, cb) {\n      target.appendChild(el);\n      if (cb) cb();\n    }\n\n    /**\n     * InsertBefore operation that takes a callback.\n     *\n     * @param {Node} el\n     * @param {Node} target\n     * @param {Vue} vm - unused\n     * @param {Function} [cb]\n     */\n\n    function beforeWithCb(el, target, vm, cb) {\n      before(el, target);\n      if (cb) cb();\n    }\n\n    /**\n     * Remove operation that takes a callback.\n     *\n     * @param {Node} el\n     * @param {Vue} vm - unused\n     * @param {Function} [cb]\n     */\n\n    function removeWithCb(el, vm, cb) {\n      remove(el);\n      if (cb) cb();\n    }\n  }\n\n  function eventsAPI (Vue) {\n    /**\n     * Listen on the given `event` with `fn`.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$on = function (event, fn) {\n      (this._events[event] || (this._events[event] = [])).push(fn);\n      modifyListenerCount(this, event, 1);\n      return this;\n    };\n\n    /**\n     * Adds an `event` listener that will be invoked a single\n     * time then automatically removed.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$once = function (event, fn) {\n      var self = this;\n      function on() {\n        self.$off(event, on);\n        fn.apply(this, arguments);\n      }\n      on.fn = fn;\n      this.$on(event, on);\n      return this;\n    };\n\n    /**\n     * Remove the given callback for `event` or all\n     * registered callbacks.\n     *\n     * @param {String} event\n     * @param {Function} fn\n     */\n\n    Vue.prototype.$off = function (event, fn) {\n      var cbs;\n      // all\n      if (!arguments.length) {\n        if (this.$parent) {\n          for (event in this._events) {\n            cbs = this._events[event];\n            if (cbs) {\n              modifyListenerCount(this, event, -cbs.length);\n            }\n          }\n        }\n        this._events = {};\n        return this;\n      }\n      // specific event\n      cbs = this._events[event];\n      if (!cbs) {\n        return this;\n      }\n      if (arguments.length === 1) {\n        modifyListenerCount(this, event, -cbs.length);\n        this._events[event] = null;\n        return this;\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          modifyListenerCount(this, event, -1);\n          cbs.splice(i, 1);\n          break;\n        }\n      }\n      return this;\n    };\n\n    /**\n     * Trigger an event on self.\n     *\n     * @param {String|Object} event\n     * @return {Boolean} shouldPropagate\n     */\n\n    Vue.prototype.$emit = function (event) {\n      var isSource = typeof event === 'string';\n      event = isSource ? event : event.name;\n      var cbs = this._events[event];\n      var shouldPropagate = isSource || !cbs;\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        // this is a somewhat hacky solution to the question raised\n        // in #2102: for an inline component listener like <comp @test=\"doThis\">,\n        // the propagation handling is somewhat broken. Therefore we\n        // need to treat these inline callbacks differently.\n        var hasParentCbs = isSource && cbs.some(function (cb) {\n          return cb._fromParent;\n        });\n        if (hasParentCbs) {\n          shouldPropagate = false;\n        }\n        var args = toArray(arguments, 1);\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          var cb = cbs[i];\n          var res = cb.apply(this, args);\n          if (res === true && (!hasParentCbs || cb._fromParent)) {\n            shouldPropagate = true;\n          }\n        }\n      }\n      return shouldPropagate;\n    };\n\n    /**\n     * Recursively broadcast an event to all children instances.\n     *\n     * @param {String|Object} event\n     * @param {...*} additional arguments\n     */\n\n    Vue.prototype.$broadcast = function (event) {\n      var isSource = typeof event === 'string';\n      event = isSource ? event : event.name;\n      // if no child has registered for this event,\n      // then there's no need to broadcast.\n      if (!this._eventsCount[event]) return;\n      var children = this.$children;\n      var args = toArray(arguments);\n      if (isSource) {\n        // use object event to indicate non-source emit\n        // on children\n        args[0] = { name: event, source: this };\n      }\n      for (var i = 0, l = children.length; i < l; i++) {\n        var child = children[i];\n        var shouldPropagate = child.$emit.apply(child, args);\n        if (shouldPropagate) {\n          child.$broadcast.apply(child, args);\n        }\n      }\n      return this;\n    };\n\n    /**\n     * Recursively propagate an event up the parent chain.\n     *\n     * @param {String} event\n     * @param {...*} additional arguments\n     */\n\n    Vue.prototype.$dispatch = function (event) {\n      var shouldPropagate = this.$emit.apply(this, arguments);\n      if (!shouldPropagate) return;\n      var parent = this.$parent;\n      var args = toArray(arguments);\n      // use object event to indicate non-source emit\n      // on parents\n      args[0] = { name: event, source: this };\n      while (parent) {\n        shouldPropagate = parent.$emit.apply(parent, args);\n        parent = shouldPropagate ? parent.$parent : null;\n      }\n      return this;\n    };\n\n    /**\n     * Modify the listener counts on all parents.\n     * This bookkeeping allows $broadcast to return early when\n     * no child has listened to a certain event.\n     *\n     * @param {Vue} vm\n     * @param {String} event\n     * @param {Number} count\n     */\n\n    var hookRE = /^hook:/;\n    function modifyListenerCount(vm, event, count) {\n      var parent = vm.$parent;\n      // hooks do not get broadcasted so no need\n      // to do bookkeeping for them\n      if (!parent || !count || hookRE.test(event)) return;\n      while (parent) {\n        parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;\n        parent = parent.$parent;\n      }\n    }\n  }\n\n  function lifecycleAPI (Vue) {\n    /**\n     * Set instance target element and kick off the compilation\n     * process. The passed in `el` can be a selector string, an\n     * existing Element, or a DocumentFragment (for block\n     * instances).\n     *\n     * @param {Element|DocumentFragment|string} el\n     * @public\n     */\n\n    Vue.prototype.$mount = function (el) {\n      if (this._isCompiled) {\n        'development' !== 'production' && warn('$mount() should be called only once.', this);\n        return;\n      }\n      el = query(el);\n      if (!el) {\n        el = document.createElement('div');\n      }\n      this._compile(el);\n      this._initDOMHooks();\n      if (inDoc(this.$el)) {\n        this._callHook('attached');\n        ready.call(this);\n      } else {\n        this.$once('hook:attached', ready);\n      }\n      return this;\n    };\n\n    /**\n     * Mark an instance as ready.\n     */\n\n    function ready() {\n      this._isAttached = true;\n      this._isReady = true;\n      this._callHook('ready');\n    }\n\n    /**\n     * Teardown the instance, simply delegate to the internal\n     * _destroy.\n     *\n     * @param {Boolean} remove\n     * @param {Boolean} deferCleanup\n     */\n\n    Vue.prototype.$destroy = function (remove, deferCleanup) {\n      this._destroy(remove, deferCleanup);\n    };\n\n    /**\n     * Partially compile a piece of DOM and return a\n     * decompile function.\n     *\n     * @param {Element|DocumentFragment} el\n     * @param {Vue} [host]\n     * @param {Object} [scope]\n     * @param {Fragment} [frag]\n     * @return {Function}\n     */\n\n    Vue.prototype.$compile = function (el, host, scope, frag) {\n      return compile(el, this.$options, true)(this, el, host, scope, frag);\n    };\n  }\n\n  /**\n   * The exposed Vue constructor.\n   *\n   * API conventions:\n   * - public API methods/properties are prefixed with `$`\n   * - internal methods/properties are prefixed with `_`\n   * - non-prefixed properties are assumed to be proxied user\n   *   data.\n   *\n   * @constructor\n   * @param {Object} [options]\n   * @public\n   */\n\n  function Vue(options) {\n    this._init(options);\n  }\n\n  // install internals\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  miscMixin(Vue);\n\n  // install instance APIs\n  dataAPI(Vue);\n  domAPI(Vue);\n  eventsAPI(Vue);\n  lifecycleAPI(Vue);\n\n  var slot = {\n\n    priority: SLOT,\n    params: ['name'],\n\n    bind: function bind() {\n      // this was resolved during component transclusion\n      var name = this.params.name || 'default';\n      var content = this.vm._slotContents && this.vm._slotContents[name];\n      if (!content || !content.hasChildNodes()) {\n        this.fallback();\n      } else {\n        this.compile(content.cloneNode(true), this.vm._context, this.vm);\n      }\n    },\n\n    compile: function compile(content, context, host) {\n      if (content && context) {\n        if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {\n          // if the inserted slot has v-if\n          // inject fallback content as the v-else\n          var elseBlock = document.createElement('template');\n          elseBlock.setAttribute('v-else', '');\n          elseBlock.innerHTML = this.el.innerHTML;\n          // the else block should be compiled in child scope\n          elseBlock._context = this.vm;\n          content.appendChild(elseBlock);\n        }\n        var scope = host ? host._scope : this._scope;\n        this.unlink = context.$compile(content, host, scope, this._frag);\n      }\n      if (content) {\n        replace(this.el, content);\n      } else {\n        remove(this.el);\n      }\n    },\n\n    fallback: function fallback() {\n      this.compile(extractContent(this.el, true), this.vm);\n    },\n\n    unbind: function unbind() {\n      if (this.unlink) {\n        this.unlink();\n      }\n    }\n  };\n\n  var partial = {\n\n    priority: PARTIAL,\n\n    params: ['name'],\n\n    // watch changes to name for dynamic partials\n    paramWatchers: {\n      name: function name(value) {\n        vIf.remove.call(this);\n        if (value) {\n          this.insert(value);\n        }\n      }\n    },\n\n    bind: function bind() {\n      this.anchor = createAnchor('v-partial');\n      replace(this.el, this.anchor);\n      this.insert(this.params.name);\n    },\n\n    insert: function insert(id) {\n      var partial = resolveAsset(this.vm.$options, 'partials', id, true);\n      if (partial) {\n        this.factory = new FragmentFactory(this.vm, partial);\n        vIf.insert.call(this);\n      }\n    },\n\n    unbind: function unbind() {\n      if (this.frag) {\n        this.frag.destroy();\n      }\n    }\n  };\n\n  var elementDirectives = {\n    slot: slot,\n    partial: partial\n  };\n\n  var convertArray = vFor._postProcess;\n\n  /**\n   * Limit filter for arrays\n   *\n   * @param {Number} n\n   * @param {Number} offset (Decimal expected)\n   */\n\n  function limitBy(arr, n, offset) {\n    offset = offset ? parseInt(offset, 10) : 0;\n    n = toNumber(n);\n    return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;\n  }\n\n  /**\n   * Filter filter for arrays\n   *\n   * @param {String} search\n   * @param {String} [delimiter]\n   * @param {String} ...dataKeys\n   */\n\n  function filterBy(arr, search, delimiter) {\n    arr = convertArray(arr);\n    if (search == null) {\n      return arr;\n    }\n    if (typeof search === 'function') {\n      return arr.filter(search);\n    }\n    // cast to lowercase string\n    search = ('' + search).toLowerCase();\n    // allow optional `in` delimiter\n    // because why not\n    var n = delimiter === 'in' ? 3 : 2;\n    // extract and flatten keys\n    var keys = Array.prototype.concat.apply([], toArray(arguments, n));\n    var res = [];\n    var item, key, val, j;\n    for (var i = 0, l = arr.length; i < l; i++) {\n      item = arr[i];\n      val = item && item.$value || item;\n      j = keys.length;\n      if (j) {\n        while (j--) {\n          key = keys[j];\n          if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {\n            res.push(item);\n            break;\n          }\n        }\n      } else if (contains(item, search)) {\n        res.push(item);\n      }\n    }\n    return res;\n  }\n\n  /**\n   * Filter filter for arrays\n   *\n   * @param {String|Array<String>|Function} ...sortKeys\n   * @param {Number} [order]\n   */\n\n  function orderBy(arr) {\n    var comparator = null;\n    var sortKeys = undefined;\n    arr = convertArray(arr);\n\n    // determine order (last argument)\n    var args = toArray(arguments, 1);\n    var order = args[args.length - 1];\n    if (typeof order === 'number') {\n      order = order < 0 ? -1 : 1;\n      args = args.length > 1 ? args.slice(0, -1) : args;\n    } else {\n      order = 1;\n    }\n\n    // determine sortKeys & comparator\n    var firstArg = args[0];\n    if (!firstArg) {\n      return arr;\n    } else if (typeof firstArg === 'function') {\n      // custom comparator\n      comparator = function (a, b) {\n        return firstArg(a, b) * order;\n      };\n    } else {\n      // string keys. flatten first\n      sortKeys = Array.prototype.concat.apply([], args);\n      comparator = function (a, b, i) {\n        i = i || 0;\n        return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);\n      };\n    }\n\n    function baseCompare(a, b, sortKeyIndex) {\n      var sortKey = sortKeys[sortKeyIndex];\n      if (sortKey) {\n        if (sortKey !== '$key') {\n          if (isObject(a) && '$value' in a) a = a.$value;\n          if (isObject(b) && '$value' in b) b = b.$value;\n        }\n        a = isObject(a) ? getPath(a, sortKey) : a;\n        b = isObject(b) ? getPath(b, sortKey) : b;\n      }\n      return a === b ? 0 : a > b ? order : -order;\n    }\n\n    // sort on a copy to avoid mutating original array\n    return arr.slice().sort(comparator);\n  }\n\n  /**\n   * String contain helper\n   *\n   * @param {*} val\n   * @param {String} search\n   */\n\n  function contains(val, search) {\n    var i;\n    if (isPlainObject(val)) {\n      var keys = Object.keys(val);\n      i = keys.length;\n      while (i--) {\n        if (contains(val[keys[i]], search)) {\n          return true;\n        }\n      }\n    } else if (isArray(val)) {\n      i = val.length;\n      while (i--) {\n        if (contains(val[i], search)) {\n          return true;\n        }\n      }\n    } else if (val != null) {\n      return val.toString().toLowerCase().indexOf(search) > -1;\n    }\n  }\n\n  var digitsRE = /(\\d{3})(?=\\d)/g;\n\n  // asset collections must be a plain object.\n  var filters = {\n\n    orderBy: orderBy,\n    filterBy: filterBy,\n    limitBy: limitBy,\n\n    /**\n     * Stringify value.\n     *\n     * @param {Number} indent\n     */\n\n    json: {\n      read: function read(value, indent) {\n        return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);\n      },\n      write: function write(value) {\n        try {\n          return JSON.parse(value);\n        } catch (e) {\n          return value;\n        }\n      }\n    },\n\n    /**\n     * 'abc' => 'Abc'\n     */\n\n    capitalize: function capitalize(value) {\n      if (!value && value !== 0) return '';\n      value = value.toString();\n      return value.charAt(0).toUpperCase() + value.slice(1);\n    },\n\n    /**\n     * 'abc' => 'ABC'\n     */\n\n    uppercase: function uppercase(value) {\n      return value || value === 0 ? value.toString().toUpperCase() : '';\n    },\n\n    /**\n     * 'AbC' => 'abc'\n     */\n\n    lowercase: function lowercase(value) {\n      return value || value === 0 ? value.toString().toLowerCase() : '';\n    },\n\n    /**\n     * 12345 => $12,345.00\n     *\n     * @param {String} sign\n     * @param {Number} decimals Decimal places\n     */\n\n    currency: function currency(value, _currency, decimals) {\n      value = parseFloat(value);\n      if (!isFinite(value) || !value && value !== 0) return '';\n      _currency = _currency != null ? _currency : '$';\n      decimals = decimals != null ? decimals : 2;\n      var stringified = Math.abs(value).toFixed(decimals);\n      var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;\n      var i = _int.length % 3;\n      var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';\n      var _float = decimals ? stringified.slice(-1 - decimals) : '';\n      var sign = value < 0 ? '-' : '';\n      return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;\n    },\n\n    /**\n     * 'item' => 'items'\n     *\n     * @params\n     *  an array of strings corresponding to\n     *  the single, double, triple ... forms of the word to\n     *  be pluralized. When the number to be pluralized\n     *  exceeds the length of the args, it will use the last\n     *  entry in the array.\n     *\n     *  e.g. ['single', 'double', 'triple', 'multiple']\n     */\n\n    pluralize: function pluralize(value) {\n      var args = toArray(arguments, 1);\n      return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');\n    },\n\n    /**\n     * Debounce a handler function.\n     *\n     * @param {Function} handler\n     * @param {Number} delay = 300\n     * @return {Function}\n     */\n\n    debounce: function debounce(handler, delay) {\n      if (!handler) return;\n      if (!delay) {\n        delay = 300;\n      }\n      return _debounce(handler, delay);\n    }\n  };\n\n  function installGlobalAPI (Vue) {\n    /**\n     * Vue and every constructor that extends Vue has an\n     * associated options object, which can be accessed during\n     * compilation steps as `this.constructor.options`.\n     *\n     * These can be seen as the default options of every\n     * Vue instance.\n     */\n\n    Vue.options = {\n      directives: directives,\n      elementDirectives: elementDirectives,\n      filters: filters,\n      transitions: {},\n      components: {},\n      partials: {},\n      replace: true\n    };\n\n    /**\n     * Expose useful internals\n     */\n\n    Vue.util = util;\n    Vue.config = config;\n    Vue.set = set;\n    Vue['delete'] = del;\n    Vue.nextTick = nextTick;\n\n    /**\n     * The following are exposed for advanced usage / plugins\n     */\n\n    Vue.compiler = compiler;\n    Vue.FragmentFactory = FragmentFactory;\n    Vue.internalDirectives = internalDirectives;\n    Vue.parsers = {\n      path: path,\n      text: text,\n      template: template,\n      directive: directive,\n      expression: expression\n    };\n\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     *\n     * @param {Object} extendOptions\n     */\n\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var isFirstExtend = Super.cid === 0;\n      if (isFirstExtend && extendOptions._Ctor) {\n        return extendOptions._Ctor;\n      }\n      var name = extendOptions.name || Super.options.name;\n      if ('development' !== 'production') {\n        if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n          warn('Invalid component name: \"' + name + '\". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');\n          name = null;\n        }\n      }\n      var Sub = createClass(name || 'VueComponent');\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(Super.options, extendOptions);\n      Sub['super'] = Super;\n      // allow further extension\n      Sub.extend = Super.extend;\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      config._assetTypes.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n      // cache constructor\n      if (isFirstExtend) {\n        extendOptions._Ctor = Sub;\n      }\n      return Sub;\n    };\n\n    /**\n     * A function that returns a sub-class constructor with the\n     * given name. This gives us much nicer output when\n     * logging instances in the console.\n     *\n     * @param {String} name\n     * @return {Function}\n     */\n\n    function createClass(name) {\n      /* eslint-disable no-new-func */\n      return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();\n      /* eslint-enable no-new-func */\n    }\n\n    /**\n     * Plugin system\n     *\n     * @param {Object} plugin\n     */\n\n    Vue.use = function (plugin) {\n      /* istanbul ignore if */\n      if (plugin.installed) {\n        return;\n      }\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else {\n        plugin.apply(null, args);\n      }\n      plugin.installed = true;\n      return this;\n    };\n\n    /**\n     * Apply a global mixin by merging it into the default\n     * options.\n     */\n\n    Vue.mixin = function (mixin) {\n      Vue.options = mergeOptions(Vue.options, mixin);\n    };\n\n    /**\n     * Create asset registration methods with the following\n     * signature:\n     *\n     * @param {String} id\n     * @param {*} definition\n     */\n\n    config._assetTypes.forEach(function (type) {\n      Vue[type] = function (id, definition) {\n        if (!definition) {\n          return this.options[type + 's'][id];\n        } else {\n          /* istanbul ignore if */\n          if ('development' !== 'production') {\n            if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {\n              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);\n            }\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = id;\n            definition = Vue.extend(definition);\n          }\n          this.options[type + 's'][id] = definition;\n          return definition;\n        }\n      };\n    });\n\n    // expose internal transition API\n    extend(Vue.transition, transition);\n  }\n\n  installGlobalAPI(Vue);\n\n  Vue.version = '1.0.24';\n\n  // devtools global hook\n  /* istanbul ignore next */\n  setTimeout(function () {\n    if (config.devtools) {\n      if (devtools) {\n        devtools.emit('init', Vue);\n      } else if ('development' !== 'production' && inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)) {\n        console.log('Download the Vue Devtools for a better development experience:\\n' + 'https://github.com/vuejs/vue-devtools');\n      }\n    }\n  }, 0);\n\n  return Vue;\n\n}));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./lib/vue/dist/vue.js\n ** module id = 2\n ** module chunks = 0\n **/","var __vue_script__, __vue_template__\n__vue_script__ = require(\"!!babel-loader?presets[]=es2015&plugins[]=transform-runtime&comments=false!./../node_modules/vue-loader/lib/selector.js?type=script&index=0!./demo.vue\")\nif (__vue_script__ &&\n    __vue_script__.__esModule &&\n    Object.keys(__vue_script__).length > 1) {\n  console.warn(\"[vue-loader] demo/demo.vue: named exports in *.vue files are ignored.\")}\n__vue_template__ = require(\"!!raw!./../node_modules/vue-loader/lib/selector.js?type=template&index=0!./demo.vue\")\nmodule.exports = __vue_script__ || {}\nif (module.exports.__esModule) module.exports = module.exports.default\nif (__vue_template__) {\n(typeof module.exports === \"function\" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__\n}\nif (module.hot) {(function () {  module.hot.accept()\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  var id = \"./demo.vue\"\n  if (!module.hot.data) {\n    hotAPI.createRecord(id, module.exports)\n  } else {\n    hotAPI.update(id, module.exports, __vue_template__)\n  }\n})()}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./demo/demo.vue\n ** module id = 3\n ** module chunks = 0\n **/","<template>\n  <div class=\"form-horizontal\">\n    <div class=\"form-group\">\n      <label for=\"select1\" class=\"col-sm-3 control-label\">\n        A simple select:\n      </label>\n      <div class=\"col-sm-5\">\n        <vue-select class=\"vue-select1\" name=\"select1\"\n                    :options=\"options1\" :model.sync=\"result1\"\n                    language=\"\">\n        </vue-select>\n      </div>\n      <div class=\"col-sm-4\">\n        <p class=\"form-control-static\">\n          Selected Result: <span class=\"vue-result1\">{{result1}}</span>\n        </p>\n      </div>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"select2\" class=\"col-sm-3 control-label\">\n        A searchable select with names and localized in en-US:\n      </label>\n      <div class=\"col-sm-5\">\n        <vue-select class=\"vue-select2\" name=\"select2\"\n                :options=\"options2\" :model.sync=\"result2\"\n                :searchable=\"true\" language=\"en-US\">\n        </vue-select>\n      </div>\n      <div class=\"col-sm-4\">\n        <p class=\"form-control-static\">\n          Selected Result: <span class=\"vue-result2\">{{result2}}</span>\n        </p>\n      </div>\n    </div>\n    <div class=\"form-group\">\n      <label for=\"select3\" class=\"col-sm-3 control-label\">\n        A searchable select with groups and localized in zh-CN:\n      </label>\n      <div class=\"col-sm-5\">\n        <vue-select class=\"vue-select3\" name=\"select3\"\n                    :options=\"options3\" :model.sync=\"result3\"\n                    :searchable=\"true\" language=\"zh-CN\">\n        </vue-select>\n      </div>\n      <div class=\"col-sm-4\">\n        <p class=\"form-control-static\">\n          Selected Result: <span class=\"vue-result3\">{{result3}}</span>\n        </p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nmodule.exports = {\n  components: {\n    \"vue-select\": require(\"../src/vue-select.js\")\n  },\n  data: function() {\n    return {\n      options1: [\n        \"value1\",\n        \"value2\",\n        \"value3\"\n      ],\n      options2: [{\n        text: \"name1\",\n        value: \"value1\"\n      }, {\n        text: \"name2\",\n        value: \"value2\"\n      }, {\n        text: \"name3\",\n        value: \"value3\"\n      }],\n      options3: [{\n        label: \"group1\",\n        options: [{\n          text: \"name1\",\n          value: \"value1\"\n        }, {\n          text: \"name2\",\n          value: \"value2\"\n        }, {\n          text: \"name3\",\n          value: \"value3\"\n        }]\n      }, {\n        label: \"group2\",\n        options: [{\n          text: \"name4\",\n          value: \"value4\"\n        }, {\n          text: \"name5\",\n          value: \"value5\"\n        }, {\n          text: \"name6\",\n          value: \"value6\"\n        }]\n      }]\n    };\n  },\n  props: {\n    result1: {\n      required: true,\n      twoWay: true\n    },\n    result2: {\n      required: true,\n      twoWay: true\n    },\n    result3: {\n      required: true,\n      twoWay: true\n    }\n  }\n};\n</script>\n\n\n/** WEBPACK FOOTER **\n ** demo.vue?0ee77516\n **/","/**\n * The default language used by this component.\n */\nvar DEFAULT_LANGUAGE = \"en-US\";\n\n/**\n * A bootstrap style selection (combobox) control using the select2 plugin.\n *\n * @param options\n *    the array of options of the selection control. It could be an array of\n *    strings, e.g., \"['opt1', 'opt2']\"; or an array of objects specifying\n *    the text and value of each option, e.g.,\n *    \"[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]\";\n *    or it could be an array of objects specifying the option group, e.g.\n *    \"[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},\n *      {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]\".\n * @param model\n *    the model bind to the control, which must be a two way binding variable.\n * @param searchable\n *    the optional flag indicates whether to show the search box. Default value\n *    is false.\n * @param matchValue\n *    the optional flag indicates whether the searching should match both the\n *    texts and values of options. Default value is true.\n * @param language\n *    the optional code of language used by the select2 plugin. If it is not set,\n *    and the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin is used,\n *    the component will use the language code `$language` provided by the\n *    [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin; otherwise, the\n *    component will use the default value \"en-US\".\n * @param theme\n *    the optional name of the theme of the select2. Default value is \"bootstrap\".\n * @author Haixing Hu\n */\nmodule.exports = {\n  replace: true,\n  inherit: false,\n  template: \"<select class='form-control' v-model='model' style='width: 100%'>\"\n          +   \"<option v-if='optionsType === \\\"values\\\"' v-for='val in options' :value='val'>{{val}}</option>\"\n          +   \"<option v-if='optionsType === \\\"options\\\"' v-for='opt in options' :value='opt.value'>{{opt.text}}</option>\"\n          +   \"<optgroup v-if='optionsType === \\\"groups\\\"' v-for='group in options' :label='group.label'>\"\n          +     \"<option v-for='opt in group.options' :value='opt.value'>{{opt.text}}</option>\"\n          +   \"</optgroup>\"\n          + \"</select>\",\n  props: {\n    options: {\n      type: Array,\n      required: true\n    },\n    model: {\n      required: true,\n      twoWay: true\n    },\n    searchable: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    matchValue: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    language: {\n      type: String,\n      required: false,\n      default: \"\"\n    },\n    theme: {\n      type: String,\n      required: false,\n      default: \"bootstrap\"\n    }\n  },\n  data: function() {\n    return {\n      optionsType: \"unknown\"\n    }\n  },\n  beforeCompile: function() {\n    this.isChanging = false;\n    this.control = null;\n    this.optionsType = this.getOptionsType();\n  },\n  watch: {\n    \"options\": function(val, oldVal) {\n      //console.debug(\"options.change\");\n      this.optionsType = this.getOptionsType();\n      var found = this.inOptions(this.model);\n      var newValue = (found ? this.model : null);\n      this.control.removeData(\"data\");  // remove the cached options data\n      // note that setting the model will automatically changed in the \"change\"\n      // event of the select2 control\n      this.control.val(newValue).trigger(\"change\");\n    },\n    \"model\": function(val, oldVal) {\n      //console.debug(\"model.change\");\n      if (! this.isChanging) {\n        this.isChanging = true;\n        this.control.val(val).trigger(\"change\");\n        this.isChanging = false;\n      }\n    }\n  },\n  ready: function() {\n    var language = this.language;\n    if (language === null || language === \"\") {\n      if (this.$language) {\n        language = this.$language;\n      } else {\n        language = DEFAULT_LANGUAGE;\n      }\n    }\n    var args = {\n      theme: this.theme,\n      language: this.getLanguageCode(language)\n    };\n    if (! this.searchable) {\n      args.minimumResultsForSearch = Infinity;  // hide the search box\n    } else {\n      if (this.matchValue) {\n        args.matcher = require(\"./value-text-matcher.js\");\n      }\n    }\n    this.control = $(this.$el);\n    this.control.select2(args);\n    var me = this;\n    this.control.on(\"change\", function(e) {\n      //console.debug(\"control.change\");\n      if (! me.isChanging) {\n        me.isChanging = true;\n        me.model = me.control.val();\n        me.$nextTick(function () {\n          me.isChanging = false;\n        });\n      }\n    });\n  },\n  methods: {\n\n    /**\n     * Gets the type of the `options` property of this component.\n     *\n     * The `options` property of this component may have the following types:\n     * - \"values\": the `options` is an array of strings, e.g., `[value1, value2, value3]`;\n     * - \"options\": the `options` is an array of options, e.g., `[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]`;\n     * - \"groups\": the `options` is an array of option groups, e.g.,\n     *   `[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},\n     *     {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]`;\n     *\n     * @param options\n     *    the new options.\n     * @return\n     *    the string representing the type of the `options` property of this\n     *    component.\n     */\n    getOptionsType: function() {\n      if (this.options.length === 0) {\n        return \"values\";\n      }\n      var el = this.options[0];\n      if (typeof el == \"string\" || el instanceof String) {\n        return \"values\";\n      } else if (typeof el.text !== \"undefined\") {\n        return \"options\";\n      } else if (typeof el.label !== \"undefined\") {\n        return \"groups\";\n      } else {\n        return \"unknown\";\n      }\n    },\n\n    /**\n     * Tests whether a specified value exists in the options.\n     *\n     * @param value\n     *    the value to test.\n     * @return\n     *    true if the specified value exists in the options; false otherwise.\n     */\n    inOptions: function(value) {\n      var type = this.getOptionsType();\n      var list = this.options;\n      var i, j;\n      switch (type) {\n      case \"values\":\n        for (i = 0; i < list.length; ++i) {\n          if (value === list[i]) {\n            return true;\n          }\n        }\n        break;\n      case \"options\":\n        for (i = 0; i < list.length; ++i) {\n          if (value === list[i].value) {\n            return true;\n          }\n        }\n        break;\n      case \"groups\":\n        for (i = 0; i < list.length; ++i) {\n          var options = list[i].options;\n          for (j = 0; j < options.length; ++j) {\n            if (value === options[j].value) {\n              return true;\n            }\n          }\n        }\n        break;\n      default:\n        break;\n      }\n      return false;\n    },\n\n    /**\n     * Gets the language code from the \"language-country\" locale code.\n     *\n     * The function will strip the language code before the first \"-\" of a\n     * locale code. For example, pass \"en-US\" will returns \"en\". But for some\n     * special locales, the function reserves the locale code. For example,\n     * the \"zh-CN\" for the simplified Chinese and the \"zh-TW\" for the\n     * traditional Chinese.\n     *\n     * @param locale\n     *    A locale code.\n     * @return\n     *    the language code of the locale.\n     */\n    getLanguageCode: function(locale) {\n      if (locale === null || locale.length === 0) {\n        return \"en\";\n      }\n      if (locale.length <= 2) {\n        return locale;\n      } else {\n        switch (locale) {\n          case \"pt-BR\":\n          case \"zh-CN\":\n          case \"zh-TW\":\n            return locale;\n          default:\n            // reserve only the first two letters language code\n            return locale.substr(0, 2);\n        }\n      }\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vue-select.js\n ** module id = 5\n ** module chunks = 0\n **/","\nvar DIACRITICS = {\n  '\\u24B6': 'A',\n  '\\uFF21': 'A',\n  '\\u00C0': 'A',\n  '\\u00C1': 'A',\n  '\\u00C2': 'A',\n  '\\u1EA6': 'A',\n  '\\u1EA4': 'A',\n  '\\u1EAA': 'A',\n  '\\u1EA8': 'A',\n  '\\u00C3': 'A',\n  '\\u0100': 'A',\n  '\\u0102': 'A',\n  '\\u1EB0': 'A',\n  '\\u1EAE': 'A',\n  '\\u1EB4': 'A',\n  '\\u1EB2': 'A',\n  '\\u0226': 'A',\n  '\\u01E0': 'A',\n  '\\u00C4': 'A',\n  '\\u01DE': 'A',\n  '\\u1EA2': 'A',\n  '\\u00C5': 'A',\n  '\\u01FA': 'A',\n  '\\u01CD': 'A',\n  '\\u0200': 'A',\n  '\\u0202': 'A',\n  '\\u1EA0': 'A',\n  '\\u1EAC': 'A',\n  '\\u1EB6': 'A',\n  '\\u1E00': 'A',\n  '\\u0104': 'A',\n  '\\u023A': 'A',\n  '\\u2C6F': 'A',\n  '\\uA732': 'AA',\n  '\\u00C6': 'AE',\n  '\\u01FC': 'AE',\n  '\\u01E2': 'AE',\n  '\\uA734': 'AO',\n  '\\uA736': 'AU',\n  '\\uA738': 'AV',\n  '\\uA73A': 'AV',\n  '\\uA73C': 'AY',\n  '\\u24B7': 'B',\n  '\\uFF22': 'B',\n  '\\u1E02': 'B',\n  '\\u1E04': 'B',\n  '\\u1E06': 'B',\n  '\\u0243': 'B',\n  '\\u0182': 'B',\n  '\\u0181': 'B',\n  '\\u24B8': 'C',\n  '\\uFF23': 'C',\n  '\\u0106': 'C',\n  '\\u0108': 'C',\n  '\\u010A': 'C',\n  '\\u010C': 'C',\n  '\\u00C7': 'C',\n  '\\u1E08': 'C',\n  '\\u0187': 'C',\n  '\\u023B': 'C',\n  '\\uA73E': 'C',\n  '\\u24B9': 'D',\n  '\\uFF24': 'D',\n  '\\u1E0A': 'D',\n  '\\u010E': 'D',\n  '\\u1E0C': 'D',\n  '\\u1E10': 'D',\n  '\\u1E12': 'D',\n  '\\u1E0E': 'D',\n  '\\u0110': 'D',\n  '\\u018B': 'D',\n  '\\u018A': 'D',\n  '\\u0189': 'D',\n  '\\uA779': 'D',\n  '\\u01F1': 'DZ',\n  '\\u01C4': 'DZ',\n  '\\u01F2': 'Dz',\n  '\\u01C5': 'Dz',\n  '\\u24BA': 'E',\n  '\\uFF25': 'E',\n  '\\u00C8': 'E',\n  '\\u00C9': 'E',\n  '\\u00CA': 'E',\n  '\\u1EC0': 'E',\n  '\\u1EBE': 'E',\n  '\\u1EC4': 'E',\n  '\\u1EC2': 'E',\n  '\\u1EBC': 'E',\n  '\\u0112': 'E',\n  '\\u1E14': 'E',\n  '\\u1E16': 'E',\n  '\\u0114': 'E',\n  '\\u0116': 'E',\n  '\\u00CB': 'E',\n  '\\u1EBA': 'E',\n  '\\u011A': 'E',\n  '\\u0204': 'E',\n  '\\u0206': 'E',\n  '\\u1EB8': 'E',\n  '\\u1EC6': 'E',\n  '\\u0228': 'E',\n  '\\u1E1C': 'E',\n  '\\u0118': 'E',\n  '\\u1E18': 'E',\n  '\\u1E1A': 'E',\n  '\\u0190': 'E',\n  '\\u018E': 'E',\n  '\\u24BB': 'F',\n  '\\uFF26': 'F',\n  '\\u1E1E': 'F',\n  '\\u0191': 'F',\n  '\\uA77B': 'F',\n  '\\u24BC': 'G',\n  '\\uFF27': 'G',\n  '\\u01F4': 'G',\n  '\\u011C': 'G',\n  '\\u1E20': 'G',\n  '\\u011E': 'G',\n  '\\u0120': 'G',\n  '\\u01E6': 'G',\n  '\\u0122': 'G',\n  '\\u01E4': 'G',\n  '\\u0193': 'G',\n  '\\uA7A0': 'G',\n  '\\uA77D': 'G',\n  '\\uA77E': 'G',\n  '\\u24BD': 'H',\n  '\\uFF28': 'H',\n  '\\u0124': 'H',\n  '\\u1E22': 'H',\n  '\\u1E26': 'H',\n  '\\u021E': 'H',\n  '\\u1E24': 'H',\n  '\\u1E28': 'H',\n  '\\u1E2A': 'H',\n  '\\u0126': 'H',\n  '\\u2C67': 'H',\n  '\\u2C75': 'H',\n  '\\uA78D': 'H',\n  '\\u24BE': 'I',\n  '\\uFF29': 'I',\n  '\\u00CC': 'I',\n  '\\u00CD': 'I',\n  '\\u00CE': 'I',\n  '\\u0128': 'I',\n  '\\u012A': 'I',\n  '\\u012C': 'I',\n  '\\u0130': 'I',\n  '\\u00CF': 'I',\n  '\\u1E2E': 'I',\n  '\\u1EC8': 'I',\n  '\\u01CF': 'I',\n  '\\u0208': 'I',\n  '\\u020A': 'I',\n  '\\u1ECA': 'I',\n  '\\u012E': 'I',\n  '\\u1E2C': 'I',\n  '\\u0197': 'I',\n  '\\u24BF': 'J',\n  '\\uFF2A': 'J',\n  '\\u0134': 'J',\n  '\\u0248': 'J',\n  '\\u24C0': 'K',\n  '\\uFF2B': 'K',\n  '\\u1E30': 'K',\n  '\\u01E8': 'K',\n  '\\u1E32': 'K',\n  '\\u0136': 'K',\n  '\\u1E34': 'K',\n  '\\u0198': 'K',\n  '\\u2C69': 'K',\n  '\\uA740': 'K',\n  '\\uA742': 'K',\n  '\\uA744': 'K',\n  '\\uA7A2': 'K',\n  '\\u24C1': 'L',\n  '\\uFF2C': 'L',\n  '\\u013F': 'L',\n  '\\u0139': 'L',\n  '\\u013D': 'L',\n  '\\u1E36': 'L',\n  '\\u1E38': 'L',\n  '\\u013B': 'L',\n  '\\u1E3C': 'L',\n  '\\u1E3A': 'L',\n  '\\u0141': 'L',\n  '\\u023D': 'L',\n  '\\u2C62': 'L',\n  '\\u2C60': 'L',\n  '\\uA748': 'L',\n  '\\uA746': 'L',\n  '\\uA780': 'L',\n  '\\u01C7': 'LJ',\n  '\\u01C8': 'Lj',\n  '\\u24C2': 'M',\n  '\\uFF2D': 'M',\n  '\\u1E3E': 'M',\n  '\\u1E40': 'M',\n  '\\u1E42': 'M',\n  '\\u2C6E': 'M',\n  '\\u019C': 'M',\n  '\\u24C3': 'N',\n  '\\uFF2E': 'N',\n  '\\u01F8': 'N',\n  '\\u0143': 'N',\n  '\\u00D1': 'N',\n  '\\u1E44': 'N',\n  '\\u0147': 'N',\n  '\\u1E46': 'N',\n  '\\u0145': 'N',\n  '\\u1E4A': 'N',\n  '\\u1E48': 'N',\n  '\\u0220': 'N',\n  '\\u019D': 'N',\n  '\\uA790': 'N',\n  '\\uA7A4': 'N',\n  '\\u01CA': 'NJ',\n  '\\u01CB': 'Nj',\n  '\\u24C4': 'O',\n  '\\uFF2F': 'O',\n  '\\u00D2': 'O',\n  '\\u00D3': 'O',\n  '\\u00D4': 'O',\n  '\\u1ED2': 'O',\n  '\\u1ED0': 'O',\n  '\\u1ED6': 'O',\n  '\\u1ED4': 'O',\n  '\\u00D5': 'O',\n  '\\u1E4C': 'O',\n  '\\u022C': 'O',\n  '\\u1E4E': 'O',\n  '\\u014C': 'O',\n  '\\u1E50': 'O',\n  '\\u1E52': 'O',\n  '\\u014E': 'O',\n  '\\u022E': 'O',\n  '\\u0230': 'O',\n  '\\u00D6': 'O',\n  '\\u022A': 'O',\n  '\\u1ECE': 'O',\n  '\\u0150': 'O',\n  '\\u01D1': 'O',\n  '\\u020C': 'O',\n  '\\u020E': 'O',\n  '\\u01A0': 'O',\n  '\\u1EDC': 'O',\n  '\\u1EDA': 'O',\n  '\\u1EE0': 'O',\n  '\\u1EDE': 'O',\n  '\\u1EE2': 'O',\n  '\\u1ECC': 'O',\n  '\\u1ED8': 'O',\n  '\\u01EA': 'O',\n  '\\u01EC': 'O',\n  '\\u00D8': 'O',\n  '\\u01FE': 'O',\n  '\\u0186': 'O',\n  '\\u019F': 'O',\n  '\\uA74A': 'O',\n  '\\uA74C': 'O',\n  '\\u01A2': 'OI',\n  '\\uA74E': 'OO',\n  '\\u0222': 'OU',\n  '\\u24C5': 'P',\n  '\\uFF30': 'P',\n  '\\u1E54': 'P',\n  '\\u1E56': 'P',\n  '\\u01A4': 'P',\n  '\\u2C63': 'P',\n  '\\uA750': 'P',\n  '\\uA752': 'P',\n  '\\uA754': 'P',\n  '\\u24C6': 'Q',\n  '\\uFF31': 'Q',\n  '\\uA756': 'Q',\n  '\\uA758': 'Q',\n  '\\u024A': 'Q',\n  '\\u24C7': 'R',\n  '\\uFF32': 'R',\n  '\\u0154': 'R',\n  '\\u1E58': 'R',\n  '\\u0158': 'R',\n  '\\u0210': 'R',\n  '\\u0212': 'R',\n  '\\u1E5A': 'R',\n  '\\u1E5C': 'R',\n  '\\u0156': 'R',\n  '\\u1E5E': 'R',\n  '\\u024C': 'R',\n  '\\u2C64': 'R',\n  '\\uA75A': 'R',\n  '\\uA7A6': 'R',\n  '\\uA782': 'R',\n  '\\u24C8': 'S',\n  '\\uFF33': 'S',\n  '\\u1E9E': 'S',\n  '\\u015A': 'S',\n  '\\u1E64': 'S',\n  '\\u015C': 'S',\n  '\\u1E60': 'S',\n  '\\u0160': 'S',\n  '\\u1E66': 'S',\n  '\\u1E62': 'S',\n  '\\u1E68': 'S',\n  '\\u0218': 'S',\n  '\\u015E': 'S',\n  '\\u2C7E': 'S',\n  '\\uA7A8': 'S',\n  '\\uA784': 'S',\n  '\\u24C9': 'T',\n  '\\uFF34': 'T',\n  '\\u1E6A': 'T',\n  '\\u0164': 'T',\n  '\\u1E6C': 'T',\n  '\\u021A': 'T',\n  '\\u0162': 'T',\n  '\\u1E70': 'T',\n  '\\u1E6E': 'T',\n  '\\u0166': 'T',\n  '\\u01AC': 'T',\n  '\\u01AE': 'T',\n  '\\u023E': 'T',\n  '\\uA786': 'T',\n  '\\uA728': 'TZ',\n  '\\u24CA': 'U',\n  '\\uFF35': 'U',\n  '\\u00D9': 'U',\n  '\\u00DA': 'U',\n  '\\u00DB': 'U',\n  '\\u0168': 'U',\n  '\\u1E78': 'U',\n  '\\u016A': 'U',\n  '\\u1E7A': 'U',\n  '\\u016C': 'U',\n  '\\u00DC': 'U',\n  '\\u01DB': 'U',\n  '\\u01D7': 'U',\n  '\\u01D5': 'U',\n  '\\u01D9': 'U',\n  '\\u1EE6': 'U',\n  '\\u016E': 'U',\n  '\\u0170': 'U',\n  '\\u01D3': 'U',\n  '\\u0214': 'U',\n  '\\u0216': 'U',\n  '\\u01AF': 'U',\n  '\\u1EEA': 'U',\n  '\\u1EE8': 'U',\n  '\\u1EEE': 'U',\n  '\\u1EEC': 'U',\n  '\\u1EF0': 'U',\n  '\\u1EE4': 'U',\n  '\\u1E72': 'U',\n  '\\u0172': 'U',\n  '\\u1E76': 'U',\n  '\\u1E74': 'U',\n  '\\u0244': 'U',\n  '\\u24CB': 'V',\n  '\\uFF36': 'V',\n  '\\u1E7C': 'V',\n  '\\u1E7E': 'V',\n  '\\u01B2': 'V',\n  '\\uA75E': 'V',\n  '\\u0245': 'V',\n  '\\uA760': 'VY',\n  '\\u24CC': 'W',\n  '\\uFF37': 'W',\n  '\\u1E80': 'W',\n  '\\u1E82': 'W',\n  '\\u0174': 'W',\n  '\\u1E86': 'W',\n  '\\u1E84': 'W',\n  '\\u1E88': 'W',\n  '\\u2C72': 'W',\n  '\\u24CD': 'X',\n  '\\uFF38': 'X',\n  '\\u1E8A': 'X',\n  '\\u1E8C': 'X',\n  '\\u24CE': 'Y',\n  '\\uFF39': 'Y',\n  '\\u1EF2': 'Y',\n  '\\u00DD': 'Y',\n  '\\u0176': 'Y',\n  '\\u1EF8': 'Y',\n  '\\u0232': 'Y',\n  '\\u1E8E': 'Y',\n  '\\u0178': 'Y',\n  '\\u1EF6': 'Y',\n  '\\u1EF4': 'Y',\n  '\\u01B3': 'Y',\n  '\\u024E': 'Y',\n  '\\u1EFE': 'Y',\n  '\\u24CF': 'Z',\n  '\\uFF3A': 'Z',\n  '\\u0179': 'Z',\n  '\\u1E90': 'Z',\n  '\\u017B': 'Z',\n  '\\u017D': 'Z',\n  '\\u1E92': 'Z',\n  '\\u1E94': 'Z',\n  '\\u01B5': 'Z',\n  '\\u0224': 'Z',\n  '\\u2C7F': 'Z',\n  '\\u2C6B': 'Z',\n  '\\uA762': 'Z',\n  '\\u24D0': 'a',\n  '\\uFF41': 'a',\n  '\\u1E9A': 'a',\n  '\\u00E0': 'a',\n  '\\u00E1': 'a',\n  '\\u00E2': 'a',\n  '\\u1EA7': 'a',\n  '\\u1EA5': 'a',\n  '\\u1EAB': 'a',\n  '\\u1EA9': 'a',\n  '\\u00E3': 'a',\n  '\\u0101': 'a',\n  '\\u0103': 'a',\n  '\\u1EB1': 'a',\n  '\\u1EAF': 'a',\n  '\\u1EB5': 'a',\n  '\\u1EB3': 'a',\n  '\\u0227': 'a',\n  '\\u01E1': 'a',\n  '\\u00E4': 'a',\n  '\\u01DF': 'a',\n  '\\u1EA3': 'a',\n  '\\u00E5': 'a',\n  '\\u01FB': 'a',\n  '\\u01CE': 'a',\n  '\\u0201': 'a',\n  '\\u0203': 'a',\n  '\\u1EA1': 'a',\n  '\\u1EAD': 'a',\n  '\\u1EB7': 'a',\n  '\\u1E01': 'a',\n  '\\u0105': 'a',\n  '\\u2C65': 'a',\n  '\\u0250': 'a',\n  '\\uA733': 'aa',\n  '\\u00E6': 'ae',\n  '\\u01FD': 'ae',\n  '\\u01E3': 'ae',\n  '\\uA735': 'ao',\n  '\\uA737': 'au',\n  '\\uA739': 'av',\n  '\\uA73B': 'av',\n  '\\uA73D': 'ay',\n  '\\u24D1': 'b',\n  '\\uFF42': 'b',\n  '\\u1E03': 'b',\n  '\\u1E05': 'b',\n  '\\u1E07': 'b',\n  '\\u0180': 'b',\n  '\\u0183': 'b',\n  '\\u0253': 'b',\n  '\\u24D2': 'c',\n  '\\uFF43': 'c',\n  '\\u0107': 'c',\n  '\\u0109': 'c',\n  '\\u010B': 'c',\n  '\\u010D': 'c',\n  '\\u00E7': 'c',\n  '\\u1E09': 'c',\n  '\\u0188': 'c',\n  '\\u023C': 'c',\n  '\\uA73F': 'c',\n  '\\u2184': 'c',\n  '\\u24D3': 'd',\n  '\\uFF44': 'd',\n  '\\u1E0B': 'd',\n  '\\u010F': 'd',\n  '\\u1E0D': 'd',\n  '\\u1E11': 'd',\n  '\\u1E13': 'd',\n  '\\u1E0F': 'd',\n  '\\u0111': 'd',\n  '\\u018C': 'd',\n  '\\u0256': 'd',\n  '\\u0257': 'd',\n  '\\uA77A': 'd',\n  '\\u01F3': 'dz',\n  '\\u01C6': 'dz',\n  '\\u24D4': 'e',\n  '\\uFF45': 'e',\n  '\\u00E8': 'e',\n  '\\u00E9': 'e',\n  '\\u00EA': 'e',\n  '\\u1EC1': 'e',\n  '\\u1EBF': 'e',\n  '\\u1EC5': 'e',\n  '\\u1EC3': 'e',\n  '\\u1EBD': 'e',\n  '\\u0113': 'e',\n  '\\u1E15': 'e',\n  '\\u1E17': 'e',\n  '\\u0115': 'e',\n  '\\u0117': 'e',\n  '\\u00EB': 'e',\n  '\\u1EBB': 'e',\n  '\\u011B': 'e',\n  '\\u0205': 'e',\n  '\\u0207': 'e',\n  '\\u1EB9': 'e',\n  '\\u1EC7': 'e',\n  '\\u0229': 'e',\n  '\\u1E1D': 'e',\n  '\\u0119': 'e',\n  '\\u1E19': 'e',\n  '\\u1E1B': 'e',\n  '\\u0247': 'e',\n  '\\u025B': 'e',\n  '\\u01DD': 'e',\n  '\\u24D5': 'f',\n  '\\uFF46': 'f',\n  '\\u1E1F': 'f',\n  '\\u0192': 'f',\n  '\\uA77C': 'f',\n  '\\u24D6': 'g',\n  '\\uFF47': 'g',\n  '\\u01F5': 'g',\n  '\\u011D': 'g',\n  '\\u1E21': 'g',\n  '\\u011F': 'g',\n  '\\u0121': 'g',\n  '\\u01E7': 'g',\n  '\\u0123': 'g',\n  '\\u01E5': 'g',\n  '\\u0260': 'g',\n  '\\uA7A1': 'g',\n  '\\u1D79': 'g',\n  '\\uA77F': 'g',\n  '\\u24D7': 'h',\n  '\\uFF48': 'h',\n  '\\u0125': 'h',\n  '\\u1E23': 'h',\n  '\\u1E27': 'h',\n  '\\u021F': 'h',\n  '\\u1E25': 'h',\n  '\\u1E29': 'h',\n  '\\u1E2B': 'h',\n  '\\u1E96': 'h',\n  '\\u0127': 'h',\n  '\\u2C68': 'h',\n  '\\u2C76': 'h',\n  '\\u0265': 'h',\n  '\\u0195': 'hv',\n  '\\u24D8': 'i',\n  '\\uFF49': 'i',\n  '\\u00EC': 'i',\n  '\\u00ED': 'i',\n  '\\u00EE': 'i',\n  '\\u0129': 'i',\n  '\\u012B': 'i',\n  '\\u012D': 'i',\n  '\\u00EF': 'i',\n  '\\u1E2F': 'i',\n  '\\u1EC9': 'i',\n  '\\u01D0': 'i',\n  '\\u0209': 'i',\n  '\\u020B': 'i',\n  '\\u1ECB': 'i',\n  '\\u012F': 'i',\n  '\\u1E2D': 'i',\n  '\\u0268': 'i',\n  '\\u0131': 'i',\n  '\\u24D9': 'j',\n  '\\uFF4A': 'j',\n  '\\u0135': 'j',\n  '\\u01F0': 'j',\n  '\\u0249': 'j',\n  '\\u24DA': 'k',\n  '\\uFF4B': 'k',\n  '\\u1E31': 'k',\n  '\\u01E9': 'k',\n  '\\u1E33': 'k',\n  '\\u0137': 'k',\n  '\\u1E35': 'k',\n  '\\u0199': 'k',\n  '\\u2C6A': 'k',\n  '\\uA741': 'k',\n  '\\uA743': 'k',\n  '\\uA745': 'k',\n  '\\uA7A3': 'k',\n  '\\u24DB': 'l',\n  '\\uFF4C': 'l',\n  '\\u0140': 'l',\n  '\\u013A': 'l',\n  '\\u013E': 'l',\n  '\\u1E37': 'l',\n  '\\u1E39': 'l',\n  '\\u013C': 'l',\n  '\\u1E3D': 'l',\n  '\\u1E3B': 'l',\n  '\\u017F': 'l',\n  '\\u0142': 'l',\n  '\\u019A': 'l',\n  '\\u026B': 'l',\n  '\\u2C61': 'l',\n  '\\uA749': 'l',\n  '\\uA781': 'l',\n  '\\uA747': 'l',\n  '\\u01C9': 'lj',\n  '\\u24DC': 'm',\n  '\\uFF4D': 'm',\n  '\\u1E3F': 'm',\n  '\\u1E41': 'm',\n  '\\u1E43': 'm',\n  '\\u0271': 'm',\n  '\\u026F': 'm',\n  '\\u24DD': 'n',\n  '\\uFF4E': 'n',\n  '\\u01F9': 'n',\n  '\\u0144': 'n',\n  '\\u00F1': 'n',\n  '\\u1E45': 'n',\n  '\\u0148': 'n',\n  '\\u1E47': 'n',\n  '\\u0146': 'n',\n  '\\u1E4B': 'n',\n  '\\u1E49': 'n',\n  '\\u019E': 'n',\n  '\\u0272': 'n',\n  '\\u0149': 'n',\n  '\\uA791': 'n',\n  '\\uA7A5': 'n',\n  '\\u01CC': 'nj',\n  '\\u24DE': 'o',\n  '\\uFF4F': 'o',\n  '\\u00F2': 'o',\n  '\\u00F3': 'o',\n  '\\u00F4': 'o',\n  '\\u1ED3': 'o',\n  '\\u1ED1': 'o',\n  '\\u1ED7': 'o',\n  '\\u1ED5': 'o',\n  '\\u00F5': 'o',\n  '\\u1E4D': 'o',\n  '\\u022D': 'o',\n  '\\u1E4F': 'o',\n  '\\u014D': 'o',\n  '\\u1E51': 'o',\n  '\\u1E53': 'o',\n  '\\u014F': 'o',\n  '\\u022F': 'o',\n  '\\u0231': 'o',\n  '\\u00F6': 'o',\n  '\\u022B': 'o',\n  '\\u1ECF': 'o',\n  '\\u0151': 'o',\n  '\\u01D2': 'o',\n  '\\u020D': 'o',\n  '\\u020F': 'o',\n  '\\u01A1': 'o',\n  '\\u1EDD': 'o',\n  '\\u1EDB': 'o',\n  '\\u1EE1': 'o',\n  '\\u1EDF': 'o',\n  '\\u1EE3': 'o',\n  '\\u1ECD': 'o',\n  '\\u1ED9': 'o',\n  '\\u01EB': 'o',\n  '\\u01ED': 'o',\n  '\\u00F8': 'o',\n  '\\u01FF': 'o',\n  '\\u0254': 'o',\n  '\\uA74B': 'o',\n  '\\uA74D': 'o',\n  '\\u0275': 'o',\n  '\\u01A3': 'oi',\n  '\\u0223': 'ou',\n  '\\uA74F': 'oo',\n  '\\u24DF': 'p',\n  '\\uFF50': 'p',\n  '\\u1E55': 'p',\n  '\\u1E57': 'p',\n  '\\u01A5': 'p',\n  '\\u1D7D': 'p',\n  '\\uA751': 'p',\n  '\\uA753': 'p',\n  '\\uA755': 'p',\n  '\\u24E0': 'q',\n  '\\uFF51': 'q',\n  '\\u024B': 'q',\n  '\\uA757': 'q',\n  '\\uA759': 'q',\n  '\\u24E1': 'r',\n  '\\uFF52': 'r',\n  '\\u0155': 'r',\n  '\\u1E59': 'r',\n  '\\u0159': 'r',\n  '\\u0211': 'r',\n  '\\u0213': 'r',\n  '\\u1E5B': 'r',\n  '\\u1E5D': 'r',\n  '\\u0157': 'r',\n  '\\u1E5F': 'r',\n  '\\u024D': 'r',\n  '\\u027D': 'r',\n  '\\uA75B': 'r',\n  '\\uA7A7': 'r',\n  '\\uA783': 'r',\n  '\\u24E2': 's',\n  '\\uFF53': 's',\n  '\\u00DF': 's',\n  '\\u015B': 's',\n  '\\u1E65': 's',\n  '\\u015D': 's',\n  '\\u1E61': 's',\n  '\\u0161': 's',\n  '\\u1E67': 's',\n  '\\u1E63': 's',\n  '\\u1E69': 's',\n  '\\u0219': 's',\n  '\\u015F': 's',\n  '\\u023F': 's',\n  '\\uA7A9': 's',\n  '\\uA785': 's',\n  '\\u1E9B': 's',\n  '\\u24E3': 't',\n  '\\uFF54': 't',\n  '\\u1E6B': 't',\n  '\\u1E97': 't',\n  '\\u0165': 't',\n  '\\u1E6D': 't',\n  '\\u021B': 't',\n  '\\u0163': 't',\n  '\\u1E71': 't',\n  '\\u1E6F': 't',\n  '\\u0167': 't',\n  '\\u01AD': 't',\n  '\\u0288': 't',\n  '\\u2C66': 't',\n  '\\uA787': 't',\n  '\\uA729': 'tz',\n  '\\u24E4': 'u',\n  '\\uFF55': 'u',\n  '\\u00F9': 'u',\n  '\\u00FA': 'u',\n  '\\u00FB': 'u',\n  '\\u0169': 'u',\n  '\\u1E79': 'u',\n  '\\u016B': 'u',\n  '\\u1E7B': 'u',\n  '\\u016D': 'u',\n  '\\u00FC': 'u',\n  '\\u01DC': 'u',\n  '\\u01D8': 'u',\n  '\\u01D6': 'u',\n  '\\u01DA': 'u',\n  '\\u1EE7': 'u',\n  '\\u016F': 'u',\n  '\\u0171': 'u',\n  '\\u01D4': 'u',\n  '\\u0215': 'u',\n  '\\u0217': 'u',\n  '\\u01B0': 'u',\n  '\\u1EEB': 'u',\n  '\\u1EE9': 'u',\n  '\\u1EEF': 'u',\n  '\\u1EED': 'u',\n  '\\u1EF1': 'u',\n  '\\u1EE5': 'u',\n  '\\u1E73': 'u',\n  '\\u0173': 'u',\n  '\\u1E77': 'u',\n  '\\u1E75': 'u',\n  '\\u0289': 'u',\n  '\\u24E5': 'v',\n  '\\uFF56': 'v',\n  '\\u1E7D': 'v',\n  '\\u1E7F': 'v',\n  '\\u028B': 'v',\n  '\\uA75F': 'v',\n  '\\u028C': 'v',\n  '\\uA761': 'vy',\n  '\\u24E6': 'w',\n  '\\uFF57': 'w',\n  '\\u1E81': 'w',\n  '\\u1E83': 'w',\n  '\\u0175': 'w',\n  '\\u1E87': 'w',\n  '\\u1E85': 'w',\n  '\\u1E98': 'w',\n  '\\u1E89': 'w',\n  '\\u2C73': 'w',\n  '\\u24E7': 'x',\n  '\\uFF58': 'x',\n  '\\u1E8B': 'x',\n  '\\u1E8D': 'x',\n  '\\u24E8': 'y',\n  '\\uFF59': 'y',\n  '\\u1EF3': 'y',\n  '\\u00FD': 'y',\n  '\\u0177': 'y',\n  '\\u1EF9': 'y',\n  '\\u0233': 'y',\n  '\\u1E8F': 'y',\n  '\\u00FF': 'y',\n  '\\u1EF7': 'y',\n  '\\u1E99': 'y',\n  '\\u1EF5': 'y',\n  '\\u01B4': 'y',\n  '\\u024F': 'y',\n  '\\u1EFF': 'y',\n  '\\u24E9': 'z',\n  '\\uFF5A': 'z',\n  '\\u017A': 'z',\n  '\\u1E91': 'z',\n  '\\u017C': 'z',\n  '\\u017E': 'z',\n  '\\u1E93': 'z',\n  '\\u1E95': 'z',\n  '\\u01B6': 'z',\n  '\\u0225': 'z',\n  '\\u0240': 'z',\n  '\\u2C6C': 'z',\n  '\\uA763': 'z',\n  '\\u0386': '\\u0391',\n  '\\u0388': '\\u0395',\n  '\\u0389': '\\u0397',\n  '\\u038A': '\\u0399',\n  '\\u03AA': '\\u0399',\n  '\\u038C': '\\u039F',\n  '\\u038E': '\\u03A5',\n  '\\u03AB': '\\u03A5',\n  '\\u038F': '\\u03A9',\n  '\\u03AC': '\\u03B1',\n  '\\u03AD': '\\u03B5',\n  '\\u03AE': '\\u03B7',\n  '\\u03AF': '\\u03B9',\n  '\\u03CA': '\\u03B9',\n  '\\u0390': '\\u03B9',\n  '\\u03CC': '\\u03BF',\n  '\\u03CD': '\\u03C5',\n  '\\u03CB': '\\u03C5',\n  '\\u03B0': '\\u03C5',\n  '\\u03C9': '\\u03C9',\n  '\\u03C2': '\\u03C3'\n};\n\n\nfunction stripDiacritics (text) {\n  // Used 'uni range + named function' from http://jsperf.com/diacritics/18\n  function match(a) {\n    return DIACRITICS[a] || a;\n  }\n  return text.replace(/[^\\u0000-\\u007E]/g, match);\n}\n\n// The following matcher is a modification version of the default matcher\n// of select2\nmodule.exports = matcher = function(params, data) {\n  // Always return the object if there is nothing to compare\n  if ($.trim(params.term) === '') {\n    return data;\n  }\n\n  // Do a recursive check for options with children\n  if (data.children && data.children.length > 0) {\n    // Clone the data object if there are children\n    // This is required as we modify the object to remove any non-matches\n    var match = $.extend(true, {}, data);\n\n    // Check each child of the option\n    for (var c = data.children.length - 1; c >= 0; c--) {\n      var child = data.children[c];\n\n      var matches = matcher(params, child);\n\n      // If there wasn't a match, remove the object in the array\n      if (matches == null) {\n        match.children.splice(c, 1);\n      }\n    }\n\n    // If any children matched, return the new object\n    if (match.children.length > 0) {\n      return match;\n    }\n\n    // If there were no matching children, check just the plain object\n    return matcher(params, match);\n  }\n\n  var original = stripDiacritics(data.text).toUpperCase();\n  var term = stripDiacritics(params.term).toUpperCase();\n\n  // Check if the text contains the term\n  if (original.indexOf(term) > -1) {\n    return data;\n  }\n\n  // add by Haixing Hu: also match the value of an option\n  if (data.id) {\n    var originalValue = stripDiacritics(data.id).toUpperCase();\n    if (originalValue.indexOf(term) > -1) {\n      return data;\n    }\n  }\n\n  // If it doesn't contain the term, don't return anything\n  return null;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/value-text-matcher.js\n ** module id = 6\n ** module chunks = 0\n **/","module.exports = \"\\n<div class=\\\"form-horizontal\\\">\\n  <div class=\\\"form-group\\\">\\n    <label for=\\\"select1\\\" class=\\\"col-sm-3 control-label\\\">\\n      A simple select:\\n    </label>\\n    <div class=\\\"col-sm-5\\\">\\n      <vue-select class=\\\"vue-select1\\\" name=\\\"select1\\\"\\n                  :options=\\\"options1\\\" :model.sync=\\\"result1\\\"\\n                  language=\\\"\\\">\\n      </vue-select>\\n    </div>\\n    <div class=\\\"col-sm-4\\\">\\n      <p class=\\\"form-control-static\\\">\\n        Selected Result: <span class=\\\"vue-result1\\\">{{result1}}</span>\\n      </p>\\n    </div>\\n  </div>\\n  <div class=\\\"form-group\\\">\\n    <label for=\\\"select2\\\" class=\\\"col-sm-3 control-label\\\">\\n      A searchable select with names and localized in en-US:\\n    </label>\\n    <div class=\\\"col-sm-5\\\">\\n      <vue-select class=\\\"vue-select2\\\" name=\\\"select2\\\"\\n              :options=\\\"options2\\\" :model.sync=\\\"result2\\\"\\n              :searchable=\\\"true\\\" language=\\\"en-US\\\">\\n      </vue-select>\\n    </div>\\n    <div class=\\\"col-sm-4\\\">\\n      <p class=\\\"form-control-static\\\">\\n        Selected Result: <span class=\\\"vue-result2\\\">{{result2}}</span>\\n      </p>\\n    </div>\\n  </div>\\n  <div class=\\\"form-group\\\">\\n    <label for=\\\"select3\\\" class=\\\"col-sm-3 control-label\\\">\\n      A searchable select with groups and localized in zh-CN:\\n    </label>\\n    <div class=\\\"col-sm-5\\\">\\n      <vue-select class=\\\"vue-select3\\\" name=\\\"select3\\\"\\n                  :options=\\\"options3\\\" :model.sync=\\\"result3\\\"\\n                  :searchable=\\\"true\\\" language=\\\"zh-CN\\\">\\n      </vue-select>\\n    </div>\\n    <div class=\\\"col-sm-4\\\">\\n      <p class=\\\"form-control-static\\\">\\n        Selected Result: <span class=\\\"vue-result3\\\">{{result3}}</span>\\n      </p>\\n    </div>\\n  </div>\\n</div>\\n\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/raw-loader!./~/vue-loader/lib/selector.js?type=template&index=0!./demo/demo.vue\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":""}
\ No newline at end of file
Index: public/node_modules/vue/src/platforms/weex/util/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/util/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/util/index.js	(revision )
@@ -0,0 +1,20 @@
+/* globals renderer */
+
+import { makeMap } from 'shared/util'
+
+export const isReservedTag = makeMap(
+  'div,img,image,input,switch,indicator,list,scroller,cell,template,text,slider,image'
+)
+
+export function isUnaryTag () { /* console.log('isUnaryTag') */ }
+export function mustUseProp () { /* console.log('mustUseProp') */ }
+export function getTagNamespace () { /* console.log('getTagNamespace') */ }
+export function isUnknownElement () { /* console.log('isUnknownElement') */ }
+
+export function query (el, document) {
+  // renderer is injected by weex factory wrapper
+  const placeholder = new renderer.Comment('root')
+  placeholder.hasAttribute = placeholder.removeAttribute = function () {} // hack for patch
+  document.documentElement.appendChild(placeholder)
+  return placeholder
+}
Index: public/node_modules/vue-resource/test/data/text.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/data/text.txt	(revision )
+++ public/node_modules/vue-resource/test/data/text.txt	(revision )
@@ -0,0 +1,1 @@
+text
\ No newline at end of file
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/package.json	(revision )
@@ -0,0 +1,41 @@
+{
+  "name": "is-retry-allowed",
+  "version": "1.1.0",
+  "description": "My prime module",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/floatdrop/is-retry-allowed"
+  },
+  "author": {
+    "name": "Vsevolod Strukchinsky",
+    "email": "floatdrop@gmail.com",
+    "url": "github.com/floatdrop"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "xo && ava"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [],
+  "dependencies": {},
+  "devDependencies": {
+    "ava": "^0.8.0",
+    "xo": "^0.12.1"
+  },
+  "readme": "# is-retry-allowed [![Build Status](https://travis-ci.org/floatdrop/is-retry-allowed.svg?branch=master)](https://travis-ci.org/floatdrop/is-retry-allowed)\n\nIs retry allowed for Error?\n\n\n## Install\n\n```\n$ npm install --save is-retry-allowed\n```\n\n\n## Usage\n\n```js\nconst isRetryAllowed = require('is-retry-allowed');\n\nisRetryAllowed({code: 'ETIMEDOUT'});\n//=> true\n\nisRetryAllowed({code: 'ENOTFOUND'});\n//=> false\n\nisRetryAllowed({});\n//=> true\n```\n\n\n## API\n\n### isRetryAllowed(error)\n\n#### error\n\nType: `object`\n\nObject with `code` property, which will be used to determine retry.\n\n\n## License\n\nMIT  [Vsevolod Strukchinsky](http://github.com/floatdrop)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/floatdrop/is-retry-allowed/issues"
+  },
+  "_id": "is-retry-allowed@1.1.0",
+  "dist": {
+    "shasum": "a2675798f28af3c4f64027d34ed89baf0efe2bec"
+  },
+  "_from": "is-retry-allowed@^1.0.0",
+  "_resolved": "https://registry.npmjs.org/is-retry-allowed/-/is-retry-allowed-1.1.0.tgz"
+}
Index: public/node_modules/vue-resource/src/http/client/xhr.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/client/xhr.js	(revision )
+++ public/node_modules/vue-resource/src/http/client/xhr.js	(revision )
@@ -0,0 +1,67 @@
+/**
+ * XMLHttp client (Browser).
+ */
+
+import Promise from '../../promise';
+import { each, trim } from '../../util';
+
+const SUPPORTS_BLOB = typeof Blob !== 'undefined' && typeof FileReader !== 'undefined';
+
+export default function (request) {
+    return new Promise(resolve => {
+
+        var xhr = new XMLHttpRequest(), handler = (event) => {
+
+            var response = request.respondWith(
+                'response' in xhr ? xhr.response : xhr.responseText, {
+                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
+                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
+                }
+            );
+
+            each(trim(xhr.getAllResponseHeaders()).split('\n'), row => {
+                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
+            });
+
+            resolve(response);
+        };
+
+        request.abort = () => xhr.abort();
+
+        if (request.progress) {
+            if (request.method === 'GET') {
+                xhr.addEventListener('progress', request.progress);
+            } else if (/^(POST|PUT)$/i.test(request.method)) {
+                xhr.upload.addEventListener('progress', request.progress);
+            }
+        }
+
+        xhr.open(request.method, request.getUrl(), true);
+
+        if (request.timeout) {
+            xhr.timeout = request.timeout;
+        }
+
+        if (request.credentials === true) {
+            xhr.withCredentials = true;
+        }
+
+        if (!request.crossOrigin) {
+            request.headers.set('X-Requested-With', 'XMLHttpRequest');
+        }
+
+        if ('responseType' in xhr && SUPPORTS_BLOB) {
+            xhr.responseType = 'blob';
+        }
+
+        request.headers.forEach((value, name) => {
+            xhr.setRequestHeader(name, value);
+        });
+
+        xhr.onload = handler;
+        xhr.onabort = handler;
+        xhr.onerror = handler;
+        xhr.ontimeout = handler;
+        xhr.send(request.getBody());
+    });
+}
Index: public/node_modules/vue/src/platforms/weex/runtime/components/transition-group.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/components/transition-group.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/components/transition-group.js	(revision )
@@ -0,0 +1,148 @@
+import { warn, extend } from 'core/util/index'
+import { transitionProps, extractTransitionData } from './transition'
+
+const props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps)
+
+delete props.mode
+
+export default {
+  props,
+
+  created () {
+    const dom = this.$requireWeexModule('dom')
+    this.getPosition = el => new Promise((resolve, reject) => {
+      dom.getComponentRect(el.ref, res => {
+        if (!res.result) {
+          reject(new Error(`failed to get rect for element: ${el.tag}`))
+        } else {
+          resolve(res.size)
+        }
+      })
+    })
+
+    const animation = this.$requireWeexModule('animation')
+    this.animate = (el, options) => new Promise(resolve => {
+      animation.transition(el.ref, options, resolve)
+    })
+  },
+
+  render (h) {
+    const tag = this.tag || this.$vnode.data.tag || 'span'
+    const map = Object.create(null)
+    const prevChildren = this.prevChildren = this.children
+    const rawChildren = this.$slots.default || []
+    const children = this.children = []
+    const transitionData = extractTransitionData(this)
+
+    for (let i = 0; i < rawChildren.length; i++) {
+      const c = rawChildren[i]
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c)
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData
+        } else if (process.env.NODE_ENV !== 'production') {
+          const opts = c.componentOptions
+          const name = opts
+            ? (opts.Ctor.options.name || opts.tag)
+            : c.tag
+          warn(`<transition-group> children must be keyed: <${name}>`)
+        }
+      }
+    }
+
+    if (prevChildren) {
+      const kept = []
+      const removed = []
+      prevChildren.forEach(c => {
+        c.data.transition = transitionData
+
+        // TODO: record before patch positions
+
+        if (map[c.key]) {
+          kept.push(c)
+        } else {
+          removed.push(c)
+        }
+      })
+      this.kept = h(tag, null, kept)
+      this.removed = removed
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    )
+    this._vnode = this.kept
+  },
+
+  updated () {
+    const children = this.prevChildren
+    const moveClass = this.moveClass || ((this.name || 'v') + '-move')
+    const moveData = children.length && this.getMoveData(children[0].context, moveClass)
+    if (!moveData) {
+      return
+    }
+
+    // TODO: finish implementing move animations once
+    // we have access to sync getComponentRect()
+
+    // children.forEach(callPendingCbs)
+
+    // Promise.all(children.map(c => {
+    //   const oldPos = c.data.pos
+    //   const newPos = c.data.newPos
+    //   const dx = oldPos.left - newPos.left
+    //   const dy = oldPos.top - newPos.top
+    //   if (dx || dy) {
+    //     c.data.moved = true
+    //     return this.animate(c.elm, {
+    //       styles: {
+    //         transform: `translate(${dx}px,${dy}px)`
+    //       }
+    //     })
+    //   }
+    // })).then(() => {
+    //   children.forEach(c => {
+    //     if (c.data.moved) {
+    //       this.animate(c.elm, {
+    //         styles: {
+    //           transform: ''
+    //         },
+    //         duration: moveData.duration || 0,
+    //         delay: moveData.delay || 0,
+    //         timingFunction: moveData.timingFunction || 'linear'
+    //       })
+    //     }
+    //   })
+    // })
+  },
+
+  methods: {
+    getMoveData (context, moveClass) {
+      const stylesheet = context.$options.style || {}
+      return stylesheet['@TRANSITION'] && stylesheet['@TRANSITION'][moveClass]
+    }
+  }
+}
+
+// function callPendingCbs (c) {
+//   /* istanbul ignore if */
+//   if (c.elm._moveCb) {
+//     c.elm._moveCb()
+//   }
+//   /* istanbul ignore if */
+//   if (c.elm._enterCb) {
+//     c.elm._enterCb()
+//   }
+// }
Index: public/node_modules/vue/src/core/observer/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/observer/index.js	(revision )
+++ public/node_modules/vue/src/core/observer/index.js	(revision )
@@ -0,0 +1,256 @@
+/* @flow */
+
+import Dep from './dep'
+import { arrayMethods } from './array'
+import {
+  def,
+  isObject,
+  isPlainObject,
+  hasProto,
+  hasOwn,
+  warn,
+  isServerRendering
+} from '../util/index'
+
+const arrayKeys = Object.getOwnPropertyNames(arrayMethods)
+
+/**
+ * By default, when a reactive property is set, the new value is
+ * also converted to become reactive. However when passing down props,
+ * we don't want to force conversion because the value may be a nested value
+ * under a frozen data structure. Converting it would defeat the optimization.
+ */
+export const observerState = {
+  shouldConvert: true,
+  isSettingProps: false
+}
+
+/**
+ * Observer class that are attached to each observed
+ * object. Once attached, the observer converts target
+ * object's property keys into getter/setters that
+ * collect dependencies and dispatches updates.
+ */
+export class Observer {
+  value: any;
+  dep: Dep;
+  vmCount: number; // number of vms that has this object as root $data
+
+  constructor (value: any) {
+    this.value = value
+    this.dep = new Dep()
+    this.vmCount = 0
+    def(value, '__ob__', this)
+    if (Array.isArray(value)) {
+      const augment = hasProto
+        ? protoAugment
+        : copyAugment
+      augment(value, arrayMethods, arrayKeys)
+      this.observeArray(value)
+    } else {
+      this.walk(value)
+    }
+  }
+
+  /**
+   * Walk through each property and convert them into
+   * getter/setters. This method should only be called when
+   * value type is Object.
+   */
+  walk (obj: Object) {
+    const keys = Object.keys(obj)
+    for (let i = 0; i < keys.length; i++) {
+      defineReactive(obj, keys[i], obj[keys[i]])
+    }
+  }
+
+  /**
+   * Observe a list of Array items.
+   */
+  observeArray (items: Array<any>) {
+    for (let i = 0, l = items.length; i < l; i++) {
+      observe(items[i])
+    }
+  }
+}
+
+// helpers
+
+/**
+ * Augment an target Object or Array by intercepting
+ * the prototype chain using __proto__
+ */
+function protoAugment (target, src: Object) {
+  /* eslint-disable no-proto */
+  target.__proto__ = src
+  /* eslint-enable no-proto */
+}
+
+/**
+ * Augment an target Object or Array by defining
+ * hidden properties.
+ */
+/* istanbul ignore next */
+function copyAugment (target: Object, src: Object, keys: Array<string>) {
+  for (let i = 0, l = keys.length; i < l; i++) {
+    const key = keys[i]
+    def(target, key, src[key])
+  }
+}
+
+/**
+ * Attempt to create an observer instance for a value,
+ * returns the new observer if successfully observed,
+ * or the existing observer if the value already has one.
+ */
+export function observe (value: any, asRootData: ?boolean): Observer | void {
+  if (!isObject(value)) {
+    return
+  }
+  let ob: Observer | void
+  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+    ob = value.__ob__
+  } else if (
+    observerState.shouldConvert &&
+    !isServerRendering() &&
+    (Array.isArray(value) || isPlainObject(value)) &&
+    Object.isExtensible(value) &&
+    !value._isVue
+  ) {
+    ob = new Observer(value)
+  }
+  if (asRootData && ob) {
+    ob.vmCount++
+  }
+  return ob
+}
+
+/**
+ * Define a reactive property on an Object.
+ */
+export function defineReactive (
+  obj: Object,
+  key: string,
+  val: any,
+  customSetter?: Function
+) {
+  const dep = new Dep()
+
+  const property = Object.getOwnPropertyDescriptor(obj, key)
+  if (property && property.configurable === false) {
+    return
+  }
+
+  // cater for pre-defined getter/setters
+  const getter = property && property.get
+  const setter = property && property.set
+
+  let childOb = observe(val)
+  Object.defineProperty(obj, key, {
+    enumerable: true,
+    configurable: true,
+    get: function reactiveGetter () {
+      const value = getter ? getter.call(obj) : val
+      if (Dep.target) {
+        dep.depend()
+        if (childOb) {
+          childOb.dep.depend()
+        }
+        if (Array.isArray(value)) {
+          dependArray(value)
+        }
+      }
+      return value
+    },
+    set: function reactiveSetter (newVal) {
+      const value = getter ? getter.call(obj) : val
+      /* eslint-disable no-self-compare */
+      if (newVal === value || (newVal !== newVal && value !== value)) {
+        return
+      }
+      /* eslint-enable no-self-compare */
+      if (process.env.NODE_ENV !== 'production' && customSetter) {
+        customSetter()
+      }
+      if (setter) {
+        setter.call(obj, newVal)
+      } else {
+        val = newVal
+      }
+      childOb = observe(newVal)
+      dep.notify()
+    }
+  })
+}
+
+/**
+ * Set a property on an object. Adds the new property and
+ * triggers change notification if the property doesn't
+ * already exist.
+ */
+export function set (target: Array<any> | Object, key: any, val: any): any {
+  if (Array.isArray(target)) {
+    target.length = Math.max(target.length, key)
+    target.splice(key, 1, val)
+    return val
+  }
+  if (hasOwn(target, key)) {
+    target[key] = val
+    return val
+  }
+  const ob = target.__ob__
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid adding reactive properties to a Vue instance or its root $data ' +
+      'at runtime - declare it upfront in the data option.'
+    )
+    return val
+  }
+  if (!ob) {
+    target[key] = val
+    return val
+  }
+  defineReactive(ob.value, key, val)
+  ob.dep.notify()
+  return val
+}
+
+/**
+ * Delete a property and trigger change if necessary.
+ */
+export function del (target: Array<any> | Object, key: any) {
+  if (Array.isArray(target)) {
+    target.splice(key, 1)
+    return
+  }
+  const ob = target.__ob__
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid deleting properties on a Vue instance or its root $data ' +
+      '- just set it to null.'
+    )
+    return
+  }
+  if (!hasOwn(target, key)) {
+    return
+  }
+  delete target[key]
+  if (!ob) {
+    return
+  }
+  ob.dep.notify()
+}
+
+/**
+ * Collect dependencies on array elements when the array is touched, since
+ * we cannot intercept array element access like property getters.
+ */
+function dependArray (value: Array<any>) {
+  for (let e, i = 0, l = value.length; i < l; i++) {
+    e = value[i]
+    e && e.__ob__ && e.__ob__.dep.depend()
+    if (Array.isArray(e)) {
+      dependArray(e)
+    }
+  }
+}
Index: public/node_modules/vue-resource/src/http/interceptor/header.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/interceptor/header.js	(revision )
+++ public/node_modules/vue-resource/src/http/interceptor/header.js	(revision )
@@ -0,0 +1,22 @@
+/**
+ * Header Interceptor.
+ */
+
+import Http from '../index';
+import { assign, each, toLower } from '../../util';
+
+export default function (request, next) {
+
+    var headers = assign({}, Http.headers.common,
+        !request.crossOrigin ? Http.headers.custom : {},
+        Http.headers[toLower(request.method)]
+    );
+
+    each(headers, (value, name) => {
+        if (!request.headers.has(name)) {
+            request.headers.set(name, value);
+        }
+    });
+
+    next();
+}
Index: public/node_modules/vue/src/core/instance/proxy.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/proxy.js	(revision )
+++ public/node_modules/vue/src/core/instance/proxy.js	(revision )
@@ -0,0 +1,78 @@
+/* not type checking this file because flow doesn't play well with Proxy */
+
+import config from 'core/config'
+import { warn, makeMap } from '../util/index'
+
+let initProxy
+
+if (process.env.NODE_ENV !== 'production') {
+  const allowedGlobals = makeMap(
+    'Infinity,undefined,NaN,isFinite,isNaN,' +
+    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
+    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
+    'require' // for Webpack/Browserify
+  )
+
+  const warnNonPresent = (target, key) => {
+    warn(
+      `Property or method "${key}" is not defined on the instance but ` +
+      `referenced during render. Make sure to declare reactive data ` +
+      `properties in the data option.`,
+      target
+    )
+  }
+
+  const hasProxy =
+    typeof Proxy !== 'undefined' &&
+    Proxy.toString().match(/native code/)
+
+  if (hasProxy) {
+    const isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta')
+    config.keyCodes = new Proxy(config.keyCodes, {
+      set (target, key, value) {
+        if (isBuiltInModifier(key)) {
+          warn(`Avoid overwriting built-in modifier in config.keyCodes: .${key}`)
+          return false
+        } else {
+          target[key] = value
+          return true
+        }
+      }
+    })
+  }
+
+  const hasHandler = {
+    has (target, key) {
+      const has = key in target
+      const isAllowed = allowedGlobals(key) || key.charAt(0) === '_'
+      if (!has && !isAllowed) {
+        warnNonPresent(target, key)
+      }
+      return has || !isAllowed
+    }
+  }
+
+  const getHandler = {
+    get (target, key) {
+      if (typeof key === 'string' && !(key in target)) {
+        warnNonPresent(target, key)
+      }
+      return target[key]
+    }
+  }
+
+  initProxy = function initProxy (vm) {
+    if (hasProxy) {
+      // determine which proxy handler to use
+      const options = vm.$options
+      const handlers = options.render && options.render._withStripped
+        ? getHandler
+        : hasHandler
+      vm._renderProxy = new Proxy(vm, handlers)
+    } else {
+      vm._renderProxy = vm
+    }
+  }
+}
+
+export { initProxy }
Index: public/node_modules/vue/dist/vue.runtime.min.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.runtime.min.js	(revision )
+++ public/node_modules/vue/dist/vue.runtime.min.js	(revision )
@@ -0,0 +1,7 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Vue=e()}(this,function(){"use strict";function t(t){return null==t?"":"object"==typeof t?JSON.stringify(t,null,2):String(t)}function e(t){var e=parseFloat(t);return isNaN(e)?t:e}function n(t,e){for(var n=Object.create(null),r=t.split(","),o=0;o<r.length;o++)n[r[o]]=!0;return e?function(t){return n[t.toLowerCase()]}:function(t){return n[t]}}function r(t,e){if(t.length){var n=t.indexOf(e);if(n>-1)return t.splice(n,1)}}function o(t,e){return Kn.call(t,e)}function i(t){return"string"==typeof t||"number"==typeof t}function a(t){var e=Object.create(null);return function(n){var r=e[n];return r||(e[n]=t(n))}}function s(t,e){function n(n){var r=arguments.length;return r?r>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n}function c(t,e){e=e||0;for(var n=t.length-e,r=new Array(n);n--;)r[n]=t[n+e];return r}function u(t,e){for(var n in e)t[n]=e[n];return t}function l(t){return null!==t&&"object"==typeof t}function f(t){return Yn.call(t)===tr}function p(t){for(var e={},n=0;n<t.length;n++)t[n]&&u(e,t[n]);return e}function d(){}function v(t,e){var n=l(t),r=l(e);if(!n||!r)return!n&&!r&&String(t)===String(e);try{return JSON.stringify(t)===JSON.stringify(e)}catch(n){return t===e}}function h(t,e){for(var n=0;n<t.length;n++)if(v(t[n],e))return n;return-1}function m(t){var e=!1;return function(){e||(e=!0,t())}}function y(t){return/native code/.test(t.toString())}function _(t){var e=(t+"").charCodeAt(0);return 36===e||95===e}function g(t,e,n,r){Object.defineProperty(t,e,{value:n,enumerable:!!r,writable:!0,configurable:!0})}function b(t){if(!_r.test(t)){var e=t.split(".");return function(t){for(var n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}}function C(t){Cr.target&&wr.push(Cr.target),Cr.target=t}function w(){Cr.target=wr.pop()}function $(t,e){t.__proto__=e}function A(t,e,n){for(var r=0,o=n.length;r<o;r++){var i=n[r];g(t,i,e[i])}}function k(t,e){if(l(t)){var n;return o(t,"__ob__")&&t.__ob__ instanceof Or?n=t.__ob__:xr.shouldConvert&&!dr()&&(Array.isArray(t)||f(t))&&Object.isExtensible(t)&&!t._isVue&&(n=new Or(t)),e&&n&&n.vmCount++,n}}function x(t,e,n,r){var o=new Cr,i=Object.getOwnPropertyDescriptor(t,e);if(!i||i.configurable!==!1){var a=i&&i.get,s=i&&i.set,c=k(n);Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:function(){var e=a?a.call(t):n;return Cr.target&&(o.depend(),c&&c.dep.depend(),Array.isArray(e)&&E(e)),e},set:function(e){var r=a?a.call(t):n;e===r||e!==e&&r!==r||(s?s.call(t,e):n=e,c=k(e),o.notify())}})}}function O(t,e,n){if(Array.isArray(t))return t.length=Math.max(t.length,e),t.splice(e,1,n),n;if(o(t,e))return t[e]=n,n;var r=t.__ob__;return t._isVue||r&&r.vmCount?n:r?(x(r.value,e,n),r.dep.notify(),n):(t[e]=n,n)}function S(t,e){if(Array.isArray(t))return void t.splice(e,1);var n=t.__ob__;t._isVue||n&&n.vmCount||o(t,e)&&(delete t[e],n&&n.dep.notify())}function E(t){for(var e=void 0,n=0,r=t.length;n<r;n++)e=t[n],e&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&E(e)}function T(t,e){if(!e)return t;for(var n,r,i,a=Object.keys(e),s=0;s<a.length;s++)n=a[s],r=t[n],i=e[n],o(t,n)?f(r)&&f(i)&&T(r,i):O(t,n,i);return t}function I(t,e){return e?t?t.concat(e):Array.isArray(e)?e:[e]:t}function j(t,e){var n=Object.create(t||null);return e?u(n,e):n}function D(t){var e=t.props;if(e){var n,r,o,i={};if(Array.isArray(e))for(n=e.length;n--;)r=e[n],"string"==typeof r&&(o=Gn(r),i[o]={type:null});else if(f(e))for(var a in e)r=e[a],o=Gn(a),i[o]=f(r)?r:{type:r};t.props=i}}function N(t){var e=t.directives;if(e)for(var n in e){var r=e[n];"function"==typeof r&&(e[n]={bind:r,update:r})}}function L(t,e,n){function r(r){var o=Sr[r]||Er;l[r]=o(t[r],e[r],n,r)}D(e),N(e);var i=e.extends;if(i&&(t="function"==typeof i?L(t,i.options,n):L(t,i,n)),e.mixins)for(var a=0,s=e.mixins.length;a<s;a++){var c=e.mixins[a];c.prototype instanceof le&&(c=c.options),t=L(t,c,n)}var u,l={};for(u in t)r(u);for(u in e)o(t,u)||r(u);return l}function P(t,e,n,r){if("string"==typeof n){var i=t[e];if(o(i,n))return i[n];var a=Gn(n);if(o(i,a))return i[a];var s=Zn(a);if(o(i,s))return i[s];var c=i[n]||i[a]||i[s];return c}}function M(t,e,n,r){var i=e[t],a=!o(n,t),s=n[t];if(V(Boolean,i.type)&&(a&&!o(i,"default")?s=!1:V(String,i.type)||""!==s&&s!==Xn(t)||(s=!0)),void 0===s){s=U(r,i,t);var c=xr.shouldConvert;xr.shouldConvert=!0,k(s),xr.shouldConvert=c}return s}function U(t,e,n){if(o(e,"default")){var r=e.default;return t&&t.$options.propsData&&void 0===t.$options.propsData[n]&&void 0!==t._props[n]?t._props[n]:"function"==typeof r&&"Function"!==R(e.type)?r.call(t):r}}function R(t){var e=t&&t.toString().match(/^\s*function (\w+)/);return e&&e[1]}function V(t,e){if(!Array.isArray(e))return R(e)===R(t);for(var n=0,r=e.length;n<r;n++)if(R(e[n])===R(t))return!0;return!1}function B(t,e,n){if(rr.errorHandler)rr.errorHandler.call(null,t,e,n);else{if(!ir||"undefined"==typeof console)throw t;console.error(t)}}function H(t){return new Tr(void 0,void 0,void 0,String(t))}function z(t){var e=new Tr(t.tag,t.data,t.children,t.text,t.elm,t.context,t.componentOptions);return e.ns=t.ns,e.isStatic=t.isStatic,e.key=t.key,e.isCloned=!0,e}function F(t){for(var e=t.length,n=new Array(e),r=0;r<e;r++)n[r]=z(t[r]);return n}function q(t){function e(){var t=arguments,n=e.fns;if(!Array.isArray(n))return n.apply(null,arguments);for(var r=0;r<n.length;r++)n[r].apply(null,t)}return e.fns=t,e}function W(t,e,n,r,o){var i,a,s,c;for(i in t)a=t[i],s=e[i],c=Nr(i),a&&(s?a!==s&&(s.fns=a,t[i]=s):(a.fns||(a=t[i]=q(a)),n(c.name,a,c.once,c.capture)));for(i in e)t[i]||(c=Nr(i),r(c.name,e[i],c.capture))}function K(t,e,n){function o(){n.apply(this,arguments),r(i.fns,o)}var i,a=t[e];a?a.fns&&a.merged?(i=a,i.fns.push(o)):i=q([a,o]):i=q([o]),i.merged=!0,t[e]=i}function J(t){for(var e=0;e<t.length;e++)if(Array.isArray(t[e]))return Array.prototype.concat.apply([],t);return t}function G(t){return i(t)?[H(t)]:Array.isArray(t)?Z(t):void 0}function Z(t,e){var n,r,o,a=[];for(n=0;n<t.length;n++)r=t[n],null!=r&&"boolean"!=typeof r&&(o=a[a.length-1],Array.isArray(r)?a.push.apply(a,Z(r,(e||"")+"_"+n)):i(r)?o&&o.text?o.text+=String(r):""!==r&&a.push(H(r)):r.text&&o&&o.text?a[a.length-1]=H(o.text+r.text):(r.tag&&null==r.key&&null!=e&&(r.key="__vlist"+e+"_"+n+"__"),a.push(r)));return a}function Q(t){return t&&t.filter(function(t){return t&&t.componentOptions})[0]}function X(t){t._events=Object.create(null),t._hasHookEvent=!1;var e=t.$options._parentListeners;e&&et(t,e)}function Y(t,e,n){n?jr.$once(t,e):jr.$on(t,e)}function tt(t,e){jr.$off(t,e)}function et(t,e,n){jr=t,W(e,n||{},Y,tt,t)}function nt(t){var e=/^hook:/;t.prototype.$on=function(t,n){var r=this,o=this;if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)r.$on(t[i],n);else(o._events[t]||(o._events[t]=[])).push(n),e.test(t)&&(o._hasHookEvent=!0);return o},t.prototype.$once=function(t,e){function n(){r.$off(t,n),e.apply(r,arguments)}var r=this;return n.fn=e,r.$on(t,n),r},t.prototype.$off=function(t,e){var n=this,r=this;if(!arguments.length)return r._events=Object.create(null),r;if(Array.isArray(t)){for(var o=0,i=t.length;o<i;o++)n.$off(t[o],e);return r}var a=r._events[t];if(!a)return r;if(1===arguments.length)return r._events[t]=null,r;for(var s,c=a.length;c--;)if(s=a[c],s===e||s.fn===e){a.splice(c,1);break}return r},t.prototype.$emit=function(t){var e=this,n=e._events[t];if(n){n=n.length>1?c(n):n;for(var r=c(arguments,1),o=0,i=n.length;o<i;o++)n[o].apply(e,r)}return e}}function rt(t,e){var n={};if(!t)return n;for(var r,o,i=[],a=0,s=t.length;a<s;a++)if(o=t[a],(o.context===e||o.functionalContext===e)&&o.data&&(r=o.data.slot)){var c=n[r]||(n[r]=[]);"template"===o.tag?c.push.apply(c,o.children):c.push(o)}else i.push(o);return i.every(ot)||(n.default=i),n}function ot(t){return t.isComment||" "===t.text}function it(t){for(var e={},n=0;n<t.length;n++)e[t[n][0]]=t[n][1];return e}function at(t){var e=t.$options,n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._watcher=null,t._inactive=null,t._directInactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}function st(t){t.prototype._update=function(t,e){var n=this;n._isMounted&&dt(n,"beforeUpdate");var r=n.$el,o=n._vnode,i=Lr;Lr=n,n._vnode=t,o?n.$el=n.__patch__(o,t):n.$el=n.__patch__(n.$el,t,e,!1,n.$options._parentElm,n.$options._refElm),Lr=i,r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},t.prototype.$forceUpdate=function(){var t=this;t._watcher&&t._watcher.update()},t.prototype.$destroy=function(){var t=this;if(!t._isBeingDestroyed){dt(t,"beforeDestroy"),t._isBeingDestroyed=!0;var e=t.$parent;!e||e._isBeingDestroyed||t.$options.abstract||r(e.$children,t),t._watcher&&t._watcher.teardown();for(var n=t._watchers.length;n--;)t._watchers[n].teardown();t._data.__ob__&&t._data.__ob__.vmCount--,t._isDestroyed=!0,dt(t,"destroyed"),t.$off(),t.$el&&(t.$el.__vue__=null),t.__patch__(t._vnode,null)}}}function ct(t,e,n){t.$el=e,t.$options.render||(t.$options.render=Dr),dt(t,"beforeMount");var r;return r=function(){t._update(t._render(),n)},t._watcher=new Hr(t,r,d),n=!1,null==t.$vnode&&(t._isMounted=!0,dt(t,"mounted")),t}function ut(t,e,n,r,o){var i=!!(o||t.$options._renderChildren||r.data.scopedSlots||t.$scopedSlots!==yr);if(t.$options._parentVnode=r,t.$vnode=r,t._vnode&&(t._vnode.parent=r),t.$options._renderChildren=o,e&&t.$options.props){xr.shouldConvert=!1;for(var a=t._props,s=t.$options._propKeys||[],c=0;c<s.length;c++){var u=s[c];a[u]=M(u,t.$options.props,e,t)}xr.shouldConvert=!0,t.$options.propsData=e}if(n){var l=t.$options._parentListeners;t.$options._parentListeners=n,et(t,n,l)}i&&(t.$slots=rt(o,r.context),t.$forceUpdate())}function lt(t){for(;t&&(t=t.$parent);)if(t._inactive)return!0;return!1}function ft(t,e){if(e){if(t._directInactive=!1,lt(t))return}else if(t._directInactive)return;if(t._inactive||null==t._inactive){t._inactive=!1;for(var n=0;n<t.$children.length;n++)ft(t.$children[n]);dt(t,"activated")}}function pt(t,e){if(!(e&&(t._directInactive=!0,lt(t))||t._inactive)){t._inactive=!0;for(var n=0;n<t.$children.length;n++)pt(t.$children[n]);dt(t,"deactivated")}}function dt(t,e){var n=t.$options[e];if(n)for(var r=0,o=n.length;r<o;r++)try{n[r].call(t)}catch(n){B(n,t,e+" hook")}t._hasHookEvent&&t.$emit("hook:"+e)}function vt(){Pr.length=0,Mr={},Ur=Rr=!1}function ht(){Rr=!0;var t,e,n;for(Pr.sort(function(t,e){return t.id-e.id}),Vr=0;Vr<Pr.length;Vr++)t=Pr[Vr],e=t.id,Mr[e]=null,t.run();for(Vr=Pr.length;Vr--;)t=Pr[Vr],n=t.vm,n._watcher===t&&n._isMounted&&dt(n,"updated");vr&&rr.devtools&&vr.emit("flush"),vt()}function mt(t){var e=t.id;if(null==Mr[e]){if(Mr[e]=!0,Rr){for(var n=Pr.length-1;n>=0&&Pr[n].id>t.id;)n--;Pr.splice(Math.max(n,Vr)+1,0,t)}else Pr.push(t);Ur||(Ur=!0,mr(ht))}}function yt(t){zr.clear(),_t(t,zr)}function _t(t,e){var n,r,o=Array.isArray(t);if((o||l(t))&&Object.isExtensible(t)){if(t.__ob__){var i=t.__ob__.dep.id;if(e.has(i))return;e.add(i)}if(o)for(n=t.length;n--;)_t(t[n],e);else for(r=Object.keys(t),n=r.length;n--;)_t(t[r[n]],e)}}function gt(t,e,n){Fr.get=function(){return this[e][n]},Fr.set=function(t){this[e][n]=t},Object.defineProperty(t,n,Fr)}function bt(t){t._watchers=[];var e=t.$options;e.props&&Ct(t,e.props),e.methods&&xt(t,e.methods),e.data?wt(t):k(t._data={},!0),e.computed&&$t(t,e.computed),e.watch&&Ot(t,e.watch)}function Ct(t,e){var n=t.$options.propsData||{},r=t._props={},o=t.$options._propKeys=[],i=!t.$parent;xr.shouldConvert=i;var a=function(i){o.push(i);var a=M(i,e,n,t);x(r,i,a),i in t||gt(t,"_props",i)};for(var s in e)a(s);xr.shouldConvert=!0}function wt(t){var e=t.$options.data;e=t._data="function"==typeof e?e.call(t):e||{},f(e)||(e={});for(var n=Object.keys(e),r=t.$options.props,i=n.length;i--;)r&&o(r,n[i])||_(n[i])||gt(t,"_data",n[i]);k(e,!0)}function $t(t,e){var n=t._computedWatchers=Object.create(null);for(var r in e){var o=e[r],i="function"==typeof o?o:o.get;n[r]=new Hr(t,i,d,qr),r in t||At(t,r,o)}}function At(t,e,n){"function"==typeof n?(Fr.get=kt(e),Fr.set=d):(Fr.get=n.get?n.cache!==!1?kt(e):n.get:d,Fr.set=n.set?n.set:d),Object.defineProperty(t,e,Fr)}function kt(t){return function(){var e=this._computedWatchers&&this._computedWatchers[t];if(e)return e.dirty&&e.evaluate(),Cr.target&&e.depend(),e.value}}function xt(t,e){t.$options.props;for(var n in e)t[n]=null==e[n]?d:s(e[n],t)}function Ot(t,e){for(var n in e){var r=e[n];if(Array.isArray(r))for(var o=0;o<r.length;o++)St(t,n,r[o]);else St(t,n,r)}}function St(t,e,n){var r;f(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,r)}function Et(t){var e={};e.get=function(){return this._data};var n={};n.get=function(){return this._props},Object.defineProperty(t.prototype,"$data",e),Object.defineProperty(t.prototype,"$props",n),t.prototype.$set=O,t.prototype.$delete=S,t.prototype.$watch=function(t,e,n){var r=this;n=n||{},n.user=!0;var o=new Hr(r,t,e,n);return n.immediate&&e.call(r,o.value),function(){o.teardown()}}}function Tt(t,e,n,r,o){if(t){var i=n.$options._base;if(l(t)&&(t=i.extend(t)),"function"==typeof t){if(!t.cid)if(t.resolved)t=t.resolved;else if(t=Mt(t,i,function(){n.$forceUpdate()}),!t)return;se(t),e=e||{},e.model&&Ht(t.options,e);var a=Ut(e,t);if(t.options.functional)return It(t,a,e,n,r);var s=e.on;e.on=e.nativeOn,t.options.abstract&&(e={}),Vt(e);var c=t.options.name||o,u=new Tr("vue-component-"+t.cid+(c?"-"+c:""),e,void 0,void 0,void 0,n,{Ctor:t,propsData:a,listeners:s,tag:o,children:r});return u}}}function It(t,e,n,r,o){var i={},a=t.options.props;if(a)for(var s in a)i[s]=M(s,a,e);var c=Object.create(r),u=function(t,e,n,r){return zt(c,t,e,n,r,!0)},l=t.options.render.call(null,u,{props:i,data:n,parent:r,children:o,slots:function(){return rt(o,r)}});return l instanceof Tr&&(l.functionalContext=r,n.slot&&((l.data||(l.data={})).slot=n.slot)),l}function jt(t,e,n,r){var o=t.componentOptions,i={_isComponent:!0,parent:e,propsData:o.propsData,_componentTag:o.tag,_parentVnode:t,_parentListeners:o.listeners,_renderChildren:o.children,_parentElm:n||null,_refElm:r||null},a=t.data.inlineTemplate;return a&&(i.render=a.render,i.staticRenderFns=a.staticRenderFns),new o.Ctor(i)}function Dt(t,e,n,r){if(!t.componentInstance||t.componentInstance._isDestroyed){var o=t.componentInstance=jt(t,Lr,n,r);o.$mount(e?t.elm:void 0,e)}else if(t.data.keepAlive){var i=t;Nt(i,i)}}function Nt(t,e){var n=e.componentOptions,r=e.componentInstance=t.componentInstance;ut(r,n.propsData,n.listeners,e,n.children)}function Lt(t){t.componentInstance._isMounted||(t.componentInstance._isMounted=!0,dt(t.componentInstance,"mounted")),t.data.keepAlive&&ft(t.componentInstance,!0)}function Pt(t){t.componentInstance._isDestroyed||(t.data.keepAlive?pt(t.componentInstance,!0):t.componentInstance.$destroy())}function Mt(t,e,n){if(!t.requested){t.requested=!0;var r=t.pendingCallbacks=[n],o=!0,i=function(n){if(l(n)&&(n=e.extend(n)),t.resolved=n,!o)for(var i=0,a=r.length;i<a;i++)r[i](n)},a=function(t){},s=t(i,a);return s&&"function"==typeof s.then&&!t.resolved&&s.then(i,a),o=!1,t.resolved}t.pendingCallbacks.push(n)}function Ut(t,e){var n=e.options.props;if(n){var r={},o=t.attrs,i=t.props,a=t.domProps;if(o||i||a)for(var s in n){var c=Xn(s);Rt(r,i,s,c,!0)||Rt(r,o,s,c)||Rt(r,a,s,c)}return r}}function Rt(t,e,n,r,i){if(e){if(o(e,n))return t[n]=e[n],i||delete e[n],!0;if(o(e,r))return t[n]=e[r],i||delete e[r],!0}return!1}function Vt(t){t.hook||(t.hook={});for(var e=0;e<Kr.length;e++){var n=Kr[e],r=t.hook[n],o=Wr[n];t.hook[n]=r?Bt(o,r):o}}function Bt(t,e){return function(n,r,o,i){t(n,r,o,i),e(n,r,o,i)}}function Ht(t,e){var n=t.model&&t.model.prop||"value",r=t.model&&t.model.event||"input";(e.props||(e.props={}))[n]=e.model.value;var o=e.on||(e.on={});o[r]?o[r]=[e.model.callback].concat(o[r]):o[r]=e.model.callback}function zt(t,e,n,r,o,a){return(Array.isArray(n)||i(n))&&(o=r,r=n,n=void 0),a&&(o=Gr),Ft(t,e,n,r,o)}function Ft(t,e,n,r,o){if(n&&n.__ob__)return Dr();if(!e)return Dr();Array.isArray(r)&&"function"==typeof r[0]&&(n=n||{},n.scopedSlots={default:r[0]},r.length=0),o===Gr?r=G(r):o===Jr&&(r=J(r));var i,a;if("string"==typeof e){var s;a=rr.getTagNamespace(e),i=rr.isReservedTag(e)?new Tr(rr.parsePlatformTagName(e),n,r,void 0,void 0,t):(s=P(t.$options,"components",e))?Tt(s,n,t,r,e):new Tr(e,n,r,void 0,void 0,t)}else i=Tt(e,n,t,r);return i?(a&&qt(i,a),i):Dr()}function qt(t,e){if(t.ns=e,"foreignObject"!==t.tag&&t.children)for(var n=0,r=t.children.length;n<r;n++){var o=t.children[n];o.tag&&!o.ns&&qt(o,e)}}function Wt(t,e){var n,r,o,i,a;if(Array.isArray(t)||"string"==typeof t)for(n=new Array(t.length),r=0,o=t.length;r<o;r++)n[r]=e(t[r],r);else if("number"==typeof t)for(n=new Array(t),r=0;r<t;r++)n[r]=e(r+1,r);else if(l(t))for(i=Object.keys(t),n=new Array(i.length),r=0,o=i.length;r<o;r++)a=i[r],n[r]=e(t[a],a,r);return n}function Kt(t,e,n,r){var o=this.$scopedSlots[t];if(o)return n=n||{},r&&u(n,r),o(n)||e;var i=this.$slots[t];return i||e}function Jt(t){return P(this.$options,"filters",t,!0)||nr}function Gt(t,e,n){var r=rr.keyCodes[e]||n;return Array.isArray(r)?r.indexOf(t)===-1:r!==t}function Zt(t,e,n,r){if(n)if(l(n)){Array.isArray(n)&&(n=p(n));for(var o in n)if("class"===o||"style"===o)t[o]=n[o];else{var i=t.attrs&&t.attrs.type,a=r||rr.mustUseProp(e,i,o)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={});a[o]=n[o]}}else;return t}function Qt(t,e){var n=this._staticTrees[t];return n&&!e?Array.isArray(n)?F(n):z(n):(n=this._staticTrees[t]=this.$options.staticRenderFns[t].call(this._renderProxy),Yt(n,"__static__"+t,!1),n)}function Xt(t,e,n){return Yt(t,"__once__"+e+(n?"_"+n:""),!0),t}function Yt(t,e,n){if(Array.isArray(t))for(var r=0;r<t.length;r++)t[r]&&"string"!=typeof t[r]&&te(t[r],e+"_"+r,n);else te(t,e,n)}function te(t,e,n){t.isStatic=!0,t.key=e,t.isOnce=n}function ee(t){t.$vnode=null,t._vnode=null,t._staticTrees=null;var e=t.$options._parentVnode,n=e&&e.context;t.$slots=rt(t.$options._renderChildren,n),t.$scopedSlots=yr,t._c=function(e,n,r,o){return zt(t,e,n,r,o,!1)},t.$createElement=function(e,n,r,o){return zt(t,e,n,r,o,!0)}}function ne(n){n.prototype.$nextTick=function(t){return mr(t,this)},n.prototype._render=function(){var t=this,e=t.$options,n=e.render,r=e.staticRenderFns,o=e._parentVnode;if(t._isMounted)for(var i in t.$slots)t.$slots[i]=F(t.$slots[i]);t.$scopedSlots=o&&o.data.scopedSlots||yr,r&&!t._staticTrees&&(t._staticTrees=[]),t.$vnode=o;var a;try{a=n.call(t._renderProxy,t.$createElement)}catch(e){B(e,t,"render function"),a=t._vnode}return a instanceof Tr||(a=Dr()),a.parent=o,a},n.prototype._o=Xt,n.prototype._n=e,n.prototype._s=t,n.prototype._l=Wt,n.prototype._t=Kt,n.prototype._q=v,n.prototype._i=h,n.prototype._m=Qt,n.prototype._f=Jt,n.prototype._k=Gt,n.prototype._b=Zt,n.prototype._v=H,n.prototype._e=Dr,n.prototype._u=it}function re(t){var e=t.$options.provide;e&&(t._provided="function"==typeof e?e.call(t):e)}function oe(t){var e=t.$options.inject;if(e)for(var n=Array.isArray(e),r=n?e:hr?Reflect.ownKeys(e):Object.keys(e),o=0;o<r.length;o++)for(var i=r[o],a=n?i:e[i],s=t;s;){if(s._provided&&a in s._provided){t[i]=s._provided[a];break}s=s.$parent}}function ie(t){t.prototype._init=function(t){var e=this;e._uid=Zr++,e._isVue=!0,t&&t._isComponent?ae(e,t):e.$options=L(se(e.constructor),t||{},e),e._renderProxy=e,e._self=e,at(e),X(e),ee(e),dt(e,"beforeCreate"),oe(e),bt(e),re(e),dt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}function ae(t,e){var n=t.$options=Object.create(t.constructor.options);n.parent=e.parent,n.propsData=e.propsData,n._parentVnode=e._parentVnode,n._parentListeners=e._parentListeners,n._renderChildren=e._renderChildren,n._componentTag=e._componentTag,n._parentElm=e._parentElm,n._refElm=e._refElm,e.render&&(n.render=e.render,n.staticRenderFns=e.staticRenderFns)}function se(t){var e=t.options;if(t.super){var n=se(t.super),r=t.superOptions;if(n!==r){t.superOptions=n;var o=ce(t);o&&u(t.extendOptions,o),e=t.options=L(n,t.extendOptions),e.name&&(e.components[e.name]=t)}}return e}function ce(t){var e,n=t.options,r=t.sealedOptions;for(var o in n)n[o]!==r[o]&&(e||(e={}),e[o]=ue(n[o],r[o]));return e}function ue(t,e){if(Array.isArray(t)){var n=[];e=Array.isArray(e)?e:[e];for(var r=0;r<t.length;r++)e.indexOf(t[r])<0&&n.push(t[r]);return n}return t}function le(t){this._init(t)}function fe(t){t.use=function(t){if(!t.installed){var e=c(arguments,1);return e.unshift(this),"function"==typeof t.install?t.install.apply(t,e):"function"==typeof t&&t.apply(null,e),t.installed=!0,this}}}function pe(t){t.mixin=function(t){this.options=L(this.options,t)}}function de(t){t.cid=0;var e=1;t.extend=function(t){t=t||{};var n=this,r=n.cid,o=t._Ctor||(t._Ctor={});if(o[r])return o[r];var i=t.name||n.options.name,a=function(t){this._init(t)};return a.prototype=Object.create(n.prototype),a.prototype.constructor=a,a.cid=e++,a.options=L(n.options,t),a.super=n,a.options.props&&ve(a),a.options.computed&&he(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,rr._assetTypes.forEach(function(t){a[t]=n[t]}),i&&(a.options.components[i]=a),a.superOptions=n.options,a.extendOptions=t,a.sealedOptions=u({},a.options),o[r]=a,a}}function ve(t){var e=t.options.props;for(var n in e)gt(t.prototype,"_props",n)}function he(t){var e=t.options.computed;for(var n in e)At(t.prototype,n,e[n])}function me(t){rr._assetTypes.forEach(function(e){t[e]=function(t,n){return n?("component"===e&&f(n)&&(n.name=n.name||t,n=this.options._base.extend(n)),"directive"===e&&"function"==typeof n&&(n={bind:n,update:n}),this.options[e+"s"][t]=n,n):this.options[e+"s"][t]}})}function ye(t){return t&&(t.Ctor.options.name||t.tag)}function _e(t,e){return"string"==typeof t?t.split(",").indexOf(e)>-1:t instanceof RegExp&&t.test(e)}function ge(t,e){for(var n in t){var r=t[n];if(r){var o=ye(r.componentOptions);o&&!e(o)&&(be(r),t[n]=null)}}}function be(t){t&&(t.componentInstance._inactive||dt(t.componentInstance,"deactivated"),t.componentInstance.$destroy())}function Ce(t){var e={};e.get=function(){return rr},Object.defineProperty(t,"config",e),t.util={warn:gr,extend:u,mergeOptions:L,defineReactive:x},t.set=O,t.delete=S,t.nextTick=mr,t.options=Object.create(null),rr._assetTypes.forEach(function(e){t.options[e+"s"]=Object.create(null)}),t.options._base=t,u(t.options.components,Yr),fe(t),pe(t),de(t),me(t)}function we(t){for(var e=t.data,n=t,r=t;r.componentInstance;)r=r.componentInstance._vnode,r.data&&(e=$e(r.data,e));for(;n=n.parent;)n.data&&(e=$e(e,n.data));return Ae(e)}function $e(t,e){return{staticClass:ke(t.staticClass,e.staticClass),class:t.class?[t.class,e.class]:e.class}}function Ae(t){var e=t.class,n=t.staticClass;return n||e?ke(n,xe(e)):""}function ke(t,e){return t?e?t+" "+e:t:e||""}function xe(t){var e="";if(!t)return e;if("string"==typeof t)return t;if(Array.isArray(t)){for(var n,r=0,o=t.length;r<o;r++)t[r]&&(n=xe(t[r]))&&(e+=n+" ");return e.slice(0,-1)}if(l(t)){for(var i in t)t[i]&&(e+=i+" ");return e.slice(0,-1)}return e}function Oe(t){return po(t)?"svg":"math"===t?"math":void 0}function Se(t){if(!ir)return!0;if(vo(t))return!1;if(t=t.toLowerCase(),null!=ho[t])return ho[t];var e=document.createElement(t);return t.indexOf("-")>-1?ho[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:ho[t]=/HTMLUnknownElement/.test(e.toString())}function Ee(t){if("string"==typeof t){var e=document.querySelector(t);return e?e:document.createElement("div")}return t}function Te(t,e){var n=document.createElement(t);return"select"!==t?n:(e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)}function Ie(t,e){return document.createElementNS(lo[t],e)}function je(t){return document.createTextNode(t)}function De(t){return document.createComment(t)}function Ne(t,e,n){t.insertBefore(e,n)}function Le(t,e){t.removeChild(e)}function Pe(t,e){t.appendChild(e)}function Me(t){return t.parentNode}function Ue(t){return t.nextSibling}function Re(t){return t.tagName}function Ve(t,e){t.textContent=e}function Be(t,e,n){t.setAttribute(e,n)}function He(t,e){var n=t.data.ref;if(n){var o=t.context,i=t.componentInstance||t.elm,a=o.$refs;e?Array.isArray(a[n])?r(a[n],i):a[n]===i&&(a[n]=void 0):t.data.refInFor?Array.isArray(a[n])&&a[n].indexOf(i)<0?a[n].push(i):a[n]=[i]:a[n]=i}}function ze(t){return null==t}function Fe(t){return null!=t}function qe(t,e){return t.key===e.key&&t.tag===e.tag&&t.isComment===e.isComment&&!t.data==!e.data}function We(t,e,n){var r,o,i={};for(r=e;r<=n;++r)o=t[r].key,Fe(o)&&(i[o]=r);return i}function Ke(t){function e(t){return new Tr(O.tagName(t).toLowerCase(),{},[],void 0,t)}function r(t,e){function n(){0===--n.listeners&&o(t)}return n.listeners=e,n}function o(t){var e=O.parentNode(t);e&&O.removeChild(e,t)}function a(t,e,n,r,o){if(t.isRootInsert=!o,!s(t,e,n,r)){var i=t.data,a=t.children,c=t.tag;Fe(c)?(t.elm=t.ns?O.createElementNS(t.ns,c):O.createElement(c,t),v(t),f(t,a,e),Fe(i)&&d(t,e),l(n,t.elm,r)):t.isComment?(t.elm=O.createComment(t.text),l(n,t.elm,r)):(t.elm=O.createTextNode(t.text),l(n,t.elm,r))}}function s(t,e,n,r){var o=t.data;if(Fe(o)){var i=Fe(t.componentInstance)&&o.keepAlive;if(Fe(o=o.hook)&&Fe(o=o.init)&&o(t,!1,n,r),Fe(t.componentInstance))return c(t,e),i&&u(t,e,n,r),!0}}function c(t,e){t.data.pendingInsert&&e.push.apply(e,t.data.pendingInsert),t.elm=t.componentInstance.$el,p(t)?(d(t,e),v(t)):(He(t),e.push(t))}function u(t,e,n,r){for(var o,i=t;i.componentInstance;)if(i=i.componentInstance._vnode,Fe(o=i.data)&&Fe(o=o.transition)){for(o=0;o<k.activate.length;++o)k.activate[o](_o,i);e.push(i);break}l(n,t.elm,r)}function l(t,e,n){t&&(n?O.insertBefore(t,e,n):O.appendChild(t,e))}function f(t,e,n){if(Array.isArray(e))for(var r=0;r<e.length;++r)a(e[r],n,t.elm,null,!0);else i(t.text)&&O.appendChild(t.elm,O.createTextNode(t.text))}function p(t){for(;t.componentInstance;)t=t.componentInstance._vnode;return Fe(t.tag)}function d(t,e){for(var n=0;n<k.create.length;++n)k.create[n](_o,t);$=t.data.hook,Fe($)&&($.create&&$.create(_o,t),$.insert&&e.push(t))}function v(t){for(var e,n=t;n;)Fe(e=n.context)&&Fe(e=e.$options._scopeId)&&O.setAttribute(t.elm,e,""),n=n.parent;Fe(e=Lr)&&e!==t.context&&Fe(e=e.$options._scopeId)&&O.setAttribute(t.elm,e,"")}function h(t,e,n,r,o,i){for(;r<=o;++r)a(n[r],i,t,e)}function m(t){var e,n,r=t.data;if(Fe(r))for(Fe(e=r.hook)&&Fe(e=e.destroy)&&e(t),e=0;e<k.destroy.length;++e)k.destroy[e](t);if(Fe(e=t.children))for(n=0;n<t.children.length;++n)m(t.children[n])}function y(t,e,n,r){for(;n<=r;++n){var i=e[n];Fe(i)&&(Fe(i.tag)?(_(i),m(i)):o(i.elm))}}function _(t,e){if(e||Fe(t.data)){var n=k.remove.length+1;for(e?e.listeners+=n:e=r(t.elm,n),Fe($=t.componentInstance)&&Fe($=$._vnode)&&Fe($.data)&&_($,e),$=0;$<k.remove.length;++$)k.remove[$](t,e);Fe($=t.data.hook)&&Fe($=$.remove)?$(t,e):e()}else o(t.elm)}function g(t,e,n,r,o){for(var i,s,c,u,l=0,f=0,p=e.length-1,d=e[0],v=e[p],m=n.length-1,_=n[0],g=n[m],C=!o;l<=p&&f<=m;)ze(d)?d=e[++l]:ze(v)?v=e[--p]:qe(d,_)?(b(d,_,r),d=e[++l],_=n[++f]):qe(v,g)?(b(v,g,r),v=e[--p],g=n[--m]):qe(d,g)?(b(d,g,r),C&&O.insertBefore(t,d.elm,O.nextSibling(v.elm)),d=e[++l],g=n[--m]):qe(v,_)?(b(v,_,r),C&&O.insertBefore(t,v.elm,d.elm),v=e[--p],_=n[++f]):(ze(i)&&(i=We(e,l,p)),s=Fe(_.key)?i[_.key]:null,ze(s)?(a(_,r,t,d.elm),_=n[++f]):(c=e[s],qe(c,_)?(b(c,_,r),e[s]=void 0,C&&O.insertBefore(t,_.elm,d.elm),_=n[++f]):(a(_,r,t,d.elm),_=n[++f])));l>p?(u=ze(n[m+1])?null:n[m+1].elm,h(t,u,n,f,m,r)):f>m&&y(t,e,l,p)}function b(t,e,n,r){if(t!==e){if(e.isStatic&&t.isStatic&&e.key===t.key&&(e.isCloned||e.isOnce))return e.elm=t.elm,void(e.componentInstance=t.componentInstance);var o,i=e.data,a=Fe(i);a&&Fe(o=i.hook)&&Fe(o=o.prepatch)&&o(t,e);var s=e.elm=t.elm,c=t.children,u=e.children;if(a&&p(e)){for(o=0;o<k.update.length;++o)k.update[o](t,e);Fe(o=i.hook)&&Fe(o=o.update)&&o(t,e)}ze(e.text)?Fe(c)&&Fe(u)?c!==u&&g(s,c,u,n,r):Fe(u)?(Fe(t.text)&&O.setTextContent(s,""),h(s,null,u,0,u.length-1,n)):Fe(c)?y(s,c,0,c.length-1):Fe(t.text)&&O.setTextContent(s,""):t.text!==e.text&&O.setTextContent(s,e.text),a&&Fe(o=i.hook)&&Fe(o=o.postpatch)&&o(t,e)}}function C(t,e,n){if(n&&t.parent)t.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}function w(t,e,n){e.elm=t;var r=e.tag,o=e.data,i=e.children;if(Fe(o)&&(Fe($=o.hook)&&Fe($=$.init)&&$(e,!0),Fe($=e.componentInstance)))return c(e,n),!0;if(Fe(r)){if(Fe(i))if(t.hasChildNodes()){for(var a=!0,s=t.firstChild,u=0;u<i.length;u++){if(!s||!w(s,i[u],n)){a=!1;break}s=s.nextSibling}if(!a||s)return!1}else f(e,i,n);if(Fe(o))for(var l in o)if(!S(l)){d(e,n);break}}else t.data!==e.text&&(t.data=e.text);return!0}var $,A,k={},x=t.modules,O=t.nodeOps;for($=0;$<go.length;++$)for(k[go[$]]=[],A=0;A<x.length;++A)void 0!==x[A][go[$]]&&k[go[$]].push(x[A][go[$]]);var S=n("attrs,style,class,staticClass,staticStyle,key");return function(t,n,r,o,i,s){if(!n)return void(t&&m(t));var c=!1,u=[];if(t){var l=Fe(t.nodeType);if(!l&&qe(t,n))b(t,n,u,o);else{if(l){if(1===t.nodeType&&t.hasAttribute("server-rendered")&&(t.removeAttribute("server-rendered"),r=!0),r&&w(t,n,u))return C(n,u,!0),t;t=e(t)}var f=t.elm,d=O.parentNode(f);if(a(n,u,f._leaveCb?null:d,O.nextSibling(f)),n.parent){for(var v=n.parent;v;)v.elm=n.elm,v=v.parent;if(p(n))for(var h=0;h<k.create.length;++h)k.create[h](_o,n.parent)}null!==d?y(d,[t],0,0):Fe(t.tag)&&m(t)}}else c=!0,a(n,u,i,s);return C(n,u,c),n.elm}}function Je(t,e){(t.data.directives||e.data.directives)&&Ge(t,e)}function Ge(t,e){var n,r,o,i=t===_o,a=e===_o,s=Ze(t.data.directives,t.context),c=Ze(e.data.directives,e.context),u=[],l=[];for(n in c)r=s[n],o=c[n],r?(o.oldValue=r.value,Xe(o,"update",e,t),o.def&&o.def.componentUpdated&&l.push(o)):(Xe(o,"bind",e,t),o.def&&o.def.inserted&&u.push(o));if(u.length){var f=function(){for(var n=0;n<u.length;n++)Xe(u[n],"inserted",e,t)};i?K(e.data.hook||(e.data.hook={}),"insert",f):f()}if(l.length&&K(e.data.hook||(e.data.hook={}),"postpatch",function(){for(var n=0;n<l.length;n++)Xe(l[n],"componentUpdated",e,t)}),!i)for(n in s)c[n]||Xe(s[n],"unbind",t,t,a)}function Ze(t,e){var n=Object.create(null);if(!t)return n;var r,o;for(r=0;r<t.length;r++)o=t[r],o.modifiers||(o.modifiers=Co),n[Qe(o)]=o,o.def=P(e.$options,"directives",o.name,!0);return n}function Qe(t){return t.rawName||t.name+"."+Object.keys(t.modifiers||{}).join(".")}function Xe(t,e,n,r,o){var i=t.def&&t.def[e];i&&i(n.elm,t,n,r,o)}function Ye(t,e){if(t.data.attrs||e.data.attrs){var n,r,o,i=e.elm,a=t.data.attrs||{},s=e.data.attrs||{};s.__ob__&&(s=e.data.attrs=u({},s));for(n in s)r=s[n],o=a[n],o!==r&&tn(i,n,r);cr&&s.value!==a.value&&tn(i,"value",s.value);for(n in a)null==s[n]&&(so(n)?i.removeAttributeNS(ao,co(n)):oo(n)||i.removeAttribute(n))}}function tn(t,e,n){io(e)?uo(n)?t.removeAttribute(e):t.setAttribute(e,e):oo(e)?t.setAttribute(e,uo(n)||"false"===n?"false":"true"):so(e)?uo(n)?t.removeAttributeNS(ao,co(e)):t.setAttributeNS(ao,e,n):uo(n)?t.removeAttribute(e):t.setAttribute(e,n)}function en(t,e){var n=e.elm,r=e.data,o=t.data;if(r.staticClass||r.class||o&&(o.staticClass||o.class)){var i=we(e),a=n._transitionClasses;a&&(i=ke(i,xe(a))),i!==n._prevClass&&(n.setAttribute("class",i),n._prevClass=i)}}function nn(t){var e;t[ko]&&(e=sr?"change":"input",t[e]=[].concat(t[ko],t[e]||[]),delete t[ko]),t[xo]&&(e=pr?"click":"change",t[e]=[].concat(t[xo],t[e]||[]),delete t[xo])}function rn(t,e,n,r){if(n){var o=e,i=to;e=function(n){var a=1===arguments.length?o(n):o.apply(null,arguments);null!==a&&on(t,e,r,i)}}to.addEventListener(t,e,r)}function on(t,e,n,r){(r||to).removeEventListener(t,e,n)}function an(t,e){if(t.data.on||e.data.on){var n=e.data.on||{},r=t.data.on||{};to=e.elm,nn(n),W(n,r,rn,on,e.context)}}function sn(t,e){if(t.data.domProps||e.data.domProps){var n,r,o=e.elm,i=t.data.domProps||{},a=e.data.domProps||{};a.__ob__&&(a=e.data.domProps=u({},a));for(n in i)null==a[n]&&(o[n]="");for(n in a)if(r=a[n],"textContent"!==n&&"innerHTML"!==n||(e.children&&(e.children.length=0),r!==i[n]))if("value"===n){o._value=r;var s=null==r?"":String(r);cn(o,e,s)&&(o.value=s)}else o[n]=r}}function cn(t,e,n){return!t.composing&&("option"===e.tag||un(t,n)||ln(t,n));
+}function un(t,e){return document.activeElement!==t&&t.value!==e}function ln(t,n){var r=t.value,o=t._vModifiers;return o&&o.number||"number"===t.type?e(r)!==e(n):o&&o.trim?r.trim()!==n.trim():r!==n}function fn(t){var e=pn(t.style);return t.staticStyle?u(t.staticStyle,e):e}function pn(t){return Array.isArray(t)?p(t):"string"==typeof t?Eo(t):t}function dn(t,e){var n,r={};if(e)for(var o=t;o.componentInstance;)o=o.componentInstance._vnode,o.data&&(n=fn(o.data))&&u(r,n);(n=fn(t.data))&&u(r,n);for(var i=t;i=i.parent;)i.data&&(n=fn(i.data))&&u(r,n);return r}function vn(t,e){var n=e.data,r=t.data;if(n.staticStyle||n.style||r.staticStyle||r.style){var o,i,a=e.elm,s=t.data.staticStyle,c=t.data.style||{},l=s||c,f=pn(e.data.style)||{};e.data.style=f.__ob__?u({},f):f;var p=dn(e,!0);for(i in l)null==p[i]&&jo(a,i,"");for(i in p)o=p[i],o!==l[i]&&jo(a,i,null==o?"":o)}}function hn(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(/\s+/).forEach(function(e){return t.classList.add(e)}):t.classList.add(e);else{var n=" "+(t.getAttribute("class")||"")+" ";n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function mn(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(/\s+/).forEach(function(e){return t.classList.remove(e)}):t.classList.remove(e);else{for(var n=" "+(t.getAttribute("class")||"")+" ",r=" "+e+" ";n.indexOf(r)>=0;)n=n.replace(r," ");t.setAttribute("class",n.trim())}}function yn(t){if(t){if("object"==typeof t){var e={};return t.css!==!1&&u(e,Po(t.name||"v")),u(e,t),e}return"string"==typeof t?Po(t):void 0}}function _n(t){Fo(function(){Fo(t)})}function gn(t,e){(t._transitionClasses||(t._transitionClasses=[])).push(e),hn(t,e)}function bn(t,e){t._transitionClasses&&r(t._transitionClasses,e),mn(t,e)}function Cn(t,e,n){var r=wn(t,e),o=r.type,i=r.timeout,a=r.propCount;if(!o)return n();var s=o===Uo?Bo:zo,c=0,u=function(){t.removeEventListener(s,l),n()},l=function(e){e.target===t&&++c>=a&&u()};setTimeout(function(){c<a&&u()},i+1),t.addEventListener(s,l)}function wn(t,e){var n,r=window.getComputedStyle(t),o=r[Vo+"Delay"].split(", "),i=r[Vo+"Duration"].split(", "),a=$n(o,i),s=r[Ho+"Delay"].split(", "),c=r[Ho+"Duration"].split(", "),u=$n(s,c),l=0,f=0;e===Uo?a>0&&(n=Uo,l=a,f=i.length):e===Ro?u>0&&(n=Ro,l=u,f=c.length):(l=Math.max(a,u),n=l>0?a>u?Uo:Ro:null,f=n?n===Uo?i.length:c.length:0);var p=n===Uo&&qo.test(r[Vo+"Property"]);return{type:n,timeout:l,propCount:f,hasTransform:p}}function $n(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map(function(e,n){return An(e)+An(t[n])}))}function An(t){return 1e3*Number(t.slice(0,-1))}function kn(t,n){var r=t.elm;r._leaveCb&&(r._leaveCb.cancelled=!0,r._leaveCb());var o=yn(t.data.transition);if(o&&!r._enterCb&&1===r.nodeType){for(var i=o.css,a=o.type,s=o.enterClass,c=o.enterToClass,u=o.enterActiveClass,f=o.appearClass,p=o.appearToClass,d=o.appearActiveClass,v=o.beforeEnter,h=o.enter,y=o.afterEnter,_=o.enterCancelled,g=o.beforeAppear,b=o.appear,C=o.afterAppear,w=o.appearCancelled,$=o.duration,A=Lr,k=Lr.$vnode;k&&k.parent;)k=k.parent,A=k.context;var x=!A._isMounted||!t.isRootInsert;if(!x||b||""===b){var O=x&&f?f:s,S=x&&d?d:u,E=x&&p?p:c,T=x?g||v:v,I=x&&"function"==typeof b?b:h,j=x?C||y:y,D=x?w||_:_,N=e(l($)?$.enter:$),L=i!==!1&&!cr,P=Sn(I),M=r._enterCb=m(function(){L&&(bn(r,E),bn(r,S)),M.cancelled?(L&&bn(r,O),D&&D(r)):j&&j(r),r._enterCb=null});t.data.show||K(t.data.hook||(t.data.hook={}),"insert",function(){var e=r.parentNode,n=e&&e._pending&&e._pending[t.key];n&&n.tag===t.tag&&n.elm._leaveCb&&n.elm._leaveCb(),I&&I(r,M)}),T&&T(r),L&&(gn(r,O),gn(r,S),_n(function(){gn(r,E),bn(r,O),M.cancelled||P||(On(N)?setTimeout(M,N):Cn(r,a,M))})),t.data.show&&(n&&n(),I&&I(r,M)),L||P||M()}}}function xn(t,n){function r(){w.cancelled||(t.data.show||((o.parentNode._pending||(o.parentNode._pending={}))[t.key]=t),p&&p(o),g&&(gn(o,c),gn(o,f),_n(function(){gn(o,u),bn(o,c),w.cancelled||b||(On(C)?setTimeout(w,C):Cn(o,s,w))})),d&&d(o,w),g||b||w())}var o=t.elm;o._enterCb&&(o._enterCb.cancelled=!0,o._enterCb());var i=yn(t.data.transition);if(!i)return n();if(!o._leaveCb&&1===o.nodeType){var a=i.css,s=i.type,c=i.leaveClass,u=i.leaveToClass,f=i.leaveActiveClass,p=i.beforeLeave,d=i.leave,v=i.afterLeave,h=i.leaveCancelled,y=i.delayLeave,_=i.duration,g=a!==!1&&!cr,b=Sn(d),C=e(l(_)?_.leave:_),w=o._leaveCb=m(function(){o.parentNode&&o.parentNode._pending&&(o.parentNode._pending[t.key]=null),g&&(bn(o,u),bn(o,f)),w.cancelled?(g&&bn(o,c),h&&h(o)):(n(),v&&v(o)),o._leaveCb=null});y?y(r):r()}}function On(t){return"number"==typeof t&&!isNaN(t)}function Sn(t){if(!t)return!1;var e=t.fns;return e?Sn(Array.isArray(e)?e[0]:e):(t._length||t.length)>1}function En(t,e){e.data.show||kn(e)}function Tn(t,e,n){var r=e.value,o=t.multiple;if(!o||Array.isArray(r)){for(var i,a,s=0,c=t.options.length;s<c;s++)if(a=t.options[s],o)i=h(r,jn(a))>-1,a.selected!==i&&(a.selected=i);else if(v(jn(a),r))return void(t.selectedIndex!==s&&(t.selectedIndex=s));o||(t.selectedIndex=-1)}}function In(t,e){for(var n=0,r=e.length;n<r;n++)if(v(jn(e[n]),t))return!1;return!0}function jn(t){return"_value"in t?t._value:t.value}function Dn(t){t.target.composing=!0}function Nn(t){t.target.composing=!1,Ln(t.target,"input")}function Ln(t,e){var n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function Pn(t){return!t.componentInstance||t.data&&t.data.transition?t:Pn(t.componentInstance._vnode)}function Mn(t){var e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?Mn(Q(e.children)):t}function Un(t){var e={},n=t.$options;for(var r in n.propsData)e[r]=t[r];var o=n._parentListeners;for(var i in o)e[Gn(i)]=o[i];return e}function Rn(t,e){return/\d-keep-alive$/.test(e.tag)?t("keep-alive"):null}function Vn(t){for(;t=t.parent;)if(t.data.transition)return!0}function Bn(t,e){return e.key===t.key&&e.tag===t.tag}function Hn(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function zn(t){t.data.newPos=t.elm.getBoundingClientRect()}function Fn(t){var e=t.data.pos,n=t.data.newPos,r=e.left-n.left,o=e.top-n.top;if(r||o){t.data.moved=!0;var i=t.elm.style;i.transform=i.WebkitTransform="translate("+r+"px,"+o+"px)",i.transitionDuration="0s"}}var qn,Wn,Kn=Object.prototype.hasOwnProperty,Jn=/-(\w)/g,Gn=a(function(t){return t.replace(Jn,function(t,e){return e?e.toUpperCase():""})}),Zn=a(function(t){return t.charAt(0).toUpperCase()+t.slice(1)}),Qn=/([^-])([A-Z])/g,Xn=a(function(t){return t.replace(Qn,"$1-$2").replace(Qn,"$1-$2").toLowerCase()}),Yn=Object.prototype.toString,tr="[object Object]",er=function(){return!1},nr=function(t){return t},rr={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:er,isUnknownElement:er,getTagNamespace:d,parsePlatformTagName:nr,mustUseProp:er,_assetTypes:["component","directive","filter"],_lifecycleHooks:["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated"],_maxUpdateCount:100},or="__proto__"in{},ir="undefined"!=typeof window,ar=ir&&window.navigator.userAgent.toLowerCase(),sr=ar&&/msie|trident/.test(ar),cr=ar&&ar.indexOf("msie 9.0")>0,ur=ar&&ar.indexOf("edge/")>0,lr=ar&&ar.indexOf("android")>0,fr=ar&&/iphone|ipad|ipod|ios/.test(ar),pr=ar&&/chrome\/\d+/.test(ar)&&!ur,dr=function(){return void 0===qn&&(qn=!ir&&"undefined"!=typeof global&&"server"===global.process.env.VUE_ENV),qn},vr=ir&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,hr="undefined"!=typeof Symbol&&y(Symbol)&&"undefined"!=typeof Reflect&&y(Reflect.ownKeys),mr=function(){function t(){r=!1;var t=n.slice(0);n.length=0;for(var e=0;e<t.length;e++)t[e]()}var e,n=[],r=!1;if("undefined"!=typeof Promise&&y(Promise)){var o=Promise.resolve(),i=function(t){console.error(t)};e=function(){o.then(t).catch(i),fr&&setTimeout(d)}}else if("undefined"==typeof MutationObserver||!y(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())e=function(){setTimeout(t,0)};else{var a=1,s=new MutationObserver(t),c=document.createTextNode(String(a));s.observe(c,{characterData:!0}),e=function(){a=(a+1)%2,c.data=String(a)}}return function(t,o){var i;if(n.push(function(){t&&t.call(o),i&&i(o)}),r||(r=!0,e()),!t&&"undefined"!=typeof Promise)return new Promise(function(t){i=t})}}();Wn="undefined"!=typeof Set&&y(Set)?Set:function(){function t(){this.set=Object.create(null)}return t.prototype.has=function(t){return this.set[t]===!0},t.prototype.add=function(t){this.set[t]=!0},t.prototype.clear=function(){this.set=Object.create(null)},t}();var yr=Object.freeze({}),_r=/[^\w.$]/,gr=d,br=0,Cr=function(){this.id=br++,this.subs=[]};Cr.prototype.addSub=function(t){this.subs.push(t)},Cr.prototype.removeSub=function(t){r(this.subs,t)},Cr.prototype.depend=function(){Cr.target&&Cr.target.addDep(this)},Cr.prototype.notify=function(){for(var t=this.subs.slice(),e=0,n=t.length;e<n;e++)t[e].update()},Cr.target=null;var wr=[],$r=Array.prototype,Ar=Object.create($r);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(t){var e=$r[t];g(Ar,t,function(){for(var n=arguments,r=arguments.length,o=new Array(r);r--;)o[r]=n[r];var i,a=e.apply(this,o),s=this.__ob__;switch(t){case"push":i=o;break;case"unshift":i=o;break;case"splice":i=o.slice(2)}return i&&s.observeArray(i),s.dep.notify(),a})});var kr=Object.getOwnPropertyNames(Ar),xr={shouldConvert:!0,isSettingProps:!1},Or=function(t){if(this.value=t,this.dep=new Cr,this.vmCount=0,g(t,"__ob__",this),Array.isArray(t)){var e=or?$:A;e(t,Ar,kr),this.observeArray(t)}else this.walk(t)};Or.prototype.walk=function(t){for(var e=Object.keys(t),n=0;n<e.length;n++)x(t,e[n],t[e[n]])},Or.prototype.observeArray=function(t){for(var e=0,n=t.length;e<n;e++)k(t[e])};var Sr=rr.optionMergeStrategies;Sr.data=function(t,e,n){return n?t||e?function(){var r="function"==typeof e?e.call(n):e,o="function"==typeof t?t.call(n):void 0;return r?T(r,o):o}:void 0:e?"function"!=typeof e?t:t?function(){return T(e.call(this),t.call(this))}:e:t},rr._lifecycleHooks.forEach(function(t){Sr[t]=I}),rr._assetTypes.forEach(function(t){Sr[t+"s"]=j}),Sr.watch=function(t,e){if(!e)return Object.create(t||null);if(!t)return e;var n={};u(n,t);for(var r in e){var o=n[r],i=e[r];o&&!Array.isArray(o)&&(o=[o]),n[r]=o?o.concat(i):[i]}return n},Sr.props=Sr.methods=Sr.computed=function(t,e){if(!e)return Object.create(t||null);if(!t)return e;var n=Object.create(null);return u(n,t),u(n,e),n};var Er=function(t,e){return void 0===e?t:e},Tr=function(t,e,n,r,o,i,a){this.tag=t,this.data=e,this.children=n,this.text=r,this.elm=o,this.ns=void 0,this.context=i,this.functionalContext=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1},Ir={child:{}};Ir.child.get=function(){return this.componentInstance},Object.defineProperties(Tr.prototype,Ir);var jr,Dr=function(){var t=new Tr;return t.text="",t.isComment=!0,t},Nr=a(function(t){var e="~"===t.charAt(0);t=e?t.slice(1):t;var n="!"===t.charAt(0);return t=n?t.slice(1):t,{name:t,once:e,capture:n}}),Lr=null,Pr=[],Mr={},Ur=!1,Rr=!1,Vr=0,Br=0,Hr=function(t,e,n,r){this.vm=t,t._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++Br,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new Wn,this.newDepIds=new Wn,this.expression="","function"==typeof e?this.getter=e:(this.getter=b(e),this.getter||(this.getter=function(){})),this.value=this.lazy?void 0:this.get()};Hr.prototype.get=function(){C(this);var t,e=this.vm;if(this.user)try{t=this.getter.call(e,e)}catch(t){B(t,e,'getter for watcher "'+this.expression+'"')}else t=this.getter.call(e,e);return this.deep&&yt(t),w(),this.cleanupDeps(),t},Hr.prototype.addDep=function(t){var e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))},Hr.prototype.cleanupDeps=function(){for(var t=this,e=this.deps.length;e--;){var n=t.deps[e];t.newDepIds.has(n.id)||n.removeSub(t)}var r=this.depIds;this.depIds=this.newDepIds,this.newDepIds=r,this.newDepIds.clear(),r=this.deps,this.deps=this.newDeps,this.newDeps=r,this.newDeps.length=0},Hr.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():mt(this)},Hr.prototype.run=function(){if(this.active){var t=this.get();if(t!==this.value||l(t)||this.deep){var e=this.value;if(this.value=t,this.user)try{this.cb.call(this.vm,t,e)}catch(t){B(t,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,t,e)}}},Hr.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},Hr.prototype.depend=function(){for(var t=this,e=this.deps.length;e--;)t.deps[e].depend()},Hr.prototype.teardown=function(){var t=this;if(this.active){this.vm._isBeingDestroyed||r(this.vm._watchers,this);for(var e=this.deps.length;e--;)t.deps[e].removeSub(t);this.active=!1}};var zr=new Wn,Fr={enumerable:!0,configurable:!0,get:d,set:d},qr={lazy:!0},Wr={init:Dt,prepatch:Nt,insert:Lt,destroy:Pt},Kr=Object.keys(Wr),Jr=1,Gr=2,Zr=0;ie(le),Et(le),nt(le),st(le),ne(le);var Qr=[String,RegExp],Xr={name:"keep-alive",abstract:!0,props:{include:Qr,exclude:Qr},created:function(){this.cache=Object.create(null)},destroyed:function(){var t=this;for(var e in t.cache)be(t.cache[e])},watch:{include:function(t){ge(this.cache,function(e){return _e(t,e)})},exclude:function(t){ge(this.cache,function(e){return!_e(t,e)})}},render:function(){var t=Q(this.$slots.default),e=t&&t.componentOptions;if(e){var n=ye(e);if(n&&(this.include&&!_e(this.include,n)||this.exclude&&_e(this.exclude,n)))return t;var r=null==t.key?e.Ctor.cid+(e.tag?"::"+e.tag:""):t.key;this.cache[r]?t.componentInstance=this.cache[r].componentInstance:this.cache[r]=t,t.data.keepAlive=!0}return t}},Yr={KeepAlive:Xr};Ce(le),Object.defineProperty(le.prototype,"$isServer",{get:dr}),le.version="2.2.2";var to,eo,no=n("input,textarea,option,select"),ro=function(t,e,n){return"value"===n&&no(t)&&"button"!==e||"selected"===n&&"option"===t||"checked"===n&&"input"===t||"muted"===n&&"video"===t},oo=n("contenteditable,draggable,spellcheck"),io=n("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),ao="http://www.w3.org/1999/xlink",so=function(t){return":"===t.charAt(5)&&"xlink"===t.slice(0,5)},co=function(t){return so(t)?t.slice(6,t.length):""},uo=function(t){return null==t||t===!1},lo={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},fo=n("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template"),po=n("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),vo=function(t){return fo(t)||po(t)},ho=Object.create(null),mo=Object.freeze({createElement:Te,createElementNS:Ie,createTextNode:je,createComment:De,insertBefore:Ne,removeChild:Le,appendChild:Pe,parentNode:Me,nextSibling:Ue,tagName:Re,setTextContent:Ve,setAttribute:Be}),yo={create:function(t,e){He(e)},update:function(t,e){t.data.ref!==e.data.ref&&(He(t,!0),He(e))},destroy:function(t){He(t,!0)}},_o=new Tr("",{},[]),go=["create","activate","update","remove","destroy"],bo={create:Je,update:Je,destroy:function(t){Je(t,_o)}},Co=Object.create(null),wo=[yo,bo],$o={create:Ye,update:Ye},Ao={create:en,update:en},ko="__r",xo="__c",Oo={create:an,update:an},So={create:sn,update:sn},Eo=a(function(t){var e={},n=/;(?![^(]*\))/g,r=/:(.+)/;return t.split(n).forEach(function(t){if(t){var n=t.split(r);n.length>1&&(e[n[0].trim()]=n[1].trim())}}),e}),To=/^--/,Io=/\s*!important$/,jo=function(t,e,n){To.test(e)?t.style.setProperty(e,n):Io.test(n)?t.style.setProperty(e,n.replace(Io,""),"important"):t.style[No(e)]=n},Do=["Webkit","Moz","ms"],No=a(function(t){if(eo=eo||document.createElement("div"),t=Gn(t),"filter"!==t&&t in eo.style)return t;for(var e=t.charAt(0).toUpperCase()+t.slice(1),n=0;n<Do.length;n++){var r=Do[n]+e;if(r in eo.style)return r}}),Lo={create:vn,update:vn},Po=a(function(t){return{enterClass:t+"-enter",enterToClass:t+"-enter-to",enterActiveClass:t+"-enter-active",leaveClass:t+"-leave",leaveToClass:t+"-leave-to",leaveActiveClass:t+"-leave-active"}}),Mo=ir&&!cr,Uo="transition",Ro="animation",Vo="transition",Bo="transitionend",Ho="animation",zo="animationend";Mo&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vo="WebkitTransition",Bo="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ho="WebkitAnimation",zo="webkitAnimationEnd"));var Fo=ir&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout,qo=/\b(transform|all)(,|$)/,Wo=ir?{create:En,activate:En,remove:function(t,e){t.data.show?e():xn(t,e)}}:{},Ko=[$o,Ao,Oo,So,Lo,Wo],Jo=Ko.concat(wo),Go=Ke({nodeOps:mo,modules:Jo});cr&&document.addEventListener("selectionchange",function(){var t=document.activeElement;t&&t.vmodel&&Ln(t,"input")});var Zo={inserted:function(t,e,n){if("select"===n.tag){var r=function(){Tn(t,e,n.context)};r(),(sr||ur)&&setTimeout(r,0)}else"textarea"!==n.tag&&"text"!==t.type||(t._vModifiers=e.modifiers,e.modifiers.lazy||(lr||(t.addEventListener("compositionstart",Dn),t.addEventListener("compositionend",Nn)),cr&&(t.vmodel=!0)))},componentUpdated:function(t,e,n){if("select"===n.tag){Tn(t,e,n.context);var r=t.multiple?e.value.some(function(e){return In(e,t.options)}):e.value!==e.oldValue&&In(e.value,t.options);r&&Ln(t,"change")}}},Qo={bind:function(t,e,n){var r=e.value;n=Pn(n);var o=n.data&&n.data.transition,i=t.__vOriginalDisplay="none"===t.style.display?"":t.style.display;r&&o&&!cr?(n.data.show=!0,kn(n,function(){t.style.display=i})):t.style.display=r?i:"none"},update:function(t,e,n){var r=e.value,o=e.oldValue;if(r!==o){n=Pn(n);var i=n.data&&n.data.transition;i&&!cr?(n.data.show=!0,r?kn(n,function(){t.style.display=t.__vOriginalDisplay}):xn(n,function(){t.style.display="none"})):t.style.display=r?t.__vOriginalDisplay:"none"}},unbind:function(t,e,n,r,o){o||(t.style.display=t.__vOriginalDisplay)}},Xo={model:Zo,show:Qo},Yo={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]},ti={name:"transition",props:Yo,abstract:!0,render:function(t){var e=this,n=this.$slots.default;if(n&&(n=n.filter(function(t){return t.tag}),n.length)){var r=this.mode,o=n[0];if(Vn(this.$vnode))return o;var a=Mn(o);if(!a)return o;if(this._leaving)return Rn(t,o);var s="__transition-"+this._uid+"-";a.key=null==a.key?s+a.tag:i(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=Un(this),l=this._vnode,f=Mn(l);if(a.data.directives&&a.data.directives.some(function(t){return"show"===t.name})&&(a.data.show=!0),f&&f.data&&!Bn(a,f)){var p=f&&(f.data.transition=u({},c));if("out-in"===r)return this._leaving=!0,K(p,"afterLeave",function(){e._leaving=!1,e.$forceUpdate()}),Rn(t,o);if("in-out"===r){var d,v=function(){d()};K(c,"afterEnter",v),K(c,"enterCancelled",v),K(p,"delayLeave",function(t){d=t})}}return o}}},ei=u({tag:String,moveClass:String},Yo);delete ei.mode;var ni={props:ei,render:function(t){for(var e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],i=this.children=[],a=Un(this),s=0;s<o.length;s++){var c=o[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(i.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=t(e,null,u),this.removed=l}return t(e,null,i)},beforeUpdate:function(){this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept},updated:function(){var t=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";if(t.length&&this.hasMove(t[0].elm,e)){t.forEach(Hn),t.forEach(zn),t.forEach(Fn);var n=document.body;n.offsetHeight;t.forEach(function(t){if(t.data.moved){var n=t.elm,r=n.style;gn(n,e),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Bo,n._moveCb=function t(r){r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Bo,t),n._moveCb=null,bn(n,e))})}})}},methods:{hasMove:function(t,e){if(!Mo)return!1;if(null!=this._hasMove)return this._hasMove;var n=t.cloneNode();t._transitionClasses&&t._transitionClasses.forEach(function(t){mn(n,t)}),hn(n,e),n.style.display="none",this.$el.appendChild(n);var r=wn(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}},ri={Transition:ti,TransitionGroup:ni};return le.config.mustUseProp=ro,le.config.isReservedTag=vo,le.config.getTagNamespace=Oe,le.config.isUnknownElement=Se,u(le.options.directives,Xo),u(le.options.components,ri),le.prototype.__patch__=ir?Go:d,le.prototype.$mount=function(t,e){return t=t&&ir?Ee(t):void 0,ct(this,t,e)},setTimeout(function(){rr.devtools&&vr&&vr.emit("init",le)},0),le});
\ No newline at end of file
Index: public/node_modules/vue-resource/src/url/root.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/url/root.js	(revision )
+++ public/node_modules/vue-resource/src/url/root.js	(revision )
@@ -0,0 +1,16 @@
+/**
+ * Root Prefix Transform.
+ */
+
+import { isString } from '../util';
+
+export default function (options, next) {
+
+    var url = next(options);
+
+    if (isString(options.root) && !url.match(/^(https?:)?\//)) {
+        url = options.root + '/' + url;
+    }
+
+    return url;
+}
Index: public/node_modules/vue/src/core/instance/render-helpers/render-slot.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render-helpers/render-slot.js	(revision )
+++ public/node_modules/vue/src/core/instance/render-helpers/render-slot.js	(revision )
@@ -0,0 +1,34 @@
+/* @flow */
+
+import { extend, warn } from 'core/util/index'
+
+/**
+ * Runtime helper for rendering <slot>
+ */
+export function renderSlot (
+  name: string,
+  fallback: ?Array<VNode>,
+  props: ?Object,
+  bindObject: ?Object
+): ?Array<VNode> {
+  const scopedSlotFn = this.$scopedSlots[name]
+  if (scopedSlotFn) { // scoped slot
+    props = props || {}
+    if (bindObject) {
+      extend(props, bindObject)
+    }
+    return scopedSlotFn(props) || fallback
+  } else {
+    const slotNodes = this.$slots[name]
+    // warn duplicate slot usage
+    if (slotNodes && process.env.NODE_ENV !== 'production') {
+      slotNodes._rendered && warn(
+        `Duplicate presence of slot "${name}" found in the same render tree ` +
+        `- this will likely cause render errors.`,
+        this
+      )
+      slotNodes._rendered = true
+    }
+    return slotNodes || fallback
+  }
+}
Index: public/node_modules/vue/src/core/vdom/helpers/update-listeners.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/helpers/update-listeners.js	(revision )
+++ public/node_modules/vue/src/core/vdom/helpers/update-listeners.js	(revision )
@@ -0,0 +1,71 @@
+/* @flow */
+
+import { cached } from 'shared/util'
+import { warn } from 'core/util/index'
+
+const normalizeEvent = cached((name: string): {
+  name: string,
+  once: boolean,
+  capture: boolean
+} => {
+  const once = name.charAt(0) === '~' // Prefixed last, checked first
+  name = once ? name.slice(1) : name
+  const capture = name.charAt(0) === '!'
+  name = capture ? name.slice(1) : name
+  return {
+    name,
+    once,
+    capture
+  }
+})
+
+export function createFnInvoker (fns: Function | Array<Function>): Function {
+  function invoker () {
+    const fns = invoker.fns
+    if (Array.isArray(fns)) {
+      for (let i = 0; i < fns.length; i++) {
+        fns[i].apply(null, arguments)
+      }
+    } else {
+      // return handler return value for single handlers
+      return fns.apply(null, arguments)
+    }
+  }
+  invoker.fns = fns
+  return invoker
+}
+
+export function updateListeners (
+  on: Object,
+  oldOn: Object,
+  add: Function,
+  remove: Function,
+  vm: Component
+) {
+  let name, cur, old, event
+  for (name in on) {
+    cur = on[name]
+    old = oldOn[name]
+    event = normalizeEvent(name)
+    if (!cur) {
+      process.env.NODE_ENV !== 'production' && warn(
+        `Invalid handler for event "${event.name}": got ` + String(cur),
+        vm
+      )
+    } else if (!old) {
+      if (!cur.fns) {
+        cur = on[name] = createFnInvoker(cur)
+      }
+      add(event.name, cur, event.once, event.capture)
+    } else if (cur !== old) {
+      old.fns = cur
+      on[name] = old
+    }
+  }
+  for (name in oldOn) {
+    if (!on[name]) {
+      event = normalizeEvent(name)
+      remove(event.name, oldOn[name], event.capture)
+    }
+  }
+}
Index: public/node_modules/vue-select2/demo/demo.all.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/demo/demo.all.js	(revision )
+++ public/node_modules/vue-select2/demo/demo.all.js	(revision )
@@ -0,0 +1,11381 @@
+/*!
+ * vue-select2 v0.2.4
+ * (c) 2016 Haixing Hu
+ * Released under the MIT License.
+ */
+/******/ (function(modules) { // webpackBootstrap
+/******/ 	// The module cache
+/******/ 	var installedModules = {};
+
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+
+/******/ 		// Check if module is in cache
+/******/ 		if(installedModules[moduleId])
+/******/ 			return installedModules[moduleId].exports;
+
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = installedModules[moduleId] = {
+/******/ 			exports: {},
+/******/ 			id: moduleId,
+/******/ 			loaded: false
+/******/ 		};
+
+/******/ 		// Execute the module function
+/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
+
+/******/ 		// Flag the module as loaded
+/******/ 		module.loaded = true;
+
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+
+
+/******/ 	// expose the modules object (__webpack_modules__)
+/******/ 	__webpack_require__.m = modules;
+
+/******/ 	// expose the module cache
+/******/ 	__webpack_require__.c = installedModules;
+
+/******/ 	// __webpack_public_path__
+/******/ 	__webpack_require__.p = "";
+
+/******/ 	// Load entry module and return exports
+/******/ 	return __webpack_require__(0);
+/******/ })
+/************************************************************************/
+/******/ ([
+/* 0 */
+/***/ function(module, exports, __webpack_require__) {
+
+	var Vue = __webpack_require__(1);
+
+	var vm = new Vue({
+	  components: {
+	    "demo": __webpack_require__(3)
+	  },
+	  data: {
+	    result1: null,
+	    result2: "value2",
+	    result3: "value6"
+	  }
+	});
+
+	vm.$mount("#app");
+
+
+/***/ },
+/* 1 */
+/***/ function(module, exports, __webpack_require__) {
+
+	module.exports = __webpack_require__(2);
+
+/***/ },
+/* 2 */
+/***/ function(module, exports, __webpack_require__) {
+
+	/* WEBPACK VAR INJECTION */(function(global) {/*!
+	 * Vue.js v1.0.24
+	 * (c) 2016 Evan You
+	 * Released under the MIT License.
+	 */
+	(function (global, factory) {
+	   true ? module.exports = factory() :
+	  typeof define === 'function' && define.amd ? define(factory) :
+	  (global.Vue = factory());
+	}(this, function () { 'use strict';
+
+	  function set(obj, key, val) {
+	    if (hasOwn(obj, key)) {
+	      obj[key] = val;
+	      return;
+	    }
+	    if (obj._isVue) {
+	      set(obj._data, key, val);
+	      return;
+	    }
+	    var ob = obj.__ob__;
+	    if (!ob) {
+	      obj[key] = val;
+	      return;
+	    }
+	    ob.convert(key, val);
+	    ob.dep.notify();
+	    if (ob.vms) {
+	      var i = ob.vms.length;
+	      while (i--) {
+	        var vm = ob.vms[i];
+	        vm._proxy(key);
+	        vm._digest();
+	      }
+	    }
+	    return val;
+	  }
+
+	  /**
+	   * Delete a property and trigger change if necessary.
+	   *
+	   * @param {Object} obj
+	   * @param {String} key
+	   */
+
+	  function del(obj, key) {
+	    if (!hasOwn(obj, key)) {
+	      return;
+	    }
+	    delete obj[key];
+	    var ob = obj.__ob__;
+	    if (!ob) {
+	      if (obj._isVue) {
+	        delete obj._data[key];
+	        obj._digest();
+	      }
+	      return;
+	    }
+	    ob.dep.notify();
+	    if (ob.vms) {
+	      var i = ob.vms.length;
+	      while (i--) {
+	        var vm = ob.vms[i];
+	        vm._unproxy(key);
+	        vm._digest();
+	      }
+	    }
+	  }
+
+	  var hasOwnProperty = Object.prototype.hasOwnProperty;
+	  /**
+	   * Check whether the object has the property.
+	   *
+	   * @param {Object} obj
+	   * @param {String} key
+	   * @return {Boolean}
+	   */
+
+	  function hasOwn(obj, key) {
+	    return hasOwnProperty.call(obj, key);
+	  }
+
+	  /**
+	   * Check if an expression is a literal value.
+	   *
+	   * @param {String} exp
+	   * @return {Boolean}
+	   */
+
+	  var literalValueRE = /^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/;
+
+	  function isLiteral(exp) {
+	    return literalValueRE.test(exp);
+	  }
+
+	  /**
+	   * Check if a string starts with $ or _
+	   *
+	   * @param {String} str
+	   * @return {Boolean}
+	   */
+
+	  function isReserved(str) {
+	    var c = (str + '').charCodeAt(0);
+	    return c === 0x24 || c === 0x5F;
+	  }
+
+	  /**
+	   * Guard text output, make sure undefined outputs
+	   * empty string
+	   *
+	   * @param {*} value
+	   * @return {String}
+	   */
+
+	  function _toString(value) {
+	    return value == null ? '' : value.toString();
+	  }
+
+	  /**
+	   * Check and convert possible numeric strings to numbers
+	   * before setting back to data
+	   *
+	   * @param {*} value
+	   * @return {*|Number}
+	   */
+
+	  function toNumber(value) {
+	    if (typeof value !== 'string') {
+	      return value;
+	    } else {
+	      var parsed = Number(value);
+	      return isNaN(parsed) ? value : parsed;
+	    }
+	  }
+
+	  /**
+	   * Convert string boolean literals into real booleans.
+	   *
+	   * @param {*} value
+	   * @return {*|Boolean}
+	   */
+
+	  function toBoolean(value) {
+	    return value === 'true' ? true : value === 'false' ? false : value;
+	  }
+
+	  /**
+	   * Strip quotes from a string
+	   *
+	   * @param {String} str
+	   * @return {String | false}
+	   */
+
+	  function stripQuotes(str) {
+	    var a = str.charCodeAt(0);
+	    var b = str.charCodeAt(str.length - 1);
+	    return a === b && (a === 0x22 || a === 0x27) ? str.slice(1, -1) : str;
+	  }
+
+	  /**
+	   * Camelize a hyphen-delmited string.
+	   *
+	   * @param {String} str
+	   * @return {String}
+	   */
+
+	  var camelizeRE = /-(\w)/g;
+
+	  function camelize(str) {
+	    return str.replace(camelizeRE, toUpper);
+	  }
+
+	  function toUpper(_, c) {
+	    return c ? c.toUpperCase() : '';
+	  }
+
+	  /**
+	   * Hyphenate a camelCase string.
+	   *
+	   * @param {String} str
+	   * @return {String}
+	   */
+
+	  var hyphenateRE = /([a-z\d])([A-Z])/g;
+
+	  function hyphenate(str) {
+	    return str.replace(hyphenateRE, '$1-$2').toLowerCase();
+	  }
+
+	  /**
+	   * Converts hyphen/underscore/slash delimitered names into
+	   * camelized classNames.
+	   *
+	   * e.g. my-component => MyComponent
+	   *      some_else    => SomeElse
+	   *      some/comp    => SomeComp
+	   *
+	   * @param {String} str
+	   * @return {String}
+	   */
+
+	  var classifyRE = /(?:^|[-_\/])(\w)/g;
+
+	  function classify(str) {
+	    return str.replace(classifyRE, toUpper);
+	  }
+
+	  /**
+	   * Simple bind, faster than native
+	   *
+	   * @param {Function} fn
+	   * @param {Object} ctx
+	   * @return {Function}
+	   */
+
+	  function bind(fn, ctx) {
+	    return function (a) {
+	      var l = arguments.length;
+	      return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
+	    };
+	  }
+
+	  /**
+	   * Convert an Array-like object to a real Array.
+	   *
+	   * @param {Array-like} list
+	   * @param {Number} [start] - start index
+	   * @return {Array}
+	   */
+
+	  function toArray(list, start) {
+	    start = start || 0;
+	    var i = list.length - start;
+	    var ret = new Array(i);
+	    while (i--) {
+	      ret[i] = list[i + start];
+	    }
+	    return ret;
+	  }
+
+	  /**
+	   * Mix properties into target object.
+	   *
+	   * @param {Object} to
+	   * @param {Object} from
+	   */
+
+	  function extend(to, from) {
+	    var keys = Object.keys(from);
+	    var i = keys.length;
+	    while (i--) {
+	      to[keys[i]] = from[keys[i]];
+	    }
+	    return to;
+	  }
+
+	  /**
+	   * Quick object check - this is primarily used to tell
+	   * Objects from primitive values when we know the value
+	   * is a JSON-compliant type.
+	   *
+	   * @param {*} obj
+	   * @return {Boolean}
+	   */
+
+	  function isObject(obj) {
+	    return obj !== null && typeof obj === 'object';
+	  }
+
+	  /**
+	   * Strict object type check. Only returns true
+	   * for plain JavaScript objects.
+	   *
+	   * @param {*} obj
+	   * @return {Boolean}
+	   */
+
+	  var toString = Object.prototype.toString;
+	  var OBJECT_STRING = '[object Object]';
+
+	  function isPlainObject(obj) {
+	    return toString.call(obj) === OBJECT_STRING;
+	  }
+
+	  /**
+	   * Array type check.
+	   *
+	   * @param {*} obj
+	   * @return {Boolean}
+	   */
+
+	  var isArray = Array.isArray;
+
+	  /**
+	   * Define a property.
+	   *
+	   * @param {Object} obj
+	   * @param {String} key
+	   * @param {*} val
+	   * @param {Boolean} [enumerable]
+	   */
+
+	  function def(obj, key, val, enumerable) {
+	    Object.defineProperty(obj, key, {
+	      value: val,
+	      enumerable: !!enumerable,
+	      writable: true,
+	      configurable: true
+	    });
+	  }
+
+	  /**
+	   * Debounce a function so it only gets called after the
+	   * input stops arriving after the given wait period.
+	   *
+	   * @param {Function} func
+	   * @param {Number} wait
+	   * @return {Function} - the debounced function
+	   */
+
+	  function _debounce(func, wait) {
+	    var timeout, args, context, timestamp, result;
+	    var later = function later() {
+	      var last = Date.now() - timestamp;
+	      if (last < wait && last >= 0) {
+	        timeout = setTimeout(later, wait - last);
+	      } else {
+	        timeout = null;
+	        result = func.apply(context, args);
+	        if (!timeout) context = args = null;
+	      }
+	    };
+	    return function () {
+	      context = this;
+	      args = arguments;
+	      timestamp = Date.now();
+	      if (!timeout) {
+	        timeout = setTimeout(later, wait);
+	      }
+	      return result;
+	    };
+	  }
+
+	  /**
+	   * Manual indexOf because it's slightly faster than
+	   * native.
+	   *
+	   * @param {Array} arr
+	   * @param {*} obj
+	   */
+
+	  function indexOf(arr, obj) {
+	    var i = arr.length;
+	    while (i--) {
+	      if (arr[i] === obj) return i;
+	    }
+	    return -1;
+	  }
+
+	  /**
+	   * Make a cancellable version of an async callback.
+	   *
+	   * @param {Function} fn
+	   * @return {Function}
+	   */
+
+	  function cancellable(fn) {
+	    var cb = function cb() {
+	      if (!cb.cancelled) {
+	        return fn.apply(this, arguments);
+	      }
+	    };
+	    cb.cancel = function () {
+	      cb.cancelled = true;
+	    };
+	    return cb;
+	  }
+
+	  /**
+	   * Check if two values are loosely equal - that is,
+	   * if they are plain objects, do they have the same shape?
+	   *
+	   * @param {*} a
+	   * @param {*} b
+	   * @return {Boolean}
+	   */
+
+	  function looseEqual(a, b) {
+	    /* eslint-disable eqeqeq */
+	    return a == b || (isObject(a) && isObject(b) ? JSON.stringify(a) === JSON.stringify(b) : false);
+	    /* eslint-enable eqeqeq */
+	  }
+
+	  var hasProto = ('__proto__' in {});
+
+	  // Browser environment sniffing
+	  var inBrowser = typeof window !== 'undefined' && Object.prototype.toString.call(window) !== '[object Object]';
+
+	  // detect devtools
+	  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
+
+	  // UA sniffing for working around browser-specific quirks
+	  var UA = inBrowser && window.navigator.userAgent.toLowerCase();
+	  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
+	  var isAndroid = UA && UA.indexOf('android') > 0;
+	  var isIos = UA && /(iphone|ipad|ipod|ios)/i.test(UA);
+	  var isWechat = UA && UA.indexOf('micromessenger') > 0;
+
+	  var transitionProp = undefined;
+	  var transitionEndEvent = undefined;
+	  var animationProp = undefined;
+	  var animationEndEvent = undefined;
+
+	  // Transition property/event sniffing
+	  if (inBrowser && !isIE9) {
+	    var isWebkitTrans = window.ontransitionend === undefined && window.onwebkittransitionend !== undefined;
+	    var isWebkitAnim = window.onanimationend === undefined && window.onwebkitanimationend !== undefined;
+	    transitionProp = isWebkitTrans ? 'WebkitTransition' : 'transition';
+	    transitionEndEvent = isWebkitTrans ? 'webkitTransitionEnd' : 'transitionend';
+	    animationProp = isWebkitAnim ? 'WebkitAnimation' : 'animation';
+	    animationEndEvent = isWebkitAnim ? 'webkitAnimationEnd' : 'animationend';
+	  }
+
+	  /**
+	   * Defer a task to execute it asynchronously. Ideally this
+	   * should be executed as a microtask, so we leverage
+	   * MutationObserver if it's available, and fallback to
+	   * setTimeout(0).
+	   *
+	   * @param {Function} cb
+	   * @param {Object} ctx
+	   */
+
+	  var nextTick = (function () {
+	    var callbacks = [];
+	    var pending = false;
+	    var timerFunc;
+	    function nextTickHandler() {
+	      pending = false;
+	      var copies = callbacks.slice(0);
+	      callbacks = [];
+	      for (var i = 0; i < copies.length; i++) {
+	        copies[i]();
+	      }
+	    }
+
+	    /* istanbul ignore if */
+	    if (typeof MutationObserver !== 'undefined' && !(isWechat && isIos)) {
+	      var counter = 1;
+	      var observer = new MutationObserver(nextTickHandler);
+	      var textNode = document.createTextNode(counter);
+	      observer.observe(textNode, {
+	        characterData: true
+	      });
+	      timerFunc = function () {
+	        counter = (counter + 1) % 2;
+	        textNode.data = counter;
+	      };
+	    } else {
+	      // webpack attempts to inject a shim for setImmediate
+	      // if it is used as a global, so we have to work around that to
+	      // avoid bundling unnecessary code.
+	      var context = inBrowser ? window : typeof global !== 'undefined' ? global : {};
+	      timerFunc = context.setImmediate || setTimeout;
+	    }
+	    return function (cb, ctx) {
+	      var func = ctx ? function () {
+	        cb.call(ctx);
+	      } : cb;
+	      callbacks.push(func);
+	      if (pending) return;
+	      pending = true;
+	      timerFunc(nextTickHandler, 0);
+	    };
+	  })();
+
+	  var _Set = undefined;
+	  /* istanbul ignore if */
+	  if (typeof Set !== 'undefined' && Set.toString().match(/native code/)) {
+	    // use native Set when available.
+	    _Set = Set;
+	  } else {
+	    // a non-standard Set polyfill that only works with primitive keys.
+	    _Set = function () {
+	      this.set = Object.create(null);
+	    };
+	    _Set.prototype.has = function (key) {
+	      return this.set[key] !== undefined;
+	    };
+	    _Set.prototype.add = function (key) {
+	      this.set[key] = 1;
+	    };
+	    _Set.prototype.clear = function () {
+	      this.set = Object.create(null);
+	    };
+	  }
+
+	  function Cache(limit) {
+	    this.size = 0;
+	    this.limit = limit;
+	    this.head = this.tail = undefined;
+	    this._keymap = Object.create(null);
+	  }
+
+	  var p = Cache.prototype;
+
+	  /**
+	   * Put <value> into the cache associated with <key>.
+	   * Returns the entry which was removed to make room for
+	   * the new entry. Otherwise undefined is returned.
+	   * (i.e. if there was enough room already).
+	   *
+	   * @param {String} key
+	   * @param {*} value
+	   * @return {Entry|undefined}
+	   */
+
+	  p.put = function (key, value) {
+	    var removed;
+	    if (this.size === this.limit) {
+	      removed = this.shift();
+	    }
+
+	    var entry = this.get(key, true);
+	    if (!entry) {
+	      entry = {
+	        key: key
+	      };
+	      this._keymap[key] = entry;
+	      if (this.tail) {
+	        this.tail.newer = entry;
+	        entry.older = this.tail;
+	      } else {
+	        this.head = entry;
+	      }
+	      this.tail = entry;
+	      this.size++;
+	    }
+	    entry.value = value;
+
+	    return removed;
+	  };
+
+	  /**
+	   * Purge the least recently used (oldest) entry from the
+	   * cache. Returns the removed entry or undefined if the
+	   * cache was empty.
+	   */
+
+	  p.shift = function () {
+	    var entry = this.head;
+	    if (entry) {
+	      this.head = this.head.newer;
+	      this.head.older = undefined;
+	      entry.newer = entry.older = undefined;
+	      this._keymap[entry.key] = undefined;
+	      this.size--;
+	    }
+	    return entry;
+	  };
+
+	  /**
+	   * Get and register recent use of <key>. Returns the value
+	   * associated with <key> or undefined if not in cache.
+	   *
+	   * @param {String} key
+	   * @param {Boolean} returnEntry
+	   * @return {Entry|*}
+	   */
+
+	  p.get = function (key, returnEntry) {
+	    var entry = this._keymap[key];
+	    if (entry === undefined) return;
+	    if (entry === this.tail) {
+	      return returnEntry ? entry : entry.value;
+	    }
+	    // HEAD--------------TAIL
+	    //   <.older   .newer>
+	    //  <--- add direction --
+	    //   A  B  C  <D>  E
+	    if (entry.newer) {
+	      if (entry === this.head) {
+	        this.head = entry.newer;
+	      }
+	      entry.newer.older = entry.older; // C <-- E.
+	    }
+	    if (entry.older) {
+	      entry.older.newer = entry.newer; // C. --> E
+	    }
+	    entry.newer = undefined; // D --x
+	    entry.older = this.tail; // D. --> E
+	    if (this.tail) {
+	      this.tail.newer = entry; // E. <-- D
+	    }
+	    this.tail = entry;
+	    return returnEntry ? entry : entry.value;
+	  };
+
+	  var cache$1 = new Cache(1000);
+	  var filterTokenRE = /[^\s'"]+|'[^']*'|"[^"]*"/g;
+	  var reservedArgRE = /^in$|^-?\d+/;
+
+	  /**
+	   * Parser state
+	   */
+
+	  var str;
+	  var dir;
+	  var c;
+	  var prev;
+	  var i;
+	  var l;
+	  var lastFilterIndex;
+	  var inSingle;
+	  var inDouble;
+	  var curly;
+	  var square;
+	  var paren;
+	  /**
+	   * Push a filter to the current directive object
+	   */
+
+	  function pushFilter() {
+	    var exp = str.slice(lastFilterIndex, i).trim();
+	    var filter;
+	    if (exp) {
+	      filter = {};
+	      var tokens = exp.match(filterTokenRE);
+	      filter.name = tokens[0];
+	      if (tokens.length > 1) {
+	        filter.args = tokens.slice(1).map(processFilterArg);
+	      }
+	    }
+	    if (filter) {
+	      (dir.filters = dir.filters || []).push(filter);
+	    }
+	    lastFilterIndex = i + 1;
+	  }
+
+	  /**
+	   * Check if an argument is dynamic and strip quotes.
+	   *
+	   * @param {String} arg
+	   * @return {Object}
+	   */
+
+	  function processFilterArg(arg) {
+	    if (reservedArgRE.test(arg)) {
+	      return {
+	        value: toNumber(arg),
+	        dynamic: false
+	      };
+	    } else {
+	      var stripped = stripQuotes(arg);
+	      var dynamic = stripped === arg;
+	      return {
+	        value: dynamic ? arg : stripped,
+	        dynamic: dynamic
+	      };
+	    }
+	  }
+
+	  /**
+	   * Parse a directive value and extract the expression
+	   * and its filters into a descriptor.
+	   *
+	   * Example:
+	   *
+	   * "a + 1 | uppercase" will yield:
+	   * {
+	   *   expression: 'a + 1',
+	   *   filters: [
+	   *     { name: 'uppercase', args: null }
+	   *   ]
+	   * }
+	   *
+	   * @param {String} s
+	   * @return {Object}
+	   */
+
+	  function parseDirective(s) {
+	    var hit = cache$1.get(s);
+	    if (hit) {
+	      return hit;
+	    }
+
+	    // reset parser state
+	    str = s;
+	    inSingle = inDouble = false;
+	    curly = square = paren = 0;
+	    lastFilterIndex = 0;
+	    dir = {};
+
+	    for (i = 0, l = str.length; i < l; i++) {
+	      prev = c;
+	      c = str.charCodeAt(i);
+	      if (inSingle) {
+	        // check single quote
+	        if (c === 0x27 && prev !== 0x5C) inSingle = !inSingle;
+	      } else if (inDouble) {
+	        // check double quote
+	        if (c === 0x22 && prev !== 0x5C) inDouble = !inDouble;
+	      } else if (c === 0x7C && // pipe
+	      str.charCodeAt(i + 1) !== 0x7C && str.charCodeAt(i - 1) !== 0x7C) {
+	        if (dir.expression == null) {
+	          // first filter, end of expression
+	          lastFilterIndex = i + 1;
+	          dir.expression = str.slice(0, i).trim();
+	        } else {
+	          // already has filter
+	          pushFilter();
+	        }
+	      } else {
+	        switch (c) {
+	          case 0x22:
+	            inDouble = true;break; // "
+	          case 0x27:
+	            inSingle = true;break; // '
+	          case 0x28:
+	            paren++;break; // (
+	          case 0x29:
+	            paren--;break; // )
+	          case 0x5B:
+	            square++;break; // [
+	          case 0x5D:
+	            square--;break; // ]
+	          case 0x7B:
+	            curly++;break; // {
+	          case 0x7D:
+	            curly--;break; // }
+	        }
+	      }
+	    }
+
+	    if (dir.expression == null) {
+	      dir.expression = str.slice(0, i).trim();
+	    } else if (lastFilterIndex !== 0) {
+	      pushFilter();
+	    }
+
+	    cache$1.put(s, dir);
+	    return dir;
+	  }
+
+	var directive = Object.freeze({
+	    parseDirective: parseDirective
+	  });
+
+	  var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
+	  var cache = undefined;
+	  var tagRE = undefined;
+	  var htmlRE = undefined;
+	  /**
+	   * Escape a string so it can be used in a RegExp
+	   * constructor.
+	   *
+	   * @param {String} str
+	   */
+
+	  function escapeRegex(str) {
+	    return str.replace(regexEscapeRE, '\\$&');
+	  }
+
+	  function compileRegex() {
+	    var open = escapeRegex(config.delimiters[0]);
+	    var close = escapeRegex(config.delimiters[1]);
+	    var unsafeOpen = escapeRegex(config.unsafeDelimiters[0]);
+	    var unsafeClose = escapeRegex(config.unsafeDelimiters[1]);
+	    tagRE = new RegExp(unsafeOpen + '((?:.|\\n)+?)' + unsafeClose + '|' + open + '((?:.|\\n)+?)' + close, 'g');
+	    htmlRE = new RegExp('^' + unsafeOpen + '.*' + unsafeClose + '$');
+	    // reset cache
+	    cache = new Cache(1000);
+	  }
+
+	  /**
+	   * Parse a template text string into an array of tokens.
+	   *
+	   * @param {String} text
+	   * @return {Array<Object> | null}
+	   *               - {String} type
+	   *               - {String} value
+	   *               - {Boolean} [html]
+	   *               - {Boolean} [oneTime]
+	   */
+
+	  function parseText(text) {
+	    if (!cache) {
+	      compileRegex();
+	    }
+	    var hit = cache.get(text);
+	    if (hit) {
+	      return hit;
+	    }
+	    if (!tagRE.test(text)) {
+	      return null;
+	    }
+	    var tokens = [];
+	    var lastIndex = tagRE.lastIndex = 0;
+	    var match, index, html, value, first, oneTime;
+	    /* eslint-disable no-cond-assign */
+	    while (match = tagRE.exec(text)) {
+	      /* eslint-enable no-cond-assign */
+	      index = match.index;
+	      // push text token
+	      if (index > lastIndex) {
+	        tokens.push({
+	          value: text.slice(lastIndex, index)
+	        });
+	      }
+	      // tag token
+	      html = htmlRE.test(match[0]);
+	      value = html ? match[1] : match[2];
+	      first = value.charCodeAt(0);
+	      oneTime = first === 42; // *
+	      value = oneTime ? value.slice(1) : value;
+	      tokens.push({
+	        tag: true,
+	        value: value.trim(),
+	        html: html,
+	        oneTime: oneTime
+	      });
+	      lastIndex = index + match[0].length;
+	    }
+	    if (lastIndex < text.length) {
+	      tokens.push({
+	        value: text.slice(lastIndex)
+	      });
+	    }
+	    cache.put(text, tokens);
+	    return tokens;
+	  }
+
+	  /**
+	   * Format a list of tokens into an expression.
+	   * e.g. tokens parsed from 'a {{b}} c' can be serialized
+	   * into one single expression as '"a " + b + " c"'.
+	   *
+	   * @param {Array} tokens
+	   * @param {Vue} [vm]
+	   * @return {String}
+	   */
+
+	  function tokensToExp(tokens, vm) {
+	    if (tokens.length > 1) {
+	      return tokens.map(function (token) {
+	        return formatToken(token, vm);
+	      }).join('+');
+	    } else {
+	      return formatToken(tokens[0], vm, true);
+	    }
+	  }
+
+	  /**
+	   * Format a single token.
+	   *
+	   * @param {Object} token
+	   * @param {Vue} [vm]
+	   * @param {Boolean} [single]
+	   * @return {String}
+	   */
+
+	  function formatToken(token, vm, single) {
+	    return token.tag ? token.oneTime && vm ? '"' + vm.$eval(token.value) + '"' : inlineFilters(token.value, single) : '"' + token.value + '"';
+	  }
+
+	  /**
+	   * For an attribute with multiple interpolation tags,
+	   * e.g. attr="some-{{thing | filter}}", in order to combine
+	   * the whole thing into a single watchable expression, we
+	   * have to inline those filters. This function does exactly
+	   * that. This is a bit hacky but it avoids heavy changes
+	   * to directive parser and watcher mechanism.
+	   *
+	   * @param {String} exp
+	   * @param {Boolean} single
+	   * @return {String}
+	   */
+
+	  var filterRE = /[^|]\|[^|]/;
+	  function inlineFilters(exp, single) {
+	    if (!filterRE.test(exp)) {
+	      return single ? exp : '(' + exp + ')';
+	    } else {
+	      var dir = parseDirective(exp);
+	      if (!dir.filters) {
+	        return '(' + exp + ')';
+	      } else {
+	        return 'this._applyFilters(' + dir.expression + // value
+	        ',null,' + // oldValue (null for read)
+	        JSON.stringify(dir.filters) + // filter descriptors
+	        ',false)'; // write?
+	      }
+	    }
+	  }
+
+	var text = Object.freeze({
+	    compileRegex: compileRegex,
+	    parseText: parseText,
+	    tokensToExp: tokensToExp
+	  });
+
+	  var delimiters = ['{{', '}}'];
+	  var unsafeDelimiters = ['{{{', '}}}'];
+
+	  var config = Object.defineProperties({
+
+	    /**
+	     * Whether to print debug messages.
+	     * Also enables stack trace for warnings.
+	     *
+	     * @type {Boolean}
+	     */
+
+	    debug: false,
+
+	    /**
+	     * Whether to suppress warnings.
+	     *
+	     * @type {Boolean}
+	     */
+
+	    silent: false,
+
+	    /**
+	     * Whether to use async rendering.
+	     */
+
+	    async: true,
+
+	    /**
+	     * Whether to warn against errors caught when evaluating
+	     * expressions.
+	     */
+
+	    warnExpressionErrors: true,
+
+	    /**
+	     * Whether to allow devtools inspection.
+	     * Disabled by default in production builds.
+	     */
+
+	    devtools: 'development' !== 'production',
+
+	    /**
+	     * Internal flag to indicate the delimiters have been
+	     * changed.
+	     *
+	     * @type {Boolean}
+	     */
+
+	    _delimitersChanged: true,
+
+	    /**
+	     * List of asset types that a component can own.
+	     *
+	     * @type {Array}
+	     */
+
+	    _assetTypes: ['component', 'directive', 'elementDirective', 'filter', 'transition', 'partial'],
+
+	    /**
+	     * prop binding modes
+	     */
+
+	    _propBindingModes: {
+	      ONE_WAY: 0,
+	      TWO_WAY: 1,
+	      ONE_TIME: 2
+	    },
+
+	    /**
+	     * Max circular updates allowed in a batcher flush cycle.
+	     */
+
+	    _maxUpdateCount: 100
+
+	  }, {
+	    delimiters: { /**
+	                   * Interpolation delimiters. Changing these would trigger
+	                   * the text parser to re-compile the regular expressions.
+	                   *
+	                   * @type {Array<String>}
+	                   */
+
+	      get: function get() {
+	        return delimiters;
+	      },
+	      set: function set(val) {
+	        delimiters = val;
+	        compileRegex();
+	      },
+	      configurable: true,
+	      enumerable: true
+	    },
+	    unsafeDelimiters: {
+	      get: function get() {
+	        return unsafeDelimiters;
+	      },
+	      set: function set(val) {
+	        unsafeDelimiters = val;
+	        compileRegex();
+	      },
+	      configurable: true,
+	      enumerable: true
+	    }
+	  });
+
+	  var warn = undefined;
+	  var formatComponentName = undefined;
+
+	  if (true) {
+	    (function () {
+	      var hasConsole = typeof console !== 'undefined';
+
+	      warn = function (msg, vm) {
+	        if (hasConsole && !config.silent) {
+	          console.error('[Vue warn]: ' + msg + (vm ? formatComponentName(vm) : ''));
+	        }
+	      };
+
+	      formatComponentName = function (vm) {
+	        var name = vm._isVue ? vm.$options.name : vm.name;
+	        return name ? ' (found in component: <' + hyphenate(name) + '>)' : '';
+	      };
+	    })();
+	  }
+
+	  /**
+	   * Append with transition.
+	   *
+	   * @param {Element} el
+	   * @param {Element} target
+	   * @param {Vue} vm
+	   * @param {Function} [cb]
+	   */
+
+	  function appendWithTransition(el, target, vm, cb) {
+	    applyTransition(el, 1, function () {
+	      target.appendChild(el);
+	    }, vm, cb);
+	  }
+
+	  /**
+	   * InsertBefore with transition.
+	   *
+	   * @param {Element} el
+	   * @param {Element} target
+	   * @param {Vue} vm
+	   * @param {Function} [cb]
+	   */
+
+	  function beforeWithTransition(el, target, vm, cb) {
+	    applyTransition(el, 1, function () {
+	      before(el, target);
+	    }, vm, cb);
+	  }
+
+	  /**
+	   * Remove with transition.
+	   *
+	   * @param {Element} el
+	   * @param {Vue} vm
+	   * @param {Function} [cb]
+	   */
+
+	  function removeWithTransition(el, vm, cb) {
+	    applyTransition(el, -1, function () {
+	      remove(el);
+	    }, vm, cb);
+	  }
+
+	  /**
+	   * Apply transitions with an operation callback.
+	   *
+	   * @param {Element} el
+	   * @param {Number} direction
+	   *                  1: enter
+	   *                 -1: leave
+	   * @param {Function} op - the actual DOM operation
+	   * @param {Vue} vm
+	   * @param {Function} [cb]
+	   */
+
+	  function applyTransition(el, direction, op, vm, cb) {
+	    var transition = el.__v_trans;
+	    if (!transition ||
+	    // skip if there are no js hooks and CSS transition is
+	    // not supported
+	    !transition.hooks && !transitionEndEvent ||
+	    // skip transitions for initial compile
+	    !vm._isCompiled ||
+	    // if the vm is being manipulated by a parent directive
+	    // during the parent's compilation phase, skip the
+	    // animation.
+	    vm.$parent && !vm.$parent._isCompiled) {
+	      op();
+	      if (cb) cb();
+	      return;
+	    }
+	    var action = direction > 0 ? 'enter' : 'leave';
+	    transition[action](op, cb);
+	  }
+
+	var transition = Object.freeze({
+	    appendWithTransition: appendWithTransition,
+	    beforeWithTransition: beforeWithTransition,
+	    removeWithTransition: removeWithTransition,
+	    applyTransition: applyTransition
+	  });
+
+	  /**
+	   * Query an element selector if it's not an element already.
+	   *
+	   * @param {String|Element} el
+	   * @return {Element}
+	   */
+
+	  function query(el) {
+	    if (typeof el === 'string') {
+	      var selector = el;
+	      el = document.querySelector(el);
+	      if (!el) {
+	        'development' !== 'production' && warn('Cannot find element: ' + selector);
+	      }
+	    }
+	    return el;
+	  }
+
+	  /**
+	   * Check if a node is in the document.
+	   * Note: document.documentElement.contains should work here
+	   * but always returns false for comment nodes in phantomjs,
+	   * making unit tests difficult. This is fixed by doing the
+	   * contains() check on the node's parentNode instead of
+	   * the node itself.
+	   *
+	   * @param {Node} node
+	   * @return {Boolean}
+	   */
+
+	  function inDoc(node) {
+	    if (!node) return false;
+	    var doc = node.ownerDocument.documentElement;
+	    var parent = node.parentNode;
+	    return doc === node || doc === parent || !!(parent && parent.nodeType === 1 && doc.contains(parent));
+	  }
+
+	  /**
+	   * Get and remove an attribute from a node.
+	   *
+	   * @param {Node} node
+	   * @param {String} _attr
+	   */
+
+	  function getAttr(node, _attr) {
+	    var val = node.getAttribute(_attr);
+	    if (val !== null) {
+	      node.removeAttribute(_attr);
+	    }
+	    return val;
+	  }
+
+	  /**
+	   * Get an attribute with colon or v-bind: prefix.
+	   *
+	   * @param {Node} node
+	   * @param {String} name
+	   * @return {String|null}
+	   */
+
+	  function getBindAttr(node, name) {
+	    var val = getAttr(node, ':' + name);
+	    if (val === null) {
+	      val = getAttr(node, 'v-bind:' + name);
+	    }
+	    return val;
+	  }
+
+	  /**
+	   * Check the presence of a bind attribute.
+	   *
+	   * @param {Node} node
+	   * @param {String} name
+	   * @return {Boolean}
+	   */
+
+	  function hasBindAttr(node, name) {
+	    return node.hasAttribute(name) || node.hasAttribute(':' + name) || node.hasAttribute('v-bind:' + name);
+	  }
+
+	  /**
+	   * Insert el before target
+	   *
+	   * @param {Element} el
+	   * @param {Element} target
+	   */
+
+	  function before(el, target) {
+	    target.parentNode.insertBefore(el, target);
+	  }
+
+	  /**
+	   * Insert el after target
+	   *
+	   * @param {Element} el
+	   * @param {Element} target
+	   */
+
+	  function after(el, target) {
+	    if (target.nextSibling) {
+	      before(el, target.nextSibling);
+	    } else {
+	      target.parentNode.appendChild(el);
+	    }
+	  }
+
+	  /**
+	   * Remove el from DOM
+	   *
+	   * @param {Element} el
+	   */
+
+	  function remove(el) {
+	    el.parentNode.removeChild(el);
+	  }
+
+	  /**
+	   * Prepend el to target
+	   *
+	   * @param {Element} el
+	   * @param {Element} target
+	   */
+
+	  function prepend(el, target) {
+	    if (target.firstChild) {
+	      before(el, target.firstChild);
+	    } else {
+	      target.appendChild(el);
+	    }
+	  }
+
+	  /**
+	   * Replace target with el
+	   *
+	   * @param {Element} target
+	   * @param {Element} el
+	   */
+
+	  function replace(target, el) {
+	    var parent = target.parentNode;
+	    if (parent) {
+	      parent.replaceChild(el, target);
+	    }
+	  }
+
+	  /**
+	   * Add event listener shorthand.
+	   *
+	   * @param {Element} el
+	   * @param {String} event
+	   * @param {Function} cb
+	   * @param {Boolean} [useCapture]
+	   */
+
+	  function on(el, event, cb, useCapture) {
+	    el.addEventListener(event, cb, useCapture);
+	  }
+
+	  /**
+	   * Remove event listener shorthand.
+	   *
+	   * @param {Element} el
+	   * @param {String} event
+	   * @param {Function} cb
+	   */
+
+	  function off(el, event, cb) {
+	    el.removeEventListener(event, cb);
+	  }
+
+	  /**
+	   * For IE9 compat: when both class and :class are present
+	   * getAttribute('class') returns wrong value...
+	   *
+	   * @param {Element} el
+	   * @return {String}
+	   */
+
+	  function getClass(el) {
+	    var classname = el.className;
+	    if (typeof classname === 'object') {
+	      classname = classname.baseVal || '';
+	    }
+	    return classname;
+	  }
+
+	  /**
+	   * In IE9, setAttribute('class') will result in empty class
+	   * if the element also has the :class attribute; However in
+	   * PhantomJS, setting `className` does not work on SVG elements...
+	   * So we have to do a conditional check here.
+	   *
+	   * @param {Element} el
+	   * @param {String} cls
+	   */
+
+	  function setClass(el, cls) {
+	    /* istanbul ignore if */
+	    if (isIE9 && !/svg$/.test(el.namespaceURI)) {
+	      el.className = cls;
+	    } else {
+	      el.setAttribute('class', cls);
+	    }
+	  }
+
+	  /**
+	   * Add class with compatibility for IE & SVG
+	   *
+	   * @param {Element} el
+	   * @param {String} cls
+	   */
+
+	  function addClass(el, cls) {
+	    if (el.classList) {
+	      el.classList.add(cls);
+	    } else {
+	      var cur = ' ' + getClass(el) + ' ';
+	      if (cur.indexOf(' ' + cls + ' ') < 0) {
+	        setClass(el, (cur + cls).trim());
+	      }
+	    }
+	  }
+
+	  /**
+	   * Remove class with compatibility for IE & SVG
+	   *
+	   * @param {Element} el
+	   * @param {String} cls
+	   */
+
+	  function removeClass(el, cls) {
+	    if (el.classList) {
+	      el.classList.remove(cls);
+	    } else {
+	      var cur = ' ' + getClass(el) + ' ';
+	      var tar = ' ' + cls + ' ';
+	      while (cur.indexOf(tar) >= 0) {
+	        cur = cur.replace(tar, ' ');
+	      }
+	      setClass(el, cur.trim());
+	    }
+	    if (!el.className) {
+	      el.removeAttribute('class');
+	    }
+	  }
+
+	  /**
+	   * Extract raw content inside an element into a temporary
+	   * container div
+	   *
+	   * @param {Element} el
+	   * @param {Boolean} asFragment
+	   * @return {Element|DocumentFragment}
+	   */
+
+	  function extractContent(el, asFragment) {
+	    var child;
+	    var rawContent;
+	    /* istanbul ignore if */
+	    if (isTemplate(el) && isFragment(el.content)) {
+	      el = el.content;
+	    }
+	    if (el.hasChildNodes()) {
+	      trimNode(el);
+	      rawContent = asFragment ? document.createDocumentFragment() : document.createElement('div');
+	      /* eslint-disable no-cond-assign */
+	      while (child = el.firstChild) {
+	        /* eslint-enable no-cond-assign */
+	        rawContent.appendChild(child);
+	      }
+	    }
+	    return rawContent;
+	  }
+
+	  /**
+	   * Trim possible empty head/tail text and comment
+	   * nodes inside a parent.
+	   *
+	   * @param {Node} node
+	   */
+
+	  function trimNode(node) {
+	    var child;
+	    /* eslint-disable no-sequences */
+	    while ((child = node.firstChild, isTrimmable(child))) {
+	      node.removeChild(child);
+	    }
+	    while ((child = node.lastChild, isTrimmable(child))) {
+	      node.removeChild(child);
+	    }
+	    /* eslint-enable no-sequences */
+	  }
+
+	  function isTrimmable(node) {
+	    return node && (node.nodeType === 3 && !node.data.trim() || node.nodeType === 8);
+	  }
+
+	  /**
+	   * Check if an element is a template tag.
+	   * Note if the template appears inside an SVG its tagName
+	   * will be in lowercase.
+	   *
+	   * @param {Element} el
+	   */
+
+	  function isTemplate(el) {
+	    return el.tagName && el.tagName.toLowerCase() === 'template';
+	  }
+
+	  /**
+	   * Create an "anchor" for performing dom insertion/removals.
+	   * This is used in a number of scenarios:
+	   * - fragment instance
+	   * - v-html
+	   * - v-if
+	   * - v-for
+	   * - component
+	   *
+	   * @param {String} content
+	   * @param {Boolean} persist - IE trashes empty textNodes on
+	   *                            cloneNode(true), so in certain
+	   *                            cases the anchor needs to be
+	   *                            non-empty to be persisted in
+	   *                            templates.
+	   * @return {Comment|Text}
+	   */
+
+	  function createAnchor(content, persist) {
+	    var anchor = config.debug ? document.createComment(content) : document.createTextNode(persist ? ' ' : '');
+	    anchor.__v_anchor = true;
+	    return anchor;
+	  }
+
+	  /**
+	   * Find a component ref attribute that starts with $.
+	   *
+	   * @param {Element} node
+	   * @return {String|undefined}
+	   */
+
+	  var refRE = /^v-ref:/;
+
+	  function findRef(node) {
+	    if (node.hasAttributes()) {
+	      var attrs = node.attributes;
+	      for (var i = 0, l = attrs.length; i < l; i++) {
+	        var name = attrs[i].name;
+	        if (refRE.test(name)) {
+	          return camelize(name.replace(refRE, ''));
+	        }
+	      }
+	    }
+	  }
+
+	  /**
+	   * Map a function to a range of nodes .
+	   *
+	   * @param {Node} node
+	   * @param {Node} end
+	   * @param {Function} op
+	   */
+
+	  function mapNodeRange(node, end, op) {
+	    var next;
+	    while (node !== end) {
+	      next = node.nextSibling;
+	      op(node);
+	      node = next;
+	    }
+	    op(end);
+	  }
+
+	  /**
+	   * Remove a range of nodes with transition, store
+	   * the nodes in a fragment with correct ordering,
+	   * and call callback when done.
+	   *
+	   * @param {Node} start
+	   * @param {Node} end
+	   * @param {Vue} vm
+	   * @param {DocumentFragment} frag
+	   * @param {Function} cb
+	   */
+
+	  function removeNodeRange(start, end, vm, frag, cb) {
+	    var done = false;
+	    var removed = 0;
+	    var nodes = [];
+	    mapNodeRange(start, end, function (node) {
+	      if (node === end) done = true;
+	      nodes.push(node);
+	      removeWithTransition(node, vm, onRemoved);
+	    });
+	    function onRemoved() {
+	      removed++;
+	      if (done && removed >= nodes.length) {
+	        for (var i = 0; i < nodes.length; i++) {
+	          frag.appendChild(nodes[i]);
+	        }
+	        cb && cb();
+	      }
+	    }
+	  }
+
+	  /**
+	   * Check if a node is a DocumentFragment.
+	   *
+	   * @param {Node} node
+	   * @return {Boolean}
+	   */
+
+	  function isFragment(node) {
+	    return node && node.nodeType === 11;
+	  }
+
+	  /**
+	   * Get outerHTML of elements, taking care
+	   * of SVG elements in IE as well.
+	   *
+	   * @param {Element} el
+	   * @return {String}
+	   */
+
+	  function getOuterHTML(el) {
+	    if (el.outerHTML) {
+	      return el.outerHTML;
+	    } else {
+	      var container = document.createElement('div');
+	      container.appendChild(el.cloneNode(true));
+	      return container.innerHTML;
+	    }
+	  }
+
+	  var commonTagRE = /^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i;
+	  var reservedTagRE = /^(slot|partial|component)$/i;
+
+	  var isUnknownElement = undefined;
+	  if (true) {
+	    isUnknownElement = function (el, tag) {
+	      if (tag.indexOf('-') > -1) {
+	        // http://stackoverflow.com/a/28210364/1070244
+	        return el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
+	      } else {
+	        return (/HTMLUnknownElement/.test(el.toString()) &&
+	          // Chrome returns unknown for several HTML5 elements.
+	          // https://code.google.com/p/chromium/issues/detail?id=540526
+	          !/^(data|time|rtc|rb)$/.test(tag)
+	        );
+	      }
+	    };
+	  }
+
+	  /**
+	   * Check if an element is a component, if yes return its
+	   * component id.
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   * @return {Object|undefined}
+	   */
+
+	  function checkComponentAttr(el, options) {
+	    var tag = el.tagName.toLowerCase();
+	    var hasAttrs = el.hasAttributes();
+	    if (!commonTagRE.test(tag) && !reservedTagRE.test(tag)) {
+	      if (resolveAsset(options, 'components', tag)) {
+	        return { id: tag };
+	      } else {
+	        var is = hasAttrs && getIsBinding(el, options);
+	        if (is) {
+	          return is;
+	        } else if (true) {
+	          var expectedTag = options._componentNameMap && options._componentNameMap[tag];
+	          if (expectedTag) {
+	            warn('Unknown custom element: <' + tag + '> - ' + 'did you mean <' + expectedTag + '>? ' + 'HTML is case-insensitive, remember to use kebab-case in templates.');
+	          } else if (isUnknownElement(el, tag)) {
+	            warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.');
+	          }
+	        }
+	      }
+	    } else if (hasAttrs) {
+	      return getIsBinding(el, options);
+	    }
+	  }
+
+	  /**
+	   * Get "is" binding from an element.
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   * @return {Object|undefined}
+	   */
+
+	  function getIsBinding(el, options) {
+	    // dynamic syntax
+	    var exp = el.getAttribute('is');
+	    if (exp != null) {
+	      if (resolveAsset(options, 'components', exp)) {
+	        el.removeAttribute('is');
+	        return { id: exp };
+	      }
+	    } else {
+	      exp = getBindAttr(el, 'is');
+	      if (exp != null) {
+	        return { id: exp, dynamic: true };
+	      }
+	    }
+	  }
+
+	  /**
+	   * Option overwriting strategies are functions that handle
+	   * how to merge a parent option value and a child option
+	   * value into the final value.
+	   *
+	   * All strategy functions follow the same signature:
+	   *
+	   * @param {*} parentVal
+	   * @param {*} childVal
+	   * @param {Vue} [vm]
+	   */
+
+	  var strats = config.optionMergeStrategies = Object.create(null);
+
+	  /**
+	   * Helper that recursively merges two data objects together.
+	   */
+
+	  function mergeData(to, from) {
+	    var key, toVal, fromVal;
+	    for (key in from) {
+	      toVal = to[key];
+	      fromVal = from[key];
+	      if (!hasOwn(to, key)) {
+	        set(to, key, fromVal);
+	      } else if (isObject(toVal) && isObject(fromVal)) {
+	        mergeData(toVal, fromVal);
+	      }
+	    }
+	    return to;
+	  }
+
+	  /**
+	   * Data
+	   */
+
+	  strats.data = function (parentVal, childVal, vm) {
+	    if (!vm) {
+	      // in a Vue.extend merge, both should be functions
+	      if (!childVal) {
+	        return parentVal;
+	      }
+	      if (typeof childVal !== 'function') {
+	        'development' !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
+	        return parentVal;
+	      }
+	      if (!parentVal) {
+	        return childVal;
+	      }
+	      // when parentVal & childVal are both present,
+	      // we need to return a function that returns the
+	      // merged result of both functions... no need to
+	      // check if parentVal is a function here because
+	      // it has to be a function to pass previous merges.
+	      return function mergedDataFn() {
+	        return mergeData(childVal.call(this), parentVal.call(this));
+	      };
+	    } else if (parentVal || childVal) {
+	      return function mergedInstanceDataFn() {
+	        // instance merge
+	        var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
+	        var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : undefined;
+	        if (instanceData) {
+	          return mergeData(instanceData, defaultData);
+	        } else {
+	          return defaultData;
+	        }
+	      };
+	    }
+	  };
+
+	  /**
+	   * El
+	   */
+
+	  strats.el = function (parentVal, childVal, vm) {
+	    if (!vm && childVal && typeof childVal !== 'function') {
+	      'development' !== 'production' && warn('The "el" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);
+	      return;
+	    }
+	    var ret = childVal || parentVal;
+	    // invoke the element factory if this is instance merge
+	    return vm && typeof ret === 'function' ? ret.call(vm) : ret;
+	  };
+
+	  /**
+	   * Hooks and param attributes are merged as arrays.
+	   */
+
+	  strats.init = strats.created = strats.ready = strats.attached = strats.detached = strats.beforeCompile = strats.compiled = strats.beforeDestroy = strats.destroyed = strats.activate = function (parentVal, childVal) {
+	    return childVal ? parentVal ? parentVal.concat(childVal) : isArray(childVal) ? childVal : [childVal] : parentVal;
+	  };
+
+	  /**
+	   * Assets
+	   *
+	   * When a vm is present (instance creation), we need to do
+	   * a three-way merge between constructor options, instance
+	   * options and parent options.
+	   */
+
+	  function mergeAssets(parentVal, childVal) {
+	    var res = Object.create(parentVal || null);
+	    return childVal ? extend(res, guardArrayAssets(childVal)) : res;
+	  }
+
+	  config._assetTypes.forEach(function (type) {
+	    strats[type + 's'] = mergeAssets;
+	  });
+
+	  /**
+	   * Events & Watchers.
+	   *
+	   * Events & watchers hashes should not overwrite one
+	   * another, so we merge them as arrays.
+	   */
+
+	  strats.watch = strats.events = function (parentVal, childVal) {
+	    if (!childVal) return parentVal;
+	    if (!parentVal) return childVal;
+	    var ret = {};
+	    extend(ret, parentVal);
+	    for (var key in childVal) {
+	      var parent = ret[key];
+	      var child = childVal[key];
+	      if (parent && !isArray(parent)) {
+	        parent = [parent];
+	      }
+	      ret[key] = parent ? parent.concat(child) : [child];
+	    }
+	    return ret;
+	  };
+
+	  /**
+	   * Other object hashes.
+	   */
+
+	  strats.props = strats.methods = strats.computed = function (parentVal, childVal) {
+	    if (!childVal) return parentVal;
+	    if (!parentVal) return childVal;
+	    var ret = Object.create(null);
+	    extend(ret, parentVal);
+	    extend(ret, childVal);
+	    return ret;
+	  };
+
+	  /**
+	   * Default strategy.
+	   */
+
+	  var defaultStrat = function defaultStrat(parentVal, childVal) {
+	    return childVal === undefined ? parentVal : childVal;
+	  };
+
+	  /**
+	   * Make sure component options get converted to actual
+	   * constructors.
+	   *
+	   * @param {Object} options
+	   */
+
+	  function guardComponents(options) {
+	    if (options.components) {
+	      var components = options.components = guardArrayAssets(options.components);
+	      var ids = Object.keys(components);
+	      var def;
+	      if (true) {
+	        var map = options._componentNameMap = {};
+	      }
+	      for (var i = 0, l = ids.length; i < l; i++) {
+	        var key = ids[i];
+	        if (commonTagRE.test(key) || reservedTagRE.test(key)) {
+	          'development' !== 'production' && warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
+	          continue;
+	        }
+	        // record a all lowercase <-> kebab-case mapping for
+	        // possible custom element case error warning
+	        if (true) {
+	          map[key.replace(/-/g, '').toLowerCase()] = hyphenate(key);
+	        }
+	        def = components[key];
+	        if (isPlainObject(def)) {
+	          components[key] = Vue.extend(def);
+	        }
+	      }
+	    }
+	  }
+
+	  /**
+	   * Ensure all props option syntax are normalized into the
+	   * Object-based format.
+	   *
+	   * @param {Object} options
+	   */
+
+	  function guardProps(options) {
+	    var props = options.props;
+	    var i, val;
+	    if (isArray(props)) {
+	      options.props = {};
+	      i = props.length;
+	      while (i--) {
+	        val = props[i];
+	        if (typeof val === 'string') {
+	          options.props[val] = null;
+	        } else if (val.name) {
+	          options.props[val.name] = val;
+	        }
+	      }
+	    } else if (isPlainObject(props)) {
+	      var keys = Object.keys(props);
+	      i = keys.length;
+	      while (i--) {
+	        val = props[keys[i]];
+	        if (typeof val === 'function') {
+	          props[keys[i]] = { type: val };
+	        }
+	      }
+	    }
+	  }
+
+	  /**
+	   * Guard an Array-format assets option and converted it
+	   * into the key-value Object format.
+	   *
+	   * @param {Object|Array} assets
+	   * @return {Object}
+	   */
+
+	  function guardArrayAssets(assets) {
+	    if (isArray(assets)) {
+	      var res = {};
+	      var i = assets.length;
+	      var asset;
+	      while (i--) {
+	        asset = assets[i];
+	        var id = typeof asset === 'function' ? asset.options && asset.options.name || asset.id : asset.name || asset.id;
+	        if (!id) {
+	          'development' !== 'production' && warn('Array-syntax assets must provide a "name" or "id" field.');
+	        } else {
+	          res[id] = asset;
+	        }
+	      }
+	      return res;
+	    }
+	    return assets;
+	  }
+
+	  /**
+	   * Merge two option objects into a new one.
+	   * Core utility used in both instantiation and inheritance.
+	   *
+	   * @param {Object} parent
+	   * @param {Object} child
+	   * @param {Vue} [vm] - if vm is present, indicates this is
+	   *                     an instantiation merge.
+	   */
+
+	  function mergeOptions(parent, child, vm) {
+	    guardComponents(child);
+	    guardProps(child);
+	    if (true) {
+	      if (child.propsData && !vm) {
+	        warn('propsData can only be used as an instantiation option.');
+	      }
+	    }
+	    var options = {};
+	    var key;
+	    if (child['extends']) {
+	      parent = typeof child['extends'] === 'function' ? mergeOptions(parent, child['extends'].options, vm) : mergeOptions(parent, child['extends'], vm);
+	    }
+	    if (child.mixins) {
+	      for (var i = 0, l = child.mixins.length; i < l; i++) {
+	        parent = mergeOptions(parent, child.mixins[i], vm);
+	      }
+	    }
+	    for (key in parent) {
+	      mergeField(key);
+	    }
+	    for (key in child) {
+	      if (!hasOwn(parent, key)) {
+	        mergeField(key);
+	      }
+	    }
+	    function mergeField(key) {
+	      var strat = strats[key] || defaultStrat;
+	      options[key] = strat(parent[key], child[key], vm, key);
+	    }
+	    return options;
+	  }
+
+	  /**
+	   * Resolve an asset.
+	   * This function is used because child instances need access
+	   * to assets defined in its ancestor chain.
+	   *
+	   * @param {Object} options
+	   * @param {String} type
+	   * @param {String} id
+	   * @param {Boolean} warnMissing
+	   * @return {Object|Function}
+	   */
+
+	  function resolveAsset(options, type, id, warnMissing) {
+	    /* istanbul ignore if */
+	    if (typeof id !== 'string') {
+	      return;
+	    }
+	    var assets = options[type];
+	    var camelizedId;
+	    var res = assets[id] ||
+	    // camelCase ID
+	    assets[camelizedId = camelize(id)] ||
+	    // Pascal Case ID
+	    assets[camelizedId.charAt(0).toUpperCase() + camelizedId.slice(1)];
+	    if ('development' !== 'production' && warnMissing && !res) {
+	      warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
+	    }
+	    return res;
+	  }
+
+	  var uid$1 = 0;
+
+	  /**
+	   * A dep is an observable that can have multiple
+	   * directives subscribing to it.
+	   *
+	   * @constructor
+	   */
+	  function Dep() {
+	    this.id = uid$1++;
+	    this.subs = [];
+	  }
+
+	  // the current target watcher being evaluated.
+	  // this is globally unique because there could be only one
+	  // watcher being evaluated at any time.
+	  Dep.target = null;
+
+	  /**
+	   * Add a directive subscriber.
+	   *
+	   * @param {Directive} sub
+	   */
+
+	  Dep.prototype.addSub = function (sub) {
+	    this.subs.push(sub);
+	  };
+
+	  /**
+	   * Remove a directive subscriber.
+	   *
+	   * @param {Directive} sub
+	   */
+
+	  Dep.prototype.removeSub = function (sub) {
+	    this.subs.$remove(sub);
+	  };
+
+	  /**
+	   * Add self as a dependency to the target watcher.
+	   */
+
+	  Dep.prototype.depend = function () {
+	    Dep.target.addDep(this);
+	  };
+
+	  /**
+	   * Notify all subscribers of a new value.
+	   */
+
+	  Dep.prototype.notify = function () {
+	    // stablize the subscriber list first
+	    var subs = toArray(this.subs);
+	    for (var i = 0, l = subs.length; i < l; i++) {
+	      subs[i].update();
+	    }
+	  };
+
+	  var arrayProto = Array.prototype;
+	  var arrayMethods = Object.create(arrayProto)
+
+	  /**
+	   * Intercept mutating methods and emit events
+	   */
+
+	  ;['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
+	    // cache original method
+	    var original = arrayProto[method];
+	    def(arrayMethods, method, function mutator() {
+	      // avoid leaking arguments:
+	      // http://jsperf.com/closure-with-arguments
+	      var i = arguments.length;
+	      var args = new Array(i);
+	      while (i--) {
+	        args[i] = arguments[i];
+	      }
+	      var result = original.apply(this, args);
+	      var ob = this.__ob__;
+	      var inserted;
+	      switch (method) {
+	        case 'push':
+	          inserted = args;
+	          break;
+	        case 'unshift':
+	          inserted = args;
+	          break;
+	        case 'splice':
+	          inserted = args.slice(2);
+	          break;
+	      }
+	      if (inserted) ob.observeArray(inserted);
+	      // notify change
+	      ob.dep.notify();
+	      return result;
+	    });
+	  });
+
+	  /**
+	   * Swap the element at the given index with a new value
+	   * and emits corresponding event.
+	   *
+	   * @param {Number} index
+	   * @param {*} val
+	   * @return {*} - replaced element
+	   */
+
+	  def(arrayProto, '$set', function $set(index, val) {
+	    if (index >= this.length) {
+	      this.length = Number(index) + 1;
+	    }
+	    return this.splice(index, 1, val)[0];
+	  });
+
+	  /**
+	   * Convenience method to remove the element at given index or target element reference.
+	   *
+	   * @param {*} item
+	   */
+
+	  def(arrayProto, '$remove', function $remove(item) {
+	    /* istanbul ignore if */
+	    if (!this.length) return;
+	    var index = indexOf(this, item);
+	    if (index > -1) {
+	      return this.splice(index, 1);
+	    }
+	  });
+
+	  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
+
+	  /**
+	   * By default, when a reactive property is set, the new value is
+	   * also converted to become reactive. However in certain cases, e.g.
+	   * v-for scope alias and props, we don't want to force conversion
+	   * because the value may be a nested value under a frozen data structure.
+	   *
+	   * So whenever we want to set a reactive property without forcing
+	   * conversion on the new value, we wrap that call inside this function.
+	   */
+
+	  var shouldConvert = true;
+
+	  function withoutConversion(fn) {
+	    shouldConvert = false;
+	    fn();
+	    shouldConvert = true;
+	  }
+
+	  /**
+	   * Observer class that are attached to each observed
+	   * object. Once attached, the observer converts target
+	   * object's property keys into getter/setters that
+	   * collect dependencies and dispatches updates.
+	   *
+	   * @param {Array|Object} value
+	   * @constructor
+	   */
+
+	  function Observer(value) {
+	    this.value = value;
+	    this.dep = new Dep();
+	    def(value, '__ob__', this);
+	    if (isArray(value)) {
+	      var augment = hasProto ? protoAugment : copyAugment;
+	      augment(value, arrayMethods, arrayKeys);
+	      this.observeArray(value);
+	    } else {
+	      this.walk(value);
+	    }
+	  }
+
+	  // Instance methods
+
+	  /**
+	   * Walk through each property and convert them into
+	   * getter/setters. This method should only be called when
+	   * value type is Object.
+	   *
+	   * @param {Object} obj
+	   */
+
+	  Observer.prototype.walk = function (obj) {
+	    var keys = Object.keys(obj);
+	    for (var i = 0, l = keys.length; i < l; i++) {
+	      this.convert(keys[i], obj[keys[i]]);
+	    }
+	  };
+
+	  /**
+	   * Observe a list of Array items.
+	   *
+	   * @param {Array} items
+	   */
+
+	  Observer.prototype.observeArray = function (items) {
+	    for (var i = 0, l = items.length; i < l; i++) {
+	      observe(items[i]);
+	    }
+	  };
+
+	  /**
+	   * Convert a property into getter/setter so we can emit
+	   * the events when the property is accessed/changed.
+	   *
+	   * @param {String} key
+	   * @param {*} val
+	   */
+
+	  Observer.prototype.convert = function (key, val) {
+	    defineReactive(this.value, key, val);
+	  };
+
+	  /**
+	   * Add an owner vm, so that when $set/$delete mutations
+	   * happen we can notify owner vms to proxy the keys and
+	   * digest the watchers. This is only called when the object
+	   * is observed as an instance's root $data.
+	   *
+	   * @param {Vue} vm
+	   */
+
+	  Observer.prototype.addVm = function (vm) {
+	    (this.vms || (this.vms = [])).push(vm);
+	  };
+
+	  /**
+	   * Remove an owner vm. This is called when the object is
+	   * swapped out as an instance's $data object.
+	   *
+	   * @param {Vue} vm
+	   */
+
+	  Observer.prototype.removeVm = function (vm) {
+	    this.vms.$remove(vm);
+	  };
+
+	  // helpers
+
+	  /**
+	   * Augment an target Object or Array by intercepting
+	   * the prototype chain using __proto__
+	   *
+	   * @param {Object|Array} target
+	   * @param {Object} src
+	   */
+
+	  function protoAugment(target, src) {
+	    /* eslint-disable no-proto */
+	    target.__proto__ = src;
+	    /* eslint-enable no-proto */
+	  }
+
+	  /**
+	   * Augment an target Object or Array by defining
+	   * hidden properties.
+	   *
+	   * @param {Object|Array} target
+	   * @param {Object} proto
+	   */
+
+	  function copyAugment(target, src, keys) {
+	    for (var i = 0, l = keys.length; i < l; i++) {
+	      var key = keys[i];
+	      def(target, key, src[key]);
+	    }
+	  }
+
+	  /**
+	   * Attempt to create an observer instance for a value,
+	   * returns the new observer if successfully observed,
+	   * or the existing observer if the value already has one.
+	   *
+	   * @param {*} value
+	   * @param {Vue} [vm]
+	   * @return {Observer|undefined}
+	   * @static
+	   */
+
+	  function observe(value, vm) {
+	    if (!value || typeof value !== 'object') {
+	      return;
+	    }
+	    var ob;
+	    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+	      ob = value.__ob__;
+	    } else if (shouldConvert && (isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
+	      ob = new Observer(value);
+	    }
+	    if (ob && vm) {
+	      ob.addVm(vm);
+	    }
+	    return ob;
+	  }
+
+	  /**
+	   * Define a reactive property on an Object.
+	   *
+	   * @param {Object} obj
+	   * @param {String} key
+	   * @param {*} val
+	   */
+
+	  function defineReactive(obj, key, val) {
+	    var dep = new Dep();
+
+	    var property = Object.getOwnPropertyDescriptor(obj, key);
+	    if (property && property.configurable === false) {
+	      return;
+	    }
+
+	    // cater for pre-defined getter/setters
+	    var getter = property && property.get;
+	    var setter = property && property.set;
+
+	    var childOb = observe(val);
+	    Object.defineProperty(obj, key, {
+	      enumerable: true,
+	      configurable: true,
+	      get: function reactiveGetter() {
+	        var value = getter ? getter.call(obj) : val;
+	        if (Dep.target) {
+	          dep.depend();
+	          if (childOb) {
+	            childOb.dep.depend();
+	          }
+	          if (isArray(value)) {
+	            for (var e, i = 0, l = value.length; i < l; i++) {
+	              e = value[i];
+	              e && e.__ob__ && e.__ob__.dep.depend();
+	            }
+	          }
+	        }
+	        return value;
+	      },
+	      set: function reactiveSetter(newVal) {
+	        var value = getter ? getter.call(obj) : val;
+	        if (newVal === value) {
+	          return;
+	        }
+	        if (setter) {
+	          setter.call(obj, newVal);
+	        } else {
+	          val = newVal;
+	        }
+	        childOb = observe(newVal);
+	        dep.notify();
+	      }
+	    });
+	  }
+
+
+
+	  var util = Object.freeze({
+	  	defineReactive: defineReactive,
+	  	set: set,
+	  	del: del,
+	  	hasOwn: hasOwn,
+	  	isLiteral: isLiteral,
+	  	isReserved: isReserved,
+	  	_toString: _toString,
+	  	toNumber: toNumber,
+	  	toBoolean: toBoolean,
+	  	stripQuotes: stripQuotes,
+	  	camelize: camelize,
+	  	hyphenate: hyphenate,
+	  	classify: classify,
+	  	bind: bind,
+	  	toArray: toArray,
+	  	extend: extend,
+	  	isObject: isObject,
+	  	isPlainObject: isPlainObject,
+	  	def: def,
+	  	debounce: _debounce,
+	  	indexOf: indexOf,
+	  	cancellable: cancellable,
+	  	looseEqual: looseEqual,
+	  	isArray: isArray,
+	  	hasProto: hasProto,
+	  	inBrowser: inBrowser,
+	  	devtools: devtools,
+	  	isIE9: isIE9,
+	  	isAndroid: isAndroid,
+	  	isIos: isIos,
+	  	isWechat: isWechat,
+	  	get transitionProp () { return transitionProp; },
+	  	get transitionEndEvent () { return transitionEndEvent; },
+	  	get animationProp () { return animationProp; },
+	  	get animationEndEvent () { return animationEndEvent; },
+	  	nextTick: nextTick,
+	  	get _Set () { return _Set; },
+	  	query: query,
+	  	inDoc: inDoc,
+	  	getAttr: getAttr,
+	  	getBindAttr: getBindAttr,
+	  	hasBindAttr: hasBindAttr,
+	  	before: before,
+	  	after: after,
+	  	remove: remove,
+	  	prepend: prepend,
+	  	replace: replace,
+	  	on: on,
+	  	off: off,
+	  	setClass: setClass,
+	  	addClass: addClass,
+	  	removeClass: removeClass,
+	  	extractContent: extractContent,
+	  	trimNode: trimNode,
+	  	isTemplate: isTemplate,
+	  	createAnchor: createAnchor,
+	  	findRef: findRef,
+	  	mapNodeRange: mapNodeRange,
+	  	removeNodeRange: removeNodeRange,
+	  	isFragment: isFragment,
+	  	getOuterHTML: getOuterHTML,
+	  	mergeOptions: mergeOptions,
+	  	resolveAsset: resolveAsset,
+	  	checkComponentAttr: checkComponentAttr,
+	  	commonTagRE: commonTagRE,
+	  	reservedTagRE: reservedTagRE,
+	  	get warn () { return warn; }
+	  });
+
+	  var uid = 0;
+
+	  function initMixin (Vue) {
+	    /**
+	     * The main init sequence. This is called for every
+	     * instance, including ones that are created from extended
+	     * constructors.
+	     *
+	     * @param {Object} options - this options object should be
+	     *                           the result of merging class
+	     *                           options and the options passed
+	     *                           in to the constructor.
+	     */
+
+	    Vue.prototype._init = function (options) {
+	      options = options || {};
+
+	      this.$el = null;
+	      this.$parent = options.parent;
+	      this.$root = this.$parent ? this.$parent.$root : this;
+	      this.$children = [];
+	      this.$refs = {}; // child vm references
+	      this.$els = {}; // element references
+	      this._watchers = []; // all watchers as an array
+	      this._directives = []; // all directives
+
+	      // a uid
+	      this._uid = uid++;
+
+	      // a flag to avoid this being observed
+	      this._isVue = true;
+
+	      // events bookkeeping
+	      this._events = {}; // registered callbacks
+	      this._eventsCount = {}; // for $broadcast optimization
+
+	      // fragment instance properties
+	      this._isFragment = false;
+	      this._fragment = // @type {DocumentFragment}
+	      this._fragmentStart = // @type {Text|Comment}
+	      this._fragmentEnd = null; // @type {Text|Comment}
+
+	      // lifecycle state
+	      this._isCompiled = this._isDestroyed = this._isReady = this._isAttached = this._isBeingDestroyed = this._vForRemoving = false;
+	      this._unlinkFn = null;
+
+	      // context:
+	      // if this is a transcluded component, context
+	      // will be the common parent vm of this instance
+	      // and its host.
+	      this._context = options._context || this.$parent;
+
+	      // scope:
+	      // if this is inside an inline v-for, the scope
+	      // will be the intermediate scope created for this
+	      // repeat fragment. this is used for linking props
+	      // and container directives.
+	      this._scope = options._scope;
+
+	      // fragment:
+	      // if this instance is compiled inside a Fragment, it
+	      // needs to reigster itself as a child of that fragment
+	      // for attach/detach to work properly.
+	      this._frag = options._frag;
+	      if (this._frag) {
+	        this._frag.children.push(this);
+	      }
+
+	      // push self into parent / transclusion host
+	      if (this.$parent) {
+	        this.$parent.$children.push(this);
+	      }
+
+	      // merge options.
+	      options = this.$options = mergeOptions(this.constructor.options, options, this);
+
+	      // set ref
+	      this._updateRef();
+
+	      // initialize data as empty object.
+	      // it will be filled up in _initData().
+	      this._data = {};
+
+	      // call init hook
+	      this._callHook('init');
+
+	      // initialize data observation and scope inheritance.
+	      this._initState();
+
+	      // setup event system and option events.
+	      this._initEvents();
+
+	      // call created hook
+	      this._callHook('created');
+
+	      // if `el` option is passed, start compilation.
+	      if (options.el) {
+	        this.$mount(options.el);
+	      }
+	    };
+	  }
+
+	  var pathCache = new Cache(1000);
+
+	  // actions
+	  var APPEND = 0;
+	  var PUSH = 1;
+	  var INC_SUB_PATH_DEPTH = 2;
+	  var PUSH_SUB_PATH = 3;
+
+	  // states
+	  var BEFORE_PATH = 0;
+	  var IN_PATH = 1;
+	  var BEFORE_IDENT = 2;
+	  var IN_IDENT = 3;
+	  var IN_SUB_PATH = 4;
+	  var IN_SINGLE_QUOTE = 5;
+	  var IN_DOUBLE_QUOTE = 6;
+	  var AFTER_PATH = 7;
+	  var ERROR = 8;
+
+	  var pathStateMachine = [];
+
+	  pathStateMachine[BEFORE_PATH] = {
+	    'ws': [BEFORE_PATH],
+	    'ident': [IN_IDENT, APPEND],
+	    '[': [IN_SUB_PATH],
+	    'eof': [AFTER_PATH]
+	  };
+
+	  pathStateMachine[IN_PATH] = {
+	    'ws': [IN_PATH],
+	    '.': [BEFORE_IDENT],
+	    '[': [IN_SUB_PATH],
+	    'eof': [AFTER_PATH]
+	  };
+
+	  pathStateMachine[BEFORE_IDENT] = {
+	    'ws': [BEFORE_IDENT],
+	    'ident': [IN_IDENT, APPEND]
+	  };
+
+	  pathStateMachine[IN_IDENT] = {
+	    'ident': [IN_IDENT, APPEND],
+	    '0': [IN_IDENT, APPEND],
+	    'number': [IN_IDENT, APPEND],
+	    'ws': [IN_PATH, PUSH],
+	    '.': [BEFORE_IDENT, PUSH],
+	    '[': [IN_SUB_PATH, PUSH],
+	    'eof': [AFTER_PATH, PUSH]
+	  };
+
+	  pathStateMachine[IN_SUB_PATH] = {
+	    "'": [IN_SINGLE_QUOTE, APPEND],
+	    '"': [IN_DOUBLE_QUOTE, APPEND],
+	    '[': [IN_SUB_PATH, INC_SUB_PATH_DEPTH],
+	    ']': [IN_PATH, PUSH_SUB_PATH],
+	    'eof': ERROR,
+	    'else': [IN_SUB_PATH, APPEND]
+	  };
+
+	  pathStateMachine[IN_SINGLE_QUOTE] = {
+	    "'": [IN_SUB_PATH, APPEND],
+	    'eof': ERROR,
+	    'else': [IN_SINGLE_QUOTE, APPEND]
+	  };
+
+	  pathStateMachine[IN_DOUBLE_QUOTE] = {
+	    '"': [IN_SUB_PATH, APPEND],
+	    'eof': ERROR,
+	    'else': [IN_DOUBLE_QUOTE, APPEND]
+	  };
+
+	  /**
+	   * Determine the type of a character in a keypath.
+	   *
+	   * @param {Char} ch
+	   * @return {String} type
+	   */
+
+	  function getPathCharType(ch) {
+	    if (ch === undefined) {
+	      return 'eof';
+	    }
+
+	    var code = ch.charCodeAt(0);
+
+	    switch (code) {
+	      case 0x5B: // [
+	      case 0x5D: // ]
+	      case 0x2E: // .
+	      case 0x22: // "
+	      case 0x27: // '
+	      case 0x30:
+	        // 0
+	        return ch;
+
+	      case 0x5F: // _
+	      case 0x24:
+	        // $
+	        return 'ident';
+
+	      case 0x20: // Space
+	      case 0x09: // Tab
+	      case 0x0A: // Newline
+	      case 0x0D: // Return
+	      case 0xA0: // No-break space
+	      case 0xFEFF: // Byte Order Mark
+	      case 0x2028: // Line Separator
+	      case 0x2029:
+	        // Paragraph Separator
+	        return 'ws';
+	    }
+
+	    // a-z, A-Z
+	    if (code >= 0x61 && code <= 0x7A || code >= 0x41 && code <= 0x5A) {
+	      return 'ident';
+	    }
+
+	    // 1-9
+	    if (code >= 0x31 && code <= 0x39) {
+	      return 'number';
+	    }
+
+	    return 'else';
+	  }
+
+	  /**
+	   * Format a subPath, return its plain form if it is
+	   * a literal string or number. Otherwise prepend the
+	   * dynamic indicator (*).
+	   *
+	   * @param {String} path
+	   * @return {String}
+	   */
+
+	  function formatSubPath(path) {
+	    var trimmed = path.trim();
+	    // invalid leading 0
+	    if (path.charAt(0) === '0' && isNaN(path)) {
+	      return false;
+	    }
+	    return isLiteral(trimmed) ? stripQuotes(trimmed) : '*' + trimmed;
+	  }
+
+	  /**
+	   * Parse a string path into an array of segments
+	   *
+	   * @param {String} path
+	   * @return {Array|undefined}
+	   */
+
+	  function parse(path) {
+	    var keys = [];
+	    var index = -1;
+	    var mode = BEFORE_PATH;
+	    var subPathDepth = 0;
+	    var c, newChar, key, type, transition, action, typeMap;
+
+	    var actions = [];
+
+	    actions[PUSH] = function () {
+	      if (key !== undefined) {
+	        keys.push(key);
+	        key = undefined;
+	      }
+	    };
+
+	    actions[APPEND] = function () {
+	      if (key === undefined) {
+	        key = newChar;
+	      } else {
+	        key += newChar;
+	      }
+	    };
+
+	    actions[INC_SUB_PATH_DEPTH] = function () {
+	      actions[APPEND]();
+	      subPathDepth++;
+	    };
+
+	    actions[PUSH_SUB_PATH] = function () {
+	      if (subPathDepth > 0) {
+	        subPathDepth--;
+	        mode = IN_SUB_PATH;
+	        actions[APPEND]();
+	      } else {
+	        subPathDepth = 0;
+	        key = formatSubPath(key);
+	        if (key === false) {
+	          return false;
+	        } else {
+	          actions[PUSH]();
+	        }
+	      }
+	    };
+
+	    function maybeUnescapeQuote() {
+	      var nextChar = path[index + 1];
+	      if (mode === IN_SINGLE_QUOTE && nextChar === "'" || mode === IN_DOUBLE_QUOTE && nextChar === '"') {
+	        index++;
+	        newChar = '\\' + nextChar;
+	        actions[APPEND]();
+	        return true;
+	      }
+	    }
+
+	    while (mode != null) {
+	      index++;
+	      c = path[index];
+
+	      if (c === '\\' && maybeUnescapeQuote()) {
+	        continue;
+	      }
+
+	      type = getPathCharType(c);
+	      typeMap = pathStateMachine[mode];
+	      transition = typeMap[type] || typeMap['else'] || ERROR;
+
+	      if (transition === ERROR) {
+	        return; // parse error
+	      }
+
+	      mode = transition[0];
+	      action = actions[transition[1]];
+	      if (action) {
+	        newChar = transition[2];
+	        newChar = newChar === undefined ? c : newChar;
+	        if (action() === false) {
+	          return;
+	        }
+	      }
+
+	      if (mode === AFTER_PATH) {
+	        keys.raw = path;
+	        return keys;
+	      }
+	    }
+	  }
+
+	  /**
+	   * External parse that check for a cache hit first
+	   *
+	   * @param {String} path
+	   * @return {Array|undefined}
+	   */
+
+	  function parsePath(path) {
+	    var hit = pathCache.get(path);
+	    if (!hit) {
+	      hit = parse(path);
+	      if (hit) {
+	        pathCache.put(path, hit);
+	      }
+	    }
+	    return hit;
+	  }
+
+	  /**
+	   * Get from an object from a path string
+	   *
+	   * @param {Object} obj
+	   * @param {String} path
+	   */
+
+	  function getPath(obj, path) {
+	    return parseExpression(path).get(obj);
+	  }
+
+	  /**
+	   * Warn against setting non-existent root path on a vm.
+	   */
+
+	  var warnNonExistent;
+	  if (true) {
+	    warnNonExistent = function (path, vm) {
+	      warn('You are setting a non-existent path "' + path.raw + '" ' + 'on a vm instance. Consider pre-initializing the property ' + 'with the "data" option for more reliable reactivity ' + 'and better performance.', vm);
+	    };
+	  }
+
+	  /**
+	   * Set on an object from a path
+	   *
+	   * @param {Object} obj
+	   * @param {String | Array} path
+	   * @param {*} val
+	   */
+
+	  function setPath(obj, path, val) {
+	    var original = obj;
+	    if (typeof path === 'string') {
+	      path = parse(path);
+	    }
+	    if (!path || !isObject(obj)) {
+	      return false;
+	    }
+	    var last, key;
+	    for (var i = 0, l = path.length; i < l; i++) {
+	      last = obj;
+	      key = path[i];
+	      if (key.charAt(0) === '*') {
+	        key = parseExpression(key.slice(1)).get.call(original, original);
+	      }
+	      if (i < l - 1) {
+	        obj = obj[key];
+	        if (!isObject(obj)) {
+	          obj = {};
+	          if ('development' !== 'production' && last._isVue) {
+	            warnNonExistent(path, last);
+	          }
+	          set(last, key, obj);
+	        }
+	      } else {
+	        if (isArray(obj)) {
+	          obj.$set(key, val);
+	        } else if (key in obj) {
+	          obj[key] = val;
+	        } else {
+	          if ('development' !== 'production' && obj._isVue) {
+	            warnNonExistent(path, obj);
+	          }
+	          set(obj, key, val);
+	        }
+	      }
+	    }
+	    return true;
+	  }
+
+	var path = Object.freeze({
+	    parsePath: parsePath,
+	    getPath: getPath,
+	    setPath: setPath
+	  });
+
+	  var expressionCache = new Cache(1000);
+
+	  var allowedKeywords = 'Math,Date,this,true,false,null,undefined,Infinity,NaN,' + 'isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,' + 'encodeURIComponent,parseInt,parseFloat';
+	  var allowedKeywordsRE = new RegExp('^(' + allowedKeywords.replace(/,/g, '\\b|') + '\\b)');
+
+	  // keywords that don't make sense inside expressions
+	  var improperKeywords = 'break,case,class,catch,const,continue,debugger,default,' + 'delete,do,else,export,extends,finally,for,function,if,' + 'import,in,instanceof,let,return,super,switch,throw,try,' + 'var,while,with,yield,enum,await,implements,package,' + 'protected,static,interface,private,public';
+	  var improperKeywordsRE = new RegExp('^(' + improperKeywords.replace(/,/g, '\\b|') + '\\b)');
+
+	  var wsRE = /\s/g;
+	  var newlineRE = /\n/g;
+	  var saveRE = /[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g;
+	  var restoreRE = /"(\d+)"/g;
+	  var pathTestRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/;
+	  var identRE = /[^\w$\.](?:[A-Za-z_$][\w$]*)/g;
+	  var booleanLiteralRE = /^(?:true|false)$/;
+
+	  /**
+	   * Save / Rewrite / Restore
+	   *
+	   * When rewriting paths found in an expression, it is
+	   * possible for the same letter sequences to be found in
+	   * strings and Object literal property keys. Therefore we
+	   * remove and store these parts in a temporary array, and
+	   * restore them after the path rewrite.
+	   */
+
+	  var saved = [];
+
+	  /**
+	   * Save replacer
+	   *
+	   * The save regex can match two possible cases:
+	   * 1. An opening object literal
+	   * 2. A string
+	   * If matched as a plain string, we need to escape its
+	   * newlines, since the string needs to be preserved when
+	   * generating the function body.
+	   *
+	   * @param {String} str
+	   * @param {String} isString - str if matched as a string
+	   * @return {String} - placeholder with index
+	   */
+
+	  function save(str, isString) {
+	    var i = saved.length;
+	    saved[i] = isString ? str.replace(newlineRE, '\\n') : str;
+	    return '"' + i + '"';
+	  }
+
+	  /**
+	   * Path rewrite replacer
+	   *
+	   * @param {String} raw
+	   * @return {String}
+	   */
+
+	  function rewrite(raw) {
+	    var c = raw.charAt(0);
+	    var path = raw.slice(1);
+	    if (allowedKeywordsRE.test(path)) {
+	      return raw;
+	    } else {
+	      path = path.indexOf('"') > -1 ? path.replace(restoreRE, restore) : path;
+	      return c + 'scope.' + path;
+	    }
+	  }
+
+	  /**
+	   * Restore replacer
+	   *
+	   * @param {String} str
+	   * @param {String} i - matched save index
+	   * @return {String}
+	   */
+
+	  function restore(str, i) {
+	    return saved[i];
+	  }
+
+	  /**
+	   * Rewrite an expression, prefixing all path accessors with
+	   * `scope.` and generate getter/setter functions.
+	   *
+	   * @param {String} exp
+	   * @return {Function}
+	   */
+
+	  function compileGetter(exp) {
+	    if (improperKeywordsRE.test(exp)) {
+	      'development' !== 'production' && warn('Avoid using reserved keywords in expression: ' + exp);
+	    }
+	    // reset state
+	    saved.length = 0;
+	    // save strings and object literal keys
+	    var body = exp.replace(saveRE, save).replace(wsRE, '');
+	    // rewrite all paths
+	    // pad 1 space here becaue the regex matches 1 extra char
+	    body = (' ' + body).replace(identRE, rewrite).replace(restoreRE, restore);
+	    return makeGetterFn(body);
+	  }
+
+	  /**
+	   * Build a getter function. Requires eval.
+	   *
+	   * We isolate the try/catch so it doesn't affect the
+	   * optimization of the parse function when it is not called.
+	   *
+	   * @param {String} body
+	   * @return {Function|undefined}
+	   */
+
+	  function makeGetterFn(body) {
+	    try {
+	      /* eslint-disable no-new-func */
+	      return new Function('scope', 'return ' + body + ';');
+	      /* eslint-enable no-new-func */
+	    } catch (e) {
+	      'development' !== 'production' && warn('Invalid expression. ' + 'Generated function body: ' + body);
+	    }
+	  }
+
+	  /**
+	   * Compile a setter function for the expression.
+	   *
+	   * @param {String} exp
+	   * @return {Function|undefined}
+	   */
+
+	  function compileSetter(exp) {
+	    var path = parsePath(exp);
+	    if (path) {
+	      return function (scope, val) {
+	        setPath(scope, path, val);
+	      };
+	    } else {
+	      'development' !== 'production' && warn('Invalid setter expression: ' + exp);
+	    }
+	  }
+
+	  /**
+	   * Parse an expression into re-written getter/setters.
+	   *
+	   * @param {String} exp
+	   * @param {Boolean} needSet
+	   * @return {Function}
+	   */
+
+	  function parseExpression(exp, needSet) {
+	    exp = exp.trim();
+	    // try cache
+	    var hit = expressionCache.get(exp);
+	    if (hit) {
+	      if (needSet && !hit.set) {
+	        hit.set = compileSetter(hit.exp);
+	      }
+	      return hit;
+	    }
+	    var res = { exp: exp };
+	    res.get = isSimplePath(exp) && exp.indexOf('[') < 0
+	    // optimized super simple getter
+	    ? makeGetterFn('scope.' + exp)
+	    // dynamic getter
+	    : compileGetter(exp);
+	    if (needSet) {
+	      res.set = compileSetter(exp);
+	    }
+	    expressionCache.put(exp, res);
+	    return res;
+	  }
+
+	  /**
+	   * Check if an expression is a simple path.
+	   *
+	   * @param {String} exp
+	   * @return {Boolean}
+	   */
+
+	  function isSimplePath(exp) {
+	    return pathTestRE.test(exp) &&
+	    // don't treat true/false as paths
+	    !booleanLiteralRE.test(exp) &&
+	    // Math constants e.g. Math.PI, Math.E etc.
+	    exp.slice(0, 5) !== 'Math.';
+	  }
+
+	var expression = Object.freeze({
+	    parseExpression: parseExpression,
+	    isSimplePath: isSimplePath
+	  });
+
+	  // we have two separate queues: one for directive updates
+	  // and one for user watcher registered via $watch().
+	  // we want to guarantee directive updates to be called
+	  // before user watchers so that when user watchers are
+	  // triggered, the DOM would have already been in updated
+	  // state.
+
+	  var queue = [];
+	  var userQueue = [];
+	  var has = {};
+	  var circular = {};
+	  var waiting = false;
+
+	  /**
+	   * Reset the batcher's state.
+	   */
+
+	  function resetBatcherState() {
+	    queue.length = 0;
+	    userQueue.length = 0;
+	    has = {};
+	    circular = {};
+	    waiting = false;
+	  }
+
+	  /**
+	   * Flush both queues and run the watchers.
+	   */
+
+	  function flushBatcherQueue() {
+	    var _again = true;
+
+	    _function: while (_again) {
+	      _again = false;
+
+	      runBatcherQueue(queue);
+	      runBatcherQueue(userQueue);
+	      // user watchers triggered more watchers,
+	      // keep flushing until it depletes
+	      if (queue.length) {
+	        _again = true;
+	        continue _function;
+	      }
+	      // dev tool hook
+	      /* istanbul ignore if */
+	      if (devtools && config.devtools) {
+	        devtools.emit('flush');
+	      }
+	      resetBatcherState();
+	    }
+	  }
+
+	  /**
+	   * Run the watchers in a single queue.
+	   *
+	   * @param {Array} queue
+	   */
+
+	  function runBatcherQueue(queue) {
+	    // do not cache length because more watchers might be pushed
+	    // as we run existing watchers
+	    for (var i = 0; i < queue.length; i++) {
+	      var watcher = queue[i];
+	      var id = watcher.id;
+	      has[id] = null;
+	      watcher.run();
+	      // in dev build, check and stop circular updates.
+	      if ('development' !== 'production' && has[id] != null) {
+	        circular[id] = (circular[id] || 0) + 1;
+	        if (circular[id] > config._maxUpdateCount) {
+	          warn('You may have an infinite update loop for watcher ' + 'with expression "' + watcher.expression + '"', watcher.vm);
+	          break;
+	        }
+	      }
+	    }
+	    queue.length = 0;
+	  }
+
+	  /**
+	   * Push a watcher into the watcher queue.
+	   * Jobs with duplicate IDs will be skipped unless it's
+	   * pushed when the queue is being flushed.
+	   *
+	   * @param {Watcher} watcher
+	   *   properties:
+	   *   - {Number} id
+	   *   - {Function} run
+	   */
+
+	  function pushWatcher(watcher) {
+	    var id = watcher.id;
+	    if (has[id] == null) {
+	      // push watcher into appropriate queue
+	      var q = watcher.user ? userQueue : queue;
+	      has[id] = q.length;
+	      q.push(watcher);
+	      // queue the flush
+	      if (!waiting) {
+	        waiting = true;
+	        nextTick(flushBatcherQueue);
+	      }
+	    }
+	  }
+
+	  var uid$2 = 0;
+
+	  /**
+	   * A watcher parses an expression, collects dependencies,
+	   * and fires callback when the expression value changes.
+	   * This is used for both the $watch() api and directives.
+	   *
+	   * @param {Vue} vm
+	   * @param {String|Function} expOrFn
+	   * @param {Function} cb
+	   * @param {Object} options
+	   *                 - {Array} filters
+	   *                 - {Boolean} twoWay
+	   *                 - {Boolean} deep
+	   *                 - {Boolean} user
+	   *                 - {Boolean} sync
+	   *                 - {Boolean} lazy
+	   *                 - {Function} [preProcess]
+	   *                 - {Function} [postProcess]
+	   * @constructor
+	   */
+	  function Watcher(vm, expOrFn, cb, options) {
+	    // mix in options
+	    if (options) {
+	      extend(this, options);
+	    }
+	    var isFn = typeof expOrFn === 'function';
+	    this.vm = vm;
+	    vm._watchers.push(this);
+	    this.expression = expOrFn;
+	    this.cb = cb;
+	    this.id = ++uid$2; // uid for batching
+	    this.active = true;
+	    this.dirty = this.lazy; // for lazy watchers
+	    this.deps = [];
+	    this.newDeps = [];
+	    this.depIds = new _Set();
+	    this.newDepIds = new _Set();
+	    this.prevError = null; // for async error stacks
+	    // parse expression for getter/setter
+	    if (isFn) {
+	      this.getter = expOrFn;
+	      this.setter = undefined;
+	    } else {
+	      var res = parseExpression(expOrFn, this.twoWay);
+	      this.getter = res.get;
+	      this.setter = res.set;
+	    }
+	    this.value = this.lazy ? undefined : this.get();
+	    // state for avoiding false triggers for deep and Array
+	    // watchers during vm._digest()
+	    this.queued = this.shallow = false;
+	  }
+
+	  /**
+	   * Evaluate the getter, and re-collect dependencies.
+	   */
+
+	  Watcher.prototype.get = function () {
+	    this.beforeGet();
+	    var scope = this.scope || this.vm;
+	    var value;
+	    try {
+	      value = this.getter.call(scope, scope);
+	    } catch (e) {
+	      if ('development' !== 'production' && config.warnExpressionErrors) {
+	        warn('Error when evaluating expression ' + '"' + this.expression + '": ' + e.toString(), this.vm);
+	      }
+	    }
+	    // "touch" every property so they are all tracked as
+	    // dependencies for deep watching
+	    if (this.deep) {
+	      traverse(value);
+	    }
+	    if (this.preProcess) {
+	      value = this.preProcess(value);
+	    }
+	    if (this.filters) {
+	      value = scope._applyFilters(value, null, this.filters, false);
+	    }
+	    if (this.postProcess) {
+	      value = this.postProcess(value);
+	    }
+	    this.afterGet();
+	    return value;
+	  };
+
+	  /**
+	   * Set the corresponding value with the setter.
+	   *
+	   * @param {*} value
+	   */
+
+	  Watcher.prototype.set = function (value) {
+	    var scope = this.scope || this.vm;
+	    if (this.filters) {
+	      value = scope._applyFilters(value, this.value, this.filters, true);
+	    }
+	    try {
+	      this.setter.call(scope, scope, value);
+	    } catch (e) {
+	      if ('development' !== 'production' && config.warnExpressionErrors) {
+	        warn('Error when evaluating setter ' + '"' + this.expression + '": ' + e.toString(), this.vm);
+	      }
+	    }
+	    // two-way sync for v-for alias
+	    var forContext = scope.$forContext;
+	    if (forContext && forContext.alias === this.expression) {
+	      if (forContext.filters) {
+	        'development' !== 'production' && warn('It seems you are using two-way binding on ' + 'a v-for alias (' + this.expression + '), and the ' + 'v-for has filters. This will not work properly. ' + 'Either remove the filters or use an array of ' + 'objects and bind to object properties instead.', this.vm);
+	        return;
+	      }
+	      forContext._withLock(function () {
+	        if (scope.$key) {
+	          // original is an object
+	          forContext.rawValue[scope.$key] = value;
+	        } else {
+	          forContext.rawValue.$set(scope.$index, value);
+	        }
+	      });
+	    }
+	  };
+
+	  /**
+	   * Prepare for dependency collection.
+	   */
+
+	  Watcher.prototype.beforeGet = function () {
+	    Dep.target = this;
+	  };
+
+	  /**
+	   * Add a dependency to this directive.
+	   *
+	   * @param {Dep} dep
+	   */
+
+	  Watcher.prototype.addDep = function (dep) {
+	    var id = dep.id;
+	    if (!this.newDepIds.has(id)) {
+	      this.newDepIds.add(id);
+	      this.newDeps.push(dep);
+	      if (!this.depIds.has(id)) {
+	        dep.addSub(this);
+	      }
+	    }
+	  };
+
+	  /**
+	   * Clean up for dependency collection.
+	   */
+
+	  Watcher.prototype.afterGet = function () {
+	    Dep.target = null;
+	    var i = this.deps.length;
+	    while (i--) {
+	      var dep = this.deps[i];
+	      if (!this.newDepIds.has(dep.id)) {
+	        dep.removeSub(this);
+	      }
+	    }
+	    var tmp = this.depIds;
+	    this.depIds = this.newDepIds;
+	    this.newDepIds = tmp;
+	    this.newDepIds.clear();
+	    tmp = this.deps;
+	    this.deps = this.newDeps;
+	    this.newDeps = tmp;
+	    this.newDeps.length = 0;
+	  };
+
+	  /**
+	   * Subscriber interface.
+	   * Will be called when a dependency changes.
+	   *
+	   * @param {Boolean} shallow
+	   */
+
+	  Watcher.prototype.update = function (shallow) {
+	    if (this.lazy) {
+	      this.dirty = true;
+	    } else if (this.sync || !config.async) {
+	      this.run();
+	    } else {
+	      // if queued, only overwrite shallow with non-shallow,
+	      // but not the other way around.
+	      this.shallow = this.queued ? shallow ? this.shallow : false : !!shallow;
+	      this.queued = true;
+	      // record before-push error stack in debug mode
+	      /* istanbul ignore if */
+	      if ('development' !== 'production' && config.debug) {
+	        this.prevError = new Error('[vue] async stack trace');
+	      }
+	      pushWatcher(this);
+	    }
+	  };
+
+	  /**
+	   * Batcher job interface.
+	   * Will be called by the batcher.
+	   */
+
+	  Watcher.prototype.run = function () {
+	    if (this.active) {
+	      var value = this.get();
+	      if (value !== this.value ||
+	      // Deep watchers and watchers on Object/Arrays should fire even
+	      // when the value is the same, because the value may
+	      // have mutated; but only do so if this is a
+	      // non-shallow update (caused by a vm digest).
+	      (isObject(value) || this.deep) && !this.shallow) {
+	        // set new value
+	        var oldValue = this.value;
+	        this.value = value;
+	        // in debug + async mode, when a watcher callbacks
+	        // throws, we also throw the saved before-push error
+	        // so the full cross-tick stack trace is available.
+	        var prevError = this.prevError;
+	        /* istanbul ignore if */
+	        if ('development' !== 'production' && config.debug && prevError) {
+	          this.prevError = null;
+	          try {
+	            this.cb.call(this.vm, value, oldValue);
+	          } catch (e) {
+	            nextTick(function () {
+	              throw prevError;
+	            }, 0);
+	            throw e;
+	          }
+	        } else {
+	          this.cb.call(this.vm, value, oldValue);
+	        }
+	      }
+	      this.queued = this.shallow = false;
+	    }
+	  };
+
+	  /**
+	   * Evaluate the value of the watcher.
+	   * This only gets called for lazy watchers.
+	   */
+
+	  Watcher.prototype.evaluate = function () {
+	    // avoid overwriting another watcher that is being
+	    // collected.
+	    var current = Dep.target;
+	    this.value = this.get();
+	    this.dirty = false;
+	    Dep.target = current;
+	  };
+
+	  /**
+	   * Depend on all deps collected by this watcher.
+	   */
+
+	  Watcher.prototype.depend = function () {
+	    var i = this.deps.length;
+	    while (i--) {
+	      this.deps[i].depend();
+	    }
+	  };
+
+	  /**
+	   * Remove self from all dependencies' subcriber list.
+	   */
+
+	  Watcher.prototype.teardown = function () {
+	    if (this.active) {
+	      // remove self from vm's watcher list
+	      // this is a somewhat expensive operation so we skip it
+	      // if the vm is being destroyed or is performing a v-for
+	      // re-render (the watcher list is then filtered by v-for).
+	      if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {
+	        this.vm._watchers.$remove(this);
+	      }
+	      var i = this.deps.length;
+	      while (i--) {
+	        this.deps[i].removeSub(this);
+	      }
+	      this.active = false;
+	      this.vm = this.cb = this.value = null;
+	    }
+	  };
+
+	  /**
+	   * Recrusively traverse an object to evoke all converted
+	   * getters, so that every nested property inside the object
+	   * is collected as a "deep" dependency.
+	   *
+	   * @param {*} val
+	   */
+
+	  var seenObjects = new _Set();
+	  function traverse(val, seen) {
+	    var i = undefined,
+	        keys = undefined;
+	    if (!seen) {
+	      seen = seenObjects;
+	      seen.clear();
+	    }
+	    var isA = isArray(val);
+	    var isO = isObject(val);
+	    if (isA || isO) {
+	      if (val.__ob__) {
+	        var depId = val.__ob__.dep.id;
+	        if (seen.has(depId)) {
+	          return;
+	        } else {
+	          seen.add(depId);
+	        }
+	      }
+	      if (isA) {
+	        i = val.length;
+	        while (i--) traverse(val[i], seen);
+	      } else if (isO) {
+	        keys = Object.keys(val);
+	        i = keys.length;
+	        while (i--) traverse(val[keys[i]], seen);
+	      }
+	    }
+	  }
+
+	  var text$1 = {
+
+	    bind: function bind() {
+	      this.attr = this.el.nodeType === 3 ? 'data' : 'textContent';
+	    },
+
+	    update: function update(value) {
+	      this.el[this.attr] = _toString(value);
+	    }
+	  };
+
+	  var templateCache = new Cache(1000);
+	  var idSelectorCache = new Cache(1000);
+
+	  var map = {
+	    efault: [0, '', ''],
+	    legend: [1, '<fieldset>', '</fieldset>'],
+	    tr: [2, '<table><tbody>', '</tbody></table>'],
+	    col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>']
+	  };
+
+	  map.td = map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
+
+	  map.option = map.optgroup = [1, '<select multiple="multiple">', '</select>'];
+
+	  map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, '<table>', '</table>'];
+
+	  map.g = map.defs = map.symbol = map.use = map.image = map.text = map.circle = map.ellipse = map.line = map.path = map.polygon = map.polyline = map.rect = [1, '<svg ' + 'xmlns="http://www.w3.org/2000/svg" ' + 'xmlns:xlink="http://www.w3.org/1999/xlink" ' + 'xmlns:ev="http://www.w3.org/2001/xml-events"' + 'version="1.1">', '</svg>'];
+
+	  /**
+	   * Check if a node is a supported template node with a
+	   * DocumentFragment content.
+	   *
+	   * @param {Node} node
+	   * @return {Boolean}
+	   */
+
+	  function isRealTemplate(node) {
+	    return isTemplate(node) && isFragment(node.content);
+	  }
+
+	  var tagRE$1 = /<([\w:-]+)/;
+	  var entityRE = /&#?\w+?;/;
+
+	  /**
+	   * Convert a string template to a DocumentFragment.
+	   * Determines correct wrapping by tag types. Wrapping
+	   * strategy found in jQuery & component/domify.
+	   *
+	   * @param {String} templateString
+	   * @param {Boolean} raw
+	   * @return {DocumentFragment}
+	   */
+
+	  function stringToFragment(templateString, raw) {
+	    // try a cache hit first
+	    var cacheKey = raw ? templateString : templateString.trim();
+	    var hit = templateCache.get(cacheKey);
+	    if (hit) {
+	      return hit;
+	    }
+
+	    var frag = document.createDocumentFragment();
+	    var tagMatch = templateString.match(tagRE$1);
+	    var entityMatch = entityRE.test(templateString);
+
+	    if (!tagMatch && !entityMatch) {
+	      // text only, return a single text node.
+	      frag.appendChild(document.createTextNode(templateString));
+	    } else {
+	      var tag = tagMatch && tagMatch[1];
+	      var wrap = map[tag] || map.efault;
+	      var depth = wrap[0];
+	      var prefix = wrap[1];
+	      var suffix = wrap[2];
+	      var node = document.createElement('div');
+
+	      node.innerHTML = prefix + templateString + suffix;
+	      while (depth--) {
+	        node = node.lastChild;
+	      }
+
+	      var child;
+	      /* eslint-disable no-cond-assign */
+	      while (child = node.firstChild) {
+	        /* eslint-enable no-cond-assign */
+	        frag.appendChild(child);
+	      }
+	    }
+	    if (!raw) {
+	      trimNode(frag);
+	    }
+	    templateCache.put(cacheKey, frag);
+	    return frag;
+	  }
+
+	  /**
+	   * Convert a template node to a DocumentFragment.
+	   *
+	   * @param {Node} node
+	   * @return {DocumentFragment}
+	   */
+
+	  function nodeToFragment(node) {
+	    // if its a template tag and the browser supports it,
+	    // its content is already a document fragment. However, iOS Safari has
+	    // bug when using directly cloned template content with touch
+	    // events and can cause crashes when the nodes are removed from DOM, so we
+	    // have to treat template elements as string templates. (#2805)
+	    /* istanbul ignore if */
+	    if (isRealTemplate(node)) {
+	      return stringToFragment(node.innerHTML);
+	    }
+	    // script template
+	    if (node.tagName === 'SCRIPT') {
+	      return stringToFragment(node.textContent);
+	    }
+	    // normal node, clone it to avoid mutating the original
+	    var clonedNode = cloneNode(node);
+	    var frag = document.createDocumentFragment();
+	    var child;
+	    /* eslint-disable no-cond-assign */
+	    while (child = clonedNode.firstChild) {
+	      /* eslint-enable no-cond-assign */
+	      frag.appendChild(child);
+	    }
+	    trimNode(frag);
+	    return frag;
+	  }
+
+	  // Test for the presence of the Safari template cloning bug
+	  // https://bugs.webkit.org/showug.cgi?id=137755
+	  var hasBrokenTemplate = (function () {
+	    /* istanbul ignore else */
+	    if (inBrowser) {
+	      var a = document.createElement('div');
+	      a.innerHTML = '<template>1</template>';
+	      return !a.cloneNode(true).firstChild.innerHTML;
+	    } else {
+	      return false;
+	    }
+	  })();
+
+	  // Test for IE10/11 textarea placeholder clone bug
+	  var hasTextareaCloneBug = (function () {
+	    /* istanbul ignore else */
+	    if (inBrowser) {
+	      var t = document.createElement('textarea');
+	      t.placeholder = 't';
+	      return t.cloneNode(true).value === 't';
+	    } else {
+	      return false;
+	    }
+	  })();
+
+	  /**
+	   * 1. Deal with Safari cloning nested <template> bug by
+	   *    manually cloning all template instances.
+	   * 2. Deal with IE10/11 textarea placeholder bug by setting
+	   *    the correct value after cloning.
+	   *
+	   * @param {Element|DocumentFragment} node
+	   * @return {Element|DocumentFragment}
+	   */
+
+	  function cloneNode(node) {
+	    /* istanbul ignore if */
+	    if (!node.querySelectorAll) {
+	      return node.cloneNode();
+	    }
+	    var res = node.cloneNode(true);
+	    var i, original, cloned;
+	    /* istanbul ignore if */
+	    if (hasBrokenTemplate) {
+	      var tempClone = res;
+	      if (isRealTemplate(node)) {
+	        node = node.content;
+	        tempClone = res.content;
+	      }
+	      original = node.querySelectorAll('template');
+	      if (original.length) {
+	        cloned = tempClone.querySelectorAll('template');
+	        i = cloned.length;
+	        while (i--) {
+	          cloned[i].parentNode.replaceChild(cloneNode(original[i]), cloned[i]);
+	        }
+	      }
+	    }
+	    /* istanbul ignore if */
+	    if (hasTextareaCloneBug) {
+	      if (node.tagName === 'TEXTAREA') {
+	        res.value = node.value;
+	      } else {
+	        original = node.querySelectorAll('textarea');
+	        if (original.length) {
+	          cloned = res.querySelectorAll('textarea');
+	          i = cloned.length;
+	          while (i--) {
+	            cloned[i].value = original[i].value;
+	          }
+	        }
+	      }
+	    }
+	    return res;
+	  }
+
+	  /**
+	   * Process the template option and normalizes it into a
+	   * a DocumentFragment that can be used as a partial or a
+	   * instance template.
+	   *
+	   * @param {*} template
+	   *        Possible values include:
+	   *        - DocumentFragment object
+	   *        - Node object of type Template
+	   *        - id selector: '#some-template-id'
+	   *        - template string: '<div><span>{{msg}}</span></div>'
+	   * @param {Boolean} shouldClone
+	   * @param {Boolean} raw
+	   *        inline HTML interpolation. Do not check for id
+	   *        selector and keep whitespace in the string.
+	   * @return {DocumentFragment|undefined}
+	   */
+
+	  function parseTemplate(template, shouldClone, raw) {
+	    var node, frag;
+
+	    // if the template is already a document fragment,
+	    // do nothing
+	    if (isFragment(template)) {
+	      trimNode(template);
+	      return shouldClone ? cloneNode(template) : template;
+	    }
+
+	    if (typeof template === 'string') {
+	      // id selector
+	      if (!raw && template.charAt(0) === '#') {
+	        // id selector can be cached too
+	        frag = idSelectorCache.get(template);
+	        if (!frag) {
+	          node = document.getElementById(template.slice(1));
+	          if (node) {
+	            frag = nodeToFragment(node);
+	            // save selector to cache
+	            idSelectorCache.put(template, frag);
+	          }
+	        }
+	      } else {
+	        // normal string template
+	        frag = stringToFragment(template, raw);
+	      }
+	    } else if (template.nodeType) {
+	      // a direct node
+	      frag = nodeToFragment(template);
+	    }
+
+	    return frag && shouldClone ? cloneNode(frag) : frag;
+	  }
+
+	var template = Object.freeze({
+	    cloneNode: cloneNode,
+	    parseTemplate: parseTemplate
+	  });
+
+	  var html = {
+
+	    bind: function bind() {
+	      // a comment node means this is a binding for
+	      // {{{ inline unescaped html }}}
+	      if (this.el.nodeType === 8) {
+	        // hold nodes
+	        this.nodes = [];
+	        // replace the placeholder with proper anchor
+	        this.anchor = createAnchor('v-html');
+	        replace(this.el, this.anchor);
+	      }
+	    },
+
+	    update: function update(value) {
+	      value = _toString(value);
+	      if (this.nodes) {
+	        this.swap(value);
+	      } else {
+	        this.el.innerHTML = value;
+	      }
+	    },
+
+	    swap: function swap(value) {
+	      // remove old nodes
+	      var i = this.nodes.length;
+	      while (i--) {
+	        remove(this.nodes[i]);
+	      }
+	      // convert new value to a fragment
+	      // do not attempt to retrieve from id selector
+	      var frag = parseTemplate(value, true, true);
+	      // save a reference to these nodes so we can remove later
+	      this.nodes = toArray(frag.childNodes);
+	      before(frag, this.anchor);
+	    }
+	  };
+
+	  /**
+	   * Abstraction for a partially-compiled fragment.
+	   * Can optionally compile content with a child scope.
+	   *
+	   * @param {Function} linker
+	   * @param {Vue} vm
+	   * @param {DocumentFragment} frag
+	   * @param {Vue} [host]
+	   * @param {Object} [scope]
+	   * @param {Fragment} [parentFrag]
+	   */
+	  function Fragment(linker, vm, frag, host, scope, parentFrag) {
+	    this.children = [];
+	    this.childFrags = [];
+	    this.vm = vm;
+	    this.scope = scope;
+	    this.inserted = false;
+	    this.parentFrag = parentFrag;
+	    if (parentFrag) {
+	      parentFrag.childFrags.push(this);
+	    }
+	    this.unlink = linker(vm, frag, host, scope, this);
+	    var single = this.single = frag.childNodes.length === 1 &&
+	    // do not go single mode if the only node is an anchor
+	    !frag.childNodes[0].__v_anchor;
+	    if (single) {
+	      this.node = frag.childNodes[0];
+	      this.before = singleBefore;
+	      this.remove = singleRemove;
+	    } else {
+	      this.node = createAnchor('fragment-start');
+	      this.end = createAnchor('fragment-end');
+	      this.frag = frag;
+	      prepend(this.node, frag);
+	      frag.appendChild(this.end);
+	      this.before = multiBefore;
+	      this.remove = multiRemove;
+	    }
+	    this.node.__v_frag = this;
+	  }
+
+	  /**
+	   * Call attach/detach for all components contained within
+	   * this fragment. Also do so recursively for all child
+	   * fragments.
+	   *
+	   * @param {Function} hook
+	   */
+
+	  Fragment.prototype.callHook = function (hook) {
+	    var i, l;
+	    for (i = 0, l = this.childFrags.length; i < l; i++) {
+	      this.childFrags[i].callHook(hook);
+	    }
+	    for (i = 0, l = this.children.length; i < l; i++) {
+	      hook(this.children[i]);
+	    }
+	  };
+
+	  /**
+	   * Insert fragment before target, single node version
+	   *
+	   * @param {Node} target
+	   * @param {Boolean} withTransition
+	   */
+
+	  function singleBefore(target, withTransition) {
+	    this.inserted = true;
+	    var method = withTransition !== false ? beforeWithTransition : before;
+	    method(this.node, target, this.vm);
+	    if (inDoc(this.node)) {
+	      this.callHook(attach);
+	    }
+	  }
+
+	  /**
+	   * Remove fragment, single node version
+	   */
+
+	  function singleRemove() {
+	    this.inserted = false;
+	    var shouldCallRemove = inDoc(this.node);
+	    var self = this;
+	    this.beforeRemove();
+	    removeWithTransition(this.node, this.vm, function () {
+	      if (shouldCallRemove) {
+	        self.callHook(detach);
+	      }
+	      self.destroy();
+	    });
+	  }
+
+	  /**
+	   * Insert fragment before target, multi-nodes version
+	   *
+	   * @param {Node} target
+	   * @param {Boolean} withTransition
+	   */
+
+	  function multiBefore(target, withTransition) {
+	    this.inserted = true;
+	    var vm = this.vm;
+	    var method = withTransition !== false ? beforeWithTransition : before;
+	    mapNodeRange(this.node, this.end, function (node) {
+	      method(node, target, vm);
+	    });
+	    if (inDoc(this.node)) {
+	      this.callHook(attach);
+	    }
+	  }
+
+	  /**
+	   * Remove fragment, multi-nodes version
+	   */
+
+	  function multiRemove() {
+	    this.inserted = false;
+	    var self = this;
+	    var shouldCallRemove = inDoc(this.node);
+	    this.beforeRemove();
+	    removeNodeRange(this.node, this.end, this.vm, this.frag, function () {
+	      if (shouldCallRemove) {
+	        self.callHook(detach);
+	      }
+	      self.destroy();
+	    });
+	  }
+
+	  /**
+	   * Prepare the fragment for removal.
+	   */
+
+	  Fragment.prototype.beforeRemove = function () {
+	    var i, l;
+	    for (i = 0, l = this.childFrags.length; i < l; i++) {
+	      // call the same method recursively on child
+	      // fragments, depth-first
+	      this.childFrags[i].beforeRemove(false);
+	    }
+	    for (i = 0, l = this.children.length; i < l; i++) {
+	      // Call destroy for all contained instances,
+	      // with remove:false and defer:true.
+	      // Defer is necessary because we need to
+	      // keep the children to call detach hooks
+	      // on them.
+	      this.children[i].$destroy(false, true);
+	    }
+	    var dirs = this.unlink.dirs;
+	    for (i = 0, l = dirs.length; i < l; i++) {
+	      // disable the watchers on all the directives
+	      // so that the rendered content stays the same
+	      // during removal.
+	      dirs[i]._watcher && dirs[i]._watcher.teardown();
+	    }
+	  };
+
+	  /**
+	   * Destroy the fragment.
+	   */
+
+	  Fragment.prototype.destroy = function () {
+	    if (this.parentFrag) {
+	      this.parentFrag.childFrags.$remove(this);
+	    }
+	    this.node.__v_frag = null;
+	    this.unlink();
+	  };
+
+	  /**
+	   * Call attach hook for a Vue instance.
+	   *
+	   * @param {Vue} child
+	   */
+
+	  function attach(child) {
+	    if (!child._isAttached && inDoc(child.$el)) {
+	      child._callHook('attached');
+	    }
+	  }
+
+	  /**
+	   * Call detach hook for a Vue instance.
+	   *
+	   * @param {Vue} child
+	   */
+
+	  function detach(child) {
+	    if (child._isAttached && !inDoc(child.$el)) {
+	      child._callHook('detached');
+	    }
+	  }
+
+	  var linkerCache = new Cache(5000);
+
+	  /**
+	   * A factory that can be used to create instances of a
+	   * fragment. Caches the compiled linker if possible.
+	   *
+	   * @param {Vue} vm
+	   * @param {Element|String} el
+	   */
+	  function FragmentFactory(vm, el) {
+	    this.vm = vm;
+	    var template;
+	    var isString = typeof el === 'string';
+	    if (isString || isTemplate(el) && !el.hasAttribute('v-if')) {
+	      template = parseTemplate(el, true);
+	    } else {
+	      template = document.createDocumentFragment();
+	      template.appendChild(el);
+	    }
+	    this.template = template;
+	    // linker can be cached, but only for components
+	    var linker;
+	    var cid = vm.constructor.cid;
+	    if (cid > 0) {
+	      var cacheId = cid + (isString ? el : getOuterHTML(el));
+	      linker = linkerCache.get(cacheId);
+	      if (!linker) {
+	        linker = compile(template, vm.$options, true);
+	        linkerCache.put(cacheId, linker);
+	      }
+	    } else {
+	      linker = compile(template, vm.$options, true);
+	    }
+	    this.linker = linker;
+	  }
+
+	  /**
+	   * Create a fragment instance with given host and scope.
+	   *
+	   * @param {Vue} host
+	   * @param {Object} scope
+	   * @param {Fragment} parentFrag
+	   */
+
+	  FragmentFactory.prototype.create = function (host, scope, parentFrag) {
+	    var frag = cloneNode(this.template);
+	    return new Fragment(this.linker, this.vm, frag, host, scope, parentFrag);
+	  };
+
+	  var ON = 700;
+	  var MODEL = 800;
+	  var BIND = 850;
+	  var TRANSITION = 1100;
+	  var EL = 1500;
+	  var COMPONENT = 1500;
+	  var PARTIAL = 1750;
+	  var IF = 2100;
+	  var FOR = 2200;
+	  var SLOT = 2300;
+
+	  var uid$3 = 0;
+
+	  var vFor = {
+
+	    priority: FOR,
+	    terminal: true,
+
+	    params: ['track-by', 'stagger', 'enter-stagger', 'leave-stagger'],
+
+	    bind: function bind() {
+	      // support "item in/of items" syntax
+	      var inMatch = this.expression.match(/(.*) (?:in|of) (.*)/);
+	      if (inMatch) {
+	        var itMatch = inMatch[1].match(/\((.*),(.*)\)/);
+	        if (itMatch) {
+	          this.iterator = itMatch[1].trim();
+	          this.alias = itMatch[2].trim();
+	        } else {
+	          this.alias = inMatch[1].trim();
+	        }
+	        this.expression = inMatch[2];
+	      }
+
+	      if (!this.alias) {
+	        'development' !== 'production' && warn('Invalid v-for expression "' + this.descriptor.raw + '": ' + 'alias is required.', this.vm);
+	        return;
+	      }
+
+	      // uid as a cache identifier
+	      this.id = '__v-for__' + ++uid$3;
+
+	      // check if this is an option list,
+	      // so that we know if we need to update the <select>'s
+	      // v-model when the option list has changed.
+	      // because v-model has a lower priority than v-for,
+	      // the v-model is not bound here yet, so we have to
+	      // retrive it in the actual updateModel() function.
+	      var tag = this.el.tagName;
+	      this.isOption = (tag === 'OPTION' || tag === 'OPTGROUP') && this.el.parentNode.tagName === 'SELECT';
+
+	      // setup anchor nodes
+	      this.start = createAnchor('v-for-start');
+	      this.end = createAnchor('v-for-end');
+	      replace(this.el, this.end);
+	      before(this.start, this.end);
+
+	      // cache
+	      this.cache = Object.create(null);
+
+	      // fragment factory
+	      this.factory = new FragmentFactory(this.vm, this.el);
+	    },
+
+	    update: function update(data) {
+	      this.diff(data);
+	      this.updateRef();
+	      this.updateModel();
+	    },
+
+	    /**
+	     * Diff, based on new data and old data, determine the
+	     * minimum amount of DOM manipulations needed to make the
+	     * DOM reflect the new data Array.
+	     *
+	     * The algorithm diffs the new data Array by storing a
+	     * hidden reference to an owner vm instance on previously
+	     * seen data. This allows us to achieve O(n) which is
+	     * better than a levenshtein distance based algorithm,
+	     * which is O(m * n).
+	     *
+	     * @param {Array} data
+	     */
+
+	    diff: function diff(data) {
+	      // check if the Array was converted from an Object
+	      var item = data[0];
+	      var convertedFromObject = this.fromObject = isObject(item) && hasOwn(item, '$key') && hasOwn(item, '$value');
+
+	      var trackByKey = this.params.trackBy;
+	      var oldFrags = this.frags;
+	      var frags = this.frags = new Array(data.length);
+	      var alias = this.alias;
+	      var iterator = this.iterator;
+	      var start = this.start;
+	      var end = this.end;
+	      var inDocument = inDoc(start);
+	      var init = !oldFrags;
+	      var i, l, frag, key, value, primitive;
+
+	      // First pass, go through the new Array and fill up
+	      // the new frags array. If a piece of data has a cached
+	      // instance for it, we reuse it. Otherwise build a new
+	      // instance.
+	      for (i = 0, l = data.length; i < l; i++) {
+	        item = data[i];
+	        key = convertedFromObject ? item.$key : null;
+	        value = convertedFromObject ? item.$value : item;
+	        primitive = !isObject(value);
+	        frag = !init && this.getCachedFrag(value, i, key);
+	        if (frag) {
+	          // reusable fragment
+	          frag.reused = true;
+	          // update $index
+	          frag.scope.$index = i;
+	          // update $key
+	          if (key) {
+	            frag.scope.$key = key;
+	          }
+	          // update iterator
+	          if (iterator) {
+	            frag.scope[iterator] = key !== null ? key : i;
+	          }
+	          // update data for track-by, object repeat &
+	          // primitive values.
+	          if (trackByKey || convertedFromObject || primitive) {
+	            withoutConversion(function () {
+	              frag.scope[alias] = value;
+	            });
+	          }
+	        } else {
+	          // new isntance
+	          frag = this.create(value, alias, i, key);
+	          frag.fresh = !init;
+	        }
+	        frags[i] = frag;
+	        if (init) {
+	          frag.before(end);
+	        }
+	      }
+
+	      // we're done for the initial render.
+	      if (init) {
+	        return;
+	      }
+
+	      // Second pass, go through the old fragments and
+	      // destroy those who are not reused (and remove them
+	      // from cache)
+	      var removalIndex = 0;
+	      var totalRemoved = oldFrags.length - frags.length;
+	      // when removing a large number of fragments, watcher removal
+	      // turns out to be a perf bottleneck, so we batch the watcher
+	      // removals into a single filter call!
+	      this.vm._vForRemoving = true;
+	      for (i = 0, l = oldFrags.length; i < l; i++) {
+	        frag = oldFrags[i];
+	        if (!frag.reused) {
+	          this.deleteCachedFrag(frag);
+	          this.remove(frag, removalIndex++, totalRemoved, inDocument);
+	        }
+	      }
+	      this.vm._vForRemoving = false;
+	      if (removalIndex) {
+	        this.vm._watchers = this.vm._watchers.filter(function (w) {
+	          return w.active;
+	        });
+	      }
+
+	      // Final pass, move/insert new fragments into the
+	      // right place.
+	      var targetPrev, prevEl, currentPrev;
+	      var insertionIndex = 0;
+	      for (i = 0, l = frags.length; i < l; i++) {
+	        frag = frags[i];
+	        // this is the frag that we should be after
+	        targetPrev = frags[i - 1];
+	        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;
+	        if (frag.reused && !frag.staggerCb) {
+	          currentPrev = findPrevFrag(frag, start, this.id);
+	          if (currentPrev !== targetPrev && (!currentPrev ||
+	          // optimization for moving a single item.
+	          // thanks to suggestions by @livoras in #1807
+	          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {
+	            this.move(frag, prevEl);
+	          }
+	        } else {
+	          // new instance, or still in stagger.
+	          // insert with updated stagger index.
+	          this.insert(frag, insertionIndex++, prevEl, inDocument);
+	        }
+	        frag.reused = frag.fresh = false;
+	      }
+	    },
+
+	    /**
+	     * Create a new fragment instance.
+	     *
+	     * @param {*} value
+	     * @param {String} alias
+	     * @param {Number} index
+	     * @param {String} [key]
+	     * @return {Fragment}
+	     */
+
+	    create: function create(value, alias, index, key) {
+	      var host = this._host;
+	      // create iteration scope
+	      var parentScope = this._scope || this.vm;
+	      var scope = Object.create(parentScope);
+	      // ref holder for the scope
+	      scope.$refs = Object.create(parentScope.$refs);
+	      scope.$els = Object.create(parentScope.$els);
+	      // make sure point $parent to parent scope
+	      scope.$parent = parentScope;
+	      // for two-way binding on alias
+	      scope.$forContext = this;
+	      // define scope properties
+	      // important: define the scope alias without forced conversion
+	      // so that frozen data structures remain non-reactive.
+	      withoutConversion(function () {
+	        defineReactive(scope, alias, value);
+	      });
+	      defineReactive(scope, '$index', index);
+	      if (key) {
+	        defineReactive(scope, '$key', key);
+	      } else if (scope.$key) {
+	        // avoid accidental fallback
+	        def(scope, '$key', null);
+	      }
+	      if (this.iterator) {
+	        defineReactive(scope, this.iterator, key !== null ? key : index);
+	      }
+	      var frag = this.factory.create(host, scope, this._frag);
+	      frag.forId = this.id;
+	      this.cacheFrag(value, frag, index, key);
+	      return frag;
+	    },
+
+	    /**
+	     * Update the v-ref on owner vm.
+	     */
+
+	    updateRef: function updateRef() {
+	      var ref = this.descriptor.ref;
+	      if (!ref) return;
+	      var hash = (this._scope || this.vm).$refs;
+	      var refs;
+	      if (!this.fromObject) {
+	        refs = this.frags.map(findVmFromFrag);
+	      } else {
+	        refs = {};
+	        this.frags.forEach(function (frag) {
+	          refs[frag.scope.$key] = findVmFromFrag(frag);
+	        });
+	      }
+	      hash[ref] = refs;
+	    },
+
+	    /**
+	     * For option lists, update the containing v-model on
+	     * parent <select>.
+	     */
+
+	    updateModel: function updateModel() {
+	      if (this.isOption) {
+	        var parent = this.start.parentNode;
+	        var model = parent && parent.__v_model;
+	        if (model) {
+	          model.forceUpdate();
+	        }
+	      }
+	    },
+
+	    /**
+	     * Insert a fragment. Handles staggering.
+	     *
+	     * @param {Fragment} frag
+	     * @param {Number} index
+	     * @param {Node} prevEl
+	     * @param {Boolean} inDocument
+	     */
+
+	    insert: function insert(frag, index, prevEl, inDocument) {
+	      if (frag.staggerCb) {
+	        frag.staggerCb.cancel();
+	        frag.staggerCb = null;
+	      }
+	      var staggerAmount = this.getStagger(frag, index, null, 'enter');
+	      if (inDocument && staggerAmount) {
+	        // create an anchor and insert it synchronously,
+	        // so that we can resolve the correct order without
+	        // worrying about some elements not inserted yet
+	        var anchor = frag.staggerAnchor;
+	        if (!anchor) {
+	          anchor = frag.staggerAnchor = createAnchor('stagger-anchor');
+	          anchor.__v_frag = frag;
+	        }
+	        after(anchor, prevEl);
+	        var op = frag.staggerCb = cancellable(function () {
+	          frag.staggerCb = null;
+	          frag.before(anchor);
+	          remove(anchor);
+	        });
+	        setTimeout(op, staggerAmount);
+	      } else {
+	        var target = prevEl.nextSibling;
+	        /* istanbul ignore if */
+	        if (!target) {
+	          // reset end anchor position in case the position was messed up
+	          // by an external drag-n-drop library.
+	          after(this.end, prevEl);
+	          target = this.end;
+	        }
+	        frag.before(target);
+	      }
+	    },
+
+	    /**
+	     * Remove a fragment. Handles staggering.
+	     *
+	     * @param {Fragment} frag
+	     * @param {Number} index
+	     * @param {Number} total
+	     * @param {Boolean} inDocument
+	     */
+
+	    remove: function remove(frag, index, total, inDocument) {
+	      if (frag.staggerCb) {
+	        frag.staggerCb.cancel();
+	        frag.staggerCb = null;
+	        // it's not possible for the same frag to be removed
+	        // twice, so if we have a pending stagger callback,
+	        // it means this frag is queued for enter but removed
+	        // before its transition started. Since it is already
+	        // destroyed, we can just leave it in detached state.
+	        return;
+	      }
+	      var staggerAmount = this.getStagger(frag, index, total, 'leave');
+	      if (inDocument && staggerAmount) {
+	        var op = frag.staggerCb = cancellable(function () {
+	          frag.staggerCb = null;
+	          frag.remove();
+	        });
+	        setTimeout(op, staggerAmount);
+	      } else {
+	        frag.remove();
+	      }
+	    },
+
+	    /**
+	     * Move a fragment to a new position.
+	     * Force no transition.
+	     *
+	     * @param {Fragment} frag
+	     * @param {Node} prevEl
+	     */
+
+	    move: function move(frag, prevEl) {
+	      // fix a common issue with Sortable:
+	      // if prevEl doesn't have nextSibling, this means it's
+	      // been dragged after the end anchor. Just re-position
+	      // the end anchor to the end of the container.
+	      /* istanbul ignore if */
+	      if (!prevEl.nextSibling) {
+	        this.end.parentNode.appendChild(this.end);
+	      }
+	      frag.before(prevEl.nextSibling, false);
+	    },
+
+	    /**
+	     * Cache a fragment using track-by or the object key.
+	     *
+	     * @param {*} value
+	     * @param {Fragment} frag
+	     * @param {Number} index
+	     * @param {String} [key]
+	     */
+
+	    cacheFrag: function cacheFrag(value, frag, index, key) {
+	      var trackByKey = this.params.trackBy;
+	      var cache = this.cache;
+	      var primitive = !isObject(value);
+	      var id;
+	      if (key || trackByKey || primitive) {
+	        id = getTrackByKey(index, key, value, trackByKey);
+	        if (!cache[id]) {
+	          cache[id] = frag;
+	        } else if (trackByKey !== '$index') {
+	          'development' !== 'production' && this.warnDuplicate(value);
+	        }
+	      } else {
+	        id = this.id;
+	        if (hasOwn(value, id)) {
+	          if (value[id] === null) {
+	            value[id] = frag;
+	          } else {
+	            'development' !== 'production' && this.warnDuplicate(value);
+	          }
+	        } else if (Object.isExtensible(value)) {
+	          def(value, id, frag);
+	        } else if (true) {
+	          warn('Frozen v-for objects cannot be automatically tracked, make sure to ' + 'provide a track-by key.');
+	        }
+	      }
+	      frag.raw = value;
+	    },
+
+	    /**
+	     * Get a cached fragment from the value/index/key
+	     *
+	     * @param {*} value
+	     * @param {Number} index
+	     * @param {String} key
+	     * @return {Fragment}
+	     */
+
+	    getCachedFrag: function getCachedFrag(value, index, key) {
+	      var trackByKey = this.params.trackBy;
+	      var primitive = !isObject(value);
+	      var frag;
+	      if (key || trackByKey || primitive) {
+	        var id = getTrackByKey(index, key, value, trackByKey);
+	        frag = this.cache[id];
+	      } else {
+	        frag = value[this.id];
+	      }
+	      if (frag && (frag.reused || frag.fresh)) {
+	        'development' !== 'production' && this.warnDuplicate(value);
+	      }
+	      return frag;
+	    },
+
+	    /**
+	     * Delete a fragment from cache.
+	     *
+	     * @param {Fragment} frag
+	     */
+
+	    deleteCachedFrag: function deleteCachedFrag(frag) {
+	      var value = frag.raw;
+	      var trackByKey = this.params.trackBy;
+	      var scope = frag.scope;
+	      var index = scope.$index;
+	      // fix #948: avoid accidentally fall through to
+	      // a parent repeater which happens to have $key.
+	      var key = hasOwn(scope, '$key') && scope.$key;
+	      var primitive = !isObject(value);
+	      if (trackByKey || key || primitive) {
+	        var id = getTrackByKey(index, key, value, trackByKey);
+	        this.cache[id] = null;
+	      } else {
+	        value[this.id] = null;
+	        frag.raw = null;
+	      }
+	    },
+
+	    /**
+	     * Get the stagger amount for an insertion/removal.
+	     *
+	     * @param {Fragment} frag
+	     * @param {Number} index
+	     * @param {Number} total
+	     * @param {String} type
+	     */
+
+	    getStagger: function getStagger(frag, index, total, type) {
+	      type = type + 'Stagger';
+	      var trans = frag.node.__v_trans;
+	      var hooks = trans && trans.hooks;
+	      var hook = hooks && (hooks[type] || hooks.stagger);
+	      return hook ? hook.call(frag, index, total) : index * parseInt(this.params[type] || this.params.stagger, 10);
+	    },
+
+	    /**
+	     * Pre-process the value before piping it through the
+	     * filters. This is passed to and called by the watcher.
+	     */
+
+	    _preProcess: function _preProcess(value) {
+	      // regardless of type, store the un-filtered raw value.
+	      this.rawValue = value;
+	      return value;
+	    },
+
+	    /**
+	     * Post-process the value after it has been piped through
+	     * the filters. This is passed to and called by the watcher.
+	     *
+	     * It is necessary for this to be called during the
+	     * wathcer's dependency collection phase because we want
+	     * the v-for to update when the source Object is mutated.
+	     */
+
+	    _postProcess: function _postProcess(value) {
+	      if (isArray(value)) {
+	        return value;
+	      } else if (isPlainObject(value)) {
+	        // convert plain object to array.
+	        var keys = Object.keys(value);
+	        var i = keys.length;
+	        var res = new Array(i);
+	        var key;
+	        while (i--) {
+	          key = keys[i];
+	          res[i] = {
+	            $key: key,
+	            $value: value[key]
+	          };
+	        }
+	        return res;
+	      } else {
+	        if (typeof value === 'number' && !isNaN(value)) {
+	          value = range(value);
+	        }
+	        return value || [];
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      if (this.descriptor.ref) {
+	        (this._scope || this.vm).$refs[this.descriptor.ref] = null;
+	      }
+	      if (this.frags) {
+	        var i = this.frags.length;
+	        var frag;
+	        while (i--) {
+	          frag = this.frags[i];
+	          this.deleteCachedFrag(frag);
+	          frag.destroy();
+	        }
+	      }
+	    }
+	  };
+
+	  /**
+	   * Helper to find the previous element that is a fragment
+	   * anchor. This is necessary because a destroyed frag's
+	   * element could still be lingering in the DOM before its
+	   * leaving transition finishes, but its inserted flag
+	   * should have been set to false so we can skip them.
+	   *
+	   * If this is a block repeat, we want to make sure we only
+	   * return frag that is bound to this v-for. (see #929)
+	   *
+	   * @param {Fragment} frag
+	   * @param {Comment|Text} anchor
+	   * @param {String} id
+	   * @return {Fragment}
+	   */
+
+	  function findPrevFrag(frag, anchor, id) {
+	    var el = frag.node.previousSibling;
+	    /* istanbul ignore if */
+	    if (!el) return;
+	    frag = el.__v_frag;
+	    while ((!frag || frag.forId !== id || !frag.inserted) && el !== anchor) {
+	      el = el.previousSibling;
+	      /* istanbul ignore if */
+	      if (!el) return;
+	      frag = el.__v_frag;
+	    }
+	    return frag;
+	  }
+
+	  /**
+	   * Find a vm from a fragment.
+	   *
+	   * @param {Fragment} frag
+	   * @return {Vue|undefined}
+	   */
+
+	  function findVmFromFrag(frag) {
+	    var node = frag.node;
+	    // handle multi-node frag
+	    if (frag.end) {
+	      while (!node.__vue__ && node !== frag.end && node.nextSibling) {
+	        node = node.nextSibling;
+	      }
+	    }
+	    return node.__vue__;
+	  }
+
+	  /**
+	   * Create a range array from given number.
+	   *
+	   * @param {Number} n
+	   * @return {Array}
+	   */
+
+	  function range(n) {
+	    var i = -1;
+	    var ret = new Array(Math.floor(n));
+	    while (++i < n) {
+	      ret[i] = i;
+	    }
+	    return ret;
+	  }
+
+	  /**
+	   * Get the track by key for an item.
+	   *
+	   * @param {Number} index
+	   * @param {String} key
+	   * @param {*} value
+	   * @param {String} [trackByKey]
+	   */
+
+	  function getTrackByKey(index, key, value, trackByKey) {
+	    return trackByKey ? trackByKey === '$index' ? index : trackByKey.charAt(0).match(/\w/) ? getPath(value, trackByKey) : value[trackByKey] : key || value;
+	  }
+
+	  if (true) {
+	    vFor.warnDuplicate = function (value) {
+	      warn('Duplicate value found in v-for="' + this.descriptor.raw + '": ' + JSON.stringify(value) + '. Use track-by="$index" if ' + 'you are expecting duplicate values.', this.vm);
+	    };
+	  }
+
+	  var vIf = {
+
+	    priority: IF,
+	    terminal: true,
+
+	    bind: function bind() {
+	      var el = this.el;
+	      if (!el.__vue__) {
+	        // check else block
+	        var next = el.nextElementSibling;
+	        if (next && getAttr(next, 'v-else') !== null) {
+	          remove(next);
+	          this.elseEl = next;
+	        }
+	        // check main block
+	        this.anchor = createAnchor('v-if');
+	        replace(el, this.anchor);
+	      } else {
+	        'development' !== 'production' && warn('v-if="' + this.expression + '" cannot be ' + 'used on an instance root element.', this.vm);
+	        this.invalid = true;
+	      }
+	    },
+
+	    update: function update(value) {
+	      if (this.invalid) return;
+	      if (value) {
+	        if (!this.frag) {
+	          this.insert();
+	        }
+	      } else {
+	        this.remove();
+	      }
+	    },
+
+	    insert: function insert() {
+	      if (this.elseFrag) {
+	        this.elseFrag.remove();
+	        this.elseFrag = null;
+	      }
+	      // lazy init factory
+	      if (!this.factory) {
+	        this.factory = new FragmentFactory(this.vm, this.el);
+	      }
+	      this.frag = this.factory.create(this._host, this._scope, this._frag);
+	      this.frag.before(this.anchor);
+	    },
+
+	    remove: function remove() {
+	      if (this.frag) {
+	        this.frag.remove();
+	        this.frag = null;
+	      }
+	      if (this.elseEl && !this.elseFrag) {
+	        if (!this.elseFactory) {
+	          this.elseFactory = new FragmentFactory(this.elseEl._context || this.vm, this.elseEl);
+	        }
+	        this.elseFrag = this.elseFactory.create(this._host, this._scope, this._frag);
+	        this.elseFrag.before(this.anchor);
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      if (this.frag) {
+	        this.frag.destroy();
+	      }
+	      if (this.elseFrag) {
+	        this.elseFrag.destroy();
+	      }
+	    }
+	  };
+
+	  var show = {
+
+	    bind: function bind() {
+	      // check else block
+	      var next = this.el.nextElementSibling;
+	      if (next && getAttr(next, 'v-else') !== null) {
+	        this.elseEl = next;
+	      }
+	    },
+
+	    update: function update(value) {
+	      this.apply(this.el, value);
+	      if (this.elseEl) {
+	        this.apply(this.elseEl, !value);
+	      }
+	    },
+
+	    apply: function apply(el, value) {
+	      if (inDoc(el)) {
+	        applyTransition(el, value ? 1 : -1, toggle, this.vm);
+	      } else {
+	        toggle();
+	      }
+	      function toggle() {
+	        el.style.display = value ? '' : 'none';
+	      }
+	    }
+	  };
+
+	  var text$2 = {
+
+	    bind: function bind() {
+	      var self = this;
+	      var el = this.el;
+	      var isRange = el.type === 'range';
+	      var lazy = this.params.lazy;
+	      var number = this.params.number;
+	      var debounce = this.params.debounce;
+
+	      // handle composition events.
+	      //   http://blog.evanyou.me/2014/01/03/composition-event/
+	      // skip this for Android because it handles composition
+	      // events quite differently. Android doesn't trigger
+	      // composition events for language input methods e.g.
+	      // Chinese, but instead triggers them for spelling
+	      // suggestions... (see Discussion/#162)
+	      var composing = false;
+	      if (!isAndroid && !isRange) {
+	        this.on('compositionstart', function () {
+	          composing = true;
+	        });
+	        this.on('compositionend', function () {
+	          composing = false;
+	          // in IE11 the "compositionend" event fires AFTER
+	          // the "input" event, so the input handler is blocked
+	          // at the end... have to call it here.
+	          //
+	          // #1327: in lazy mode this is unecessary.
+	          if (!lazy) {
+	            self.listener();
+	          }
+	        });
+	      }
+
+	      // prevent messing with the input when user is typing,
+	      // and force update on blur.
+	      this.focused = false;
+	      if (!isRange && !lazy) {
+	        this.on('focus', function () {
+	          self.focused = true;
+	        });
+	        this.on('blur', function () {
+	          self.focused = false;
+	          // do not sync value after fragment removal (#2017)
+	          if (!self._frag || self._frag.inserted) {
+	            self.rawListener();
+	          }
+	        });
+	      }
+
+	      // Now attach the main listener
+	      this.listener = this.rawListener = function () {
+	        if (composing || !self._bound) {
+	          return;
+	        }
+	        var val = number || isRange ? toNumber(el.value) : el.value;
+	        self.set(val);
+	        // force update on next tick to avoid lock & same value
+	        // also only update when user is not typing
+	        nextTick(function () {
+	          if (self._bound && !self.focused) {
+	            self.update(self._watcher.value);
+	          }
+	        });
+	      };
+
+	      // apply debounce
+	      if (debounce) {
+	        this.listener = _debounce(this.listener, debounce);
+	      }
+
+	      // Support jQuery events, since jQuery.trigger() doesn't
+	      // trigger native events in some cases and some plugins
+	      // rely on $.trigger()
+	      //
+	      // We want to make sure if a listener is attached using
+	      // jQuery, it is also removed with jQuery, that's why
+	      // we do the check for each directive instance and
+	      // store that check result on itself. This also allows
+	      // easier test coverage control by unsetting the global
+	      // jQuery variable in tests.
+	      this.hasjQuery = typeof jQuery === 'function';
+	      if (this.hasjQuery) {
+	        var method = jQuery.fn.on ? 'on' : 'bind';
+	        jQuery(el)[method]('change', this.rawListener);
+	        if (!lazy) {
+	          jQuery(el)[method]('input', this.listener);
+	        }
+	      } else {
+	        this.on('change', this.rawListener);
+	        if (!lazy) {
+	          this.on('input', this.listener);
+	        }
+	      }
+
+	      // IE9 doesn't fire input event on backspace/del/cut
+	      if (!lazy && isIE9) {
+	        this.on('cut', function () {
+	          nextTick(self.listener);
+	        });
+	        this.on('keyup', function (e) {
+	          if (e.keyCode === 46 || e.keyCode === 8) {
+	            self.listener();
+	          }
+	        });
+	      }
+
+	      // set initial value if present
+	      if (el.hasAttribute('value') || el.tagName === 'TEXTAREA' && el.value.trim()) {
+	        this.afterBind = this.listener;
+	      }
+	    },
+
+	    update: function update(value) {
+	      this.el.value = _toString(value);
+	    },
+
+	    unbind: function unbind() {
+	      var el = this.el;
+	      if (this.hasjQuery) {
+	        var method = jQuery.fn.off ? 'off' : 'unbind';
+	        jQuery(el)[method]('change', this.listener);
+	        jQuery(el)[method]('input', this.listener);
+	      }
+	    }
+	  };
+
+	  var radio = {
+
+	    bind: function bind() {
+	      var self = this;
+	      var el = this.el;
+
+	      this.getValue = function () {
+	        // value overwrite via v-bind:value
+	        if (el.hasOwnProperty('_value')) {
+	          return el._value;
+	        }
+	        var val = el.value;
+	        if (self.params.number) {
+	          val = toNumber(val);
+	        }
+	        return val;
+	      };
+
+	      this.listener = function () {
+	        self.set(self.getValue());
+	      };
+	      this.on('change', this.listener);
+
+	      if (el.hasAttribute('checked')) {
+	        this.afterBind = this.listener;
+	      }
+	    },
+
+	    update: function update(value) {
+	      this.el.checked = looseEqual(value, this.getValue());
+	    }
+	  };
+
+	  var select = {
+
+	    bind: function bind() {
+	      var self = this;
+	      var el = this.el;
+
+	      // method to force update DOM using latest value.
+	      this.forceUpdate = function () {
+	        if (self._watcher) {
+	          self.update(self._watcher.get());
+	        }
+	      };
+
+	      // check if this is a multiple select
+	      var multiple = this.multiple = el.hasAttribute('multiple');
+
+	      // attach listener
+	      this.listener = function () {
+	        var value = getValue(el, multiple);
+	        value = self.params.number ? isArray(value) ? value.map(toNumber) : toNumber(value) : value;
+	        self.set(value);
+	      };
+	      this.on('change', this.listener);
+
+	      // if has initial value, set afterBind
+	      var initValue = getValue(el, multiple, true);
+	      if (multiple && initValue.length || !multiple && initValue !== null) {
+	        this.afterBind = this.listener;
+	      }
+
+	      // All major browsers except Firefox resets
+	      // selectedIndex with value -1 to 0 when the element
+	      // is appended to a new parent, therefore we have to
+	      // force a DOM update whenever that happens...
+	      this.vm.$on('hook:attached', this.forceUpdate);
+	    },
+
+	    update: function update(value) {
+	      var el = this.el;
+	      el.selectedIndex = -1;
+	      var multi = this.multiple && isArray(value);
+	      var options = el.options;
+	      var i = options.length;
+	      var op, val;
+	      while (i--) {
+	        op = options[i];
+	        val = op.hasOwnProperty('_value') ? op._value : op.value;
+	        /* eslint-disable eqeqeq */
+	        op.selected = multi ? indexOf$1(value, val) > -1 : looseEqual(value, val);
+	        /* eslint-enable eqeqeq */
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      /* istanbul ignore next */
+	      this.vm.$off('hook:attached', this.forceUpdate);
+	    }
+	  };
+
+	  /**
+	   * Get select value
+	   *
+	   * @param {SelectElement} el
+	   * @param {Boolean} multi
+	   * @param {Boolean} init
+	   * @return {Array|*}
+	   */
+
+	  function getValue(el, multi, init) {
+	    var res = multi ? [] : null;
+	    var op, val, selected;
+	    for (var i = 0, l = el.options.length; i < l; i++) {
+	      op = el.options[i];
+	      selected = init ? op.hasAttribute('selected') : op.selected;
+	      if (selected) {
+	        val = op.hasOwnProperty('_value') ? op._value : op.value;
+	        if (multi) {
+	          res.push(val);
+	        } else {
+	          return val;
+	        }
+	      }
+	    }
+	    return res;
+	  }
+
+	  /**
+	   * Native Array.indexOf uses strict equal, but in this
+	   * case we need to match string/numbers with custom equal.
+	   *
+	   * @param {Array} arr
+	   * @param {*} val
+	   */
+
+	  function indexOf$1(arr, val) {
+	    var i = arr.length;
+	    while (i--) {
+	      if (looseEqual(arr[i], val)) {
+	        return i;
+	      }
+	    }
+	    return -1;
+	  }
+
+	  var checkbox = {
+
+	    bind: function bind() {
+	      var self = this;
+	      var el = this.el;
+
+	      this.getValue = function () {
+	        return el.hasOwnProperty('_value') ? el._value : self.params.number ? toNumber(el.value) : el.value;
+	      };
+
+	      function getBooleanValue() {
+	        var val = el.checked;
+	        if (val && el.hasOwnProperty('_trueValue')) {
+	          return el._trueValue;
+	        }
+	        if (!val && el.hasOwnProperty('_falseValue')) {
+	          return el._falseValue;
+	        }
+	        return val;
+	      }
+
+	      this.listener = function () {
+	        var model = self._watcher.value;
+	        if (isArray(model)) {
+	          var val = self.getValue();
+	          if (el.checked) {
+	            if (indexOf(model, val) < 0) {
+	              model.push(val);
+	            }
+	          } else {
+	            model.$remove(val);
+	          }
+	        } else {
+	          self.set(getBooleanValue());
+	        }
+	      };
+
+	      this.on('change', this.listener);
+	      if (el.hasAttribute('checked')) {
+	        this.afterBind = this.listener;
+	      }
+	    },
+
+	    update: function update(value) {
+	      var el = this.el;
+	      if (isArray(value)) {
+	        el.checked = indexOf(value, this.getValue()) > -1;
+	      } else {
+	        if (el.hasOwnProperty('_trueValue')) {
+	          el.checked = looseEqual(value, el._trueValue);
+	        } else {
+	          el.checked = !!value;
+	        }
+	      }
+	    }
+	  };
+
+	  var handlers = {
+	    text: text$2,
+	    radio: radio,
+	    select: select,
+	    checkbox: checkbox
+	  };
+
+	  var model = {
+
+	    priority: MODEL,
+	    twoWay: true,
+	    handlers: handlers,
+	    params: ['lazy', 'number', 'debounce'],
+
+	    /**
+	     * Possible elements:
+	     *   <select>
+	     *   <textarea>
+	     *   <input type="*">
+	     *     - text
+	     *     - checkbox
+	     *     - radio
+	     *     - number
+	     */
+
+	    bind: function bind() {
+	      // friendly warning...
+	      this.checkFilters();
+	      if (this.hasRead && !this.hasWrite) {
+	        'development' !== 'production' && warn('It seems you are using a read-only filter with ' + 'v-model="' + this.descriptor.raw + '". ' + 'You might want to use a two-way filter to ensure correct behavior.', this.vm);
+	      }
+	      var el = this.el;
+	      var tag = el.tagName;
+	      var handler;
+	      if (tag === 'INPUT') {
+	        handler = handlers[el.type] || handlers.text;
+	      } else if (tag === 'SELECT') {
+	        handler = handlers.select;
+	      } else if (tag === 'TEXTAREA') {
+	        handler = handlers.text;
+	      } else {
+	        'development' !== 'production' && warn('v-model does not support element type: ' + tag, this.vm);
+	        return;
+	      }
+	      el.__v_model = this;
+	      handler.bind.call(this);
+	      this.update = handler.update;
+	      this._unbind = handler.unbind;
+	    },
+
+	    /**
+	     * Check read/write filter stats.
+	     */
+
+	    checkFilters: function checkFilters() {
+	      var filters = this.filters;
+	      if (!filters) return;
+	      var i = filters.length;
+	      while (i--) {
+	        var filter = resolveAsset(this.vm.$options, 'filters', filters[i].name);
+	        if (typeof filter === 'function' || filter.read) {
+	          this.hasRead = true;
+	        }
+	        if (filter.write) {
+	          this.hasWrite = true;
+	        }
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      this.el.__v_model = null;
+	      this._unbind && this._unbind();
+	    }
+	  };
+
+	  // keyCode aliases
+	  var keyCodes = {
+	    esc: 27,
+	    tab: 9,
+	    enter: 13,
+	    space: 32,
+	    'delete': [8, 46],
+	    up: 38,
+	    left: 37,
+	    right: 39,
+	    down: 40
+	  };
+
+	  function keyFilter(handler, keys) {
+	    var codes = keys.map(function (key) {
+	      var charCode = key.charCodeAt(0);
+	      if (charCode > 47 && charCode < 58) {
+	        return parseInt(key, 10);
+	      }
+	      if (key.length === 1) {
+	        charCode = key.toUpperCase().charCodeAt(0);
+	        if (charCode > 64 && charCode < 91) {
+	          return charCode;
+	        }
+	      }
+	      return keyCodes[key];
+	    });
+	    codes = [].concat.apply([], codes);
+	    return function keyHandler(e) {
+	      if (codes.indexOf(e.keyCode) > -1) {
+	        return handler.call(this, e);
+	      }
+	    };
+	  }
+
+	  function stopFilter(handler) {
+	    return function stopHandler(e) {
+	      e.stopPropagation();
+	      return handler.call(this, e);
+	    };
+	  }
+
+	  function preventFilter(handler) {
+	    return function preventHandler(e) {
+	      e.preventDefault();
+	      return handler.call(this, e);
+	    };
+	  }
+
+	  function selfFilter(handler) {
+	    return function selfHandler(e) {
+	      if (e.target === e.currentTarget) {
+	        return handler.call(this, e);
+	      }
+	    };
+	  }
+
+	  var on$1 = {
+
+	    priority: ON,
+	    acceptStatement: true,
+	    keyCodes: keyCodes,
+
+	    bind: function bind() {
+	      // deal with iframes
+	      if (this.el.tagName === 'IFRAME' && this.arg !== 'load') {
+	        var self = this;
+	        this.iframeBind = function () {
+	          on(self.el.contentWindow, self.arg, self.handler, self.modifiers.capture);
+	        };
+	        this.on('load', this.iframeBind);
+	      }
+	    },
+
+	    update: function update(handler) {
+	      // stub a noop for v-on with no value,
+	      // e.g. @mousedown.prevent
+	      if (!this.descriptor.raw) {
+	        handler = function () {};
+	      }
+
+	      if (typeof handler !== 'function') {
+	        'development' !== 'production' && warn('v-on:' + this.arg + '="' + this.expression + '" expects a function value, ' + 'got ' + handler, this.vm);
+	        return;
+	      }
+
+	      // apply modifiers
+	      if (this.modifiers.stop) {
+	        handler = stopFilter(handler);
+	      }
+	      if (this.modifiers.prevent) {
+	        handler = preventFilter(handler);
+	      }
+	      if (this.modifiers.self) {
+	        handler = selfFilter(handler);
+	      }
+	      // key filter
+	      var keys = Object.keys(this.modifiers).filter(function (key) {
+	        return key !== 'stop' && key !== 'prevent' && key !== 'self' && key !== 'capture';
+	      });
+	      if (keys.length) {
+	        handler = keyFilter(handler, keys);
+	      }
+
+	      this.reset();
+	      this.handler = handler;
+
+	      if (this.iframeBind) {
+	        this.iframeBind();
+	      } else {
+	        on(this.el, this.arg, this.handler, this.modifiers.capture);
+	      }
+	    },
+
+	    reset: function reset() {
+	      var el = this.iframeBind ? this.el.contentWindow : this.el;
+	      if (this.handler) {
+	        off(el, this.arg, this.handler);
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      this.reset();
+	    }
+	  };
+
+	  var prefixes = ['-webkit-', '-moz-', '-ms-'];
+	  var camelPrefixes = ['Webkit', 'Moz', 'ms'];
+	  var importantRE = /!important;?$/;
+	  var propCache = Object.create(null);
+
+	  var testEl = null;
+
+	  var style = {
+
+	    deep: true,
+
+	    update: function update(value) {
+	      if (typeof value === 'string') {
+	        this.el.style.cssText = value;
+	      } else if (isArray(value)) {
+	        this.handleObject(value.reduce(extend, {}));
+	      } else {
+	        this.handleObject(value || {});
+	      }
+	    },
+
+	    handleObject: function handleObject(value) {
+	      // cache object styles so that only changed props
+	      // are actually updated.
+	      var cache = this.cache || (this.cache = {});
+	      var name, val;
+	      for (name in cache) {
+	        if (!(name in value)) {
+	          this.handleSingle(name, null);
+	          delete cache[name];
+	        }
+	      }
+	      for (name in value) {
+	        val = value[name];
+	        if (val !== cache[name]) {
+	          cache[name] = val;
+	          this.handleSingle(name, val);
+	        }
+	      }
+	    },
+
+	    handleSingle: function handleSingle(prop, value) {
+	      prop = normalize(prop);
+	      if (!prop) return; // unsupported prop
+	      // cast possible numbers/booleans into strings
+	      if (value != null) value += '';
+	      if (value) {
+	        var isImportant = importantRE.test(value) ? 'important' : '';
+	        if (isImportant) {
+	          /* istanbul ignore if */
+	          if (true) {
+	            warn('It\'s probably a bad idea to use !important with inline rules. ' + 'This feature will be deprecated in a future version of Vue.');
+	          }
+	          value = value.replace(importantRE, '').trim();
+	          this.el.style.setProperty(prop.kebab, value, isImportant);
+	        } else {
+	          this.el.style[prop.camel] = value;
+	        }
+	      } else {
+	        this.el.style[prop.camel] = '';
+	      }
+	    }
+
+	  };
+
+	  /**
+	   * Normalize a CSS property name.
+	   * - cache result
+	   * - auto prefix
+	   * - camelCase -> dash-case
+	   *
+	   * @param {String} prop
+	   * @return {String}
+	   */
+
+	  function normalize(prop) {
+	    if (propCache[prop]) {
+	      return propCache[prop];
+	    }
+	    var res = prefix(prop);
+	    propCache[prop] = propCache[res] = res;
+	    return res;
+	  }
+
+	  /**
+	   * Auto detect the appropriate prefix for a CSS property.
+	   * https://gist.github.com/paulirish/523692
+	   *
+	   * @param {String} prop
+	   * @return {String}
+	   */
+
+	  function prefix(prop) {
+	    prop = hyphenate(prop);
+	    var camel = camelize(prop);
+	    var upper = camel.charAt(0).toUpperCase() + camel.slice(1);
+	    if (!testEl) {
+	      testEl = document.createElement('div');
+	    }
+	    var i = prefixes.length;
+	    var prefixed;
+	    if (camel !== 'filter' && camel in testEl.style) {
+	      return {
+	        kebab: prop,
+	        camel: camel
+	      };
+	    }
+	    while (i--) {
+	      prefixed = camelPrefixes[i] + upper;
+	      if (prefixed in testEl.style) {
+	        return {
+	          kebab: prefixes[i] + prop,
+	          camel: prefixed
+	        };
+	      }
+	    }
+	  }
+
+	  // xlink
+	  var xlinkNS = 'http://www.w3.org/1999/xlink';
+	  var xlinkRE = /^xlink:/;
+
+	  // check for attributes that prohibit interpolations
+	  var disallowedInterpAttrRE = /^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/;
+	  // these attributes should also set their corresponding properties
+	  // because they only affect the initial state of the element
+	  var attrWithPropsRE = /^(?:value|checked|selected|muted)$/;
+	  // these attributes expect enumrated values of "true" or "false"
+	  // but are not boolean attributes
+	  var enumeratedAttrRE = /^(?:draggable|contenteditable|spellcheck)$/;
+
+	  // these attributes should set a hidden property for
+	  // binding v-model to object values
+	  var modelProps = {
+	    value: '_value',
+	    'true-value': '_trueValue',
+	    'false-value': '_falseValue'
+	  };
+
+	  var bind$1 = {
+
+	    priority: BIND,
+
+	    bind: function bind() {
+	      var attr = this.arg;
+	      var tag = this.el.tagName;
+	      // should be deep watch on object mode
+	      if (!attr) {
+	        this.deep = true;
+	      }
+	      // handle interpolation bindings
+	      var descriptor = this.descriptor;
+	      var tokens = descriptor.interp;
+	      if (tokens) {
+	        // handle interpolations with one-time tokens
+	        if (descriptor.hasOneTime) {
+	          this.expression = tokensToExp(tokens, this._scope || this.vm);
+	        }
+
+	        // only allow binding on native attributes
+	        if (disallowedInterpAttrRE.test(attr) || attr === 'name' && (tag === 'PARTIAL' || tag === 'SLOT')) {
+	          'development' !== 'production' && warn(attr + '="' + descriptor.raw + '": ' + 'attribute interpolation is not allowed in Vue.js ' + 'directives and special attributes.', this.vm);
+	          this.el.removeAttribute(attr);
+	          this.invalid = true;
+	        }
+
+	        /* istanbul ignore if */
+	        if (true) {
+	          var raw = attr + '="' + descriptor.raw + '": ';
+	          // warn src
+	          if (attr === 'src') {
+	            warn(raw + 'interpolation in "src" attribute will cause ' + 'a 404 request. Use v-bind:src instead.', this.vm);
+	          }
+
+	          // warn style
+	          if (attr === 'style') {
+	            warn(raw + 'interpolation in "style" attribute will cause ' + 'the attribute to be discarded in Internet Explorer. ' + 'Use v-bind:style instead.', this.vm);
+	          }
+	        }
+	      }
+	    },
+
+	    update: function update(value) {
+	      if (this.invalid) {
+	        return;
+	      }
+	      var attr = this.arg;
+	      if (this.arg) {
+	        this.handleSingle(attr, value);
+	      } else {
+	        this.handleObject(value || {});
+	      }
+	    },
+
+	    // share object handler with v-bind:class
+	    handleObject: style.handleObject,
+
+	    handleSingle: function handleSingle(attr, value) {
+	      var el = this.el;
+	      var interp = this.descriptor.interp;
+	      if (this.modifiers.camel) {
+	        attr = camelize(attr);
+	      }
+	      if (!interp && attrWithPropsRE.test(attr) && attr in el) {
+	        var attrValue = attr === 'value' ? value == null // IE9 will set input.value to "null" for null...
+	        ? '' : value : value;
+
+	        if (el[attr] !== attrValue) {
+	          el[attr] = attrValue;
+	        }
+	      }
+	      // set model props
+	      var modelProp = modelProps[attr];
+	      if (!interp && modelProp) {
+	        el[modelProp] = value;
+	        // update v-model if present
+	        var model = el.__v_model;
+	        if (model) {
+	          model.listener();
+	        }
+	      }
+	      // do not set value attribute for textarea
+	      if (attr === 'value' && el.tagName === 'TEXTAREA') {
+	        el.removeAttribute(attr);
+	        return;
+	      }
+	      // update attribute
+	      if (enumeratedAttrRE.test(attr)) {
+	        el.setAttribute(attr, value ? 'true' : 'false');
+	      } else if (value != null && value !== false) {
+	        if (attr === 'class') {
+	          // handle edge case #1960:
+	          // class interpolation should not overwrite Vue transition class
+	          if (el.__v_trans) {
+	            value += ' ' + el.__v_trans.id + '-transition';
+	          }
+	          setClass(el, value);
+	        } else if (xlinkRE.test(attr)) {
+	          el.setAttributeNS(xlinkNS, attr, value === true ? '' : value);
+	        } else {
+	          el.setAttribute(attr, value === true ? '' : value);
+	        }
+	      } else {
+	        el.removeAttribute(attr);
+	      }
+	    }
+	  };
+
+	  var el = {
+
+	    priority: EL,
+
+	    bind: function bind() {
+	      /* istanbul ignore if */
+	      if (!this.arg) {
+	        return;
+	      }
+	      var id = this.id = camelize(this.arg);
+	      var refs = (this._scope || this.vm).$els;
+	      if (hasOwn(refs, id)) {
+	        refs[id] = this.el;
+	      } else {
+	        defineReactive(refs, id, this.el);
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      var refs = (this._scope || this.vm).$els;
+	      if (refs[this.id] === this.el) {
+	        refs[this.id] = null;
+	      }
+	    }
+	  };
+
+	  var ref = {
+	    bind: function bind() {
+	      'development' !== 'production' && warn('v-ref:' + this.arg + ' must be used on a child ' + 'component. Found on <' + this.el.tagName.toLowerCase() + '>.', this.vm);
+	    }
+	  };
+
+	  var cloak = {
+	    bind: function bind() {
+	      var el = this.el;
+	      this.vm.$once('pre-hook:compiled', function () {
+	        el.removeAttribute('v-cloak');
+	      });
+	    }
+	  };
+
+	  // must export plain object
+	  var directives = {
+	    text: text$1,
+	    html: html,
+	    'for': vFor,
+	    'if': vIf,
+	    show: show,
+	    model: model,
+	    on: on$1,
+	    bind: bind$1,
+	    el: el,
+	    ref: ref,
+	    cloak: cloak
+	  };
+
+	  var vClass = {
+
+	    deep: true,
+
+	    update: function update(value) {
+	      if (!value) {
+	        this.cleanup();
+	      } else if (typeof value === 'string') {
+	        this.setClass(value.trim().split(/\s+/));
+	      } else {
+	        this.setClass(normalize$1(value));
+	      }
+	    },
+
+	    setClass: function setClass(value) {
+	      this.cleanup(value);
+	      for (var i = 0, l = value.length; i < l; i++) {
+	        var val = value[i];
+	        if (val) {
+	          apply(this.el, val, addClass);
+	        }
+	      }
+	      this.prevKeys = value;
+	    },
+
+	    cleanup: function cleanup(value) {
+	      var prevKeys = this.prevKeys;
+	      if (!prevKeys) return;
+	      var i = prevKeys.length;
+	      while (i--) {
+	        var key = prevKeys[i];
+	        if (!value || value.indexOf(key) < 0) {
+	          apply(this.el, key, removeClass);
+	        }
+	      }
+	    }
+	  };
+
+	  /**
+	   * Normalize objects and arrays (potentially containing objects)
+	   * into array of strings.
+	   *
+	   * @param {Object|Array<String|Object>} value
+	   * @return {Array<String>}
+	   */
+
+	  function normalize$1(value) {
+	    var res = [];
+	    if (isArray(value)) {
+	      for (var i = 0, l = value.length; i < l; i++) {
+	        var _key = value[i];
+	        if (_key) {
+	          if (typeof _key === 'string') {
+	            res.push(_key);
+	          } else {
+	            for (var k in _key) {
+	              if (_key[k]) res.push(k);
+	            }
+	          }
+	        }
+	      }
+	    } else if (isObject(value)) {
+	      for (var key in value) {
+	        if (value[key]) res.push(key);
+	      }
+	    }
+	    return res;
+	  }
+
+	  /**
+	   * Add or remove a class/classes on an element
+	   *
+	   * @param {Element} el
+	   * @param {String} key The class name. This may or may not
+	   *                     contain a space character, in such a
+	   *                     case we'll deal with multiple class
+	   *                     names at once.
+	   * @param {Function} fn
+	   */
+
+	  function apply(el, key, fn) {
+	    key = key.trim();
+	    if (key.indexOf(' ') === -1) {
+	      fn(el, key);
+	      return;
+	    }
+	    // The key contains one or more space characters.
+	    // Since a class name doesn't accept such characters, we
+	    // treat it as multiple classes.
+	    var keys = key.split(/\s+/);
+	    for (var i = 0, l = keys.length; i < l; i++) {
+	      fn(el, keys[i]);
+	    }
+	  }
+
+	  var component = {
+
+	    priority: COMPONENT,
+
+	    params: ['keep-alive', 'transition-mode', 'inline-template'],
+
+	    /**
+	     * Setup. Two possible usages:
+	     *
+	     * - static:
+	     *   <comp> or <div v-component="comp">
+	     *
+	     * - dynamic:
+	     *   <component :is="view">
+	     */
+
+	    bind: function bind() {
+	      if (!this.el.__vue__) {
+	        // keep-alive cache
+	        this.keepAlive = this.params.keepAlive;
+	        if (this.keepAlive) {
+	          this.cache = {};
+	        }
+	        // check inline-template
+	        if (this.params.inlineTemplate) {
+	          // extract inline template as a DocumentFragment
+	          this.inlineTemplate = extractContent(this.el, true);
+	        }
+	        // component resolution related state
+	        this.pendingComponentCb = this.Component = null;
+	        // transition related state
+	        this.pendingRemovals = 0;
+	        this.pendingRemovalCb = null;
+	        // create a ref anchor
+	        this.anchor = createAnchor('v-component');
+	        replace(this.el, this.anchor);
+	        // remove is attribute.
+	        // this is removed during compilation, but because compilation is
+	        // cached, when the component is used elsewhere this attribute
+	        // will remain at link time.
+	        this.el.removeAttribute('is');
+	        this.el.removeAttribute(':is');
+	        // remove ref, same as above
+	        if (this.descriptor.ref) {
+	          this.el.removeAttribute('v-ref:' + hyphenate(this.descriptor.ref));
+	        }
+	        // if static, build right now.
+	        if (this.literal) {
+	          this.setComponent(this.expression);
+	        }
+	      } else {
+	        'development' !== 'production' && warn('cannot mount component "' + this.expression + '" ' + 'on already mounted element: ' + this.el);
+	      }
+	    },
+
+	    /**
+	     * Public update, called by the watcher in the dynamic
+	     * literal scenario, e.g. <component :is="view">
+	     */
+
+	    update: function update(value) {
+	      if (!this.literal) {
+	        this.setComponent(value);
+	      }
+	    },
+
+	    /**
+	     * Switch dynamic components. May resolve the component
+	     * asynchronously, and perform transition based on
+	     * specified transition mode. Accepts a few additional
+	     * arguments specifically for vue-router.
+	     *
+	     * The callback is called when the full transition is
+	     * finished.
+	     *
+	     * @param {String} value
+	     * @param {Function} [cb]
+	     */
+
+	    setComponent: function setComponent(value, cb) {
+	      this.invalidatePending();
+	      if (!value) {
+	        // just remove current
+	        this.unbuild(true);
+	        this.remove(this.childVM, cb);
+	        this.childVM = null;
+	      } else {
+	        var self = this;
+	        this.resolveComponent(value, function () {
+	          self.mountComponent(cb);
+	        });
+	      }
+	    },
+
+	    /**
+	     * Resolve the component constructor to use when creating
+	     * the child vm.
+	     *
+	     * @param {String|Function} value
+	     * @param {Function} cb
+	     */
+
+	    resolveComponent: function resolveComponent(value, cb) {
+	      var self = this;
+	      this.pendingComponentCb = cancellable(function (Component) {
+	        self.ComponentName = Component.options.name || (typeof value === 'string' ? value : null);
+	        self.Component = Component;
+	        cb();
+	      });
+	      this.vm._resolveComponent(value, this.pendingComponentCb);
+	    },
+
+	    /**
+	     * Create a new instance using the current constructor and
+	     * replace the existing instance. This method doesn't care
+	     * whether the new component and the old one are actually
+	     * the same.
+	     *
+	     * @param {Function} [cb]
+	     */
+
+	    mountComponent: function mountComponent(cb) {
+	      // actual mount
+	      this.unbuild(true);
+	      var self = this;
+	      var activateHooks = this.Component.options.activate;
+	      var cached = this.getCached();
+	      var newComponent = this.build();
+	      if (activateHooks && !cached) {
+	        this.waitingFor = newComponent;
+	        callActivateHooks(activateHooks, newComponent, function () {
+	          if (self.waitingFor !== newComponent) {
+	            return;
+	          }
+	          self.waitingFor = null;
+	          self.transition(newComponent, cb);
+	        });
+	      } else {
+	        // update ref for kept-alive component
+	        if (cached) {
+	          newComponent._updateRef();
+	        }
+	        this.transition(newComponent, cb);
+	      }
+	    },
+
+	    /**
+	     * When the component changes or unbinds before an async
+	     * constructor is resolved, we need to invalidate its
+	     * pending callback.
+	     */
+
+	    invalidatePending: function invalidatePending() {
+	      if (this.pendingComponentCb) {
+	        this.pendingComponentCb.cancel();
+	        this.pendingComponentCb = null;
+	      }
+	    },
+
+	    /**
+	     * Instantiate/insert a new child vm.
+	     * If keep alive and has cached instance, insert that
+	     * instance; otherwise build a new one and cache it.
+	     *
+	     * @param {Object} [extraOptions]
+	     * @return {Vue} - the created instance
+	     */
+
+	    build: function build(extraOptions) {
+	      var cached = this.getCached();
+	      if (cached) {
+	        return cached;
+	      }
+	      if (this.Component) {
+	        // default options
+	        var options = {
+	          name: this.ComponentName,
+	          el: cloneNode(this.el),
+	          template: this.inlineTemplate,
+	          // make sure to add the child with correct parent
+	          // if this is a transcluded component, its parent
+	          // should be the transclusion host.
+	          parent: this._host || this.vm,
+	          // if no inline-template, then the compiled
+	          // linker can be cached for better performance.
+	          _linkerCachable: !this.inlineTemplate,
+	          _ref: this.descriptor.ref,
+	          _asComponent: true,
+	          _isRouterView: this._isRouterView,
+	          // if this is a transcluded component, context
+	          // will be the common parent vm of this instance
+	          // and its host.
+	          _context: this.vm,
+	          // if this is inside an inline v-for, the scope
+	          // will be the intermediate scope created for this
+	          // repeat fragment. this is used for linking props
+	          // and container directives.
+	          _scope: this._scope,
+	          // pass in the owner fragment of this component.
+	          // this is necessary so that the fragment can keep
+	          // track of its contained components in order to
+	          // call attach/detach hooks for them.
+	          _frag: this._frag
+	        };
+	        // extra options
+	        // in 1.0.0 this is used by vue-router only
+	        /* istanbul ignore if */
+	        if (extraOptions) {
+	          extend(options, extraOptions);
+	        }
+	        var child = new this.Component(options);
+	        if (this.keepAlive) {
+	          this.cache[this.Component.cid] = child;
+	        }
+	        /* istanbul ignore if */
+	        if ('development' !== 'production' && this.el.hasAttribute('transition') && child._isFragment) {
+	          warn('Transitions will not work on a fragment instance. ' + 'Template: ' + child.$options.template, child);
+	        }
+	        return child;
+	      }
+	    },
+
+	    /**
+	     * Try to get a cached instance of the current component.
+	     *
+	     * @return {Vue|undefined}
+	     */
+
+	    getCached: function getCached() {
+	      return this.keepAlive && this.cache[this.Component.cid];
+	    },
+
+	    /**
+	     * Teardown the current child, but defers cleanup so
+	     * that we can separate the destroy and removal steps.
+	     *
+	     * @param {Boolean} defer
+	     */
+
+	    unbuild: function unbuild(defer) {
+	      if (this.waitingFor) {
+	        if (!this.keepAlive) {
+	          this.waitingFor.$destroy();
+	        }
+	        this.waitingFor = null;
+	      }
+	      var child = this.childVM;
+	      if (!child || this.keepAlive) {
+	        if (child) {
+	          // remove ref
+	          child._inactive = true;
+	          child._updateRef(true);
+	        }
+	        return;
+	      }
+	      // the sole purpose of `deferCleanup` is so that we can
+	      // "deactivate" the vm right now and perform DOM removal
+	      // later.
+	      child.$destroy(false, defer);
+	    },
+
+	    /**
+	     * Remove current destroyed child and manually do
+	     * the cleanup after removal.
+	     *
+	     * @param {Function} cb
+	     */
+
+	    remove: function remove(child, cb) {
+	      var keepAlive = this.keepAlive;
+	      if (child) {
+	        // we may have a component switch when a previous
+	        // component is still being transitioned out.
+	        // we want to trigger only one lastest insertion cb
+	        // when the existing transition finishes. (#1119)
+	        this.pendingRemovals++;
+	        this.pendingRemovalCb = cb;
+	        var self = this;
+	        child.$remove(function () {
+	          self.pendingRemovals--;
+	          if (!keepAlive) child._cleanup();
+	          if (!self.pendingRemovals && self.pendingRemovalCb) {
+	            self.pendingRemovalCb();
+	            self.pendingRemovalCb = null;
+	          }
+	        });
+	      } else if (cb) {
+	        cb();
+	      }
+	    },
+
+	    /**
+	     * Actually swap the components, depending on the
+	     * transition mode. Defaults to simultaneous.
+	     *
+	     * @param {Vue} target
+	     * @param {Function} [cb]
+	     */
+
+	    transition: function transition(target, cb) {
+	      var self = this;
+	      var current = this.childVM;
+	      // for devtool inspection
+	      if (current) current._inactive = true;
+	      target._inactive = false;
+	      this.childVM = target;
+	      switch (self.params.transitionMode) {
+	        case 'in-out':
+	          target.$before(self.anchor, function () {
+	            self.remove(current, cb);
+	          });
+	          break;
+	        case 'out-in':
+	          self.remove(current, function () {
+	            target.$before(self.anchor, cb);
+	          });
+	          break;
+	        default:
+	          self.remove(current);
+	          target.$before(self.anchor, cb);
+	      }
+	    },
+
+	    /**
+	     * Unbind.
+	     */
+
+	    unbind: function unbind() {
+	      this.invalidatePending();
+	      // Do not defer cleanup when unbinding
+	      this.unbuild();
+	      // destroy all keep-alive cached instances
+	      if (this.cache) {
+	        for (var key in this.cache) {
+	          this.cache[key].$destroy();
+	        }
+	        this.cache = null;
+	      }
+	    }
+	  };
+
+	  /**
+	   * Call activate hooks in order (asynchronous)
+	   *
+	   * @param {Array} hooks
+	   * @param {Vue} vm
+	   * @param {Function} cb
+	   */
+
+	  function callActivateHooks(hooks, vm, cb) {
+	    var total = hooks.length;
+	    var called = 0;
+	    hooks[0].call(vm, next);
+	    function next() {
+	      if (++called >= total) {
+	        cb();
+	      } else {
+	        hooks[called].call(vm, next);
+	      }
+	    }
+	  }
+
+	  var propBindingModes = config._propBindingModes;
+	  var empty = {};
+
+	  // regexes
+	  var identRE$1 = /^[$_a-zA-Z]+[\w$]*$/;
+	  var settablePathRE = /^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/;
+
+	  /**
+	   * Compile props on a root element and return
+	   * a props link function.
+	   *
+	   * @param {Element|DocumentFragment} el
+	   * @param {Array} propOptions
+	   * @param {Vue} vm
+	   * @return {Function} propsLinkFn
+	   */
+
+	  function compileProps(el, propOptions, vm) {
+	    var props = [];
+	    var names = Object.keys(propOptions);
+	    var i = names.length;
+	    var options, name, attr, value, path, parsed, prop;
+	    while (i--) {
+	      name = names[i];
+	      options = propOptions[name] || empty;
+
+	      if ('development' !== 'production' && name === '$data') {
+	        warn('Do not use $data as prop.', vm);
+	        continue;
+	      }
+
+	      // props could contain dashes, which will be
+	      // interpreted as minus calculations by the parser
+	      // so we need to camelize the path here
+	      path = camelize(name);
+	      if (!identRE$1.test(path)) {
+	        'development' !== 'production' && warn('Invalid prop key: "' + name + '". Prop keys ' + 'must be valid identifiers.', vm);
+	        continue;
+	      }
+
+	      prop = {
+	        name: name,
+	        path: path,
+	        options: options,
+	        mode: propBindingModes.ONE_WAY,
+	        raw: null
+	      };
+
+	      attr = hyphenate(name);
+	      // first check dynamic version
+	      if ((value = getBindAttr(el, attr)) === null) {
+	        if ((value = getBindAttr(el, attr + '.sync')) !== null) {
+	          prop.mode = propBindingModes.TWO_WAY;
+	        } else if ((value = getBindAttr(el, attr + '.once')) !== null) {
+	          prop.mode = propBindingModes.ONE_TIME;
+	        }
+	      }
+	      if (value !== null) {
+	        // has dynamic binding!
+	        prop.raw = value;
+	        parsed = parseDirective(value);
+	        value = parsed.expression;
+	        prop.filters = parsed.filters;
+	        // check binding type
+	        if (isLiteral(value) && !parsed.filters) {
+	          // for expressions containing literal numbers and
+	          // booleans, there's no need to setup a prop binding,
+	          // so we can optimize them as a one-time set.
+	          prop.optimizedLiteral = true;
+	        } else {
+	          prop.dynamic = true;
+	          // check non-settable path for two-way bindings
+	          if ('development' !== 'production' && prop.mode === propBindingModes.TWO_WAY && !settablePathRE.test(value)) {
+	            prop.mode = propBindingModes.ONE_WAY;
+	            warn('Cannot bind two-way prop with non-settable ' + 'parent path: ' + value, vm);
+	          }
+	        }
+	        prop.parentPath = value;
+
+	        // warn required two-way
+	        if ('development' !== 'production' && options.twoWay && prop.mode !== propBindingModes.TWO_WAY) {
+	          warn('Prop "' + name + '" expects a two-way binding type.', vm);
+	        }
+	      } else if ((value = getAttr(el, attr)) !== null) {
+	        // has literal binding!
+	        prop.raw = value;
+	      } else if (true) {
+	        // check possible camelCase prop usage
+	        var lowerCaseName = path.toLowerCase();
+	        value = /[A-Z\-]/.test(name) && (el.getAttribute(lowerCaseName) || el.getAttribute(':' + lowerCaseName) || el.getAttribute('v-bind:' + lowerCaseName) || el.getAttribute(':' + lowerCaseName + '.once') || el.getAttribute('v-bind:' + lowerCaseName + '.once') || el.getAttribute(':' + lowerCaseName + '.sync') || el.getAttribute('v-bind:' + lowerCaseName + '.sync'));
+	        if (value) {
+	          warn('Possible usage error for prop `' + lowerCaseName + '` - ' + 'did you mean `' + attr + '`? HTML is case-insensitive, remember to use ' + 'kebab-case for props in templates.', vm);
+	        } else if (options.required) {
+	          // warn missing required
+	          warn('Missing required prop: ' + name, vm);
+	        }
+	      }
+	      // push prop
+	      props.push(prop);
+	    }
+	    return makePropsLinkFn(props);
+	  }
+
+	  /**
+	   * Build a function that applies props to a vm.
+	   *
+	   * @param {Array} props
+	   * @return {Function} propsLinkFn
+	   */
+
+	  function makePropsLinkFn(props) {
+	    return function propsLinkFn(vm, scope) {
+	      // store resolved props info
+	      vm._props = {};
+	      var inlineProps = vm.$options.propsData;
+	      var i = props.length;
+	      var prop, path, options, value, raw;
+	      while (i--) {
+	        prop = props[i];
+	        raw = prop.raw;
+	        path = prop.path;
+	        options = prop.options;
+	        vm._props[path] = prop;
+	        if (inlineProps && hasOwn(inlineProps, path)) {
+	          initProp(vm, prop, inlineProps[path]);
+	        }if (raw === null) {
+	          // initialize absent prop
+	          initProp(vm, prop, undefined);
+	        } else if (prop.dynamic) {
+	          // dynamic prop
+	          if (prop.mode === propBindingModes.ONE_TIME) {
+	            // one time binding
+	            value = (scope || vm._context || vm).$get(prop.parentPath);
+	            initProp(vm, prop, value);
+	          } else {
+	            if (vm._context) {
+	              // dynamic binding
+	              vm._bindDir({
+	                name: 'prop',
+	                def: propDef,
+	                prop: prop
+	              }, null, null, scope); // el, host, scope
+	            } else {
+	                // root instance
+	                initProp(vm, prop, vm.$get(prop.parentPath));
+	              }
+	          }
+	        } else if (prop.optimizedLiteral) {
+	          // optimized literal, cast it and just set once
+	          var stripped = stripQuotes(raw);
+	          value = stripped === raw ? toBoolean(toNumber(raw)) : stripped;
+	          initProp(vm, prop, value);
+	        } else {
+	          // string literal, but we need to cater for
+	          // Boolean props with no value, or with same
+	          // literal value (e.g. disabled="disabled")
+	          // see https://github.com/vuejs/vue-loader/issues/182
+	          value = options.type === Boolean && (raw === '' || raw === hyphenate(prop.name)) ? true : raw;
+	          initProp(vm, prop, value);
+	        }
+	      }
+	    };
+	  }
+
+	  /**
+	   * Process a prop with a rawValue, applying necessary coersions,
+	   * default values & assertions and call the given callback with
+	   * processed value.
+	   *
+	   * @param {Vue} vm
+	   * @param {Object} prop
+	   * @param {*} rawValue
+	   * @param {Function} fn
+	   */
+
+	  function processPropValue(vm, prop, rawValue, fn) {
+	    var isSimple = prop.dynamic && isSimplePath(prop.parentPath);
+	    var value = rawValue;
+	    if (value === undefined) {
+	      value = getPropDefaultValue(vm, prop);
+	    }
+	    value = coerceProp(prop, value);
+	    var coerced = value !== rawValue;
+	    if (!assertProp(prop, value, vm)) {
+	      value = undefined;
+	    }
+	    if (isSimple && !coerced) {
+	      withoutConversion(function () {
+	        fn(value);
+	      });
+	    } else {
+	      fn(value);
+	    }
+	  }
+
+	  /**
+	   * Set a prop's initial value on a vm and its data object.
+	   *
+	   * @param {Vue} vm
+	   * @param {Object} prop
+	   * @param {*} value
+	   */
+
+	  function initProp(vm, prop, value) {
+	    processPropValue(vm, prop, value, function (value) {
+	      defineReactive(vm, prop.path, value);
+	    });
+	  }
+
+	  /**
+	   * Update a prop's value on a vm.
+	   *
+	   * @param {Vue} vm
+	   * @param {Object} prop
+	   * @param {*} value
+	   */
+
+	  function updateProp(vm, prop, value) {
+	    processPropValue(vm, prop, value, function (value) {
+	      vm[prop.path] = value;
+	    });
+	  }
+
+	  /**
+	   * Get the default value of a prop.
+	   *
+	   * @param {Vue} vm
+	   * @param {Object} prop
+	   * @return {*}
+	   */
+
+	  function getPropDefaultValue(vm, prop) {
+	    // no default, return undefined
+	    var options = prop.options;
+	    if (!hasOwn(options, 'default')) {
+	      // absent boolean value defaults to false
+	      return options.type === Boolean ? false : undefined;
+	    }
+	    var def = options['default'];
+	    // warn against non-factory defaults for Object & Array
+	    if (isObject(def)) {
+	      'development' !== 'production' && warn('Invalid default value for prop "' + prop.name + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
+	    }
+	    // call factory function for non-Function types
+	    return typeof def === 'function' && options.type !== Function ? def.call(vm) : def;
+	  }
+
+	  /**
+	   * Assert whether a prop is valid.
+	   *
+	   * @param {Object} prop
+	   * @param {*} value
+	   * @param {Vue} vm
+	   */
+
+	  function assertProp(prop, value, vm) {
+	    if (!prop.options.required && ( // non-required
+	    prop.raw === null || // abscent
+	    value == null) // null or undefined
+	    ) {
+	        return true;
+	      }
+	    var options = prop.options;
+	    var type = options.type;
+	    var valid = !type;
+	    var expectedTypes = [];
+	    if (type) {
+	      if (!isArray(type)) {
+	        type = [type];
+	      }
+	      for (var i = 0; i < type.length && !valid; i++) {
+	        var assertedType = assertType(value, type[i]);
+	        expectedTypes.push(assertedType.expectedType);
+	        valid = assertedType.valid;
+	      }
+	    }
+	    if (!valid) {
+	      if (true) {
+	        warn('Invalid prop: type check failed for prop "' + prop.name + '".' + ' Expected ' + expectedTypes.map(formatType).join(', ') + ', got ' + formatValue(value) + '.', vm);
+	      }
+	      return false;
+	    }
+	    var validator = options.validator;
+	    if (validator) {
+	      if (!validator(value)) {
+	        'development' !== 'production' && warn('Invalid prop: custom validator check failed for prop "' + prop.name + '".', vm);
+	        return false;
+	      }
+	    }
+	    return true;
+	  }
+
+	  /**
+	   * Force parsing value with coerce option.
+	   *
+	   * @param {*} value
+	   * @param {Object} options
+	   * @return {*}
+	   */
+
+	  function coerceProp(prop, value) {
+	    var coerce = prop.options.coerce;
+	    if (!coerce) {
+	      return value;
+	    }
+	    // coerce is a function
+	    return coerce(value);
+	  }
+
+	  /**
+	   * Assert the type of a value
+	   *
+	   * @param {*} value
+	   * @param {Function} type
+	   * @return {Object}
+	   */
+
+	  function assertType(value, type) {
+	    var valid;
+	    var expectedType;
+	    if (type === String) {
+	      expectedType = 'string';
+	      valid = typeof value === expectedType;
+	    } else if (type === Number) {
+	      expectedType = 'number';
+	      valid = typeof value === expectedType;
+	    } else if (type === Boolean) {
+	      expectedType = 'boolean';
+	      valid = typeof value === expectedType;
+	    } else if (type === Function) {
+	      expectedType = 'function';
+	      valid = typeof value === expectedType;
+	    } else if (type === Object) {
+	      expectedType = 'object';
+	      valid = isPlainObject(value);
+	    } else if (type === Array) {
+	      expectedType = 'array';
+	      valid = isArray(value);
+	    } else {
+	      valid = value instanceof type;
+	    }
+	    return {
+	      valid: valid,
+	      expectedType: expectedType
+	    };
+	  }
+
+	  /**
+	   * Format type for output
+	   *
+	   * @param {String} type
+	   * @return {String}
+	   */
+
+	  function formatType(type) {
+	    return type ? type.charAt(0).toUpperCase() + type.slice(1) : 'custom type';
+	  }
+
+	  /**
+	   * Format value
+	   *
+	   * @param {*} value
+	   * @return {String}
+	   */
+
+	  function formatValue(val) {
+	    return Object.prototype.toString.call(val).slice(8, -1);
+	  }
+
+	  var bindingModes = config._propBindingModes;
+
+	  var propDef = {
+
+	    bind: function bind() {
+	      var child = this.vm;
+	      var parent = child._context;
+	      // passed in from compiler directly
+	      var prop = this.descriptor.prop;
+	      var childKey = prop.path;
+	      var parentKey = prop.parentPath;
+	      var twoWay = prop.mode === bindingModes.TWO_WAY;
+
+	      var parentWatcher = this.parentWatcher = new Watcher(parent, parentKey, function (val) {
+	        updateProp(child, prop, val);
+	      }, {
+	        twoWay: twoWay,
+	        filters: prop.filters,
+	        // important: props need to be observed on the
+	        // v-for scope if present
+	        scope: this._scope
+	      });
+
+	      // set the child initial value.
+	      initProp(child, prop, parentWatcher.value);
+
+	      // setup two-way binding
+	      if (twoWay) {
+	        // important: defer the child watcher creation until
+	        // the created hook (after data observation)
+	        var self = this;
+	        child.$once('pre-hook:created', function () {
+	          self.childWatcher = new Watcher(child, childKey, function (val) {
+	            parentWatcher.set(val);
+	          }, {
+	            // ensure sync upward before parent sync down.
+	            // this is necessary in cases e.g. the child
+	            // mutates a prop array, then replaces it. (#1683)
+	            sync: true
+	          });
+	        });
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      this.parentWatcher.teardown();
+	      if (this.childWatcher) {
+	        this.childWatcher.teardown();
+	      }
+	    }
+	  };
+
+	  var queue$1 = [];
+	  var queued = false;
+
+	  /**
+	   * Push a job into the queue.
+	   *
+	   * @param {Function} job
+	   */
+
+	  function pushJob(job) {
+	    queue$1.push(job);
+	    if (!queued) {
+	      queued = true;
+	      nextTick(flush);
+	    }
+	  }
+
+	  /**
+	   * Flush the queue, and do one forced reflow before
+	   * triggering transitions.
+	   */
+
+	  function flush() {
+	    // Force layout
+	    var f = document.documentElement.offsetHeight;
+	    for (var i = 0; i < queue$1.length; i++) {
+	      queue$1[i]();
+	    }
+	    queue$1 = [];
+	    queued = false;
+	    // dummy return, so js linters don't complain about
+	    // unused variable f
+	    return f;
+	  }
+
+	  var TYPE_TRANSITION = 'transition';
+	  var TYPE_ANIMATION = 'animation';
+	  var transDurationProp = transitionProp + 'Duration';
+	  var animDurationProp = animationProp + 'Duration';
+
+	  /**
+	   * If a just-entered element is applied the
+	   * leave class while its enter transition hasn't started yet,
+	   * and the transitioned property has the same value for both
+	   * enter/leave, then the leave transition will be skipped and
+	   * the transitionend event never fires. This function ensures
+	   * its callback to be called after a transition has started
+	   * by waiting for double raf.
+	   *
+	   * It falls back to setTimeout on devices that support CSS
+	   * transitions but not raf (e.g. Android 4.2 browser) - since
+	   * these environments are usually slow, we are giving it a
+	   * relatively large timeout.
+	   */
+
+	  var raf = inBrowser && window.requestAnimationFrame;
+	  var waitForTransitionStart = raf
+	  /* istanbul ignore next */
+	  ? function (fn) {
+	    raf(function () {
+	      raf(fn);
+	    });
+	  } : function (fn) {
+	    setTimeout(fn, 50);
+	  };
+
+	  /**
+	   * A Transition object that encapsulates the state and logic
+	   * of the transition.
+	   *
+	   * @param {Element} el
+	   * @param {String} id
+	   * @param {Object} hooks
+	   * @param {Vue} vm
+	   */
+	  function Transition(el, id, hooks, vm) {
+	    this.id = id;
+	    this.el = el;
+	    this.enterClass = hooks && hooks.enterClass || id + '-enter';
+	    this.leaveClass = hooks && hooks.leaveClass || id + '-leave';
+	    this.hooks = hooks;
+	    this.vm = vm;
+	    // async state
+	    this.pendingCssEvent = this.pendingCssCb = this.cancel = this.pendingJsCb = this.op = this.cb = null;
+	    this.justEntered = false;
+	    this.entered = this.left = false;
+	    this.typeCache = {};
+	    // check css transition type
+	    this.type = hooks && hooks.type;
+	    /* istanbul ignore if */
+	    if (true) {
+	      if (this.type && this.type !== TYPE_TRANSITION && this.type !== TYPE_ANIMATION) {
+	        warn('invalid CSS transition type for transition="' + this.id + '": ' + this.type, vm);
+	      }
+	    }
+	    // bind
+	    var self = this;['enterNextTick', 'enterDone', 'leaveNextTick', 'leaveDone'].forEach(function (m) {
+	      self[m] = bind(self[m], self);
+	    });
+	  }
+
+	  var p$1 = Transition.prototype;
+
+	  /**
+	   * Start an entering transition.
+	   *
+	   * 1. enter transition triggered
+	   * 2. call beforeEnter hook
+	   * 3. add enter class
+	   * 4. insert/show element
+	   * 5. call enter hook (with possible explicit js callback)
+	   * 6. reflow
+	   * 7. based on transition type:
+	   *    - transition:
+	   *        remove class now, wait for transitionend,
+	   *        then done if there's no explicit js callback.
+	   *    - animation:
+	   *        wait for animationend, remove class,
+	   *        then done if there's no explicit js callback.
+	   *    - no css transition:
+	   *        done now if there's no explicit js callback.
+	   * 8. wait for either done or js callback, then call
+	   *    afterEnter hook.
+	   *
+	   * @param {Function} op - insert/show the element
+	   * @param {Function} [cb]
+	   */
+
+	  p$1.enter = function (op, cb) {
+	    this.cancelPending();
+	    this.callHook('beforeEnter');
+	    this.cb = cb;
+	    addClass(this.el, this.enterClass);
+	    op();
+	    this.entered = false;
+	    this.callHookWithCb('enter');
+	    if (this.entered) {
+	      return; // user called done synchronously.
+	    }
+	    this.cancel = this.hooks && this.hooks.enterCancelled;
+	    pushJob(this.enterNextTick);
+	  };
+
+	  /**
+	   * The "nextTick" phase of an entering transition, which is
+	   * to be pushed into a queue and executed after a reflow so
+	   * that removing the class can trigger a CSS transition.
+	   */
+
+	  p$1.enterNextTick = function () {
+	    var _this = this;
+
+	    // prevent transition skipping
+	    this.justEntered = true;
+	    waitForTransitionStart(function () {
+	      _this.justEntered = false;
+	    });
+	    var enterDone = this.enterDone;
+	    var type = this.getCssTransitionType(this.enterClass);
+	    if (!this.pendingJsCb) {
+	      if (type === TYPE_TRANSITION) {
+	        // trigger transition by removing enter class now
+	        removeClass(this.el, this.enterClass);
+	        this.setupCssCb(transitionEndEvent, enterDone);
+	      } else if (type === TYPE_ANIMATION) {
+	        this.setupCssCb(animationEndEvent, enterDone);
+	      } else {
+	        enterDone();
+	      }
+	    } else if (type === TYPE_TRANSITION) {
+	      removeClass(this.el, this.enterClass);
+	    }
+	  };
+
+	  /**
+	   * The "cleanup" phase of an entering transition.
+	   */
+
+	  p$1.enterDone = function () {
+	    this.entered = true;
+	    this.cancel = this.pendingJsCb = null;
+	    removeClass(this.el, this.enterClass);
+	    this.callHook('afterEnter');
+	    if (this.cb) this.cb();
+	  };
+
+	  /**
+	   * Start a leaving transition.
+	   *
+	   * 1. leave transition triggered.
+	   * 2. call beforeLeave hook
+	   * 3. add leave class (trigger css transition)
+	   * 4. call leave hook (with possible explicit js callback)
+	   * 5. reflow if no explicit js callback is provided
+	   * 6. based on transition type:
+	   *    - transition or animation:
+	   *        wait for end event, remove class, then done if
+	   *        there's no explicit js callback.
+	   *    - no css transition:
+	   *        done if there's no explicit js callback.
+	   * 7. wait for either done or js callback, then call
+	   *    afterLeave hook.
+	   *
+	   * @param {Function} op - remove/hide the element
+	   * @param {Function} [cb]
+	   */
+
+	  p$1.leave = function (op, cb) {
+	    this.cancelPending();
+	    this.callHook('beforeLeave');
+	    this.op = op;
+	    this.cb = cb;
+	    addClass(this.el, this.leaveClass);
+	    this.left = false;
+	    this.callHookWithCb('leave');
+	    if (this.left) {
+	      return; // user called done synchronously.
+	    }
+	    this.cancel = this.hooks && this.hooks.leaveCancelled;
+	    // only need to handle leaveDone if
+	    // 1. the transition is already done (synchronously called
+	    //    by the user, which causes this.op set to null)
+	    // 2. there's no explicit js callback
+	    if (this.op && !this.pendingJsCb) {
+	      // if a CSS transition leaves immediately after enter,
+	      // the transitionend event never fires. therefore we
+	      // detect such cases and end the leave immediately.
+	      if (this.justEntered) {
+	        this.leaveDone();
+	      } else {
+	        pushJob(this.leaveNextTick);
+	      }
+	    }
+	  };
+
+	  /**
+	   * The "nextTick" phase of a leaving transition.
+	   */
+
+	  p$1.leaveNextTick = function () {
+	    var type = this.getCssTransitionType(this.leaveClass);
+	    if (type) {
+	      var event = type === TYPE_TRANSITION ? transitionEndEvent : animationEndEvent;
+	      this.setupCssCb(event, this.leaveDone);
+	    } else {
+	      this.leaveDone();
+	    }
+	  };
+
+	  /**
+	   * The "cleanup" phase of a leaving transition.
+	   */
+
+	  p$1.leaveDone = function () {
+	    this.left = true;
+	    this.cancel = this.pendingJsCb = null;
+	    this.op();
+	    removeClass(this.el, this.leaveClass);
+	    this.callHook('afterLeave');
+	    if (this.cb) this.cb();
+	    this.op = null;
+	  };
+
+	  /**
+	   * Cancel any pending callbacks from a previously running
+	   * but not finished transition.
+	   */
+
+	  p$1.cancelPending = function () {
+	    this.op = this.cb = null;
+	    var hasPending = false;
+	    if (this.pendingCssCb) {
+	      hasPending = true;
+	      off(this.el, this.pendingCssEvent, this.pendingCssCb);
+	      this.pendingCssEvent = this.pendingCssCb = null;
+	    }
+	    if (this.pendingJsCb) {
+	      hasPending = true;
+	      this.pendingJsCb.cancel();
+	      this.pendingJsCb = null;
+	    }
+	    if (hasPending) {
+	      removeClass(this.el, this.enterClass);
+	      removeClass(this.el, this.leaveClass);
+	    }
+	    if (this.cancel) {
+	      this.cancel.call(this.vm, this.el);
+	      this.cancel = null;
+	    }
+	  };
+
+	  /**
+	   * Call a user-provided synchronous hook function.
+	   *
+	   * @param {String} type
+	   */
+
+	  p$1.callHook = function (type) {
+	    if (this.hooks && this.hooks[type]) {
+	      this.hooks[type].call(this.vm, this.el);
+	    }
+	  };
+
+	  /**
+	   * Call a user-provided, potentially-async hook function.
+	   * We check for the length of arguments to see if the hook
+	   * expects a `done` callback. If true, the transition's end
+	   * will be determined by when the user calls that callback;
+	   * otherwise, the end is determined by the CSS transition or
+	   * animation.
+	   *
+	   * @param {String} type
+	   */
+
+	  p$1.callHookWithCb = function (type) {
+	    var hook = this.hooks && this.hooks[type];
+	    if (hook) {
+	      if (hook.length > 1) {
+	        this.pendingJsCb = cancellable(this[type + 'Done']);
+	      }
+	      hook.call(this.vm, this.el, this.pendingJsCb);
+	    }
+	  };
+
+	  /**
+	   * Get an element's transition type based on the
+	   * calculated styles.
+	   *
+	   * @param {String} className
+	   * @return {Number}
+	   */
+
+	  p$1.getCssTransitionType = function (className) {
+	    /* istanbul ignore if */
+	    if (!transitionEndEvent ||
+	    // skip CSS transitions if page is not visible -
+	    // this solves the issue of transitionend events not
+	    // firing until the page is visible again.
+	    // pageVisibility API is supported in IE10+, same as
+	    // CSS transitions.
+	    document.hidden ||
+	    // explicit js-only transition
+	    this.hooks && this.hooks.css === false ||
+	    // element is hidden
+	    isHidden(this.el)) {
+	      return;
+	    }
+	    var type = this.type || this.typeCache[className];
+	    if (type) return type;
+	    var inlineStyles = this.el.style;
+	    var computedStyles = window.getComputedStyle(this.el);
+	    var transDuration = inlineStyles[transDurationProp] || computedStyles[transDurationProp];
+	    if (transDuration && transDuration !== '0s') {
+	      type = TYPE_TRANSITION;
+	    } else {
+	      var animDuration = inlineStyles[animDurationProp] || computedStyles[animDurationProp];
+	      if (animDuration && animDuration !== '0s') {
+	        type = TYPE_ANIMATION;
+	      }
+	    }
+	    if (type) {
+	      this.typeCache[className] = type;
+	    }
+	    return type;
+	  };
+
+	  /**
+	   * Setup a CSS transitionend/animationend callback.
+	   *
+	   * @param {String} event
+	   * @param {Function} cb
+	   */
+
+	  p$1.setupCssCb = function (event, cb) {
+	    this.pendingCssEvent = event;
+	    var self = this;
+	    var el = this.el;
+	    var onEnd = this.pendingCssCb = function (e) {
+	      if (e.target === el) {
+	        off(el, event, onEnd);
+	        self.pendingCssEvent = self.pendingCssCb = null;
+	        if (!self.pendingJsCb && cb) {
+	          cb();
+	        }
+	      }
+	    };
+	    on(el, event, onEnd);
+	  };
+
+	  /**
+	   * Check if an element is hidden - in that case we can just
+	   * skip the transition alltogether.
+	   *
+	   * @param {Element} el
+	   * @return {Boolean}
+	   */
+
+	  function isHidden(el) {
+	    if (/svg$/.test(el.namespaceURI)) {
+	      // SVG elements do not have offset(Width|Height)
+	      // so we need to check the client rect
+	      var rect = el.getBoundingClientRect();
+	      return !(rect.width || rect.height);
+	    } else {
+	      return !(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
+	    }
+	  }
+
+	  var transition$1 = {
+
+	    priority: TRANSITION,
+
+	    update: function update(id, oldId) {
+	      var el = this.el;
+	      // resolve on owner vm
+	      var hooks = resolveAsset(this.vm.$options, 'transitions', id);
+	      id = id || 'v';
+	      el.__v_trans = new Transition(el, id, hooks, this.vm);
+	      if (oldId) {
+	        removeClass(el, oldId + '-transition');
+	      }
+	      addClass(el, id + '-transition');
+	    }
+	  };
+
+	  var internalDirectives = {
+	    style: style,
+	    'class': vClass,
+	    component: component,
+	    prop: propDef,
+	    transition: transition$1
+	  };
+
+	  // special binding prefixes
+	  var bindRE = /^v-bind:|^:/;
+	  var onRE = /^v-on:|^@/;
+	  var dirAttrRE = /^v-([^:]+)(?:$|:(.*)$)/;
+	  var modifierRE = /\.[^\.]+/g;
+	  var transitionRE = /^(v-bind:|:)?transition$/;
+
+	  // default directive priority
+	  var DEFAULT_PRIORITY = 1000;
+	  var DEFAULT_TERMINAL_PRIORITY = 2000;
+
+	  /**
+	   * Compile a template and return a reusable composite link
+	   * function, which recursively contains more link functions
+	   * inside. This top level compile function would normally
+	   * be called on instance root nodes, but can also be used
+	   * for partial compilation if the partial argument is true.
+	   *
+	   * The returned composite link function, when called, will
+	   * return an unlink function that tearsdown all directives
+	   * created during the linking phase.
+	   *
+	   * @param {Element|DocumentFragment} el
+	   * @param {Object} options
+	   * @param {Boolean} partial
+	   * @return {Function}
+	   */
+
+	  function compile(el, options, partial) {
+	    // link function for the node itself.
+	    var nodeLinkFn = partial || !options._asComponent ? compileNode(el, options) : null;
+	    // link function for the childNodes
+	    var childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && !isScript(el) && el.hasChildNodes() ? compileNodeList(el.childNodes, options) : null;
+
+	    /**
+	     * A composite linker function to be called on a already
+	     * compiled piece of DOM, which instantiates all directive
+	     * instances.
+	     *
+	     * @param {Vue} vm
+	     * @param {Element|DocumentFragment} el
+	     * @param {Vue} [host] - host vm of transcluded content
+	     * @param {Object} [scope] - v-for scope
+	     * @param {Fragment} [frag] - link context fragment
+	     * @return {Function|undefined}
+	     */
+
+	    return function compositeLinkFn(vm, el, host, scope, frag) {
+	      // cache childNodes before linking parent, fix #657
+	      var childNodes = toArray(el.childNodes);
+	      // link
+	      var dirs = linkAndCapture(function compositeLinkCapturer() {
+	        if (nodeLinkFn) nodeLinkFn(vm, el, host, scope, frag);
+	        if (childLinkFn) childLinkFn(vm, childNodes, host, scope, frag);
+	      }, vm);
+	      return makeUnlinkFn(vm, dirs);
+	    };
+	  }
+
+	  /**
+	   * Apply a linker to a vm/element pair and capture the
+	   * directives created during the process.
+	   *
+	   * @param {Function} linker
+	   * @param {Vue} vm
+	   */
+
+	  function linkAndCapture(linker, vm) {
+	    /* istanbul ignore if */
+	    if (false) {}
+	    var originalDirCount = vm._directives.length;
+	    linker();
+	    var dirs = vm._directives.slice(originalDirCount);
+	    dirs.sort(directiveComparator);
+	    for (var i = 0, l = dirs.length; i < l; i++) {
+	      dirs[i]._bind();
+	    }
+	    return dirs;
+	  }
+
+	  /**
+	   * Directive priority sort comparator
+	   *
+	   * @param {Object} a
+	   * @param {Object} b
+	   */
+
+	  function directiveComparator(a, b) {
+	    a = a.descriptor.def.priority || DEFAULT_PRIORITY;
+	    b = b.descriptor.def.priority || DEFAULT_PRIORITY;
+	    return a > b ? -1 : a === b ? 0 : 1;
+	  }
+
+	  /**
+	   * Linker functions return an unlink function that
+	   * tearsdown all directives instances generated during
+	   * the process.
+	   *
+	   * We create unlink functions with only the necessary
+	   * information to avoid retaining additional closures.
+	   *
+	   * @param {Vue} vm
+	   * @param {Array} dirs
+	   * @param {Vue} [context]
+	   * @param {Array} [contextDirs]
+	   * @return {Function}
+	   */
+
+	  function makeUnlinkFn(vm, dirs, context, contextDirs) {
+	    function unlink(destroying) {
+	      teardownDirs(vm, dirs, destroying);
+	      if (context && contextDirs) {
+	        teardownDirs(context, contextDirs);
+	      }
+	    }
+	    // expose linked directives
+	    unlink.dirs = dirs;
+	    return unlink;
+	  }
+
+	  /**
+	   * Teardown partial linked directives.
+	   *
+	   * @param {Vue} vm
+	   * @param {Array} dirs
+	   * @param {Boolean} destroying
+	   */
+
+	  function teardownDirs(vm, dirs, destroying) {
+	    var i = dirs.length;
+	    while (i--) {
+	      dirs[i]._teardown();
+	      if ('development' !== 'production' && !destroying) {
+	        vm._directives.$remove(dirs[i]);
+	      }
+	    }
+	  }
+
+	  /**
+	   * Compile link props on an instance.
+	   *
+	   * @param {Vue} vm
+	   * @param {Element} el
+	   * @param {Object} props
+	   * @param {Object} [scope]
+	   * @return {Function}
+	   */
+
+	  function compileAndLinkProps(vm, el, props, scope) {
+	    var propsLinkFn = compileProps(el, props, vm);
+	    var propDirs = linkAndCapture(function () {
+	      propsLinkFn(vm, scope);
+	    }, vm);
+	    return makeUnlinkFn(vm, propDirs);
+	  }
+
+	  /**
+	   * Compile the root element of an instance.
+	   *
+	   * 1. attrs on context container (context scope)
+	   * 2. attrs on the component template root node, if
+	   *    replace:true (child scope)
+	   *
+	   * If this is a fragment instance, we only need to compile 1.
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   * @param {Object} contextOptions
+	   * @return {Function}
+	   */
+
+	  function compileRoot(el, options, contextOptions) {
+	    var containerAttrs = options._containerAttrs;
+	    var replacerAttrs = options._replacerAttrs;
+	    var contextLinkFn, replacerLinkFn;
+
+	    // only need to compile other attributes for
+	    // non-fragment instances
+	    if (el.nodeType !== 11) {
+	      // for components, container and replacer need to be
+	      // compiled separately and linked in different scopes.
+	      if (options._asComponent) {
+	        // 2. container attributes
+	        if (containerAttrs && contextOptions) {
+	          contextLinkFn = compileDirectives(containerAttrs, contextOptions);
+	        }
+	        if (replacerAttrs) {
+	          // 3. replacer attributes
+	          replacerLinkFn = compileDirectives(replacerAttrs, options);
+	        }
+	      } else {
+	        // non-component, just compile as a normal element.
+	        replacerLinkFn = compileDirectives(el.attributes, options);
+	      }
+	    } else if ('development' !== 'production' && containerAttrs) {
+	      // warn container directives for fragment instances
+	      var names = containerAttrs.filter(function (attr) {
+	        // allow vue-loader/vueify scoped css attributes
+	        return attr.name.indexOf('_v-') < 0 &&
+	        // allow event listeners
+	        !onRE.test(attr.name) &&
+	        // allow slots
+	        attr.name !== 'slot';
+	      }).map(function (attr) {
+	        return '"' + attr.name + '"';
+	      });
+	      if (names.length) {
+	        var plural = names.length > 1;
+	        warn('Attribute' + (plural ? 's ' : ' ') + names.join(', ') + (plural ? ' are' : ' is') + ' ignored on component ' + '<' + options.el.tagName.toLowerCase() + '> because ' + 'the component is a fragment instance: ' + 'http://vuejs.org/guide/components.html#Fragment-Instance');
+	      }
+	    }
+
+	    options._containerAttrs = options._replacerAttrs = null;
+	    return function rootLinkFn(vm, el, scope) {
+	      // link context scope dirs
+	      var context = vm._context;
+	      var contextDirs;
+	      if (context && contextLinkFn) {
+	        contextDirs = linkAndCapture(function () {
+	          contextLinkFn(context, el, null, scope);
+	        }, context);
+	      }
+
+	      // link self
+	      var selfDirs = linkAndCapture(function () {
+	        if (replacerLinkFn) replacerLinkFn(vm, el);
+	      }, vm);
+
+	      // return the unlink function that tearsdown context
+	      // container directives.
+	      return makeUnlinkFn(vm, selfDirs, context, contextDirs);
+	    };
+	  }
+
+	  /**
+	   * Compile a node and return a nodeLinkFn based on the
+	   * node type.
+	   *
+	   * @param {Node} node
+	   * @param {Object} options
+	   * @return {Function|null}
+	   */
+
+	  function compileNode(node, options) {
+	    var type = node.nodeType;
+	    if (type === 1 && !isScript(node)) {
+	      return compileElement(node, options);
+	    } else if (type === 3 && node.data.trim()) {
+	      return compileTextNode(node, options);
+	    } else {
+	      return null;
+	    }
+	  }
+
+	  /**
+	   * Compile an element and return a nodeLinkFn.
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   * @return {Function|null}
+	   */
+
+	  function compileElement(el, options) {
+	    // preprocess textareas.
+	    // textarea treats its text content as the initial value.
+	    // just bind it as an attr directive for value.
+	    if (el.tagName === 'TEXTAREA') {
+	      var tokens = parseText(el.value);
+	      if (tokens) {
+	        el.setAttribute(':value', tokensToExp(tokens));
+	        el.value = '';
+	      }
+	    }
+	    var linkFn;
+	    var hasAttrs = el.hasAttributes();
+	    var attrs = hasAttrs && toArray(el.attributes);
+	    // check terminal directives (for & if)
+	    if (hasAttrs) {
+	      linkFn = checkTerminalDirectives(el, attrs, options);
+	    }
+	    // check element directives
+	    if (!linkFn) {
+	      linkFn = checkElementDirectives(el, options);
+	    }
+	    // check component
+	    if (!linkFn) {
+	      linkFn = checkComponent(el, options);
+	    }
+	    // normal directives
+	    if (!linkFn && hasAttrs) {
+	      linkFn = compileDirectives(attrs, options);
+	    }
+	    return linkFn;
+	  }
+
+	  /**
+	   * Compile a textNode and return a nodeLinkFn.
+	   *
+	   * @param {TextNode} node
+	   * @param {Object} options
+	   * @return {Function|null} textNodeLinkFn
+	   */
+
+	  function compileTextNode(node, options) {
+	    // skip marked text nodes
+	    if (node._skip) {
+	      return removeText;
+	    }
+
+	    var tokens = parseText(node.wholeText);
+	    if (!tokens) {
+	      return null;
+	    }
+
+	    // mark adjacent text nodes as skipped,
+	    // because we are using node.wholeText to compile
+	    // all adjacent text nodes together. This fixes
+	    // issues in IE where sometimes it splits up a single
+	    // text node into multiple ones.
+	    var next = node.nextSibling;
+	    while (next && next.nodeType === 3) {
+	      next._skip = true;
+	      next = next.nextSibling;
+	    }
+
+	    var frag = document.createDocumentFragment();
+	    var el, token;
+	    for (var i = 0, l = tokens.length; i < l; i++) {
+	      token = tokens[i];
+	      el = token.tag ? processTextToken(token, options) : document.createTextNode(token.value);
+	      frag.appendChild(el);
+	    }
+	    return makeTextNodeLinkFn(tokens, frag, options);
+	  }
+
+	  /**
+	   * Linker for an skipped text node.
+	   *
+	   * @param {Vue} vm
+	   * @param {Text} node
+	   */
+
+	  function removeText(vm, node) {
+	    remove(node);
+	  }
+
+	  /**
+	   * Process a single text token.
+	   *
+	   * @param {Object} token
+	   * @param {Object} options
+	   * @return {Node}
+	   */
+
+	  function processTextToken(token, options) {
+	    var el;
+	    if (token.oneTime) {
+	      el = document.createTextNode(token.value);
+	    } else {
+	      if (token.html) {
+	        el = document.createComment('v-html');
+	        setTokenType('html');
+	      } else {
+	        // IE will clean up empty textNodes during
+	        // frag.cloneNode(true), so we have to give it
+	        // something here...
+	        el = document.createTextNode(' ');
+	        setTokenType('text');
+	      }
+	    }
+	    function setTokenType(type) {
+	      if (token.descriptor) return;
+	      var parsed = parseDirective(token.value);
+	      token.descriptor = {
+	        name: type,
+	        def: directives[type],
+	        expression: parsed.expression,
+	        filters: parsed.filters
+	      };
+	    }
+	    return el;
+	  }
+
+	  /**
+	   * Build a function that processes a textNode.
+	   *
+	   * @param {Array<Object>} tokens
+	   * @param {DocumentFragment} frag
+	   */
+
+	  function makeTextNodeLinkFn(tokens, frag) {
+	    return function textNodeLinkFn(vm, el, host, scope) {
+	      var fragClone = frag.cloneNode(true);
+	      var childNodes = toArray(fragClone.childNodes);
+	      var token, value, node;
+	      for (var i = 0, l = tokens.length; i < l; i++) {
+	        token = tokens[i];
+	        value = token.value;
+	        if (token.tag) {
+	          node = childNodes[i];
+	          if (token.oneTime) {
+	            value = (scope || vm).$eval(value);
+	            if (token.html) {
+	              replace(node, parseTemplate(value, true));
+	            } else {
+	              node.data = value;
+	            }
+	          } else {
+	            vm._bindDir(token.descriptor, node, host, scope);
+	          }
+	        }
+	      }
+	      replace(el, fragClone);
+	    };
+	  }
+
+	  /**
+	   * Compile a node list and return a childLinkFn.
+	   *
+	   * @param {NodeList} nodeList
+	   * @param {Object} options
+	   * @return {Function|undefined}
+	   */
+
+	  function compileNodeList(nodeList, options) {
+	    var linkFns = [];
+	    var nodeLinkFn, childLinkFn, node;
+	    for (var i = 0, l = nodeList.length; i < l; i++) {
+	      node = nodeList[i];
+	      nodeLinkFn = compileNode(node, options);
+	      childLinkFn = !(nodeLinkFn && nodeLinkFn.terminal) && node.tagName !== 'SCRIPT' && node.hasChildNodes() ? compileNodeList(node.childNodes, options) : null;
+	      linkFns.push(nodeLinkFn, childLinkFn);
+	    }
+	    return linkFns.length ? makeChildLinkFn(linkFns) : null;
+	  }
+
+	  /**
+	   * Make a child link function for a node's childNodes.
+	   *
+	   * @param {Array<Function>} linkFns
+	   * @return {Function} childLinkFn
+	   */
+
+	  function makeChildLinkFn(linkFns) {
+	    return function childLinkFn(vm, nodes, host, scope, frag) {
+	      var node, nodeLinkFn, childrenLinkFn;
+	      for (var i = 0, n = 0, l = linkFns.length; i < l; n++) {
+	        node = nodes[n];
+	        nodeLinkFn = linkFns[i++];
+	        childrenLinkFn = linkFns[i++];
+	        // cache childNodes before linking parent, fix #657
+	        var childNodes = toArray(node.childNodes);
+	        if (nodeLinkFn) {
+	          nodeLinkFn(vm, node, host, scope, frag);
+	        }
+	        if (childrenLinkFn) {
+	          childrenLinkFn(vm, childNodes, host, scope, frag);
+	        }
+	      }
+	    };
+	  }
+
+	  /**
+	   * Check for element directives (custom elements that should
+	   * be resovled as terminal directives).
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   */
+
+	  function checkElementDirectives(el, options) {
+	    var tag = el.tagName.toLowerCase();
+	    if (commonTagRE.test(tag)) {
+	      return;
+	    }
+	    var def = resolveAsset(options, 'elementDirectives', tag);
+	    if (def) {
+	      return makeTerminalNodeLinkFn(el, tag, '', options, def);
+	    }
+	  }
+
+	  /**
+	   * Check if an element is a component. If yes, return
+	   * a component link function.
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   * @return {Function|undefined}
+	   */
+
+	  function checkComponent(el, options) {
+	    var component = checkComponentAttr(el, options);
+	    if (component) {
+	      var ref = findRef(el);
+	      var descriptor = {
+	        name: 'component',
+	        ref: ref,
+	        expression: component.id,
+	        def: internalDirectives.component,
+	        modifiers: {
+	          literal: !component.dynamic
+	        }
+	      };
+	      var componentLinkFn = function componentLinkFn(vm, el, host, scope, frag) {
+	        if (ref) {
+	          defineReactive((scope || vm).$refs, ref, null);
+	        }
+	        vm._bindDir(descriptor, el, host, scope, frag);
+	      };
+	      componentLinkFn.terminal = true;
+	      return componentLinkFn;
+	    }
+	  }
+
+	  /**
+	   * Check an element for terminal directives in fixed order.
+	   * If it finds one, return a terminal link function.
+	   *
+	   * @param {Element} el
+	   * @param {Array} attrs
+	   * @param {Object} options
+	   * @return {Function} terminalLinkFn
+	   */
+
+	  function checkTerminalDirectives(el, attrs, options) {
+	    // skip v-pre
+	    if (getAttr(el, 'v-pre') !== null) {
+	      return skip;
+	    }
+	    // skip v-else block, but only if following v-if
+	    if (el.hasAttribute('v-else')) {
+	      var prev = el.previousElementSibling;
+	      if (prev && prev.hasAttribute('v-if')) {
+	        return skip;
+	      }
+	    }
+
+	    var attr, name, value, modifiers, matched, dirName, rawName, arg, def, termDef;
+	    for (var i = 0, j = attrs.length; i < j; i++) {
+	      attr = attrs[i];
+	      name = attr.name.replace(modifierRE, '');
+	      if (matched = name.match(dirAttrRE)) {
+	        def = resolveAsset(options, 'directives', matched[1]);
+	        if (def && def.terminal) {
+	          if (!termDef || (def.priority || DEFAULT_TERMINAL_PRIORITY) > termDef.priority) {
+	            termDef = def;
+	            rawName = attr.name;
+	            modifiers = parseModifiers(attr.name);
+	            value = attr.value;
+	            dirName = matched[1];
+	            arg = matched[2];
+	          }
+	        }
+	      }
+	    }
+
+	    if (termDef) {
+	      return makeTerminalNodeLinkFn(el, dirName, value, options, termDef, rawName, arg, modifiers);
+	    }
+	  }
+
+	  function skip() {}
+	  skip.terminal = true;
+
+	  /**
+	   * Build a node link function for a terminal directive.
+	   * A terminal link function terminates the current
+	   * compilation recursion and handles compilation of the
+	   * subtree in the directive.
+	   *
+	   * @param {Element} el
+	   * @param {String} dirName
+	   * @param {String} value
+	   * @param {Object} options
+	   * @param {Object} def
+	   * @param {String} [rawName]
+	   * @param {String} [arg]
+	   * @param {Object} [modifiers]
+	   * @return {Function} terminalLinkFn
+	   */
+
+	  function makeTerminalNodeLinkFn(el, dirName, value, options, def, rawName, arg, modifiers) {
+	    var parsed = parseDirective(value);
+	    var descriptor = {
+	      name: dirName,
+	      arg: arg,
+	      expression: parsed.expression,
+	      filters: parsed.filters,
+	      raw: value,
+	      attr: rawName,
+	      modifiers: modifiers,
+	      def: def
+	    };
+	    // check ref for v-for and router-view
+	    if (dirName === 'for' || dirName === 'router-view') {
+	      descriptor.ref = findRef(el);
+	    }
+	    var fn = function terminalNodeLinkFn(vm, el, host, scope, frag) {
+	      if (descriptor.ref) {
+	        defineReactive((scope || vm).$refs, descriptor.ref, null);
+	      }
+	      vm._bindDir(descriptor, el, host, scope, frag);
+	    };
+	    fn.terminal = true;
+	    return fn;
+	  }
+
+	  /**
+	   * Compile the directives on an element and return a linker.
+	   *
+	   * @param {Array|NamedNodeMap} attrs
+	   * @param {Object} options
+	   * @return {Function}
+	   */
+
+	  function compileDirectives(attrs, options) {
+	    var i = attrs.length;
+	    var dirs = [];
+	    var attr, name, value, rawName, rawValue, dirName, arg, modifiers, dirDef, tokens, matched;
+	    while (i--) {
+	      attr = attrs[i];
+	      name = rawName = attr.name;
+	      value = rawValue = attr.value;
+	      tokens = parseText(value);
+	      // reset arg
+	      arg = null;
+	      // check modifiers
+	      modifiers = parseModifiers(name);
+	      name = name.replace(modifierRE, '');
+
+	      // attribute interpolations
+	      if (tokens) {
+	        value = tokensToExp(tokens);
+	        arg = name;
+	        pushDir('bind', directives.bind, tokens);
+	        // warn against mixing mustaches with v-bind
+	        if (true) {
+	          if (name === 'class' && Array.prototype.some.call(attrs, function (attr) {
+	            return attr.name === ':class' || attr.name === 'v-bind:class';
+	          })) {
+	            warn('class="' + rawValue + '": Do not mix mustache interpolation ' + 'and v-bind for "class" on the same element. Use one or the other.', options);
+	          }
+	        }
+	      } else
+
+	        // special attribute: transition
+	        if (transitionRE.test(name)) {
+	          modifiers.literal = !bindRE.test(name);
+	          pushDir('transition', internalDirectives.transition);
+	        } else
+
+	          // event handlers
+	          if (onRE.test(name)) {
+	            arg = name.replace(onRE, '');
+	            pushDir('on', directives.on);
+	          } else
+
+	            // attribute bindings
+	            if (bindRE.test(name)) {
+	              dirName = name.replace(bindRE, '');
+	              if (dirName === 'style' || dirName === 'class') {
+	                pushDir(dirName, internalDirectives[dirName]);
+	              } else {
+	                arg = dirName;
+	                pushDir('bind', directives.bind);
+	              }
+	            } else
+
+	              // normal directives
+	              if (matched = name.match(dirAttrRE)) {
+	                dirName = matched[1];
+	                arg = matched[2];
+
+	                // skip v-else (when used with v-show)
+	                if (dirName === 'else') {
+	                  continue;
+	                }
+
+	                dirDef = resolveAsset(options, 'directives', dirName, true);
+	                if (dirDef) {
+	                  pushDir(dirName, dirDef);
+	                }
+	              }
+	    }
+
+	    /**
+	     * Push a directive.
+	     *
+	     * @param {String} dirName
+	     * @param {Object|Function} def
+	     * @param {Array} [interpTokens]
+	     */
+
+	    function pushDir(dirName, def, interpTokens) {
+	      var hasOneTimeToken = interpTokens && hasOneTime(interpTokens);
+	      var parsed = !hasOneTimeToken && parseDirective(value);
+	      dirs.push({
+	        name: dirName,
+	        attr: rawName,
+	        raw: rawValue,
+	        def: def,
+	        arg: arg,
+	        modifiers: modifiers,
+	        // conversion from interpolation strings with one-time token
+	        // to expression is differed until directive bind time so that we
+	        // have access to the actual vm context for one-time bindings.
+	        expression: parsed && parsed.expression,
+	        filters: parsed && parsed.filters,
+	        interp: interpTokens,
+	        hasOneTime: hasOneTimeToken
+	      });
+	    }
+
+	    if (dirs.length) {
+	      return makeNodeLinkFn(dirs);
+	    }
+	  }
+
+	  /**
+	   * Parse modifiers from directive attribute name.
+	   *
+	   * @param {String} name
+	   * @return {Object}
+	   */
+
+	  function parseModifiers(name) {
+	    var res = Object.create(null);
+	    var match = name.match(modifierRE);
+	    if (match) {
+	      var i = match.length;
+	      while (i--) {
+	        res[match[i].slice(1)] = true;
+	      }
+	    }
+	    return res;
+	  }
+
+	  /**
+	   * Build a link function for all directives on a single node.
+	   *
+	   * @param {Array} directives
+	   * @return {Function} directivesLinkFn
+	   */
+
+	  function makeNodeLinkFn(directives) {
+	    return function nodeLinkFn(vm, el, host, scope, frag) {
+	      // reverse apply because it's sorted low to high
+	      var i = directives.length;
+	      while (i--) {
+	        vm._bindDir(directives[i], el, host, scope, frag);
+	      }
+	    };
+	  }
+
+	  /**
+	   * Check if an interpolation string contains one-time tokens.
+	   *
+	   * @param {Array} tokens
+	   * @return {Boolean}
+	   */
+
+	  function hasOneTime(tokens) {
+	    var i = tokens.length;
+	    while (i--) {
+	      if (tokens[i].oneTime) return true;
+	    }
+	  }
+
+	  function isScript(el) {
+	    return el.tagName === 'SCRIPT' && (!el.hasAttribute('type') || el.getAttribute('type') === 'text/javascript');
+	  }
+
+	  var specialCharRE = /[^\w\-:\.]/;
+
+	  /**
+	   * Process an element or a DocumentFragment based on a
+	   * instance option object. This allows us to transclude
+	   * a template node/fragment before the instance is created,
+	   * so the processed fragment can then be cloned and reused
+	   * in v-for.
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   * @return {Element|DocumentFragment}
+	   */
+
+	  function transclude(el, options) {
+	    // extract container attributes to pass them down
+	    // to compiler, because they need to be compiled in
+	    // parent scope. we are mutating the options object here
+	    // assuming the same object will be used for compile
+	    // right after this.
+	    if (options) {
+	      options._containerAttrs = extractAttrs(el);
+	    }
+	    // for template tags, what we want is its content as
+	    // a documentFragment (for fragment instances)
+	    if (isTemplate(el)) {
+	      el = parseTemplate(el);
+	    }
+	    if (options) {
+	      if (options._asComponent && !options.template) {
+	        options.template = '<slot></slot>';
+	      }
+	      if (options.template) {
+	        options._content = extractContent(el);
+	        el = transcludeTemplate(el, options);
+	      }
+	    }
+	    if (isFragment(el)) {
+	      // anchors for fragment instance
+	      // passing in `persist: true` to avoid them being
+	      // discarded by IE during template cloning
+	      prepend(createAnchor('v-start', true), el);
+	      el.appendChild(createAnchor('v-end', true));
+	    }
+	    return el;
+	  }
+
+	  /**
+	   * Process the template option.
+	   * If the replace option is true this will swap the $el.
+	   *
+	   * @param {Element} el
+	   * @param {Object} options
+	   * @return {Element|DocumentFragment}
+	   */
+
+	  function transcludeTemplate(el, options) {
+	    var template = options.template;
+	    var frag = parseTemplate(template, true);
+	    if (frag) {
+	      var replacer = frag.firstChild;
+	      var tag = replacer.tagName && replacer.tagName.toLowerCase();
+	      if (options.replace) {
+	        /* istanbul ignore if */
+	        if (el === document.body) {
+	          'development' !== 'production' && warn('You are mounting an instance with a template to ' + '<body>. This will replace <body> entirely. You ' + 'should probably use `replace: false` here.');
+	        }
+	        // there are many cases where the instance must
+	        // become a fragment instance: basically anything that
+	        // can create more than 1 root nodes.
+	        if (
+	        // multi-children template
+	        frag.childNodes.length > 1 ||
+	        // non-element template
+	        replacer.nodeType !== 1 ||
+	        // single nested component
+	        tag === 'component' || resolveAsset(options, 'components', tag) || hasBindAttr(replacer, 'is') ||
+	        // element directive
+	        resolveAsset(options, 'elementDirectives', tag) ||
+	        // for block
+	        replacer.hasAttribute('v-for') ||
+	        // if block
+	        replacer.hasAttribute('v-if')) {
+	          return frag;
+	        } else {
+	          options._replacerAttrs = extractAttrs(replacer);
+	          mergeAttrs(el, replacer);
+	          return replacer;
+	        }
+	      } else {
+	        el.appendChild(frag);
+	        return el;
+	      }
+	    } else {
+	      'development' !== 'production' && warn('Invalid template option: ' + template);
+	    }
+	  }
+
+	  /**
+	   * Helper to extract a component container's attributes
+	   * into a plain object array.
+	   *
+	   * @param {Element} el
+	   * @return {Array}
+	   */
+
+	  function extractAttrs(el) {
+	    if (el.nodeType === 1 && el.hasAttributes()) {
+	      return toArray(el.attributes);
+	    }
+	  }
+
+	  /**
+	   * Merge the attributes of two elements, and make sure
+	   * the class names are merged properly.
+	   *
+	   * @param {Element} from
+	   * @param {Element} to
+	   */
+
+	  function mergeAttrs(from, to) {
+	    var attrs = from.attributes;
+	    var i = attrs.length;
+	    var name, value;
+	    while (i--) {
+	      name = attrs[i].name;
+	      value = attrs[i].value;
+	      if (!to.hasAttribute(name) && !specialCharRE.test(name)) {
+	        to.setAttribute(name, value);
+	      } else if (name === 'class' && !parseText(value) && (value = value.trim())) {
+	        value.split(/\s+/).forEach(function (cls) {
+	          addClass(to, cls);
+	        });
+	      }
+	    }
+	  }
+
+	  /**
+	   * Scan and determine slot content distribution.
+	   * We do this during transclusion instead at compile time so that
+	   * the distribution is decoupled from the compilation order of
+	   * the slots.
+	   *
+	   * @param {Element|DocumentFragment} template
+	   * @param {Element} content
+	   * @param {Vue} vm
+	   */
+
+	  function resolveSlots(vm, content) {
+	    if (!content) {
+	      return;
+	    }
+	    var contents = vm._slotContents = Object.create(null);
+	    var el, name;
+	    for (var i = 0, l = content.children.length; i < l; i++) {
+	      el = content.children[i];
+	      /* eslint-disable no-cond-assign */
+	      if (name = el.getAttribute('slot')) {
+	        (contents[name] || (contents[name] = [])).push(el);
+	      }
+	      /* eslint-enable no-cond-assign */
+	      if ('development' !== 'production' && getBindAttr(el, 'slot')) {
+	        warn('The "slot" attribute must be static.', vm.$parent);
+	      }
+	    }
+	    for (name in contents) {
+	      contents[name] = extractFragment(contents[name], content);
+	    }
+	    if (content.hasChildNodes()) {
+	      var nodes = content.childNodes;
+	      if (nodes.length === 1 && nodes[0].nodeType === 3 && !nodes[0].data.trim()) {
+	        return;
+	      }
+	      contents['default'] = extractFragment(content.childNodes, content);
+	    }
+	  }
+
+	  /**
+	   * Extract qualified content nodes from a node list.
+	   *
+	   * @param {NodeList} nodes
+	   * @return {DocumentFragment}
+	   */
+
+	  function extractFragment(nodes, parent) {
+	    var frag = document.createDocumentFragment();
+	    nodes = toArray(nodes);
+	    for (var i = 0, l = nodes.length; i < l; i++) {
+	      var node = nodes[i];
+	      if (isTemplate(node) && !node.hasAttribute('v-if') && !node.hasAttribute('v-for')) {
+	        parent.removeChild(node);
+	        node = parseTemplate(node, true);
+	      }
+	      frag.appendChild(node);
+	    }
+	    return frag;
+	  }
+
+
+
+	  var compiler = Object.freeze({
+	  	compile: compile,
+	  	compileAndLinkProps: compileAndLinkProps,
+	  	compileRoot: compileRoot,
+	  	transclude: transclude,
+	  	resolveSlots: resolveSlots
+	  });
+
+	  function stateMixin (Vue) {
+	    /**
+	     * Accessor for `$data` property, since setting $data
+	     * requires observing the new object and updating
+	     * proxied properties.
+	     */
+
+	    Object.defineProperty(Vue.prototype, '$data', {
+	      get: function get() {
+	        return this._data;
+	      },
+	      set: function set(newData) {
+	        if (newData !== this._data) {
+	          this._setData(newData);
+	        }
+	      }
+	    });
+
+	    /**
+	     * Setup the scope of an instance, which contains:
+	     * - observed data
+	     * - computed properties
+	     * - user methods
+	     * - meta properties
+	     */
+
+	    Vue.prototype._initState = function () {
+	      this._initProps();
+	      this._initMeta();
+	      this._initMethods();
+	      this._initData();
+	      this._initComputed();
+	    };
+
+	    /**
+	     * Initialize props.
+	     */
+
+	    Vue.prototype._initProps = function () {
+	      var options = this.$options;
+	      var el = options.el;
+	      var props = options.props;
+	      if (props && !el) {
+	        'development' !== 'production' && warn('Props will not be compiled if no `el` option is ' + 'provided at instantiation.', this);
+	      }
+	      // make sure to convert string selectors into element now
+	      el = options.el = query(el);
+	      this._propsUnlinkFn = el && el.nodeType === 1 && props
+	      // props must be linked in proper scope if inside v-for
+	      ? compileAndLinkProps(this, el, props, this._scope) : null;
+	    };
+
+	    /**
+	     * Initialize the data.
+	     */
+
+	    Vue.prototype._initData = function () {
+	      var dataFn = this.$options.data;
+	      var data = this._data = dataFn ? dataFn() : {};
+	      if (!isPlainObject(data)) {
+	        data = {};
+	        'development' !== 'production' && warn('data functions should return an object.', this);
+	      }
+	      var props = this._props;
+	      // proxy data on instance
+	      var keys = Object.keys(data);
+	      var i, key;
+	      i = keys.length;
+	      while (i--) {
+	        key = keys[i];
+	        // there are two scenarios where we can proxy a data key:
+	        // 1. it's not already defined as a prop
+	        // 2. it's provided via a instantiation option AND there are no
+	        //    template prop present
+	        if (!props || !hasOwn(props, key)) {
+	          this._proxy(key);
+	        } else if (true) {
+	          warn('Data field "' + key + '" is already defined ' + 'as a prop. To provide default value for a prop, use the "default" ' + 'prop option; if you want to pass prop values to an instantiation ' + 'call, use the "propsData" option.', this);
+	        }
+	      }
+	      // observe data
+	      observe(data, this);
+	    };
+
+	    /**
+	     * Swap the instance's $data. Called in $data's setter.
+	     *
+	     * @param {Object} newData
+	     */
+
+	    Vue.prototype._setData = function (newData) {
+	      newData = newData || {};
+	      var oldData = this._data;
+	      this._data = newData;
+	      var keys, key, i;
+	      // unproxy keys not present in new data
+	      keys = Object.keys(oldData);
+	      i = keys.length;
+	      while (i--) {
+	        key = keys[i];
+	        if (!(key in newData)) {
+	          this._unproxy(key);
+	        }
+	      }
+	      // proxy keys not already proxied,
+	      // and trigger change for changed values
+	      keys = Object.keys(newData);
+	      i = keys.length;
+	      while (i--) {
+	        key = keys[i];
+	        if (!hasOwn(this, key)) {
+	          // new property
+	          this._proxy(key);
+	        }
+	      }
+	      oldData.__ob__.removeVm(this);
+	      observe(newData, this);
+	      this._digest();
+	    };
+
+	    /**
+	     * Proxy a property, so that
+	     * vm.prop === vm._data.prop
+	     *
+	     * @param {String} key
+	     */
+
+	    Vue.prototype._proxy = function (key) {
+	      if (!isReserved(key)) {
+	        // need to store ref to self here
+	        // because these getter/setters might
+	        // be called by child scopes via
+	        // prototype inheritance.
+	        var self = this;
+	        Object.defineProperty(self, key, {
+	          configurable: true,
+	          enumerable: true,
+	          get: function proxyGetter() {
+	            return self._data[key];
+	          },
+	          set: function proxySetter(val) {
+	            self._data[key] = val;
+	          }
+	        });
+	      }
+	    };
+
+	    /**
+	     * Unproxy a property.
+	     *
+	     * @param {String} key
+	     */
+
+	    Vue.prototype._unproxy = function (key) {
+	      if (!isReserved(key)) {
+	        delete this[key];
+	      }
+	    };
+
+	    /**
+	     * Force update on every watcher in scope.
+	     */
+
+	    Vue.prototype._digest = function () {
+	      for (var i = 0, l = this._watchers.length; i < l; i++) {
+	        this._watchers[i].update(true); // shallow updates
+	      }
+	    };
+
+	    /**
+	     * Setup computed properties. They are essentially
+	     * special getter/setters
+	     */
+
+	    function noop() {}
+	    Vue.prototype._initComputed = function () {
+	      var computed = this.$options.computed;
+	      if (computed) {
+	        for (var key in computed) {
+	          var userDef = computed[key];
+	          var def = {
+	            enumerable: true,
+	            configurable: true
+	          };
+	          if (typeof userDef === 'function') {
+	            def.get = makeComputedGetter(userDef, this);
+	            def.set = noop;
+	          } else {
+	            def.get = userDef.get ? userDef.cache !== false ? makeComputedGetter(userDef.get, this) : bind(userDef.get, this) : noop;
+	            def.set = userDef.set ? bind(userDef.set, this) : noop;
+	          }
+	          Object.defineProperty(this, key, def);
+	        }
+	      }
+	    };
+
+	    function makeComputedGetter(getter, owner) {
+	      var watcher = new Watcher(owner, getter, null, {
+	        lazy: true
+	      });
+	      return function computedGetter() {
+	        if (watcher.dirty) {
+	          watcher.evaluate();
+	        }
+	        if (Dep.target) {
+	          watcher.depend();
+	        }
+	        return watcher.value;
+	      };
+	    }
+
+	    /**
+	     * Setup instance methods. Methods must be bound to the
+	     * instance since they might be passed down as a prop to
+	     * child components.
+	     */
+
+	    Vue.prototype._initMethods = function () {
+	      var methods = this.$options.methods;
+	      if (methods) {
+	        for (var key in methods) {
+	          this[key] = bind(methods[key], this);
+	        }
+	      }
+	    };
+
+	    /**
+	     * Initialize meta information like $index, $key & $value.
+	     */
+
+	    Vue.prototype._initMeta = function () {
+	      var metas = this.$options._meta;
+	      if (metas) {
+	        for (var key in metas) {
+	          defineReactive(this, key, metas[key]);
+	        }
+	      }
+	    };
+	  }
+
+	  var eventRE = /^v-on:|^@/;
+
+	  function eventsMixin (Vue) {
+	    /**
+	     * Setup the instance's option events & watchers.
+	     * If the value is a string, we pull it from the
+	     * instance's methods by name.
+	     */
+
+	    Vue.prototype._initEvents = function () {
+	      var options = this.$options;
+	      if (options._asComponent) {
+	        registerComponentEvents(this, options.el);
+	      }
+	      registerCallbacks(this, '$on', options.events);
+	      registerCallbacks(this, '$watch', options.watch);
+	    };
+
+	    /**
+	     * Register v-on events on a child component
+	     *
+	     * @param {Vue} vm
+	     * @param {Element} el
+	     */
+
+	    function registerComponentEvents(vm, el) {
+	      var attrs = el.attributes;
+	      var name, value, handler;
+	      for (var i = 0, l = attrs.length; i < l; i++) {
+	        name = attrs[i].name;
+	        if (eventRE.test(name)) {
+	          name = name.replace(eventRE, '');
+	          // force the expression into a statement so that
+	          // it always dynamically resolves the method to call (#2670)
+	          // kinda ugly hack, but does the job.
+	          value = attrs[i].value;
+	          if (isSimplePath(value)) {
+	            value += '.apply(this, $arguments)';
+	          }
+	          handler = (vm._scope || vm._context).$eval(value, true);
+	          handler._fromParent = true;
+	          vm.$on(name.replace(eventRE), handler);
+	        }
+	      }
+	    }
+
+	    /**
+	     * Register callbacks for option events and watchers.
+	     *
+	     * @param {Vue} vm
+	     * @param {String} action
+	     * @param {Object} hash
+	     */
+
+	    function registerCallbacks(vm, action, hash) {
+	      if (!hash) return;
+	      var handlers, key, i, j;
+	      for (key in hash) {
+	        handlers = hash[key];
+	        if (isArray(handlers)) {
+	          for (i = 0, j = handlers.length; i < j; i++) {
+	            register(vm, action, key, handlers[i]);
+	          }
+	        } else {
+	          register(vm, action, key, handlers);
+	        }
+	      }
+	    }
+
+	    /**
+	     * Helper to register an event/watch callback.
+	     *
+	     * @param {Vue} vm
+	     * @param {String} action
+	     * @param {String} key
+	     * @param {Function|String|Object} handler
+	     * @param {Object} [options]
+	     */
+
+	    function register(vm, action, key, handler, options) {
+	      var type = typeof handler;
+	      if (type === 'function') {
+	        vm[action](key, handler, options);
+	      } else if (type === 'string') {
+	        var methods = vm.$options.methods;
+	        var method = methods && methods[handler];
+	        if (method) {
+	          vm[action](key, method, options);
+	        } else {
+	          'development' !== 'production' && warn('Unknown method: "' + handler + '" when ' + 'registering callback for ' + action + ': "' + key + '".', vm);
+	        }
+	      } else if (handler && type === 'object') {
+	        register(vm, action, key, handler.handler, handler);
+	      }
+	    }
+
+	    /**
+	     * Setup recursive attached/detached calls
+	     */
+
+	    Vue.prototype._initDOMHooks = function () {
+	      this.$on('hook:attached', onAttached);
+	      this.$on('hook:detached', onDetached);
+	    };
+
+	    /**
+	     * Callback to recursively call attached hook on children
+	     */
+
+	    function onAttached() {
+	      if (!this._isAttached) {
+	        this._isAttached = true;
+	        this.$children.forEach(callAttach);
+	      }
+	    }
+
+	    /**
+	     * Iterator to call attached hook
+	     *
+	     * @param {Vue} child
+	     */
+
+	    function callAttach(child) {
+	      if (!child._isAttached && inDoc(child.$el)) {
+	        child._callHook('attached');
+	      }
+	    }
+
+	    /**
+	     * Callback to recursively call detached hook on children
+	     */
+
+	    function onDetached() {
+	      if (this._isAttached) {
+	        this._isAttached = false;
+	        this.$children.forEach(callDetach);
+	      }
+	    }
+
+	    /**
+	     * Iterator to call detached hook
+	     *
+	     * @param {Vue} child
+	     */
+
+	    function callDetach(child) {
+	      if (child._isAttached && !inDoc(child.$el)) {
+	        child._callHook('detached');
+	      }
+	    }
+
+	    /**
+	     * Trigger all handlers for a hook
+	     *
+	     * @param {String} hook
+	     */
+
+	    Vue.prototype._callHook = function (hook) {
+	      this.$emit('pre-hook:' + hook);
+	      var handlers = this.$options[hook];
+	      if (handlers) {
+	        for (var i = 0, j = handlers.length; i < j; i++) {
+	          handlers[i].call(this);
+	        }
+	      }
+	      this.$emit('hook:' + hook);
+	    };
+	  }
+
+	  function noop() {}
+
+	  /**
+	   * A directive links a DOM element with a piece of data,
+	   * which is the result of evaluating an expression.
+	   * It registers a watcher with the expression and calls
+	   * the DOM update function when a change is triggered.
+	   *
+	   * @param {Object} descriptor
+	   *                 - {String} name
+	   *                 - {Object} def
+	   *                 - {String} expression
+	   *                 - {Array<Object>} [filters]
+	   *                 - {Object} [modifiers]
+	   *                 - {Boolean} literal
+	   *                 - {String} attr
+	   *                 - {String} arg
+	   *                 - {String} raw
+	   *                 - {String} [ref]
+	   *                 - {Array<Object>} [interp]
+	   *                 - {Boolean} [hasOneTime]
+	   * @param {Vue} vm
+	   * @param {Node} el
+	   * @param {Vue} [host] - transclusion host component
+	   * @param {Object} [scope] - v-for scope
+	   * @param {Fragment} [frag] - owner fragment
+	   * @constructor
+	   */
+	  function Directive(descriptor, vm, el, host, scope, frag) {
+	    this.vm = vm;
+	    this.el = el;
+	    // copy descriptor properties
+	    this.descriptor = descriptor;
+	    this.name = descriptor.name;
+	    this.expression = descriptor.expression;
+	    this.arg = descriptor.arg;
+	    this.modifiers = descriptor.modifiers;
+	    this.filters = descriptor.filters;
+	    this.literal = this.modifiers && this.modifiers.literal;
+	    // private
+	    this._locked = false;
+	    this._bound = false;
+	    this._listeners = null;
+	    // link context
+	    this._host = host;
+	    this._scope = scope;
+	    this._frag = frag;
+	    // store directives on node in dev mode
+	    if ('development' !== 'production' && this.el) {
+	      this.el._vue_directives = this.el._vue_directives || [];
+	      this.el._vue_directives.push(this);
+	    }
+	  }
+
+	  /**
+	   * Initialize the directive, mixin definition properties,
+	   * setup the watcher, call definition bind() and update()
+	   * if present.
+	   */
+
+	  Directive.prototype._bind = function () {
+	    var name = this.name;
+	    var descriptor = this.descriptor;
+
+	    // remove attribute
+	    if ((name !== 'cloak' || this.vm._isCompiled) && this.el && this.el.removeAttribute) {
+	      var attr = descriptor.attr || 'v-' + name;
+	      this.el.removeAttribute(attr);
+	    }
+
+	    // copy def properties
+	    var def = descriptor.def;
+	    if (typeof def === 'function') {
+	      this.update = def;
+	    } else {
+	      extend(this, def);
+	    }
+
+	    // setup directive params
+	    this._setupParams();
+
+	    // initial bind
+	    if (this.bind) {
+	      this.bind();
+	    }
+	    this._bound = true;
+
+	    if (this.literal) {
+	      this.update && this.update(descriptor.raw);
+	    } else if ((this.expression || this.modifiers) && (this.update || this.twoWay) && !this._checkStatement()) {
+	      // wrapped updater for context
+	      var dir = this;
+	      if (this.update) {
+	        this._update = function (val, oldVal) {
+	          if (!dir._locked) {
+	            dir.update(val, oldVal);
+	          }
+	        };
+	      } else {
+	        this._update = noop;
+	      }
+	      var preProcess = this._preProcess ? bind(this._preProcess, this) : null;
+	      var postProcess = this._postProcess ? bind(this._postProcess, this) : null;
+	      var watcher = this._watcher = new Watcher(this.vm, this.expression, this._update, // callback
+	      {
+	        filters: this.filters,
+	        twoWay: this.twoWay,
+	        deep: this.deep,
+	        preProcess: preProcess,
+	        postProcess: postProcess,
+	        scope: this._scope
+	      });
+	      // v-model with inital inline value need to sync back to
+	      // model instead of update to DOM on init. They would
+	      // set the afterBind hook to indicate that.
+	      if (this.afterBind) {
+	        this.afterBind();
+	      } else if (this.update) {
+	        this.update(watcher.value);
+	      }
+	    }
+	  };
+
+	  /**
+	   * Setup all param attributes, e.g. track-by,
+	   * transition-mode, etc...
+	   */
+
+	  Directive.prototype._setupParams = function () {
+	    if (!this.params) {
+	      return;
+	    }
+	    var params = this.params;
+	    // swap the params array with a fresh object.
+	    this.params = Object.create(null);
+	    var i = params.length;
+	    var key, val, mappedKey;
+	    while (i--) {
+	      key = hyphenate(params[i]);
+	      mappedKey = camelize(key);
+	      val = getBindAttr(this.el, key);
+	      if (val != null) {
+	        // dynamic
+	        this._setupParamWatcher(mappedKey, val);
+	      } else {
+	        // static
+	        val = getAttr(this.el, key);
+	        if (val != null) {
+	          this.params[mappedKey] = val === '' ? true : val;
+	        }
+	      }
+	    }
+	  };
+
+	  /**
+	   * Setup a watcher for a dynamic param.
+	   *
+	   * @param {String} key
+	   * @param {String} expression
+	   */
+
+	  Directive.prototype._setupParamWatcher = function (key, expression) {
+	    var self = this;
+	    var called = false;
+	    var unwatch = (this._scope || this.vm).$watch(expression, function (val, oldVal) {
+	      self.params[key] = val;
+	      // since we are in immediate mode,
+	      // only call the param change callbacks if this is not the first update.
+	      if (called) {
+	        var cb = self.paramWatchers && self.paramWatchers[key];
+	        if (cb) {
+	          cb.call(self, val, oldVal);
+	        }
+	      } else {
+	        called = true;
+	      }
+	    }, {
+	      immediate: true,
+	      user: false
+	    });(this._paramUnwatchFns || (this._paramUnwatchFns = [])).push(unwatch);
+	  };
+
+	  /**
+	   * Check if the directive is a function caller
+	   * and if the expression is a callable one. If both true,
+	   * we wrap up the expression and use it as the event
+	   * handler.
+	   *
+	   * e.g. on-click="a++"
+	   *
+	   * @return {Boolean}
+	   */
+
+	  Directive.prototype._checkStatement = function () {
+	    var expression = this.expression;
+	    if (expression && this.acceptStatement && !isSimplePath(expression)) {
+	      var fn = parseExpression(expression).get;
+	      var scope = this._scope || this.vm;
+	      var handler = function handler(e) {
+	        scope.$event = e;
+	        fn.call(scope, scope);
+	        scope.$event = null;
+	      };
+	      if (this.filters) {
+	        handler = scope._applyFilters(handler, null, this.filters);
+	      }
+	      this.update(handler);
+	      return true;
+	    }
+	  };
+
+	  /**
+	   * Set the corresponding value with the setter.
+	   * This should only be used in two-way directives
+	   * e.g. v-model.
+	   *
+	   * @param {*} value
+	   * @public
+	   */
+
+	  Directive.prototype.set = function (value) {
+	    /* istanbul ignore else */
+	    if (this.twoWay) {
+	      this._withLock(function () {
+	        this._watcher.set(value);
+	      });
+	    } else if (true) {
+	      warn('Directive.set() can only be used inside twoWay' + 'directives.');
+	    }
+	  };
+
+	  /**
+	   * Execute a function while preventing that function from
+	   * triggering updates on this directive instance.
+	   *
+	   * @param {Function} fn
+	   */
+
+	  Directive.prototype._withLock = function (fn) {
+	    var self = this;
+	    self._locked = true;
+	    fn.call(self);
+	    nextTick(function () {
+	      self._locked = false;
+	    });
+	  };
+
+	  /**
+	   * Convenience method that attaches a DOM event listener
+	   * to the directive element and autometically tears it down
+	   * during unbind.
+	   *
+	   * @param {String} event
+	   * @param {Function} handler
+	   * @param {Boolean} [useCapture]
+	   */
+
+	  Directive.prototype.on = function (event, handler, useCapture) {
+	    on(this.el, event, handler, useCapture);(this._listeners || (this._listeners = [])).push([event, handler]);
+	  };
+
+	  /**
+	   * Teardown the watcher and call unbind.
+	   */
+
+	  Directive.prototype._teardown = function () {
+	    if (this._bound) {
+	      this._bound = false;
+	      if (this.unbind) {
+	        this.unbind();
+	      }
+	      if (this._watcher) {
+	        this._watcher.teardown();
+	      }
+	      var listeners = this._listeners;
+	      var i;
+	      if (listeners) {
+	        i = listeners.length;
+	        while (i--) {
+	          off(this.el, listeners[i][0], listeners[i][1]);
+	        }
+	      }
+	      var unwatchFns = this._paramUnwatchFns;
+	      if (unwatchFns) {
+	        i = unwatchFns.length;
+	        while (i--) {
+	          unwatchFns[i]();
+	        }
+	      }
+	      if ('development' !== 'production' && this.el) {
+	        this.el._vue_directives.$remove(this);
+	      }
+	      this.vm = this.el = this._watcher = this._listeners = null;
+	    }
+	  };
+
+	  function lifecycleMixin (Vue) {
+	    /**
+	     * Update v-ref for component.
+	     *
+	     * @param {Boolean} remove
+	     */
+
+	    Vue.prototype._updateRef = function (remove) {
+	      var ref = this.$options._ref;
+	      if (ref) {
+	        var refs = (this._scope || this._context).$refs;
+	        if (remove) {
+	          if (refs[ref] === this) {
+	            refs[ref] = null;
+	          }
+	        } else {
+	          refs[ref] = this;
+	        }
+	      }
+	    };
+
+	    /**
+	     * Transclude, compile and link element.
+	     *
+	     * If a pre-compiled linker is available, that means the
+	     * passed in element will be pre-transcluded and compiled
+	     * as well - all we need to do is to call the linker.
+	     *
+	     * Otherwise we need to call transclude/compile/link here.
+	     *
+	     * @param {Element} el
+	     */
+
+	    Vue.prototype._compile = function (el) {
+	      var options = this.$options;
+
+	      // transclude and init element
+	      // transclude can potentially replace original
+	      // so we need to keep reference; this step also injects
+	      // the template and caches the original attributes
+	      // on the container node and replacer node.
+	      var original = el;
+	      el = transclude(el, options);
+	      this._initElement(el);
+
+	      // handle v-pre on root node (#2026)
+	      if (el.nodeType === 1 && getAttr(el, 'v-pre') !== null) {
+	        return;
+	      }
+
+	      // root is always compiled per-instance, because
+	      // container attrs and props can be different every time.
+	      var contextOptions = this._context && this._context.$options;
+	      var rootLinker = compileRoot(el, options, contextOptions);
+
+	      // resolve slot distribution
+	      resolveSlots(this, options._content);
+
+	      // compile and link the rest
+	      var contentLinkFn;
+	      var ctor = this.constructor;
+	      // component compilation can be cached
+	      // as long as it's not using inline-template
+	      if (options._linkerCachable) {
+	        contentLinkFn = ctor.linker;
+	        if (!contentLinkFn) {
+	          contentLinkFn = ctor.linker = compile(el, options);
+	        }
+	      }
+
+	      // link phase
+	      // make sure to link root with prop scope!
+	      var rootUnlinkFn = rootLinker(this, el, this._scope);
+	      var contentUnlinkFn = contentLinkFn ? contentLinkFn(this, el) : compile(el, options)(this, el);
+
+	      // register composite unlink function
+	      // to be called during instance destruction
+	      this._unlinkFn = function () {
+	        rootUnlinkFn();
+	        // passing destroying: true to avoid searching and
+	        // splicing the directives
+	        contentUnlinkFn(true);
+	      };
+
+	      // finally replace original
+	      if (options.replace) {
+	        replace(original, el);
+	      }
+
+	      this._isCompiled = true;
+	      this._callHook('compiled');
+	    };
+
+	    /**
+	     * Initialize instance element. Called in the public
+	     * $mount() method.
+	     *
+	     * @param {Element} el
+	     */
+
+	    Vue.prototype._initElement = function (el) {
+	      if (isFragment(el)) {
+	        this._isFragment = true;
+	        this.$el = this._fragmentStart = el.firstChild;
+	        this._fragmentEnd = el.lastChild;
+	        // set persisted text anchors to empty
+	        if (this._fragmentStart.nodeType === 3) {
+	          this._fragmentStart.data = this._fragmentEnd.data = '';
+	        }
+	        this._fragment = el;
+	      } else {
+	        this.$el = el;
+	      }
+	      this.$el.__vue__ = this;
+	      this._callHook('beforeCompile');
+	    };
+
+	    /**
+	     * Create and bind a directive to an element.
+	     *
+	     * @param {Object} descriptor - parsed directive descriptor
+	     * @param {Node} node   - target node
+	     * @param {Vue} [host] - transclusion host component
+	     * @param {Object} [scope] - v-for scope
+	     * @param {Fragment} [frag] - owner fragment
+	     */
+
+	    Vue.prototype._bindDir = function (descriptor, node, host, scope, frag) {
+	      this._directives.push(new Directive(descriptor, this, node, host, scope, frag));
+	    };
+
+	    /**
+	     * Teardown an instance, unobserves the data, unbind all the
+	     * directives, turn off all the event listeners, etc.
+	     *
+	     * @param {Boolean} remove - whether to remove the DOM node.
+	     * @param {Boolean} deferCleanup - if true, defer cleanup to
+	     *                                 be called later
+	     */
+
+	    Vue.prototype._destroy = function (remove, deferCleanup) {
+	      if (this._isBeingDestroyed) {
+	        if (!deferCleanup) {
+	          this._cleanup();
+	        }
+	        return;
+	      }
+
+	      var destroyReady;
+	      var pendingRemoval;
+
+	      var self = this;
+	      // Cleanup should be called either synchronously or asynchronoysly as
+	      // callback of this.$remove(), or if remove and deferCleanup are false.
+	      // In any case it should be called after all other removing, unbinding and
+	      // turning of is done
+	      var cleanupIfPossible = function cleanupIfPossible() {
+	        if (destroyReady && !pendingRemoval && !deferCleanup) {
+	          self._cleanup();
+	        }
+	      };
+
+	      // remove DOM element
+	      if (remove && this.$el) {
+	        pendingRemoval = true;
+	        this.$remove(function () {
+	          pendingRemoval = false;
+	          cleanupIfPossible();
+	        });
+	      }
+
+	      this._callHook('beforeDestroy');
+	      this._isBeingDestroyed = true;
+	      var i;
+	      // remove self from parent. only necessary
+	      // if parent is not being destroyed as well.
+	      var parent = this.$parent;
+	      if (parent && !parent._isBeingDestroyed) {
+	        parent.$children.$remove(this);
+	        // unregister ref (remove: true)
+	        this._updateRef(true);
+	      }
+	      // destroy all children.
+	      i = this.$children.length;
+	      while (i--) {
+	        this.$children[i].$destroy();
+	      }
+	      // teardown props
+	      if (this._propsUnlinkFn) {
+	        this._propsUnlinkFn();
+	      }
+	      // teardown all directives. this also tearsdown all
+	      // directive-owned watchers.
+	      if (this._unlinkFn) {
+	        this._unlinkFn();
+	      }
+	      i = this._watchers.length;
+	      while (i--) {
+	        this._watchers[i].teardown();
+	      }
+	      // remove reference to self on $el
+	      if (this.$el) {
+	        this.$el.__vue__ = null;
+	      }
+
+	      destroyReady = true;
+	      cleanupIfPossible();
+	    };
+
+	    /**
+	     * Clean up to ensure garbage collection.
+	     * This is called after the leave transition if there
+	     * is any.
+	     */
+
+	    Vue.prototype._cleanup = function () {
+	      if (this._isDestroyed) {
+	        return;
+	      }
+	      // remove self from owner fragment
+	      // do it in cleanup so that we can call $destroy with
+	      // defer right when a fragment is about to be removed.
+	      if (this._frag) {
+	        this._frag.children.$remove(this);
+	      }
+	      // remove reference from data ob
+	      // frozen object may not have observer.
+	      if (this._data && this._data.__ob__) {
+	        this._data.__ob__.removeVm(this);
+	      }
+	      // Clean up references to private properties and other
+	      // instances. preserve reference to _data so that proxy
+	      // accessors still work. The only potential side effect
+	      // here is that mutating the instance after it's destroyed
+	      // may affect the state of other components that are still
+	      // observing the same object, but that seems to be a
+	      // reasonable responsibility for the user rather than
+	      // always throwing an error on them.
+	      this.$el = this.$parent = this.$root = this.$children = this._watchers = this._context = this._scope = this._directives = null;
+	      // call the last hook...
+	      this._isDestroyed = true;
+	      this._callHook('destroyed');
+	      // turn off all instance listeners.
+	      this.$off();
+	    };
+	  }
+
+	  function miscMixin (Vue) {
+	    /**
+	     * Apply a list of filter (descriptors) to a value.
+	     * Using plain for loops here because this will be called in
+	     * the getter of any watcher with filters so it is very
+	     * performance sensitive.
+	     *
+	     * @param {*} value
+	     * @param {*} [oldValue]
+	     * @param {Array} filters
+	     * @param {Boolean} write
+	     * @return {*}
+	     */
+
+	    Vue.prototype._applyFilters = function (value, oldValue, filters, write) {
+	      var filter, fn, args, arg, offset, i, l, j, k;
+	      for (i = 0, l = filters.length; i < l; i++) {
+	        filter = filters[write ? l - i - 1 : i];
+	        fn = resolveAsset(this.$options, 'filters', filter.name, true);
+	        if (!fn) continue;
+	        fn = write ? fn.write : fn.read || fn;
+	        if (typeof fn !== 'function') continue;
+	        args = write ? [value, oldValue] : [value];
+	        offset = write ? 2 : 1;
+	        if (filter.args) {
+	          for (j = 0, k = filter.args.length; j < k; j++) {
+	            arg = filter.args[j];
+	            args[j + offset] = arg.dynamic ? this.$get(arg.value) : arg.value;
+	          }
+	        }
+	        value = fn.apply(this, args);
+	      }
+	      return value;
+	    };
+
+	    /**
+	     * Resolve a component, depending on whether the component
+	     * is defined normally or using an async factory function.
+	     * Resolves synchronously if already resolved, otherwise
+	     * resolves asynchronously and caches the resolved
+	     * constructor on the factory.
+	     *
+	     * @param {String|Function} value
+	     * @param {Function} cb
+	     */
+
+	    Vue.prototype._resolveComponent = function (value, cb) {
+	      var factory;
+	      if (typeof value === 'function') {
+	        factory = value;
+	      } else {
+	        factory = resolveAsset(this.$options, 'components', value, true);
+	      }
+	      /* istanbul ignore if */
+	      if (!factory) {
+	        return;
+	      }
+	      // async component factory
+	      if (!factory.options) {
+	        if (factory.resolved) {
+	          // cached
+	          cb(factory.resolved);
+	        } else if (factory.requested) {
+	          // pool callbacks
+	          factory.pendingCallbacks.push(cb);
+	        } else {
+	          factory.requested = true;
+	          var cbs = factory.pendingCallbacks = [cb];
+	          factory.call(this, function resolve(res) {
+	            if (isPlainObject(res)) {
+	              res = Vue.extend(res);
+	            }
+	            // cache resolved
+	            factory.resolved = res;
+	            // invoke callbacks
+	            for (var i = 0, l = cbs.length; i < l; i++) {
+	              cbs[i](res);
+	            }
+	          }, function reject(reason) {
+	            'development' !== 'production' && warn('Failed to resolve async component' + (typeof value === 'string' ? ': ' + value : '') + '. ' + (reason ? '\nReason: ' + reason : ''));
+	          });
+	        }
+	      } else {
+	        // normal component
+	        cb(factory);
+	      }
+	    };
+	  }
+
+	  var filterRE$1 = /[^|]\|[^|]/;
+
+	  function dataAPI (Vue) {
+	    /**
+	     * Get the value from an expression on this vm.
+	     *
+	     * @param {String} exp
+	     * @param {Boolean} [asStatement]
+	     * @return {*}
+	     */
+
+	    Vue.prototype.$get = function (exp, asStatement) {
+	      var res = parseExpression(exp);
+	      if (res) {
+	        if (asStatement) {
+	          var self = this;
+	          return function statementHandler() {
+	            self.$arguments = toArray(arguments);
+	            var result = res.get.call(self, self);
+	            self.$arguments = null;
+	            return result;
+	          };
+	        } else {
+	          try {
+	            return res.get.call(this, this);
+	          } catch (e) {}
+	        }
+	      }
+	    };
+
+	    /**
+	     * Set the value from an expression on this vm.
+	     * The expression must be a valid left-hand
+	     * expression in an assignment.
+	     *
+	     * @param {String} exp
+	     * @param {*} val
+	     */
+
+	    Vue.prototype.$set = function (exp, val) {
+	      var res = parseExpression(exp, true);
+	      if (res && res.set) {
+	        res.set.call(this, this, val);
+	      }
+	    };
+
+	    /**
+	     * Delete a property on the VM
+	     *
+	     * @param {String} key
+	     */
+
+	    Vue.prototype.$delete = function (key) {
+	      del(this._data, key);
+	    };
+
+	    /**
+	     * Watch an expression, trigger callback when its
+	     * value changes.
+	     *
+	     * @param {String|Function} expOrFn
+	     * @param {Function} cb
+	     * @param {Object} [options]
+	     *                 - {Boolean} deep
+	     *                 - {Boolean} immediate
+	     * @return {Function} - unwatchFn
+	     */
+
+	    Vue.prototype.$watch = function (expOrFn, cb, options) {
+	      var vm = this;
+	      var parsed;
+	      if (typeof expOrFn === 'string') {
+	        parsed = parseDirective(expOrFn);
+	        expOrFn = parsed.expression;
+	      }
+	      var watcher = new Watcher(vm, expOrFn, cb, {
+	        deep: options && options.deep,
+	        sync: options && options.sync,
+	        filters: parsed && parsed.filters,
+	        user: !options || options.user !== false
+	      });
+	      if (options && options.immediate) {
+	        cb.call(vm, watcher.value);
+	      }
+	      return function unwatchFn() {
+	        watcher.teardown();
+	      };
+	    };
+
+	    /**
+	     * Evaluate a text directive, including filters.
+	     *
+	     * @param {String} text
+	     * @param {Boolean} [asStatement]
+	     * @return {String}
+	     */
+
+	    Vue.prototype.$eval = function (text, asStatement) {
+	      // check for filters.
+	      if (filterRE$1.test(text)) {
+	        var dir = parseDirective(text);
+	        // the filter regex check might give false positive
+	        // for pipes inside strings, so it's possible that
+	        // we don't get any filters here
+	        var val = this.$get(dir.expression, asStatement);
+	        return dir.filters ? this._applyFilters(val, null, dir.filters) : val;
+	      } else {
+	        // no filter
+	        return this.$get(text, asStatement);
+	      }
+	    };
+
+	    /**
+	     * Interpolate a piece of template text.
+	     *
+	     * @param {String} text
+	     * @return {String}
+	     */
+
+	    Vue.prototype.$interpolate = function (text) {
+	      var tokens = parseText(text);
+	      var vm = this;
+	      if (tokens) {
+	        if (tokens.length === 1) {
+	          return vm.$eval(tokens[0].value) + '';
+	        } else {
+	          return tokens.map(function (token) {
+	            return token.tag ? vm.$eval(token.value) : token.value;
+	          }).join('');
+	        }
+	      } else {
+	        return text;
+	      }
+	    };
+
+	    /**
+	     * Log instance data as a plain JS object
+	     * so that it is easier to inspect in console.
+	     * This method assumes console is available.
+	     *
+	     * @param {String} [path]
+	     */
+
+	    Vue.prototype.$log = function (path) {
+	      var data = path ? getPath(this._data, path) : this._data;
+	      if (data) {
+	        data = clean(data);
+	      }
+	      // include computed fields
+	      if (!path) {
+	        var key;
+	        for (key in this.$options.computed) {
+	          data[key] = clean(this[key]);
+	        }
+	        if (this._props) {
+	          for (key in this._props) {
+	            data[key] = clean(this[key]);
+	          }
+	        }
+	      }
+	      console.log(data);
+	    };
+
+	    /**
+	     * "clean" a getter/setter converted object into a plain
+	     * object copy.
+	     *
+	     * @param {Object} - obj
+	     * @return {Object}
+	     */
+
+	    function clean(obj) {
+	      return JSON.parse(JSON.stringify(obj));
+	    }
+	  }
+
+	  function domAPI (Vue) {
+	    /**
+	     * Convenience on-instance nextTick. The callback is
+	     * auto-bound to the instance, and this avoids component
+	     * modules having to rely on the global Vue.
+	     *
+	     * @param {Function} fn
+	     */
+
+	    Vue.prototype.$nextTick = function (fn) {
+	      nextTick(fn, this);
+	    };
+
+	    /**
+	     * Append instance to target
+	     *
+	     * @param {Node} target
+	     * @param {Function} [cb]
+	     * @param {Boolean} [withTransition] - defaults to true
+	     */
+
+	    Vue.prototype.$appendTo = function (target, cb, withTransition) {
+	      return insert(this, target, cb, withTransition, append, appendWithTransition);
+	    };
+
+	    /**
+	     * Prepend instance to target
+	     *
+	     * @param {Node} target
+	     * @param {Function} [cb]
+	     * @param {Boolean} [withTransition] - defaults to true
+	     */
+
+	    Vue.prototype.$prependTo = function (target, cb, withTransition) {
+	      target = query(target);
+	      if (target.hasChildNodes()) {
+	        this.$before(target.firstChild, cb, withTransition);
+	      } else {
+	        this.$appendTo(target, cb, withTransition);
+	      }
+	      return this;
+	    };
+
+	    /**
+	     * Insert instance before target
+	     *
+	     * @param {Node} target
+	     * @param {Function} [cb]
+	     * @param {Boolean} [withTransition] - defaults to true
+	     */
+
+	    Vue.prototype.$before = function (target, cb, withTransition) {
+	      return insert(this, target, cb, withTransition, beforeWithCb, beforeWithTransition);
+	    };
+
+	    /**
+	     * Insert instance after target
+	     *
+	     * @param {Node} target
+	     * @param {Function} [cb]
+	     * @param {Boolean} [withTransition] - defaults to true
+	     */
+
+	    Vue.prototype.$after = function (target, cb, withTransition) {
+	      target = query(target);
+	      if (target.nextSibling) {
+	        this.$before(target.nextSibling, cb, withTransition);
+	      } else {
+	        this.$appendTo(target.parentNode, cb, withTransition);
+	      }
+	      return this;
+	    };
+
+	    /**
+	     * Remove instance from DOM
+	     *
+	     * @param {Function} [cb]
+	     * @param {Boolean} [withTransition] - defaults to true
+	     */
+
+	    Vue.prototype.$remove = function (cb, withTransition) {
+	      if (!this.$el.parentNode) {
+	        return cb && cb();
+	      }
+	      var inDocument = this._isAttached && inDoc(this.$el);
+	      // if we are not in document, no need to check
+	      // for transitions
+	      if (!inDocument) withTransition = false;
+	      var self = this;
+	      var realCb = function realCb() {
+	        if (inDocument) self._callHook('detached');
+	        if (cb) cb();
+	      };
+	      if (this._isFragment) {
+	        removeNodeRange(this._fragmentStart, this._fragmentEnd, this, this._fragment, realCb);
+	      } else {
+	        var op = withTransition === false ? removeWithCb : removeWithTransition;
+	        op(this.$el, this, realCb);
+	      }
+	      return this;
+	    };
+
+	    /**
+	     * Shared DOM insertion function.
+	     *
+	     * @param {Vue} vm
+	     * @param {Element} target
+	     * @param {Function} [cb]
+	     * @param {Boolean} [withTransition]
+	     * @param {Function} op1 - op for non-transition insert
+	     * @param {Function} op2 - op for transition insert
+	     * @return vm
+	     */
+
+	    function insert(vm, target, cb, withTransition, op1, op2) {
+	      target = query(target);
+	      var targetIsDetached = !inDoc(target);
+	      var op = withTransition === false || targetIsDetached ? op1 : op2;
+	      var shouldCallHook = !targetIsDetached && !vm._isAttached && !inDoc(vm.$el);
+	      if (vm._isFragment) {
+	        mapNodeRange(vm._fragmentStart, vm._fragmentEnd, function (node) {
+	          op(node, target, vm);
+	        });
+	        cb && cb();
+	      } else {
+	        op(vm.$el, target, vm, cb);
+	      }
+	      if (shouldCallHook) {
+	        vm._callHook('attached');
+	      }
+	      return vm;
+	    }
+
+	    /**
+	     * Check for selectors
+	     *
+	     * @param {String|Element} el
+	     */
+
+	    function query(el) {
+	      return typeof el === 'string' ? document.querySelector(el) : el;
+	    }
+
+	    /**
+	     * Append operation that takes a callback.
+	     *
+	     * @param {Node} el
+	     * @param {Node} target
+	     * @param {Vue} vm - unused
+	     * @param {Function} [cb]
+	     */
+
+	    function append(el, target, vm, cb) {
+	      target.appendChild(el);
+	      if (cb) cb();
+	    }
+
+	    /**
+	     * InsertBefore operation that takes a callback.
+	     *
+	     * @param {Node} el
+	     * @param {Node} target
+	     * @param {Vue} vm - unused
+	     * @param {Function} [cb]
+	     */
+
+	    function beforeWithCb(el, target, vm, cb) {
+	      before(el, target);
+	      if (cb) cb();
+	    }
+
+	    /**
+	     * Remove operation that takes a callback.
+	     *
+	     * @param {Node} el
+	     * @param {Vue} vm - unused
+	     * @param {Function} [cb]
+	     */
+
+	    function removeWithCb(el, vm, cb) {
+	      remove(el);
+	      if (cb) cb();
+	    }
+	  }
+
+	  function eventsAPI (Vue) {
+	    /**
+	     * Listen on the given `event` with `fn`.
+	     *
+	     * @param {String} event
+	     * @param {Function} fn
+	     */
+
+	    Vue.prototype.$on = function (event, fn) {
+	      (this._events[event] || (this._events[event] = [])).push(fn);
+	      modifyListenerCount(this, event, 1);
+	      return this;
+	    };
+
+	    /**
+	     * Adds an `event` listener that will be invoked a single
+	     * time then automatically removed.
+	     *
+	     * @param {String} event
+	     * @param {Function} fn
+	     */
+
+	    Vue.prototype.$once = function (event, fn) {
+	      var self = this;
+	      function on() {
+	        self.$off(event, on);
+	        fn.apply(this, arguments);
+	      }
+	      on.fn = fn;
+	      this.$on(event, on);
+	      return this;
+	    };
+
+	    /**
+	     * Remove the given callback for `event` or all
+	     * registered callbacks.
+	     *
+	     * @param {String} event
+	     * @param {Function} fn
+	     */
+
+	    Vue.prototype.$off = function (event, fn) {
+	      var cbs;
+	      // all
+	      if (!arguments.length) {
+	        if (this.$parent) {
+	          for (event in this._events) {
+	            cbs = this._events[event];
+	            if (cbs) {
+	              modifyListenerCount(this, event, -cbs.length);
+	            }
+	          }
+	        }
+	        this._events = {};
+	        return this;
+	      }
+	      // specific event
+	      cbs = this._events[event];
+	      if (!cbs) {
+	        return this;
+	      }
+	      if (arguments.length === 1) {
+	        modifyListenerCount(this, event, -cbs.length);
+	        this._events[event] = null;
+	        return this;
+	      }
+	      // specific handler
+	      var cb;
+	      var i = cbs.length;
+	      while (i--) {
+	        cb = cbs[i];
+	        if (cb === fn || cb.fn === fn) {
+	          modifyListenerCount(this, event, -1);
+	          cbs.splice(i, 1);
+	          break;
+	        }
+	      }
+	      return this;
+	    };
+
+	    /**
+	     * Trigger an event on self.
+	     *
+	     * @param {String|Object} event
+	     * @return {Boolean} shouldPropagate
+	     */
+
+	    Vue.prototype.$emit = function (event) {
+	      var isSource = typeof event === 'string';
+	      event = isSource ? event : event.name;
+	      var cbs = this._events[event];
+	      var shouldPropagate = isSource || !cbs;
+	      if (cbs) {
+	        cbs = cbs.length > 1 ? toArray(cbs) : cbs;
+	        // this is a somewhat hacky solution to the question raised
+	        // in #2102: for an inline component listener like <comp @test="doThis">,
+	        // the propagation handling is somewhat broken. Therefore we
+	        // need to treat these inline callbacks differently.
+	        var hasParentCbs = isSource && cbs.some(function (cb) {
+	          return cb._fromParent;
+	        });
+	        if (hasParentCbs) {
+	          shouldPropagate = false;
+	        }
+	        var args = toArray(arguments, 1);
+	        for (var i = 0, l = cbs.length; i < l; i++) {
+	          var cb = cbs[i];
+	          var res = cb.apply(this, args);
+	          if (res === true && (!hasParentCbs || cb._fromParent)) {
+	            shouldPropagate = true;
+	          }
+	        }
+	      }
+	      return shouldPropagate;
+	    };
+
+	    /**
+	     * Recursively broadcast an event to all children instances.
+	     *
+	     * @param {String|Object} event
+	     * @param {...*} additional arguments
+	     */
+
+	    Vue.prototype.$broadcast = function (event) {
+	      var isSource = typeof event === 'string';
+	      event = isSource ? event : event.name;
+	      // if no child has registered for this event,
+	      // then there's no need to broadcast.
+	      if (!this._eventsCount[event]) return;
+	      var children = this.$children;
+	      var args = toArray(arguments);
+	      if (isSource) {
+	        // use object event to indicate non-source emit
+	        // on children
+	        args[0] = { name: event, source: this };
+	      }
+	      for (var i = 0, l = children.length; i < l; i++) {
+	        var child = children[i];
+	        var shouldPropagate = child.$emit.apply(child, args);
+	        if (shouldPropagate) {
+	          child.$broadcast.apply(child, args);
+	        }
+	      }
+	      return this;
+	    };
+
+	    /**
+	     * Recursively propagate an event up the parent chain.
+	     *
+	     * @param {String} event
+	     * @param {...*} additional arguments
+	     */
+
+	    Vue.prototype.$dispatch = function (event) {
+	      var shouldPropagate = this.$emit.apply(this, arguments);
+	      if (!shouldPropagate) return;
+	      var parent = this.$parent;
+	      var args = toArray(arguments);
+	      // use object event to indicate non-source emit
+	      // on parents
+	      args[0] = { name: event, source: this };
+	      while (parent) {
+	        shouldPropagate = parent.$emit.apply(parent, args);
+	        parent = shouldPropagate ? parent.$parent : null;
+	      }
+	      return this;
+	    };
+
+	    /**
+	     * Modify the listener counts on all parents.
+	     * This bookkeeping allows $broadcast to return early when
+	     * no child has listened to a certain event.
+	     *
+	     * @param {Vue} vm
+	     * @param {String} event
+	     * @param {Number} count
+	     */
+
+	    var hookRE = /^hook:/;
+	    function modifyListenerCount(vm, event, count) {
+	      var parent = vm.$parent;
+	      // hooks do not get broadcasted so no need
+	      // to do bookkeeping for them
+	      if (!parent || !count || hookRE.test(event)) return;
+	      while (parent) {
+	        parent._eventsCount[event] = (parent._eventsCount[event] || 0) + count;
+	        parent = parent.$parent;
+	      }
+	    }
+	  }
+
+	  function lifecycleAPI (Vue) {
+	    /**
+	     * Set instance target element and kick off the compilation
+	     * process. The passed in `el` can be a selector string, an
+	     * existing Element, or a DocumentFragment (for block
+	     * instances).
+	     *
+	     * @param {Element|DocumentFragment|string} el
+	     * @public
+	     */
+
+	    Vue.prototype.$mount = function (el) {
+	      if (this._isCompiled) {
+	        'development' !== 'production' && warn('$mount() should be called only once.', this);
+	        return;
+	      }
+	      el = query(el);
+	      if (!el) {
+	        el = document.createElement('div');
+	      }
+	      this._compile(el);
+	      this._initDOMHooks();
+	      if (inDoc(this.$el)) {
+	        this._callHook('attached');
+	        ready.call(this);
+	      } else {
+	        this.$once('hook:attached', ready);
+	      }
+	      return this;
+	    };
+
+	    /**
+	     * Mark an instance as ready.
+	     */
+
+	    function ready() {
+	      this._isAttached = true;
+	      this._isReady = true;
+	      this._callHook('ready');
+	    }
+
+	    /**
+	     * Teardown the instance, simply delegate to the internal
+	     * _destroy.
+	     *
+	     * @param {Boolean} remove
+	     * @param {Boolean} deferCleanup
+	     */
+
+	    Vue.prototype.$destroy = function (remove, deferCleanup) {
+	      this._destroy(remove, deferCleanup);
+	    };
+
+	    /**
+	     * Partially compile a piece of DOM and return a
+	     * decompile function.
+	     *
+	     * @param {Element|DocumentFragment} el
+	     * @param {Vue} [host]
+	     * @param {Object} [scope]
+	     * @param {Fragment} [frag]
+	     * @return {Function}
+	     */
+
+	    Vue.prototype.$compile = function (el, host, scope, frag) {
+	      return compile(el, this.$options, true)(this, el, host, scope, frag);
+	    };
+	  }
+
+	  /**
+	   * The exposed Vue constructor.
+	   *
+	   * API conventions:
+	   * - public API methods/properties are prefixed with `$`
+	   * - internal methods/properties are prefixed with `_`
+	   * - non-prefixed properties are assumed to be proxied user
+	   *   data.
+	   *
+	   * @constructor
+	   * @param {Object} [options]
+	   * @public
+	   */
+
+	  function Vue(options) {
+	    this._init(options);
+	  }
+
+	  // install internals
+	  initMixin(Vue);
+	  stateMixin(Vue);
+	  eventsMixin(Vue);
+	  lifecycleMixin(Vue);
+	  miscMixin(Vue);
+
+	  // install instance APIs
+	  dataAPI(Vue);
+	  domAPI(Vue);
+	  eventsAPI(Vue);
+	  lifecycleAPI(Vue);
+
+	  var slot = {
+
+	    priority: SLOT,
+	    params: ['name'],
+
+	    bind: function bind() {
+	      // this was resolved during component transclusion
+	      var name = this.params.name || 'default';
+	      var content = this.vm._slotContents && this.vm._slotContents[name];
+	      if (!content || !content.hasChildNodes()) {
+	        this.fallback();
+	      } else {
+	        this.compile(content.cloneNode(true), this.vm._context, this.vm);
+	      }
+	    },
+
+	    compile: function compile(content, context, host) {
+	      if (content && context) {
+	        if (this.el.hasChildNodes() && content.childNodes.length === 1 && content.childNodes[0].nodeType === 1 && content.childNodes[0].hasAttribute('v-if')) {
+	          // if the inserted slot has v-if
+	          // inject fallback content as the v-else
+	          var elseBlock = document.createElement('template');
+	          elseBlock.setAttribute('v-else', '');
+	          elseBlock.innerHTML = this.el.innerHTML;
+	          // the else block should be compiled in child scope
+	          elseBlock._context = this.vm;
+	          content.appendChild(elseBlock);
+	        }
+	        var scope = host ? host._scope : this._scope;
+	        this.unlink = context.$compile(content, host, scope, this._frag);
+	      }
+	      if (content) {
+	        replace(this.el, content);
+	      } else {
+	        remove(this.el);
+	      }
+	    },
+
+	    fallback: function fallback() {
+	      this.compile(extractContent(this.el, true), this.vm);
+	    },
+
+	    unbind: function unbind() {
+	      if (this.unlink) {
+	        this.unlink();
+	      }
+	    }
+	  };
+
+	  var partial = {
+
+	    priority: PARTIAL,
+
+	    params: ['name'],
+
+	    // watch changes to name for dynamic partials
+	    paramWatchers: {
+	      name: function name(value) {
+	        vIf.remove.call(this);
+	        if (value) {
+	          this.insert(value);
+	        }
+	      }
+	    },
+
+	    bind: function bind() {
+	      this.anchor = createAnchor('v-partial');
+	      replace(this.el, this.anchor);
+	      this.insert(this.params.name);
+	    },
+
+	    insert: function insert(id) {
+	      var partial = resolveAsset(this.vm.$options, 'partials', id, true);
+	      if (partial) {
+	        this.factory = new FragmentFactory(this.vm, partial);
+	        vIf.insert.call(this);
+	      }
+	    },
+
+	    unbind: function unbind() {
+	      if (this.frag) {
+	        this.frag.destroy();
+	      }
+	    }
+	  };
+
+	  var elementDirectives = {
+	    slot: slot,
+	    partial: partial
+	  };
+
+	  var convertArray = vFor._postProcess;
+
+	  /**
+	   * Limit filter for arrays
+	   *
+	   * @param {Number} n
+	   * @param {Number} offset (Decimal expected)
+	   */
+
+	  function limitBy(arr, n, offset) {
+	    offset = offset ? parseInt(offset, 10) : 0;
+	    n = toNumber(n);
+	    return typeof n === 'number' ? arr.slice(offset, offset + n) : arr;
+	  }
+
+	  /**
+	   * Filter filter for arrays
+	   *
+	   * @param {String} search
+	   * @param {String} [delimiter]
+	   * @param {String} ...dataKeys
+	   */
+
+	  function filterBy(arr, search, delimiter) {
+	    arr = convertArray(arr);
+	    if (search == null) {
+	      return arr;
+	    }
+	    if (typeof search === 'function') {
+	      return arr.filter(search);
+	    }
+	    // cast to lowercase string
+	    search = ('' + search).toLowerCase();
+	    // allow optional `in` delimiter
+	    // because why not
+	    var n = delimiter === 'in' ? 3 : 2;
+	    // extract and flatten keys
+	    var keys = Array.prototype.concat.apply([], toArray(arguments, n));
+	    var res = [];
+	    var item, key, val, j;
+	    for (var i = 0, l = arr.length; i < l; i++) {
+	      item = arr[i];
+	      val = item && item.$value || item;
+	      j = keys.length;
+	      if (j) {
+	        while (j--) {
+	          key = keys[j];
+	          if (key === '$key' && contains(item.$key, search) || contains(getPath(val, key), search)) {
+	            res.push(item);
+	            break;
+	          }
+	        }
+	      } else if (contains(item, search)) {
+	        res.push(item);
+	      }
+	    }
+	    return res;
+	  }
+
+	  /**
+	   * Filter filter for arrays
+	   *
+	   * @param {String|Array<String>|Function} ...sortKeys
+	   * @param {Number} [order]
+	   */
+
+	  function orderBy(arr) {
+	    var comparator = null;
+	    var sortKeys = undefined;
+	    arr = convertArray(arr);
+
+	    // determine order (last argument)
+	    var args = toArray(arguments, 1);
+	    var order = args[args.length - 1];
+	    if (typeof order === 'number') {
+	      order = order < 0 ? -1 : 1;
+	      args = args.length > 1 ? args.slice(0, -1) : args;
+	    } else {
+	      order = 1;
+	    }
+
+	    // determine sortKeys & comparator
+	    var firstArg = args[0];
+	    if (!firstArg) {
+	      return arr;
+	    } else if (typeof firstArg === 'function') {
+	      // custom comparator
+	      comparator = function (a, b) {
+	        return firstArg(a, b) * order;
+	      };
+	    } else {
+	      // string keys. flatten first
+	      sortKeys = Array.prototype.concat.apply([], args);
+	      comparator = function (a, b, i) {
+	        i = i || 0;
+	        return i >= sortKeys.length - 1 ? baseCompare(a, b, i) : baseCompare(a, b, i) || comparator(a, b, i + 1);
+	      };
+	    }
+
+	    function baseCompare(a, b, sortKeyIndex) {
+	      var sortKey = sortKeys[sortKeyIndex];
+	      if (sortKey) {
+	        if (sortKey !== '$key') {
+	          if (isObject(a) && '$value' in a) a = a.$value;
+	          if (isObject(b) && '$value' in b) b = b.$value;
+	        }
+	        a = isObject(a) ? getPath(a, sortKey) : a;
+	        b = isObject(b) ? getPath(b, sortKey) : b;
+	      }
+	      return a === b ? 0 : a > b ? order : -order;
+	    }
+
+	    // sort on a copy to avoid mutating original array
+	    return arr.slice().sort(comparator);
+	  }
+
+	  /**
+	   * String contain helper
+	   *
+	   * @param {*} val
+	   * @param {String} search
+	   */
+
+	  function contains(val, search) {
+	    var i;
+	    if (isPlainObject(val)) {
+	      var keys = Object.keys(val);
+	      i = keys.length;
+	      while (i--) {
+	        if (contains(val[keys[i]], search)) {
+	          return true;
+	        }
+	      }
+	    } else if (isArray(val)) {
+	      i = val.length;
+	      while (i--) {
+	        if (contains(val[i], search)) {
+	          return true;
+	        }
+	      }
+	    } else if (val != null) {
+	      return val.toString().toLowerCase().indexOf(search) > -1;
+	    }
+	  }
+
+	  var digitsRE = /(\d{3})(?=\d)/g;
+
+	  // asset collections must be a plain object.
+	  var filters = {
+
+	    orderBy: orderBy,
+	    filterBy: filterBy,
+	    limitBy: limitBy,
+
+	    /**
+	     * Stringify value.
+	     *
+	     * @param {Number} indent
+	     */
+
+	    json: {
+	      read: function read(value, indent) {
+	        return typeof value === 'string' ? value : JSON.stringify(value, null, Number(indent) || 2);
+	      },
+	      write: function write(value) {
+	        try {
+	          return JSON.parse(value);
+	        } catch (e) {
+	          return value;
+	        }
+	      }
+	    },
+
+	    /**
+	     * 'abc' => 'Abc'
+	     */
+
+	    capitalize: function capitalize(value) {
+	      if (!value && value !== 0) return '';
+	      value = value.toString();
+	      return value.charAt(0).toUpperCase() + value.slice(1);
+	    },
+
+	    /**
+	     * 'abc' => 'ABC'
+	     */
+
+	    uppercase: function uppercase(value) {
+	      return value || value === 0 ? value.toString().toUpperCase() : '';
+	    },
+
+	    /**
+	     * 'AbC' => 'abc'
+	     */
+
+	    lowercase: function lowercase(value) {
+	      return value || value === 0 ? value.toString().toLowerCase() : '';
+	    },
+
+	    /**
+	     * 12345 => $12,345.00
+	     *
+	     * @param {String} sign
+	     * @param {Number} decimals Decimal places
+	     */
+
+	    currency: function currency(value, _currency, decimals) {
+	      value = parseFloat(value);
+	      if (!isFinite(value) || !value && value !== 0) return '';
+	      _currency = _currency != null ? _currency : '$';
+	      decimals = decimals != null ? decimals : 2;
+	      var stringified = Math.abs(value).toFixed(decimals);
+	      var _int = decimals ? stringified.slice(0, -1 - decimals) : stringified;
+	      var i = _int.length % 3;
+	      var head = i > 0 ? _int.slice(0, i) + (_int.length > 3 ? ',' : '') : '';
+	      var _float = decimals ? stringified.slice(-1 - decimals) : '';
+	      var sign = value < 0 ? '-' : '';
+	      return sign + _currency + head + _int.slice(i).replace(digitsRE, '$1,') + _float;
+	    },
+
+	    /**
+	     * 'item' => 'items'
+	     *
+	     * @params
+	     *  an array of strings corresponding to
+	     *  the single, double, triple ... forms of the word to
+	     *  be pluralized. When the number to be pluralized
+	     *  exceeds the length of the args, it will use the last
+	     *  entry in the array.
+	     *
+	     *  e.g. ['single', 'double', 'triple', 'multiple']
+	     */
+
+	    pluralize: function pluralize(value) {
+	      var args = toArray(arguments, 1);
+	      return args.length > 1 ? args[value % 10 - 1] || args[args.length - 1] : args[0] + (value === 1 ? '' : 's');
+	    },
+
+	    /**
+	     * Debounce a handler function.
+	     *
+	     * @param {Function} handler
+	     * @param {Number} delay = 300
+	     * @return {Function}
+	     */
+
+	    debounce: function debounce(handler, delay) {
+	      if (!handler) return;
+	      if (!delay) {
+	        delay = 300;
+	      }
+	      return _debounce(handler, delay);
+	    }
+	  };
+
+	  function installGlobalAPI (Vue) {
+	    /**
+	     * Vue and every constructor that extends Vue has an
+	     * associated options object, which can be accessed during
+	     * compilation steps as `this.constructor.options`.
+	     *
+	     * These can be seen as the default options of every
+	     * Vue instance.
+	     */
+
+	    Vue.options = {
+	      directives: directives,
+	      elementDirectives: elementDirectives,
+	      filters: filters,
+	      transitions: {},
+	      components: {},
+	      partials: {},
+	      replace: true
+	    };
+
+	    /**
+	     * Expose useful internals
+	     */
+
+	    Vue.util = util;
+	    Vue.config = config;
+	    Vue.set = set;
+	    Vue['delete'] = del;
+	    Vue.nextTick = nextTick;
+
+	    /**
+	     * The following are exposed for advanced usage / plugins
+	     */
+
+	    Vue.compiler = compiler;
+	    Vue.FragmentFactory = FragmentFactory;
+	    Vue.internalDirectives = internalDirectives;
+	    Vue.parsers = {
+	      path: path,
+	      text: text,
+	      template: template,
+	      directive: directive,
+	      expression: expression
+	    };
+
+	    /**
+	     * Each instance constructor, including Vue, has a unique
+	     * cid. This enables us to create wrapped "child
+	     * constructors" for prototypal inheritance and cache them.
+	     */
+
+	    Vue.cid = 0;
+	    var cid = 1;
+
+	    /**
+	     * Class inheritance
+	     *
+	     * @param {Object} extendOptions
+	     */
+
+	    Vue.extend = function (extendOptions) {
+	      extendOptions = extendOptions || {};
+	      var Super = this;
+	      var isFirstExtend = Super.cid === 0;
+	      if (isFirstExtend && extendOptions._Ctor) {
+	        return extendOptions._Ctor;
+	      }
+	      var name = extendOptions.name || Super.options.name;
+	      if (true) {
+	        if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+	          warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characaters and the hyphen.');
+	          name = null;
+	        }
+	      }
+	      var Sub = createClass(name || 'VueComponent');
+	      Sub.prototype = Object.create(Super.prototype);
+	      Sub.prototype.constructor = Sub;
+	      Sub.cid = cid++;
+	      Sub.options = mergeOptions(Super.options, extendOptions);
+	      Sub['super'] = Super;
+	      // allow further extension
+	      Sub.extend = Super.extend;
+	      // create asset registers, so extended classes
+	      // can have their private assets too.
+	      config._assetTypes.forEach(function (type) {
+	        Sub[type] = Super[type];
+	      });
+	      // enable recursive self-lookup
+	      if (name) {
+	        Sub.options.components[name] = Sub;
+	      }
+	      // cache constructor
+	      if (isFirstExtend) {
+	        extendOptions._Ctor = Sub;
+	      }
+	      return Sub;
+	    };
+
+	    /**
+	     * A function that returns a sub-class constructor with the
+	     * given name. This gives us much nicer output when
+	     * logging instances in the console.
+	     *
+	     * @param {String} name
+	     * @return {Function}
+	     */
+
+	    function createClass(name) {
+	      /* eslint-disable no-new-func */
+	      return new Function('return function ' + classify(name) + ' (options) { this._init(options) }')();
+	      /* eslint-enable no-new-func */
+	    }
+
+	    /**
+	     * Plugin system
+	     *
+	     * @param {Object} plugin
+	     */
+
+	    Vue.use = function (plugin) {
+	      /* istanbul ignore if */
+	      if (plugin.installed) {
+	        return;
+	      }
+	      // additional parameters
+	      var args = toArray(arguments, 1);
+	      args.unshift(this);
+	      if (typeof plugin.install === 'function') {
+	        plugin.install.apply(plugin, args);
+	      } else {
+	        plugin.apply(null, args);
+	      }
+	      plugin.installed = true;
+	      return this;
+	    };
+
+	    /**
+	     * Apply a global mixin by merging it into the default
+	     * options.
+	     */
+
+	    Vue.mixin = function (mixin) {
+	      Vue.options = mergeOptions(Vue.options, mixin);
+	    };
+
+	    /**
+	     * Create asset registration methods with the following
+	     * signature:
+	     *
+	     * @param {String} id
+	     * @param {*} definition
+	     */
+
+	    config._assetTypes.forEach(function (type) {
+	      Vue[type] = function (id, definition) {
+	        if (!definition) {
+	          return this.options[type + 's'][id];
+	        } else {
+	          /* istanbul ignore if */
+	          if (true) {
+	            if (type === 'component' && (commonTagRE.test(id) || reservedTagRE.test(id))) {
+	              warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
+	            }
+	          }
+	          if (type === 'component' && isPlainObject(definition)) {
+	            definition.name = id;
+	            definition = Vue.extend(definition);
+	          }
+	          this.options[type + 's'][id] = definition;
+	          return definition;
+	        }
+	      };
+	    });
+
+	    // expose internal transition API
+	    extend(Vue.transition, transition);
+	  }
+
+	  installGlobalAPI(Vue);
+
+	  Vue.version = '1.0.24';
+
+	  // devtools global hook
+	  /* istanbul ignore next */
+	  setTimeout(function () {
+	    if (config.devtools) {
+	      if (devtools) {
+	        devtools.emit('init', Vue);
+	      } else if ('development' !== 'production' && inBrowser && /Chrome\/\d+/.test(window.navigator.userAgent)) {
+	        console.log('Download the Vue Devtools for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
+	      }
+	    }
+	  }, 0);
+
+	  return Vue;
+
+	}));
+	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))
+
+/***/ },
+/* 3 */
+/***/ function(module, exports, __webpack_require__) {
+
+	var __vue_script__, __vue_template__
+	__vue_script__ = __webpack_require__(4)
+	if (__vue_script__ &&
+	    __vue_script__.__esModule &&
+	    Object.keys(__vue_script__).length > 1) {
+	  console.warn("[vue-loader] demo.vue: named exports in *.vue files are ignored.")}
+	__vue_template__ = __webpack_require__(7)
+	module.exports = __vue_script__ || {}
+	if (module.exports.__esModule) module.exports = module.exports.default
+	if (__vue_template__) {
+	(typeof module.exports === "function" ? (module.exports.options || (module.exports.options = {})) : module.exports).template = __vue_template__
+	}
+	if (false) {(function () {  module.hot.accept()
+	  var hotAPI = require("vue-hot-reload-api")
+	  hotAPI.install(require("vue"), false)
+	  if (!hotAPI.compatible) return
+	  var id = "./demo.vue"
+	  if (!module.hot.data) {
+	    hotAPI.createRecord(id, module.exports)
+	  } else {
+	    hotAPI.update(id, module.exports, __vue_template__)
+	  }
+	})()}
+
+/***/ },
+/* 4 */
+/***/ function(module, exports, __webpack_require__) {
+
+	"use strict";
+
+	module.exports = {
+	  components: {
+	    "vue-select": __webpack_require__(5)
+	  },
+	  data: function data() {
+	    return {
+	      options1: ["value1", "value2", "value3"],
+	      options2: [{
+	        text: "name1",
+	        value: "value1"
+	      }, {
+	        text: "name2",
+	        value: "value2"
+	      }, {
+	        text: "name3",
+	        value: "value3"
+	      }],
+	      options3: [{
+	        label: "group1",
+	        options: [{
+	          text: "name1",
+	          value: "value1"
+	        }, {
+	          text: "name2",
+	          value: "value2"
+	        }, {
+	          text: "name3",
+	          value: "value3"
+	        }]
+	      }, {
+	        label: "group2",
+	        options: [{
+	          text: "name4",
+	          value: "value4"
+	        }, {
+	          text: "name5",
+	          value: "value5"
+	        }, {
+	          text: "name6",
+	          value: "value6"
+	        }]
+	      }]
+	    };
+	  },
+	  props: {
+	    result1: {
+	      required: true,
+	      twoWay: true
+	    },
+	    result2: {
+	      required: true,
+	      twoWay: true
+	    },
+	    result3: {
+	      required: true,
+	      twoWay: true
+	    }
+	  }
+	};
+
+/***/ },
+/* 5 */
+/***/ function(module, exports, __webpack_require__) {
+
+	/**
+	 * The default language used by this component.
+	 */
+	var DEFAULT_LANGUAGE = "en-US";
+
+	/**
+	 * A bootstrap style selection (combobox) control using the select2 plugin.
+	 *
+	 * @param options
+	 *    the array of options of the selection control. It could be an array of
+	 *    strings, e.g., "['opt1', 'opt2']"; or an array of objects specifying
+	 *    the text and value of each option, e.g.,
+	 *    "[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]";
+	 *    or it could be an array of objects specifying the option group, e.g.
+	 *    "[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},
+	 *      {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]".
+	 * @param model
+	 *    the model bind to the control, which must be a two way binding variable.
+	 * @param searchable
+	 *    the optional flag indicates whether to show the search box. Default value
+	 *    is false.
+	 * @param matchValue
+	 *    the optional flag indicates whether the searching should match both the
+	 *    texts and values of options. Default value is true.
+	 * @param language
+	 *    the optional code of language used by the select2 plugin. If it is not set,
+	 *    and the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin is used,
+	 *    the component will use the language code `$language` provided by the
+	 *    [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin; otherwise, the
+	 *    component will use the default value "en-US".
+	 * @param theme
+	 *    the optional name of the theme of the select2. Default value is "bootstrap".
+	 * @author Haixing Hu
+	 */
+	module.exports = {
+	  replace: true,
+	  inherit: false,
+	  template: "<select class='form-control' v-model='model' :name='name' style='width: 100%'>"
+	          +   "<option v-if='optionsType === \"values\"' v-for='val in options' :value='val'>{{val}}</option>"
+	          +   "<option v-if='optionsType === \"options\"' v-for='opt in options' :value='opt.value'>{{opt.text}}</option>"
+	          +   "<optgroup v-if='optionsType === \"groups\"' v-for='group in options' :label='group.label'>"
+	          +     "<option v-for='opt in group.options' :value='opt.value'>{{opt.text}}</option>"
+	          +   "</optgroup>"
+	          + "</select>",
+	  props: {
+	    options: {
+	      type: Array,
+	      required: true
+	    },
+	    model: {
+	      required: true,
+	      twoWay: true
+	    },
+	    searchable: {
+	      type: Boolean,
+	      required: false,
+	      default: false
+	    },
+	    matchValue: {
+	      type: Boolean,
+	      required: false,
+	      default: true
+	    },
+	    name: {
+	      type: String,
+	      required: false,
+	      default: ""
+	    },
+	    language: {
+	      type: String,
+	      required: false,
+	      default: ""
+	    },
+	    theme: {
+	      type: String,
+	      required: false,
+	      default: "bootstrap"
+	    }
+	  },
+	  data: function() {
+	    return {
+	      optionsType: "unknown"
+	    }
+	  },
+	  beforeCompile: function() {
+	    this.isChanging = false;
+	    this.control = null;
+	    this.optionsType = this.getOptionsType();
+	  },
+	  watch: {
+	    "options": function(val, oldVal) {
+	      //console.debug("options.change");
+	      this.optionsType = this.getOptionsType();
+	      var found = this.inOptions(this.model);
+	      var newValue = (found ? this.model : null);
+	      this.control.removeData("data");  // remove the cached options data
+	      // note that setting the model will automatically changed in the "change"
+	      // event of the select2 control
+	      this.control.val(newValue).trigger("change");
+	    },
+	    "model": function(val, oldVal) {
+	      //console.debug("model.change");
+	      if (! this.isChanging) {
+	        this.isChanging = true;
+	        this.control.val(val).trigger("change");
+	        this.isChanging = false;
+	      }
+	    }
+	  },
+	  ready: function() {
+	    var language = this.language;
+	    if (language === null || language === "") {
+	      if (this.$language) {
+	        language = this.$language;
+	      } else {
+	        language = DEFAULT_LANGUAGE;
+	      }
+	    }
+	    var args = {
+	      theme: this.theme,
+	      language: this.getLanguageCode(language)
+	    };
+	    if (! this.searchable) {
+	      args.minimumResultsForSearch = Infinity;  // hide the search box
+	    } else {
+	      if (this.matchValue) {
+	        args.matcher = __webpack_require__(6);
+	      }
+	    }
+	    this.control = $(this.$el);
+	    this.control.select2(args);
+	    var me = this;
+	    this.control.on("change", function(e) {
+	      //console.debug("control.change");
+	      if (! me.isChanging) {
+	        me.isChanging = true;
+	        me.model = me.control.val();
+	        me.$nextTick(function () {
+	          me.isChanging = false;
+	        });
+	      }
+	    });
+	  },
+	  methods: {
+
+	    /**
+	     * Gets the type of the `options` property of this component.
+	     *
+	     * The `options` property of this component may have the following types:
+	     * - "values": the `options` is an array of strings, e.g., `[value1, value2, value3]`;
+	     * - "options": the `options` is an array of options, e.g., `[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]`;
+	     * - "groups": the `options` is an array of option groups, e.g.,
+	     *   `[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},
+	     *     {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]`;
+	     *
+	     * @param options
+	     *    the new options.
+	     * @return
+	     *    the string representing the type of the `options` property of this
+	     *    component.
+	     */
+	    getOptionsType: function() {
+	      if (this.options.length === 0) {
+	        return "values";
+	      }
+	      var el = this.options[0];
+	      if (typeof el == "string" || el instanceof String) {
+	        return "values";
+	      } else if (typeof el.text !== "undefined") {
+	        return "options";
+	      } else if (typeof el.label !== "undefined") {
+	        return "groups";
+	      } else {
+	        return "unknown";
+	      }
+	    },
+
+	    /**
+	     * Tests whether a specified value exists in the options.
+	     *
+	     * @param value
+	     *    the value to test.
+	     * @return
+	     *    true if the specified value exists in the options; false otherwise.
+	     */
+	    inOptions: function(value) {
+	      var type = this.getOptionsType();
+	      var list = this.options;
+	      var i, j;
+	      switch (type) {
+	      case "values":
+	        for (i = 0; i < list.length; ++i) {
+	          if (value === list[i]) {
+	            return true;
+	          }
+	        }
+	        break;
+	      case "options":
+	        for (i = 0; i < list.length; ++i) {
+	          if (value === list[i].value) {
+	            return true;
+	          }
+	        }
+	        break;
+	      case "groups":
+	        for (i = 0; i < list.length; ++i) {
+	          var options = list[i].options;
+	          for (j = 0; j < options.length; ++j) {
+	            if (value === options[j].value) {
+	              return true;
+	            }
+	          }
+	        }
+	        break;
+	      default:
+	        break;
+	      }
+	      return false;
+	    },
+
+	    /**
+	     * Gets the language code from the "language-country" locale code.
+	     *
+	     * The function will strip the language code before the first "-" of a
+	     * locale code. For example, pass "en-US" will returns "en". But for some
+	     * special locales, the function reserves the locale code. For example,
+	     * the "zh-CN" for the simplified Chinese and the "zh-TW" for the
+	     * traditional Chinese.
+	     *
+	     * @param locale
+	     *    A locale code.
+	     * @return
+	     *    the language code of the locale.
+	     */
+	    getLanguageCode: function(locale) {
+	      if (locale === null || locale.length === 0) {
+	        return "en";
+	      }
+	      if (locale.length <= 2) {
+	        return locale;
+	      } else {
+	        switch (locale) {
+	          case "pt-BR":
+	          case "zh-CN":
+	          case "zh-TW":
+	            return locale;
+	          default:
+	            // reserve only the first two letters language code
+	            return locale.substr(0, 2);
+	        }
+	      }
+	    }
+	  }
+	};
+
+
+/***/ },
+/* 6 */
+/***/ function(module, exports) {
+
+	
+	var DIACRITICS = {
+	  '\u24B6': 'A',
+	  '\uFF21': 'A',
+	  '\u00C0': 'A',
+	  '\u00C1': 'A',
+	  '\u00C2': 'A',
+	  '\u1EA6': 'A',
+	  '\u1EA4': 'A',
+	  '\u1EAA': 'A',
+	  '\u1EA8': 'A',
+	  '\u00C3': 'A',
+	  '\u0100': 'A',
+	  '\u0102': 'A',
+	  '\u1EB0': 'A',
+	  '\u1EAE': 'A',
+	  '\u1EB4': 'A',
+	  '\u1EB2': 'A',
+	  '\u0226': 'A',
+	  '\u01E0': 'A',
+	  '\u00C4': 'A',
+	  '\u01DE': 'A',
+	  '\u1EA2': 'A',
+	  '\u00C5': 'A',
+	  '\u01FA': 'A',
+	  '\u01CD': 'A',
+	  '\u0200': 'A',
+	  '\u0202': 'A',
+	  '\u1EA0': 'A',
+	  '\u1EAC': 'A',
+	  '\u1EB6': 'A',
+	  '\u1E00': 'A',
+	  '\u0104': 'A',
+	  '\u023A': 'A',
+	  '\u2C6F': 'A',
+	  '\uA732': 'AA',
+	  '\u00C6': 'AE',
+	  '\u01FC': 'AE',
+	  '\u01E2': 'AE',
+	  '\uA734': 'AO',
+	  '\uA736': 'AU',
+	  '\uA738': 'AV',
+	  '\uA73A': 'AV',
+	  '\uA73C': 'AY',
+	  '\u24B7': 'B',
+	  '\uFF22': 'B',
+	  '\u1E02': 'B',
+	  '\u1E04': 'B',
+	  '\u1E06': 'B',
+	  '\u0243': 'B',
+	  '\u0182': 'B',
+	  '\u0181': 'B',
+	  '\u24B8': 'C',
+	  '\uFF23': 'C',
+	  '\u0106': 'C',
+	  '\u0108': 'C',
+	  '\u010A': 'C',
+	  '\u010C': 'C',
+	  '\u00C7': 'C',
+	  '\u1E08': 'C',
+	  '\u0187': 'C',
+	  '\u023B': 'C',
+	  '\uA73E': 'C',
+	  '\u24B9': 'D',
+	  '\uFF24': 'D',
+	  '\u1E0A': 'D',
+	  '\u010E': 'D',
+	  '\u1E0C': 'D',
+	  '\u1E10': 'D',
+	  '\u1E12': 'D',
+	  '\u1E0E': 'D',
+	  '\u0110': 'D',
+	  '\u018B': 'D',
+	  '\u018A': 'D',
+	  '\u0189': 'D',
+	  '\uA779': 'D',
+	  '\u01F1': 'DZ',
+	  '\u01C4': 'DZ',
+	  '\u01F2': 'Dz',
+	  '\u01C5': 'Dz',
+	  '\u24BA': 'E',
+	  '\uFF25': 'E',
+	  '\u00C8': 'E',
+	  '\u00C9': 'E',
+	  '\u00CA': 'E',
+	  '\u1EC0': 'E',
+	  '\u1EBE': 'E',
+	  '\u1EC4': 'E',
+	  '\u1EC2': 'E',
+	  '\u1EBC': 'E',
+	  '\u0112': 'E',
+	  '\u1E14': 'E',
+	  '\u1E16': 'E',
+	  '\u0114': 'E',
+	  '\u0116': 'E',
+	  '\u00CB': 'E',
+	  '\u1EBA': 'E',
+	  '\u011A': 'E',
+	  '\u0204': 'E',
+	  '\u0206': 'E',
+	  '\u1EB8': 'E',
+	  '\u1EC6': 'E',
+	  '\u0228': 'E',
+	  '\u1E1C': 'E',
+	  '\u0118': 'E',
+	  '\u1E18': 'E',
+	  '\u1E1A': 'E',
+	  '\u0190': 'E',
+	  '\u018E': 'E',
+	  '\u24BB': 'F',
+	  '\uFF26': 'F',
+	  '\u1E1E': 'F',
+	  '\u0191': 'F',
+	  '\uA77B': 'F',
+	  '\u24BC': 'G',
+	  '\uFF27': 'G',
+	  '\u01F4': 'G',
+	  '\u011C': 'G',
+	  '\u1E20': 'G',
+	  '\u011E': 'G',
+	  '\u0120': 'G',
+	  '\u01E6': 'G',
+	  '\u0122': 'G',
+	  '\u01E4': 'G',
+	  '\u0193': 'G',
+	  '\uA7A0': 'G',
+	  '\uA77D': 'G',
+	  '\uA77E': 'G',
+	  '\u24BD': 'H',
+	  '\uFF28': 'H',
+	  '\u0124': 'H',
+	  '\u1E22': 'H',
+	  '\u1E26': 'H',
+	  '\u021E': 'H',
+	  '\u1E24': 'H',
+	  '\u1E28': 'H',
+	  '\u1E2A': 'H',
+	  '\u0126': 'H',
+	  '\u2C67': 'H',
+	  '\u2C75': 'H',
+	  '\uA78D': 'H',
+	  '\u24BE': 'I',
+	  '\uFF29': 'I',
+	  '\u00CC': 'I',
+	  '\u00CD': 'I',
+	  '\u00CE': 'I',
+	  '\u0128': 'I',
+	  '\u012A': 'I',
+	  '\u012C': 'I',
+	  '\u0130': 'I',
+	  '\u00CF': 'I',
+	  '\u1E2E': 'I',
+	  '\u1EC8': 'I',
+	  '\u01CF': 'I',
+	  '\u0208': 'I',
+	  '\u020A': 'I',
+	  '\u1ECA': 'I',
+	  '\u012E': 'I',
+	  '\u1E2C': 'I',
+	  '\u0197': 'I',
+	  '\u24BF': 'J',
+	  '\uFF2A': 'J',
+	  '\u0134': 'J',
+	  '\u0248': 'J',
+	  '\u24C0': 'K',
+	  '\uFF2B': 'K',
+	  '\u1E30': 'K',
+	  '\u01E8': 'K',
+	  '\u1E32': 'K',
+	  '\u0136': 'K',
+	  '\u1E34': 'K',
+	  '\u0198': 'K',
+	  '\u2C69': 'K',
+	  '\uA740': 'K',
+	  '\uA742': 'K',
+	  '\uA744': 'K',
+	  '\uA7A2': 'K',
+	  '\u24C1': 'L',
+	  '\uFF2C': 'L',
+	  '\u013F': 'L',
+	  '\u0139': 'L',
+	  '\u013D': 'L',
+	  '\u1E36': 'L',
+	  '\u1E38': 'L',
+	  '\u013B': 'L',
+	  '\u1E3C': 'L',
+	  '\u1E3A': 'L',
+	  '\u0141': 'L',
+	  '\u023D': 'L',
+	  '\u2C62': 'L',
+	  '\u2C60': 'L',
+	  '\uA748': 'L',
+	  '\uA746': 'L',
+	  '\uA780': 'L',
+	  '\u01C7': 'LJ',
+	  '\u01C8': 'Lj',
+	  '\u24C2': 'M',
+	  '\uFF2D': 'M',
+	  '\u1E3E': 'M',
+	  '\u1E40': 'M',
+	  '\u1E42': 'M',
+	  '\u2C6E': 'M',
+	  '\u019C': 'M',
+	  '\u24C3': 'N',
+	  '\uFF2E': 'N',
+	  '\u01F8': 'N',
+	  '\u0143': 'N',
+	  '\u00D1': 'N',
+	  '\u1E44': 'N',
+	  '\u0147': 'N',
+	  '\u1E46': 'N',
+	  '\u0145': 'N',
+	  '\u1E4A': 'N',
+	  '\u1E48': 'N',
+	  '\u0220': 'N',
+	  '\u019D': 'N',
+	  '\uA790': 'N',
+	  '\uA7A4': 'N',
+	  '\u01CA': 'NJ',
+	  '\u01CB': 'Nj',
+	  '\u24C4': 'O',
+	  '\uFF2F': 'O',
+	  '\u00D2': 'O',
+	  '\u00D3': 'O',
+	  '\u00D4': 'O',
+	  '\u1ED2': 'O',
+	  '\u1ED0': 'O',
+	  '\u1ED6': 'O',
+	  '\u1ED4': 'O',
+	  '\u00D5': 'O',
+	  '\u1E4C': 'O',
+	  '\u022C': 'O',
+	  '\u1E4E': 'O',
+	  '\u014C': 'O',
+	  '\u1E50': 'O',
+	  '\u1E52': 'O',
+	  '\u014E': 'O',
+	  '\u022E': 'O',
+	  '\u0230': 'O',
+	  '\u00D6': 'O',
+	  '\u022A': 'O',
+	  '\u1ECE': 'O',
+	  '\u0150': 'O',
+	  '\u01D1': 'O',
+	  '\u020C': 'O',
+	  '\u020E': 'O',
+	  '\u01A0': 'O',
+	  '\u1EDC': 'O',
+	  '\u1EDA': 'O',
+	  '\u1EE0': 'O',
+	  '\u1EDE': 'O',
+	  '\u1EE2': 'O',
+	  '\u1ECC': 'O',
+	  '\u1ED8': 'O',
+	  '\u01EA': 'O',
+	  '\u01EC': 'O',
+	  '\u00D8': 'O',
+	  '\u01FE': 'O',
+	  '\u0186': 'O',
+	  '\u019F': 'O',
+	  '\uA74A': 'O',
+	  '\uA74C': 'O',
+	  '\u01A2': 'OI',
+	  '\uA74E': 'OO',
+	  '\u0222': 'OU',
+	  '\u24C5': 'P',
+	  '\uFF30': 'P',
+	  '\u1E54': 'P',
+	  '\u1E56': 'P',
+	  '\u01A4': 'P',
+	  '\u2C63': 'P',
+	  '\uA750': 'P',
+	  '\uA752': 'P',
+	  '\uA754': 'P',
+	  '\u24C6': 'Q',
+	  '\uFF31': 'Q',
+	  '\uA756': 'Q',
+	  '\uA758': 'Q',
+	  '\u024A': 'Q',
+	  '\u24C7': 'R',
+	  '\uFF32': 'R',
+	  '\u0154': 'R',
+	  '\u1E58': 'R',
+	  '\u0158': 'R',
+	  '\u0210': 'R',
+	  '\u0212': 'R',
+	  '\u1E5A': 'R',
+	  '\u1E5C': 'R',
+	  '\u0156': 'R',
+	  '\u1E5E': 'R',
+	  '\u024C': 'R',
+	  '\u2C64': 'R',
+	  '\uA75A': 'R',
+	  '\uA7A6': 'R',
+	  '\uA782': 'R',
+	  '\u24C8': 'S',
+	  '\uFF33': 'S',
+	  '\u1E9E': 'S',
+	  '\u015A': 'S',
+	  '\u1E64': 'S',
+	  '\u015C': 'S',
+	  '\u1E60': 'S',
+	  '\u0160': 'S',
+	  '\u1E66': 'S',
+	  '\u1E62': 'S',
+	  '\u1E68': 'S',
+	  '\u0218': 'S',
+	  '\u015E': 'S',
+	  '\u2C7E': 'S',
+	  '\uA7A8': 'S',
+	  '\uA784': 'S',
+	  '\u24C9': 'T',
+	  '\uFF34': 'T',
+	  '\u1E6A': 'T',
+	  '\u0164': 'T',
+	  '\u1E6C': 'T',
+	  '\u021A': 'T',
+	  '\u0162': 'T',
+	  '\u1E70': 'T',
+	  '\u1E6E': 'T',
+	  '\u0166': 'T',
+	  '\u01AC': 'T',
+	  '\u01AE': 'T',
+	  '\u023E': 'T',
+	  '\uA786': 'T',
+	  '\uA728': 'TZ',
+	  '\u24CA': 'U',
+	  '\uFF35': 'U',
+	  '\u00D9': 'U',
+	  '\u00DA': 'U',
+	  '\u00DB': 'U',
+	  '\u0168': 'U',
+	  '\u1E78': 'U',
+	  '\u016A': 'U',
+	  '\u1E7A': 'U',
+	  '\u016C': 'U',
+	  '\u00DC': 'U',
+	  '\u01DB': 'U',
+	  '\u01D7': 'U',
+	  '\u01D5': 'U',
+	  '\u01D9': 'U',
+	  '\u1EE6': 'U',
+	  '\u016E': 'U',
+	  '\u0170': 'U',
+	  '\u01D3': 'U',
+	  '\u0214': 'U',
+	  '\u0216': 'U',
+	  '\u01AF': 'U',
+	  '\u1EEA': 'U',
+	  '\u1EE8': 'U',
+	  '\u1EEE': 'U',
+	  '\u1EEC': 'U',
+	  '\u1EF0': 'U',
+	  '\u1EE4': 'U',
+	  '\u1E72': 'U',
+	  '\u0172': 'U',
+	  '\u1E76': 'U',
+	  '\u1E74': 'U',
+	  '\u0244': 'U',
+	  '\u24CB': 'V',
+	  '\uFF36': 'V',
+	  '\u1E7C': 'V',
+	  '\u1E7E': 'V',
+	  '\u01B2': 'V',
+	  '\uA75E': 'V',
+	  '\u0245': 'V',
+	  '\uA760': 'VY',
+	  '\u24CC': 'W',
+	  '\uFF37': 'W',
+	  '\u1E80': 'W',
+	  '\u1E82': 'W',
+	  '\u0174': 'W',
+	  '\u1E86': 'W',
+	  '\u1E84': 'W',
+	  '\u1E88': 'W',
+	  '\u2C72': 'W',
+	  '\u24CD': 'X',
+	  '\uFF38': 'X',
+	  '\u1E8A': 'X',
+	  '\u1E8C': 'X',
+	  '\u24CE': 'Y',
+	  '\uFF39': 'Y',
+	  '\u1EF2': 'Y',
+	  '\u00DD': 'Y',
+	  '\u0176': 'Y',
+	  '\u1EF8': 'Y',
+	  '\u0232': 'Y',
+	  '\u1E8E': 'Y',
+	  '\u0178': 'Y',
+	  '\u1EF6': 'Y',
+	  '\u1EF4': 'Y',
+	  '\u01B3': 'Y',
+	  '\u024E': 'Y',
+	  '\u1EFE': 'Y',
+	  '\u24CF': 'Z',
+	  '\uFF3A': 'Z',
+	  '\u0179': 'Z',
+	  '\u1E90': 'Z',
+	  '\u017B': 'Z',
+	  '\u017D': 'Z',
+	  '\u1E92': 'Z',
+	  '\u1E94': 'Z',
+	  '\u01B5': 'Z',
+	  '\u0224': 'Z',
+	  '\u2C7F': 'Z',
+	  '\u2C6B': 'Z',
+	  '\uA762': 'Z',
+	  '\u24D0': 'a',
+	  '\uFF41': 'a',
+	  '\u1E9A': 'a',
+	  '\u00E0': 'a',
+	  '\u00E1': 'a',
+	  '\u00E2': 'a',
+	  '\u1EA7': 'a',
+	  '\u1EA5': 'a',
+	  '\u1EAB': 'a',
+	  '\u1EA9': 'a',
+	  '\u00E3': 'a',
+	  '\u0101': 'a',
+	  '\u0103': 'a',
+	  '\u1EB1': 'a',
+	  '\u1EAF': 'a',
+	  '\u1EB5': 'a',
+	  '\u1EB3': 'a',
+	  '\u0227': 'a',
+	  '\u01E1': 'a',
+	  '\u00E4': 'a',
+	  '\u01DF': 'a',
+	  '\u1EA3': 'a',
+	  '\u00E5': 'a',
+	  '\u01FB': 'a',
+	  '\u01CE': 'a',
+	  '\u0201': 'a',
+	  '\u0203': 'a',
+	  '\u1EA1': 'a',
+	  '\u1EAD': 'a',
+	  '\u1EB7': 'a',
+	  '\u1E01': 'a',
+	  '\u0105': 'a',
+	  '\u2C65': 'a',
+	  '\u0250': 'a',
+	  '\uA733': 'aa',
+	  '\u00E6': 'ae',
+	  '\u01FD': 'ae',
+	  '\u01E3': 'ae',
+	  '\uA735': 'ao',
+	  '\uA737': 'au',
+	  '\uA739': 'av',
+	  '\uA73B': 'av',
+	  '\uA73D': 'ay',
+	  '\u24D1': 'b',
+	  '\uFF42': 'b',
+	  '\u1E03': 'b',
+	  '\u1E05': 'b',
+	  '\u1E07': 'b',
+	  '\u0180': 'b',
+	  '\u0183': 'b',
+	  '\u0253': 'b',
+	  '\u24D2': 'c',
+	  '\uFF43': 'c',
+	  '\u0107': 'c',
+	  '\u0109': 'c',
+	  '\u010B': 'c',
+	  '\u010D': 'c',
+	  '\u00E7': 'c',
+	  '\u1E09': 'c',
+	  '\u0188': 'c',
+	  '\u023C': 'c',
+	  '\uA73F': 'c',
+	  '\u2184': 'c',
+	  '\u24D3': 'd',
+	  '\uFF44': 'd',
+	  '\u1E0B': 'd',
+	  '\u010F': 'd',
+	  '\u1E0D': 'd',
+	  '\u1E11': 'd',
+	  '\u1E13': 'd',
+	  '\u1E0F': 'd',
+	  '\u0111': 'd',
+	  '\u018C': 'd',
+	  '\u0256': 'd',
+	  '\u0257': 'd',
+	  '\uA77A': 'd',
+	  '\u01F3': 'dz',
+	  '\u01C6': 'dz',
+	  '\u24D4': 'e',
+	  '\uFF45': 'e',
+	  '\u00E8': 'e',
+	  '\u00E9': 'e',
+	  '\u00EA': 'e',
+	  '\u1EC1': 'e',
+	  '\u1EBF': 'e',
+	  '\u1EC5': 'e',
+	  '\u1EC3': 'e',
+	  '\u1EBD': 'e',
+	  '\u0113': 'e',
+	  '\u1E15': 'e',
+	  '\u1E17': 'e',
+	  '\u0115': 'e',
+	  '\u0117': 'e',
+	  '\u00EB': 'e',
+	  '\u1EBB': 'e',
+	  '\u011B': 'e',
+	  '\u0205': 'e',
+	  '\u0207': 'e',
+	  '\u1EB9': 'e',
+	  '\u1EC7': 'e',
+	  '\u0229': 'e',
+	  '\u1E1D': 'e',
+	  '\u0119': 'e',
+	  '\u1E19': 'e',
+	  '\u1E1B': 'e',
+	  '\u0247': 'e',
+	  '\u025B': 'e',
+	  '\u01DD': 'e',
+	  '\u24D5': 'f',
+	  '\uFF46': 'f',
+	  '\u1E1F': 'f',
+	  '\u0192': 'f',
+	  '\uA77C': 'f',
+	  '\u24D6': 'g',
+	  '\uFF47': 'g',
+	  '\u01F5': 'g',
+	  '\u011D': 'g',
+	  '\u1E21': 'g',
+	  '\u011F': 'g',
+	  '\u0121': 'g',
+	  '\u01E7': 'g',
+	  '\u0123': 'g',
+	  '\u01E5': 'g',
+	  '\u0260': 'g',
+	  '\uA7A1': 'g',
+	  '\u1D79': 'g',
+	  '\uA77F': 'g',
+	  '\u24D7': 'h',
+	  '\uFF48': 'h',
+	  '\u0125': 'h',
+	  '\u1E23': 'h',
+	  '\u1E27': 'h',
+	  '\u021F': 'h',
+	  '\u1E25': 'h',
+	  '\u1E29': 'h',
+	  '\u1E2B': 'h',
+	  '\u1E96': 'h',
+	  '\u0127': 'h',
+	  '\u2C68': 'h',
+	  '\u2C76': 'h',
+	  '\u0265': 'h',
+	  '\u0195': 'hv',
+	  '\u24D8': 'i',
+	  '\uFF49': 'i',
+	  '\u00EC': 'i',
+	  '\u00ED': 'i',
+	  '\u00EE': 'i',
+	  '\u0129': 'i',
+	  '\u012B': 'i',
+	  '\u012D': 'i',
+	  '\u00EF': 'i',
+	  '\u1E2F': 'i',
+	  '\u1EC9': 'i',
+	  '\u01D0': 'i',
+	  '\u0209': 'i',
+	  '\u020B': 'i',
+	  '\u1ECB': 'i',
+	  '\u012F': 'i',
+	  '\u1E2D': 'i',
+	  '\u0268': 'i',
+	  '\u0131': 'i',
+	  '\u24D9': 'j',
+	  '\uFF4A': 'j',
+	  '\u0135': 'j',
+	  '\u01F0': 'j',
+	  '\u0249': 'j',
+	  '\u24DA': 'k',
+	  '\uFF4B': 'k',
+	  '\u1E31': 'k',
+	  '\u01E9': 'k',
+	  '\u1E33': 'k',
+	  '\u0137': 'k',
+	  '\u1E35': 'k',
+	  '\u0199': 'k',
+	  '\u2C6A': 'k',
+	  '\uA741': 'k',
+	  '\uA743': 'k',
+	  '\uA745': 'k',
+	  '\uA7A3': 'k',
+	  '\u24DB': 'l',
+	  '\uFF4C': 'l',
+	  '\u0140': 'l',
+	  '\u013A': 'l',
+	  '\u013E': 'l',
+	  '\u1E37': 'l',
+	  '\u1E39': 'l',
+	  '\u013C': 'l',
+	  '\u1E3D': 'l',
+	  '\u1E3B': 'l',
+	  '\u017F': 'l',
+	  '\u0142': 'l',
+	  '\u019A': 'l',
+	  '\u026B': 'l',
+	  '\u2C61': 'l',
+	  '\uA749': 'l',
+	  '\uA781': 'l',
+	  '\uA747': 'l',
+	  '\u01C9': 'lj',
+	  '\u24DC': 'm',
+	  '\uFF4D': 'm',
+	  '\u1E3F': 'm',
+	  '\u1E41': 'm',
+	  '\u1E43': 'm',
+	  '\u0271': 'm',
+	  '\u026F': 'm',
+	  '\u24DD': 'n',
+	  '\uFF4E': 'n',
+	  '\u01F9': 'n',
+	  '\u0144': 'n',
+	  '\u00F1': 'n',
+	  '\u1E45': 'n',
+	  '\u0148': 'n',
+	  '\u1E47': 'n',
+	  '\u0146': 'n',
+	  '\u1E4B': 'n',
+	  '\u1E49': 'n',
+	  '\u019E': 'n',
+	  '\u0272': 'n',
+	  '\u0149': 'n',
+	  '\uA791': 'n',
+	  '\uA7A5': 'n',
+	  '\u01CC': 'nj',
+	  '\u24DE': 'o',
+	  '\uFF4F': 'o',
+	  '\u00F2': 'o',
+	  '\u00F3': 'o',
+	  '\u00F4': 'o',
+	  '\u1ED3': 'o',
+	  '\u1ED1': 'o',
+	  '\u1ED7': 'o',
+	  '\u1ED5': 'o',
+	  '\u00F5': 'o',
+	  '\u1E4D': 'o',
+	  '\u022D': 'o',
+	  '\u1E4F': 'o',
+	  '\u014D': 'o',
+	  '\u1E51': 'o',
+	  '\u1E53': 'o',
+	  '\u014F': 'o',
+	  '\u022F': 'o',
+	  '\u0231': 'o',
+	  '\u00F6': 'o',
+	  '\u022B': 'o',
+	  '\u1ECF': 'o',
+	  '\u0151': 'o',
+	  '\u01D2': 'o',
+	  '\u020D': 'o',
+	  '\u020F': 'o',
+	  '\u01A1': 'o',
+	  '\u1EDD': 'o',
+	  '\u1EDB': 'o',
+	  '\u1EE1': 'o',
+	  '\u1EDF': 'o',
+	  '\u1EE3': 'o',
+	  '\u1ECD': 'o',
+	  '\u1ED9': 'o',
+	  '\u01EB': 'o',
+	  '\u01ED': 'o',
+	  '\u00F8': 'o',
+	  '\u01FF': 'o',
+	  '\u0254': 'o',
+	  '\uA74B': 'o',
+	  '\uA74D': 'o',
+	  '\u0275': 'o',
+	  '\u01A3': 'oi',
+	  '\u0223': 'ou',
+	  '\uA74F': 'oo',
+	  '\u24DF': 'p',
+	  '\uFF50': 'p',
+	  '\u1E55': 'p',
+	  '\u1E57': 'p',
+	  '\u01A5': 'p',
+	  '\u1D7D': 'p',
+	  '\uA751': 'p',
+	  '\uA753': 'p',
+	  '\uA755': 'p',
+	  '\u24E0': 'q',
+	  '\uFF51': 'q',
+	  '\u024B': 'q',
+	  '\uA757': 'q',
+	  '\uA759': 'q',
+	  '\u24E1': 'r',
+	  '\uFF52': 'r',
+	  '\u0155': 'r',
+	  '\u1E59': 'r',
+	  '\u0159': 'r',
+	  '\u0211': 'r',
+	  '\u0213': 'r',
+	  '\u1E5B': 'r',
+	  '\u1E5D': 'r',
+	  '\u0157': 'r',
+	  '\u1E5F': 'r',
+	  '\u024D': 'r',
+	  '\u027D': 'r',
+	  '\uA75B': 'r',
+	  '\uA7A7': 'r',
+	  '\uA783': 'r',
+	  '\u24E2': 's',
+	  '\uFF53': 's',
+	  '\u00DF': 's',
+	  '\u015B': 's',
+	  '\u1E65': 's',
+	  '\u015D': 's',
+	  '\u1E61': 's',
+	  '\u0161': 's',
+	  '\u1E67': 's',
+	  '\u1E63': 's',
+	  '\u1E69': 's',
+	  '\u0219': 's',
+	  '\u015F': 's',
+	  '\u023F': 's',
+	  '\uA7A9': 's',
+	  '\uA785': 's',
+	  '\u1E9B': 's',
+	  '\u24E3': 't',
+	  '\uFF54': 't',
+	  '\u1E6B': 't',
+	  '\u1E97': 't',
+	  '\u0165': 't',
+	  '\u1E6D': 't',
+	  '\u021B': 't',
+	  '\u0163': 't',
+	  '\u1E71': 't',
+	  '\u1E6F': 't',
+	  '\u0167': 't',
+	  '\u01AD': 't',
+	  '\u0288': 't',
+	  '\u2C66': 't',
+	  '\uA787': 't',
+	  '\uA729': 'tz',
+	  '\u24E4': 'u',
+	  '\uFF55': 'u',
+	  '\u00F9': 'u',
+	  '\u00FA': 'u',
+	  '\u00FB': 'u',
+	  '\u0169': 'u',
+	  '\u1E79': 'u',
+	  '\u016B': 'u',
+	  '\u1E7B': 'u',
+	  '\u016D': 'u',
+	  '\u00FC': 'u',
+	  '\u01DC': 'u',
+	  '\u01D8': 'u',
+	  '\u01D6': 'u',
+	  '\u01DA': 'u',
+	  '\u1EE7': 'u',
+	  '\u016F': 'u',
+	  '\u0171': 'u',
+	  '\u01D4': 'u',
+	  '\u0215': 'u',
+	  '\u0217': 'u',
+	  '\u01B0': 'u',
+	  '\u1EEB': 'u',
+	  '\u1EE9': 'u',
+	  '\u1EEF': 'u',
+	  '\u1EED': 'u',
+	  '\u1EF1': 'u',
+	  '\u1EE5': 'u',
+	  '\u1E73': 'u',
+	  '\u0173': 'u',
+	  '\u1E77': 'u',
+	  '\u1E75': 'u',
+	  '\u0289': 'u',
+	  '\u24E5': 'v',
+	  '\uFF56': 'v',
+	  '\u1E7D': 'v',
+	  '\u1E7F': 'v',
+	  '\u028B': 'v',
+	  '\uA75F': 'v',
+	  '\u028C': 'v',
+	  '\uA761': 'vy',
+	  '\u24E6': 'w',
+	  '\uFF57': 'w',
+	  '\u1E81': 'w',
+	  '\u1E83': 'w',
+	  '\u0175': 'w',
+	  '\u1E87': 'w',
+	  '\u1E85': 'w',
+	  '\u1E98': 'w',
+	  '\u1E89': 'w',
+	  '\u2C73': 'w',
+	  '\u24E7': 'x',
+	  '\uFF58': 'x',
+	  '\u1E8B': 'x',
+	  '\u1E8D': 'x',
+	  '\u24E8': 'y',
+	  '\uFF59': 'y',
+	  '\u1EF3': 'y',
+	  '\u00FD': 'y',
+	  '\u0177': 'y',
+	  '\u1EF9': 'y',
+	  '\u0233': 'y',
+	  '\u1E8F': 'y',
+	  '\u00FF': 'y',
+	  '\u1EF7': 'y',
+	  '\u1E99': 'y',
+	  '\u1EF5': 'y',
+	  '\u01B4': 'y',
+	  '\u024F': 'y',
+	  '\u1EFF': 'y',
+	  '\u24E9': 'z',
+	  '\uFF5A': 'z',
+	  '\u017A': 'z',
+	  '\u1E91': 'z',
+	  '\u017C': 'z',
+	  '\u017E': 'z',
+	  '\u1E93': 'z',
+	  '\u1E95': 'z',
+	  '\u01B6': 'z',
+	  '\u0225': 'z',
+	  '\u0240': 'z',
+	  '\u2C6C': 'z',
+	  '\uA763': 'z',
+	  '\u0386': '\u0391',
+	  '\u0388': '\u0395',
+	  '\u0389': '\u0397',
+	  '\u038A': '\u0399',
+	  '\u03AA': '\u0399',
+	  '\u038C': '\u039F',
+	  '\u038E': '\u03A5',
+	  '\u03AB': '\u03A5',
+	  '\u038F': '\u03A9',
+	  '\u03AC': '\u03B1',
+	  '\u03AD': '\u03B5',
+	  '\u03AE': '\u03B7',
+	  '\u03AF': '\u03B9',
+	  '\u03CA': '\u03B9',
+	  '\u0390': '\u03B9',
+	  '\u03CC': '\u03BF',
+	  '\u03CD': '\u03C5',
+	  '\u03CB': '\u03C5',
+	  '\u03B0': '\u03C5',
+	  '\u03C9': '\u03C9',
+	  '\u03C2': '\u03C3'
+	};
+
+
+	function stripDiacritics (text) {
+	  // Used 'uni range + named function' from http://jsperf.com/diacritics/18
+	  function match(a) {
+	    return DIACRITICS[a] || a;
+	  }
+	  return text.replace(/[^\u0000-\u007E]/g, match);
+	}
+
+	// The following matcher is a modification version of the default matcher
+	// of select2
+	module.exports = matcher = function(params, data) {
+	  // Always return the object if there is nothing to compare
+	  if ($.trim(params.term) === '') {
+	    return data;
+	  }
+
+	  // Do a recursive check for options with children
+	  if (data.children && data.children.length > 0) {
+	    // Clone the data object if there are children
+	    // This is required as we modify the object to remove any non-matches
+	    var match = $.extend(true, {}, data);
+
+	    // Check each child of the option
+	    for (var c = data.children.length - 1; c >= 0; c--) {
+	      var child = data.children[c];
+
+	      var matches = matcher(params, child);
+
+	      // If there wasn't a match, remove the object in the array
+	      if (matches == null) {
+	        match.children.splice(c, 1);
+	      }
+	    }
+
+	    // If any children matched, return the new object
+	    if (match.children.length > 0) {
+	      return match;
+	    }
+
+	    // If there were no matching children, check just the plain object
+	    return matcher(params, match);
+	  }
+
+	  var original = stripDiacritics(data.text).toUpperCase();
+	  var term = stripDiacritics(params.term).toUpperCase();
+
+	  // Check if the text contains the term
+	  if (original.indexOf(term) > -1) {
+	    return data;
+	  }
+
+	  // add by Haixing Hu: also match the value of an option
+	  if (data.id) {
+	    var originalValue = stripDiacritics(data.id).toUpperCase();
+	    if (originalValue.indexOf(term) > -1) {
+	      return data;
+	    }
+	  }
+
+	  // If it doesn't contain the term, don't return anything
+	  return null;
+	}
+
+/***/ },
+/* 7 */
+/***/ function(module, exports) {
+
+	module.exports = "\n<div class=\"form-horizontal\">\n  <div class=\"form-group\">\n    <label for=\"select1\" class=\"col-sm-3 control-label\">\n      A simple select:\n    </label>\n    <div class=\"col-sm-5\">\n      <vue-select class=\"vue-select1\" name=\"select1\"\n                  :options=\"options1\" :model.sync=\"result1\"\n                  language=\"\">\n      </vue-select>\n    </div>\n    <div class=\"col-sm-4\">\n      <p class=\"form-control-static\">\n        Selected Result: <span class=\"vue-result1\">{{result1}}</span>\n      </p>\n    </div>\n  </div>\n  <div class=\"form-group\">\n    <label for=\"select2\" class=\"col-sm-3 control-label\">\n      A searchable select with names and localized in en-US:\n    </label>\n    <div class=\"col-sm-5\">\n      <vue-select class=\"vue-select2\" name=\"select2\"\n              :options=\"options2\" :model.sync=\"result2\"\n              :searchable=\"true\" language=\"en-US\">\n      </vue-select>\n    </div>\n    <div class=\"col-sm-4\">\n      <p class=\"form-control-static\">\n        Selected Result: <span class=\"vue-result2\">{{result2}}</span>\n      </p>\n    </div>\n  </div>\n  <div class=\"form-group\">\n    <label for=\"select3\" class=\"col-sm-3 control-label\">\n      A searchable select with groups and localized in zh-CN:\n    </label>\n    <div class=\"col-sm-5\">\n      <vue-select class=\"vue-select3\" name=\"select3\"\n                  :options=\"options3\" :model.sync=\"result3\"\n                  :searchable=\"true\" language=\"zh-CN\">\n      </vue-select>\n    </div>\n    <div class=\"col-sm-4\">\n      <p class=\"form-control-static\">\n        Selected Result: <span class=\"vue-result3\">{{result3}}</span>\n      </p>\n    </div>\n  </div>\n</div>\n"
+
+/***/ }
+/******/ ]);
\ No newline at end of file
Index: public/node_modules/vue-select2/demo/demo.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/demo/demo.html	(revision )
+++ public/node_modules/vue-select2/demo/demo.html	(revision )
@@ -0,0 +1,26 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+  <meta charset="utf-8">
+  <title>Demo of vue-select</title>
+  <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/select2/4.0.0/css/select2.css">
+  <link rel="stylesheet" type="text/css" href="https://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.css">
+  <link rel="stylesheet" type="text/css" href="https://select2.github.io/select2-bootstrap-theme/css/select2-bootstrap.css">
+</head>
+
+<body>
+  <h1 class="text-center">Demo of vue-select</h1>
+  <div class="container" id="app">
+    <demo :result1.sync='result1'
+          :result2.sync='result2'
+          :result3.sync='result3'>
+    </demo>
+  </div>
+  <script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.0.0/jquery.js"></script>
+  <script type="text/javascript" src="https://cdn.bootcss.com/select2/4.0.0/js/select2.js"></script>
+  <script type="text/javascript" src="https://cdn.bootcss.com/select2/4.0.0/js/i18n/en.js"></script>
+  <script type="text/javascript" src="https://cdn.bootcss.com/select2/4.0.0/js/i18n/zh-CN.js"></script>
+  <script type="text/javascript" src="./demo.all.js"></script>
+</body>
+</html>
Index: public/node_modules/vue/src/platforms/weex/compiler/directives/model.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/directives/model.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/directives/model.js	(revision )
@@ -0,0 +1,34 @@
+/* @flow */
+
+import { addHandler, addAttr } from 'compiler/helpers'
+import { genComponentModel, genAssignmentCode } from 'compiler/directives/model'
+
+export default function model (
+  el: ASTElement,
+  dir: ASTDirective,
+  _warn: Function
+): ?boolean {
+  if (el.tag === 'input' || el.tag === 'textarea') {
+    genDefaultModel(el, dir.value, dir.modifiers)
+  } else {
+    genComponentModel(el, dir.value, dir.modifiers)
+  }
+}
+
+function genDefaultModel (
+  el: ASTElement,
+  value: string,
+  modifiers: ?ASTModifiers
+): ?boolean {
+  const { lazy, trim, number } = modifiers || {}
+  const event = lazy ? 'change' : 'input'
+
+  let valueExpression = `$event.target.attr.value${trim ? '.trim()' : ''}`
+  if (number) {
+    valueExpression = `_n(${valueExpression})`
+  }
+
+  const code = genAssignmentCode(value, valueExpression)
+  addAttr(el, 'value', `(${value})`)
+  addHandler(el, event, code, null, true)
+}
Index: public/node_modules/vue/src/core/util/env.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/env.js	(revision )
+++ public/node_modules/vue/src/core/util/env.js	(revision )
@@ -0,0 +1,151 @@
+/* @flow */
+/* globals MutationObserver */
+
+import { noop } from 'shared/util'
+
+// can we use __proto__?
+export const hasProto = '__proto__' in {}
+
+// Browser environment sniffing
+export const inBrowser = typeof window !== 'undefined'
+export const UA = inBrowser && window.navigator.userAgent.toLowerCase()
+export const isIE = UA && /msie|trident/.test(UA)
+export const isIE9 = UA && UA.indexOf('msie 9.0') > 0
+export const isEdge = UA && UA.indexOf('edge/') > 0
+export const isAndroid = UA && UA.indexOf('android') > 0
+export const isIOS = UA && /iphone|ipad|ipod|ios/.test(UA)
+export const isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge
+
+// this needs to be lazy-evaled because vue may be required before
+// vue-server-renderer can set VUE_ENV
+let _isServer
+export const isServerRendering = () => {
+  if (_isServer === undefined) {
+    /* istanbul ignore if */
+    if (!inBrowser && typeof global !== 'undefined') {
+      // detect presence of vue-server-renderer and avoid
+      // Webpack shimming the process
+      _isServer = global['process'].env.VUE_ENV === 'server'
+    } else {
+      _isServer = false
+    }
+  }
+  return _isServer
+}
+
+// detect devtools
+export const devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__
+
+/* istanbul ignore next */
+export function isNative (Ctor: Function): boolean {
+  return /native code/.test(Ctor.toString())
+}
+
+export const hasSymbol =
+  typeof Symbol !== 'undefined' && isNative(Symbol) &&
+  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys)
+
+/**
+ * Defer a task to execute it asynchronously.
+ */
+export const nextTick = (function () {
+  const callbacks = []
+  let pending = false
+  let timerFunc
+
+  function nextTickHandler () {
+    pending = false
+    const copies = callbacks.slice(0)
+    callbacks.length = 0
+    for (let i = 0; i < copies.length; i++) {
+      copies[i]()
+    }
+  }
+
+  // the nextTick behavior leverages the microtask queue, which can be accessed
+  // via either native Promise.then or MutationObserver.
+  // MutationObserver has wider support, however it is seriously bugged in
+  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
+  // completely stops working after triggering a few times... so, if native
+  // Promise is available, we will use it:
+  /* istanbul ignore if */
+  if (typeof Promise !== 'undefined' && isNative(Promise)) {
+    var p = Promise.resolve()
+    var logError = err => { console.error(err) }
+    timerFunc = () => {
+      p.then(nextTickHandler).catch(logError)
+      // in problematic UIWebViews, Promise.then doesn't completely break, but
+      // it can get stuck in a weird state where callbacks are pushed into the
+      // microtask queue but the queue isn't being flushed, until the browser
+      // needs to do some other work, e.g. handle a timer. Therefore we can
+      // "force" the microtask queue to be flushed by adding an empty timer.
+      if (isIOS) setTimeout(noop)
+    }
+  } else if (typeof MutationObserver !== 'undefined' && (
+    isNative(MutationObserver) ||
+    // PhantomJS and iOS 7.x
+    MutationObserver.toString() === '[object MutationObserverConstructor]'
+  )) {
+    // use MutationObserver where native Promise is not available,
+    // e.g. PhantomJS IE11, iOS7, Android 4.4
+    var counter = 1
+    var observer = new MutationObserver(nextTickHandler)
+    var textNode = document.createTextNode(String(counter))
+    observer.observe(textNode, {
+      characterData: true
+    })
+    timerFunc = () => {
+      counter = (counter + 1) % 2
+      textNode.data = String(counter)
+    }
+  } else {
+    // fallback to setTimeout
+    /* istanbul ignore next */
+    timerFunc = () => {
+      setTimeout(nextTickHandler, 0)
+    }
+  }
+
+  return function queueNextTick (cb?: Function, ctx?: Object) {
+    let _resolve
+    callbacks.push(() => {
+      if (cb) cb.call(ctx)
+      if (_resolve) _resolve(ctx)
+    })
+    if (!pending) {
+      pending = true
+      timerFunc()
+    }
+    if (!cb && typeof Promise !== 'undefined') {
+      return new Promise(resolve => {
+        _resolve = resolve
+      })
+    }
+  }
+})()
+
+let _Set
+/* istanbul ignore if */
+if (typeof Set !== 'undefined' && isNative(Set)) {
+  // use native Set when available.
+  _Set = Set
+} else {
+  // a non-standard Set polyfill that only works with primitive keys.
+  _Set = class Set {
+    set: Object;
+    constructor () {
+      this.set = Object.create(null)
+    }
+    has (key: string | number) {
+      return this.set[key] === true
+    }
+    add (key: string | number) {
+      this.set[key] = true
+    }
+    clear () {
+      this.set = Object.create(null)
+    }
+  }
+}
+
+export { _Set }
Index: public/node_modules/vue/src/server/render-stream.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/render-stream.js	(revision )
+++ public/node_modules/vue/src/server/render-stream.js	(revision )
@@ -0,0 +1,92 @@
+/* @flow */
+
+/**
+ * Original RenderStream implementation by Sasha Aickin (@aickin)
+ * Licensed under the Apache License, Version 2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Modified by Evan You (@yyx990803)
+ */
+
+const stream = require('stream')
+
+import { createWriteFunction } from './write'
+
+export default class RenderStream extends stream.Readable {
+  buffer: string;
+  render: (write: Function, done: Function) => void;
+  expectedSize: number;
+  write: Function;
+  next: Function;
+  end: Function;
+  done: boolean;
+
+  constructor (render: Function) {
+    super()
+    this.buffer = ''
+    this.render = render
+    this.expectedSize = 0
+
+    this.write = createWriteFunction((text, next) => {
+      const n = this.expectedSize
+      this.buffer += text
+      if (this.buffer.length >= n) {
+        this.next = next
+        this.pushBySize(n)
+        return true // we will decide when to call next
+      }
+    }, err => {
+      this.emit('error', err)
+    })
+
+    this.end = () => {
+      // the rendering is finished; we should push out the last of the buffer.
+      this.done = true
+      this.push(this.buffer)
+    }
+  }
+
+  pushBySize (n: number) {
+    const bufferToPush = this.buffer.substring(0, n)
+    this.buffer = this.buffer.substring(n)
+    this.push(bufferToPush)
+  }
+
+  tryRender () {
+    try {
+      this.render(this.write, this.end)
+    } catch (e) {
+      this.emit('error', e)
+    }
+  }
+
+  tryNext () {
+    try {
+      this.next()
+    } catch (e) {
+      this.emit('error', e)
+    }
+  }
+
+  _read (n: number) {
+    this.expectedSize = n
+    // it's possible that the last chunk added bumped the buffer up to > 2 * n,
+    // which means we will need to go through multiple read calls to drain it
+    // down to < n.
+    if (this.done) {
+      this.push(null)
+      return
+    }
+    if (this.buffer.length >= n) {
+      this.pushBySize(n)
+      return
+    }
+    if (!this.next) {
+      // start the rendering chain.
+      this.tryRender()
+    } else {
+      // continue with the rendering.
+      this.tryNext()
+    }
+  }
+}
Index: public/node_modules/vue-select2/test/specs/i18n/zh-CN.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/test/specs/i18n/zh-CN.json	(revision )
+++ public/node_modules/vue-select2/test/specs/i18n/zh-CN.json	(revision )
@@ -0,0 +1,3 @@
+{
+  "hello": ""
+}
\ No newline at end of file
Index: public/node_modules/vue-resource/src/resource.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/resource.js	(revision )
+++ public/node_modules/vue-resource/src/resource.js	(revision )
@@ -0,0 +1,76 @@
+/**
+ * Service for interacting with RESTful services.
+ */
+
+import Http from './http/index';
+import { assign, each, merge } from './util';
+
+export default function Resource(url, params, actions, options) {
+
+    var self = this || {}, resource = {};
+
+    actions = assign({},
+        Resource.actions,
+        actions
+    );
+
+    each(actions, (action, name) => {
+
+        action = merge({url, params: assign({}, params)}, options, action);
+
+        resource[name] = function () {
+            return (self.$http || Http)(opts(action, arguments));
+        };
+    });
+
+    return resource;
+}
+
+function opts(action, args) {
+
+    var options = assign({}, action), params = {}, body;
+
+    switch (args.length) {
+
+        case 2:
+
+            params = args[0];
+            body = args[1];
+
+            break;
+
+        case 1:
+
+            if (/^(POST|PUT|PATCH)$/i.test(options.method)) {
+                body = args[0];
+            } else {
+                params = args[0];
+            }
+
+            break;
+
+        case 0:
+
+            break;
+
+        default:
+
+            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
+    }
+
+    options.body = body;
+    options.params = assign({}, options.params, params);
+
+    return options;
+}
+
+Resource.actions = {
+
+    get: {method: 'GET'},
+    save: {method: 'POST'},
+    query: {method: 'GET'},
+    update: {method: 'PUT'},
+    remove: {method: 'DELETE'},
+    delete: {method: 'DELETE'}
+
+};
Index: public/node_modules/vue/src/core/vdom/helpers/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/helpers/index.js	(revision )
+++ public/node_modules/vue/src/core/vdom/helpers/index.js	(revision )
@@ -0,0 +1,9 @@
+/* @flow */
+
+export * from './merge-hook'
+export * from './update-listeners'
+export * from './normalize-children'
+
+export function getFirstComponentChild (children: ?Array<VNode>): ?VNode {
+  return children && children.filter((c: VNode) => c && c.componentOptions)[0]
+}
Index: public/node_modules/vue-resource/test/webpack.config.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/webpack.config.js	(revision )
+++ public/node_modules/vue-resource/test/webpack.config.js	(revision )
@@ -0,0 +1,12 @@
+module.exports = {
+    entry: __dirname + '/index.js',
+    output: {
+        path: __dirname + '/',
+        filename: 'specs.js'
+    },
+    module: {
+        loaders: [
+            {test: /\.js$/, loader: 'buble-loader', exclude: /node_modules/}
+        ]
+    }
+};
Index: public/node_modules/vue/types/index.d.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/types/index.d.ts	(revision )
+++ public/node_modules/vue/types/index.d.ts	(revision )
@@ -0,0 +1,37 @@
+import * as V from "./vue";
+import * as Options from "./options";
+import * as Plugin from "./plugin";
+import * as VNode from "./vnode";
+
+// `Vue` in `export = Vue` must be a namespace
+// All available types are exported via this namespace
+declare namespace Vue {
+  export type CreateElement = V.CreateElement;
+
+  export type Component = Options.Component;
+  export type AsyncComponent = Options.AsyncComponent;
+  export type ComponentOptions<V extends Vue> = Options.ComponentOptions<V>;
+  export type FunctionalComponentOptions = Options.FunctionalComponentOptions;
+  export type RenderContext = Options.RenderContext;
+  export type PropOptions = Options.PropOptions;
+  export type ComputedOptions<V extends Vue> = Options.ComputedOptions<V>;
+  export type WatchHandler<V extends Vue> = Options.WatchHandler<V, any>;
+  export type WatchOptions = Options.WatchOptions;
+  export type DirectiveFunction = Options.DirectiveFunction;
+  export type DirectiveOptions = Options.DirectiveOptions;
+
+  export type PluginFunction<T> = Plugin.PluginFunction<T>;
+  export type PluginObject<T> = Plugin.PluginObject<T>;
+
+  export type VNodeChildren = VNode.VNodeChildren;
+  export type VNodeChildrenArrayContents = VNode.VNodeChildrenArrayContents;
+  export type VNode = VNode.VNode;
+  export type VNodeComponentOptions = VNode.VNodeComponentOptions;
+  export type VNodeData = VNode.VNodeData;
+  export type VNodeDirective = VNode.VNodeDirective;
+}
+
+// TS cannot merge imported class with namespace, declare a subclass to bypass
+declare class Vue extends V.Vue {}
+
+export = Vue;
Index: public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/package.json	(revision )
@@ -0,0 +1,50 @@
+{
+  "name": "timed-out",
+  "version": "4.0.1",
+  "description": "Emit `ETIMEDOUT` or `ESOCKETTIMEDOUT` when ClientRequest is hanged",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/floatdrop/timed-out"
+  },
+  "author": {
+    "name": "Vsevolod Strukchinsky",
+    "email": "floatdrop@gmail.com"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "xo && mocha"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "http",
+    "https",
+    "get",
+    "got",
+    "url",
+    "uri",
+    "request",
+    "util",
+    "utility",
+    "simple"
+  ],
+  "devDependencies": {
+    "mocha": "*",
+    "xo": "^0.16.0"
+  },
+  "readme": "# timed-out [![Build Status](https://travis-ci.org/floatdrop/timed-out.svg?branch=master)](https://travis-ci.org/floatdrop/timed-out)\n\n> Timeout HTTP/HTTPS requests\n\nEmit Error object with `code` property equal `ETIMEDOUT` or `ESOCKETTIMEDOUT` when ClientRequest is hanged.\n\n## Usage\n\n```js\nvar get = require('http').get;\nvar timeout = require('timed-out');\n\nvar req = get('http://www.google.ru');\ntimeout(req, 2000); // Set 2 seconds limit\n```\n\n### API\n\n#### timedout(request, time)\n\n##### request\n\n*Required*  \nType: [`ClientRequest`](http://nodejs.org/api/http.html#http_class_http_clientrequest)\n\nThe request to watch on.\n\n##### time\n\n*Required*  \nType: `number` or `object`\n\nTime in milliseconds to wait for `connect` event on socket and also time to wait on inactive socket.\n\nOr you can pass Object with following fields:\n\n- `connect` - time to wait for connection\n- `socket`  - time to wait for activity on socket\n\n## License\n\nMIT  [Vsevolod Strukchinsky](floatdrop@gmail.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/floatdrop/timed-out/issues"
+  },
+  "_id": "timed-out@4.0.1",
+  "dist": {
+    "shasum": "d3d2d335a386201774a0527cc1a9b9dfce659c75"
+  },
+  "_from": "timed-out@^4.0.0",
+  "_resolved": "https://registry.npmjs.org/timed-out/-/timed-out-4.0.1.tgz"
+}
Index: public/node_modules/vue/src/core/vdom/helpers/merge-hook.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/helpers/merge-hook.js	(revision )
+++ public/node_modules/vue/src/core/vdom/helpers/merge-hook.js	(revision )
@@ -0,0 +1,34 @@
+/* @flow */
+
+import { remove } from 'shared/util'
+import { createFnInvoker } from './update-listeners'
+
+export function mergeVNodeHook (def: Object, hookKey: string, hook: Function) {
+  let invoker
+  const oldHook = def[hookKey]
+
+  function wrappedHook () {
+    hook.apply(this, arguments)
+    // important: remove merged hook to ensure it's called only once
+    // and prevent memory leak
+    remove(invoker.fns, wrappedHook)
+  }
+
+  if (!oldHook) {
+    // no existing hook
+    invoker = createFnInvoker([wrappedHook])
+  } else {
+    /* istanbul ignore if */
+    if (oldHook.fns && oldHook.merged) {
+      // already a merged invoker
+      invoker = oldHook
+      invoker.fns.push(wrappedHook)
+    } else {
+      // existing plain hook
+      invoker = createFnInvoker([oldHook, wrappedHook])
+    }
+  }
+
+  invoker.merged = true
+  def[hookKey] = invoker
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/index.js	(revision )
@@ -0,0 +1,51 @@
+'use strict';
+const bufferStream = require('./buffer-stream');
+
+function getStream(inputStream, opts) {
+	if (!inputStream) {
+		return Promise.reject(new Error('Expected a stream'));
+	}
+
+	opts = Object.assign({maxBuffer: Infinity}, opts);
+
+	const maxBuffer = opts.maxBuffer;
+	let stream;
+	let clean;
+
+	const p = new Promise((resolve, reject) => {
+		const error = err => {
+			if (err) { // null check
+				err.bufferedData = stream.getBufferedValue();
+			}
+
+			reject(err);
+		};
+
+		stream = bufferStream(opts);
+		inputStream.once('error', error);
+		inputStream.pipe(stream);
+
+		stream.on('data', () => {
+			if (stream.getBufferedLength() > maxBuffer) {
+				reject(new Error('maxBuffer exceeded'));
+			}
+		});
+		stream.once('error', error);
+		stream.on('end', resolve);
+
+		clean = () => {
+			// some streams doesn't implement the `stream.Readable` interface correctly
+			if (inputStream.unpipe) {
+				inputStream.unpipe(stream);
+			}
+		};
+	});
+
+	p.then(clean, clean);
+
+	return p.then(() => stream.getBufferedValue());
+}
+
+module.exports = getStream;
+module.exports.buffer = (stream, opts) => getStream(stream, Object.assign({}, opts, {encoding: 'buffer'}));
+module.exports.array = (stream, opts) => getStream(stream, Object.assign({}, opts, {array: true}));
Index: public/node_modules/vue/src/platforms/web/runtime/modules/style.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/modules/style.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/modules/style.js	(revision )
@@ -0,0 +1,77 @@
+/* @flow */
+
+import { cached, camelize, extend } from 'shared/util'
+import { normalizeStyleBinding, getStyle } from 'web/util/style'
+
+const cssVarRE = /^--/
+const importantRE = /\s*!important$/
+const setProp = (el, name, val) => {
+  /* istanbul ignore if */
+  if (cssVarRE.test(name)) {
+    el.style.setProperty(name, val)
+  } else if (importantRE.test(val)) {
+    el.style.setProperty(name, val.replace(importantRE, ''), 'important')
+  } else {
+    el.style[normalize(name)] = val
+  }
+}
+
+const prefixes = ['Webkit', 'Moz', 'ms']
+
+let testEl
+const normalize = cached(function (prop) {
+  testEl = testEl || document.createElement('div')
+  prop = camelize(prop)
+  if (prop !== 'filter' && (prop in testEl.style)) {
+    return prop
+  }
+  const upper = prop.charAt(0).toUpperCase() + prop.slice(1)
+  for (let i = 0; i < prefixes.length; i++) {
+    const prefixed = prefixes[i] + upper
+    if (prefixed in testEl.style) {
+      return prefixed
+    }
+  }
+})
+
+function updateStyle (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  const data = vnode.data
+  const oldData = oldVnode.data
+
+  if (!data.staticStyle && !data.style &&
+      !oldData.staticStyle && !oldData.style) {
+    return
+  }
+
+  let cur, name
+  const el: any = vnode.elm
+  const oldStaticStyle: any = oldVnode.data.staticStyle
+  const oldStyleBinding: any = oldVnode.data.style || {}
+
+  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
+  const oldStyle = oldStaticStyle || oldStyleBinding
+
+  const style = normalizeStyleBinding(vnode.data.style) || {}
+
+  vnode.data.style = style.__ob__ ? extend({}, style) : style
+
+  const newStyle = getStyle(vnode, true)
+
+  for (name in oldStyle) {
+    if (newStyle[name] == null) {
+      setProp(el, name, '')
+    }
+  }
+  for (name in newStyle) {
+    cur = newStyle[name]
+    if (cur !== oldStyle[name]) {
+      // ie9 setting to null has no effect, must use empty string
+      setProp(el, name, cur == null ? '' : cur)
+    }
+  }
+}
+
+export default {
+  create: updateStyle,
+  update: updateStyle
+}
Index: public/node_modules/vue/src/core/instance/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/index.js	(revision )
+++ public/node_modules/vue/src/core/instance/index.js	(revision )
@@ -0,0 +1,22 @@
+import { initMixin } from './init'
+import { stateMixin } from './state'
+import { renderMixin } from './render'
+import { eventsMixin } from './events'
+import { lifecycleMixin } from './lifecycle'
+import { warn } from '../util/index'
+
+function Vue (options) {
+  if (process.env.NODE_ENV !== 'production' &&
+    !(this instanceof Vue)) {
+    warn('Vue is a constructor and should be called with the `new` keyword')
+  }
+  this._init(options)
+}
+
+initMixin(Vue)
+stateMixin(Vue)
+eventsMixin(Vue)
+lifecycleMixin(Vue)
+renderMixin(Vue)
+
+export default Vue
Index: public/node_modules/vue/src/compiler/codegen/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/codegen/index.js	(revision )
+++ public/node_modules/vue/src/compiler/codegen/index.js	(revision )
@@ -0,0 +1,413 @@
+/* @flow */
+
+import { genHandlers } from './events'
+import { baseWarn, pluckModuleFunction } from '../helpers'
+import baseDirectives from '../directives/index'
+import { camelize, no } from 'shared/util'
+
+type TransformFunction = (el: ASTElement, code: string) => string;
+type DataGenFunction = (el: ASTElement) => string;
+type DirectiveFunction = (el: ASTElement, dir: ASTDirective, warn: Function) => boolean;
+
+// configurable state
+let warn
+let transforms: Array<TransformFunction>
+let dataGenFns: Array<DataGenFunction>
+let platformDirectives
+let isPlatformReservedTag
+let staticRenderFns
+let onceCount
+let currentOptions
+
+export function generate (
+  ast: ASTElement | void,
+  options: CompilerOptions
+): {
+  render: string,
+  staticRenderFns: Array<string>
+} {
+  // save previous staticRenderFns so generate calls can be nested
+  const prevStaticRenderFns: Array<string> = staticRenderFns
+  const currentStaticRenderFns: Array<string> = staticRenderFns = []
+  const prevOnceCount = onceCount
+  onceCount = 0
+  currentOptions = options
+  warn = options.warn || baseWarn
+  transforms = pluckModuleFunction(options.modules, 'transformCode')
+  dataGenFns = pluckModuleFunction(options.modules, 'genData')
+  platformDirectives = options.directives || {}
+  isPlatformReservedTag = options.isReservedTag || no
+  const code = ast ? genElement(ast) : '_c("div")'
+  staticRenderFns = prevStaticRenderFns
+  onceCount = prevOnceCount
+  return {
+    render: `with(this){return ${code}}`,
+    staticRenderFns: currentStaticRenderFns
+  }
+}
+
+function genElement (el: ASTElement): string {
+  if (el.staticRoot && !el.staticProcessed) {
+    return genStatic(el)
+  } else if (el.once && !el.onceProcessed) {
+    return genOnce(el)
+  } else if (el.for && !el.forProcessed) {
+    return genFor(el)
+  } else if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.tag === 'template' && !el.slotTarget) {
+    return genChildren(el) || 'void 0'
+  } else if (el.tag === 'slot') {
+    return genSlot(el)
+  } else {
+    // component or element
+    let code
+    if (el.component) {
+      code = genComponent(el.component, el)
+    } else {
+      const data = el.plain ? undefined : genData(el)
+
+      const children = el.inlineTemplate ? null : genChildren(el, true)
+      code = `_c('${el.tag}'${
+        data ? `,${data}` : '' // data
+      }${
+        children ? `,${children}` : '' // children
+      })`
+    }
+    // module transforms
+    for (let i = 0; i < transforms.length; i++) {
+      code = transforms[i](el, code)
+    }
+    return code
+  }
+}
+
+// hoist static sub-trees out
+function genStatic (el: ASTElement): string {
+  el.staticProcessed = true
+  staticRenderFns.push(`with(this){return ${genElement(el)}}`)
+  return `_m(${staticRenderFns.length - 1}${el.staticInFor ? ',true' : ''})`
+}
+
+// v-once
+function genOnce (el: ASTElement): string {
+  el.onceProcessed = true
+  if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.staticInFor) {
+    let key = ''
+    let parent = el.parent
+    while (parent) {
+      if (parent.for) {
+        key = parent.key
+        break
+      }
+      parent = parent.parent
+    }
+    if (!key) {
+      process.env.NODE_ENV !== 'production' && warn(
+        `v-once can only be used inside v-for that is keyed. `
+      )
+      return genElement(el)
+    }
+    return `_o(${genElement(el)},${onceCount++}${key ? `,${key}` : ``})`
+  } else {
+    return genStatic(el)
+  }
+}
+
+function genIf (el: any): string {
+  el.ifProcessed = true // avoid recursion
+  return genIfConditions(el.ifConditions.slice())
+}
+
+function genIfConditions (conditions: ASTIfConditions): string {
+  if (!conditions.length) {
+    return '_e()'
+  }
+
+  const condition = conditions.shift()
+  if (condition.exp) {
+    return `(${condition.exp})?${genTernaryExp(condition.block)}:${genIfConditions(conditions)}`
+  } else {
+    return `${genTernaryExp(condition.block)}`
+  }
+
+  // v-if with v-once should generate code like (a)?_m(0):_m(1)
+  function genTernaryExp (el) {
+    return el.once ? genOnce(el) : genElement(el)
+  }
+}
+
+function genFor (el: any): string {
+  const exp = el.for
+  const alias = el.alias
+  const iterator1 = el.iterator1 ? `,${el.iterator1}` : ''
+  const iterator2 = el.iterator2 ? `,${el.iterator2}` : ''
+
+  if (
+    process.env.NODE_ENV !== 'production' &&
+    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key
+  ) {
+    warn(
+      `<${el.tag} v-for="${alias} in ${exp}">: component lists rendered with ` +
+      `v-for should have explicit keys. ` +
+      `See https://vuejs.org/guide/list.html#key for more info.`,
+      true /* tip */
+    )
+  }
+
+  el.forProcessed = true // avoid recursion
+  return `_l((${exp}),` +
+    `function(${alias}${iterator1}${iterator2}){` +
+      `return ${genElement(el)}` +
+    '})'
+}
+
+function genData (el: ASTElement): string {
+  let data = '{'
+
+  // directives first.
+  // directives may mutate the el's other properties before they are generated.
+  const dirs = genDirectives(el)
+  if (dirs) data += dirs + ','
+
+  // key
+  if (el.key) {
+    data += `key:${el.key},`
+  }
+  // ref
+  if (el.ref) {
+    data += `ref:${el.ref},`
+  }
+  if (el.refInFor) {
+    data += `refInFor:true,`
+  }
+  // pre
+  if (el.pre) {
+    data += `pre:true,`
+  }
+  // record original tag name for components using "is" attribute
+  if (el.component) {
+    data += `tag:"${el.tag}",`
+  }
+  // module data generation functions
+  for (let i = 0; i < dataGenFns.length; i++) {
+    data += dataGenFns[i](el)
+  }
+  // attributes
+  if (el.attrs) {
+    data += `attrs:{${genProps(el.attrs)}},`
+  }
+  // DOM props
+  if (el.props) {
+    data += `domProps:{${genProps(el.props)}},`
+  }
+  // event handlers
+  if (el.events) {
+    data += `${genHandlers(el.events)},`
+  }
+  if (el.nativeEvents) {
+    data += `${genHandlers(el.nativeEvents, true)},`
+  }
+  // slot target
+  if (el.slotTarget) {
+    data += `slot:${el.slotTarget},`
+  }
+  // scoped slots
+  if (el.scopedSlots) {
+    data += `${genScopedSlots(el.scopedSlots)},`
+  }
+  // component v-model
+  if (el.model) {
+    data += `model:{value:${
+      el.model.value
+    },callback:${
+      el.model.callback
+    },expression:${
+      el.model.expression
+    }},`
+  }
+  // inline-template
+  if (el.inlineTemplate) {
+    const inlineTemplate = genInlineTemplate(el)
+    if (inlineTemplate) {
+      data += `${inlineTemplate},`
+    }
+  }
+  data = data.replace(/,$/, '') + '}'
+  // v-bind data wrap
+  if (el.wrapData) {
+    data = el.wrapData(data)
+  }
+  return data
+}
+
+function genDirectives (el: ASTElement): string | void {
+  const dirs = el.directives
+  if (!dirs) return
+  let res = 'directives:['
+  let hasRuntime = false
+  let i, l, dir, needRuntime
+  for (i = 0, l = dirs.length; i < l; i++) {
+    dir = dirs[i]
+    needRuntime = true
+    const gen: DirectiveFunction = platformDirectives[dir.name] || baseDirectives[dir.name]
+    if (gen) {
+      // compile-time directive that manipulates AST.
+      // returns true if it also needs a runtime counterpart.
+      needRuntime = !!gen(el, dir, warn)
+    }
+    if (needRuntime) {
+      hasRuntime = true
+      res += `{name:"${dir.name}",rawName:"${dir.rawName}"${
+        dir.value ? `,value:(${dir.value}),expression:${JSON.stringify(dir.value)}` : ''
+      }${
+        dir.arg ? `,arg:"${dir.arg}"` : ''
+      }${
+        dir.modifiers ? `,modifiers:${JSON.stringify(dir.modifiers)}` : ''
+      }},`
+    }
+  }
+  if (hasRuntime) {
+    return res.slice(0, -1) + ']'
+  }
+}
+
+function genInlineTemplate (el: ASTElement): ?string {
+  const ast = el.children[0]
+  if (process.env.NODE_ENV !== 'production' && (
+    el.children.length > 1 || ast.type !== 1
+  )) {
+    warn('Inline-template components must have exactly one child element.')
+  }
+  if (ast.type === 1) {
+    const inlineRenderFns = generate(ast, currentOptions)
+    return `inlineTemplate:{render:function(){${
+      inlineRenderFns.render
+    }},staticRenderFns:[${
+      inlineRenderFns.staticRenderFns.map(code => `function(){${code}}`).join(',')
+    }]}`
+  }
+}
+
+function genScopedSlots (slots: { [key: string]: ASTElement }): string {
+  return `scopedSlots:_u([${
+    Object.keys(slots).map(key => genScopedSlot(key, slots[key])).join(',')
+  }])`
+}
+
+function genScopedSlot (key: string, el: ASTElement) {
+  return `[${key},function(${String(el.attrsMap.scope)}){` +
+    `return ${el.tag === 'template'
+      ? genChildren(el) || 'void 0'
+      : genElement(el)
+  }}]`
+}
+
+function genChildren (el: ASTElement, checkSkip?: boolean): string | void {
+  const children = el.children
+  if (children.length) {
+    const el: any = children[0]
+    // optimize single v-for
+    if (children.length === 1 &&
+        el.for &&
+        el.tag !== 'template' &&
+        el.tag !== 'slot') {
+      return genElement(el)
+    }
+    const normalizationType = checkSkip ? getNormalizationType(children) : 0
+    return `[${children.map(genNode).join(',')}]${
+      normalizationType ? `,${normalizationType}` : ''
+    }`
+  }
+}
+
+// determine the normalization needed for the children array.
+// 0: no normalization needed
+// 1: simple normalization needed (possible 1-level deep nested array)
+// 2: full normalization needed
+function getNormalizationType (children: Array<ASTNode>): number {
+  let res = 0
+  for (let i = 0; i < children.length; i++) {
+    const el: ASTNode = children[i]
+    if (el.type !== 1) {
+      continue
+    }
+    if (needsNormalization(el) ||
+        (el.ifConditions && el.ifConditions.some(c => needsNormalization(c.block)))) {
+      res = 2
+      break
+    }
+    if (maybeComponent(el) ||
+        (el.ifConditions && el.ifConditions.some(c => maybeComponent(c.block)))) {
+      res = 1
+    }
+  }
+  return res
+}
+
+function needsNormalization (el: ASTElement): boolean {
+  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
+}
+
+function maybeComponent (el: ASTElement): boolean {
+  return !isPlatformReservedTag(el.tag)
+}
+
+function genNode (node: ASTNode): string {
+  if (node.type === 1) {
+    return genElement(node)
+  } else {
+    return genText(node)
+  }
+}
+
+function genText (text: ASTText | ASTExpression): string {
+  return `_v(${text.type === 2
+    ? text.expression // no need for () because already wrapped in _s()
+    : transformSpecialNewlines(JSON.stringify(text.text))
+  })`
+}
+
+function genSlot (el: ASTElement): string {
+  const slotName = el.slotName || '"default"'
+  const children = genChildren(el)
+  let res = `_t(${slotName}${children ? `,${children}` : ''}`
+  const attrs = el.attrs && `{${el.attrs.map(a => `${camelize(a.name)}:${a.value}`).join(',')}}`
+  const bind = el.attrsMap['v-bind']
+  if ((attrs || bind) && !children) {
+    res += `,null`
+  }
+  if (attrs) {
+    res += `,${attrs}`
+  }
+  if (bind) {
+    res += `${attrs ? '' : ',null'},${bind}`
+  }
+  return res + ')'
+}
+
+// componentName is el.component, take it as argument to shun flow's pessimistic refinement
+function genComponent (componentName: string, el: ASTElement): string {
+  const children = el.inlineTemplate ? null : genChildren(el, true)
+  return `_c(${componentName},${genData(el)}${
+    children ? `,${children}` : ''
+  })`
+}
+
+function genProps (props: Array<{ name: string, value: string }>): string {
+  let res = ''
+  for (let i = 0; i < props.length; i++) {
+    const prop = props[i]
+    res += `"${prop.name}":${transformSpecialNewlines(prop.value)},`
+  }
+  return res.slice(0, -1)
+}
+
+// #3895, #4268
+function transformSpecialNewlines (text: string): string {
+  return text
+    .replace(/\u2028/g, '\\u2028')
+    .replace(/\u2029/g, '\\u2029')
+}
Index: public/node_modules/vue-resource/test/index.html
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/index.html	(revision )
+++ public/node_modules/vue-resource/test/index.html	(revision )
@@ -0,0 +1,18 @@
+<!DOCTYPE html>
+<html>
+<head>
+  <meta charset="utf-8">
+  <title>Vue Resource - Jasmine</title>
+
+  <link rel="shortcut icon" type="image/png" href="../node_modules/jasmine-core/images/jasmine_favicon.png">
+  <link rel="stylesheet" href="../node_modules/jasmine-core/lib/jasmine-core/jasmine.css">
+
+  <script src="../node_modules/jasmine-core/lib/jasmine-core/jasmine.js"></script>
+  <script src="../node_modules/jasmine-core/lib/jasmine-core/jasmine-html.js"></script>
+  <script src="../node_modules/jasmine-core/lib/jasmine-core/boot.js"></script>
+  <script src="specs.js"></script>
+
+</head>
+<body>
+</body>
+</html>
Index: public/node_modules/vue/src/platforms/web/compiler/util.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/util.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/util.js	(revision )
@@ -0,0 +1,24 @@
+/* @flow */
+
+import { makeMap } from 'shared/util'
+
+export const isUnaryTag = makeMap(
+  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
+  'link,meta,param,source,track,wbr'
+)
+
+// Elements that you can, intentionally, leave open
+// (and which close themselves)
+export const canBeLeftOpenTag = makeMap(
+  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
+)
+
+// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
+// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
+export const isNonPhrasingTag = makeMap(
+  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
+  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
+  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
+  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
+  'title,tr,track'
+)
Index: public/node_modules/vue-select2/dist/vue-select.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/dist/vue-select.js	(revision )
+++ public/node_modules/vue-select2/dist/vue-select.js	(revision )
@@ -0,0 +1,1223 @@
+/*!
+ * vue-select2 v0.2.6
+ * (c) 2016 Haixing Hu
+ * Released under the MIT License.
+ */
+/******/ (function(modules) { // webpackBootstrap
+/******/ 	// The module cache
+/******/ 	var installedModules = {};
+/******/
+/******/ 	// The require function
+/******/ 	function __webpack_require__(moduleId) {
+/******/
+/******/ 		// Check if module is in cache
+/******/ 		if(installedModules[moduleId])
+/******/ 			return installedModules[moduleId].exports;
+/******/
+/******/ 		// Create a new module (and put it into the cache)
+/******/ 		var module = installedModules[moduleId] = {
+/******/ 			exports: {},
+/******/ 			id: moduleId,
+/******/ 			loaded: false
+/******/ 		};
+/******/
+/******/ 		// Execute the module function
+/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
+/******/
+/******/ 		// Flag the module as loaded
+/******/ 		module.loaded = true;
+/******/
+/******/ 		// Return the exports of the module
+/******/ 		return module.exports;
+/******/ 	}
+/******/
+/******/
+/******/ 	// expose the modules object (__webpack_modules__)
+/******/ 	__webpack_require__.m = modules;
+/******/
+/******/ 	// expose the module cache
+/******/ 	__webpack_require__.c = installedModules;
+/******/
+/******/ 	// __webpack_public_path__
+/******/ 	__webpack_require__.p = "";
+/******/
+/******/ 	// Load entry module and return exports
+/******/ 	return __webpack_require__(0);
+/******/ })
+/************************************************************************/
+/******/ ([
+/* 0 */
+/***/ function(module, exports, __webpack_require__) {
+
+	/**
+	 * The default language used by this component.
+	 */
+	var DEFAULT_LANGUAGE = "en-US";
+	
+	/**
+	 * A bootstrap style selection (combobox) control using the select2 plugin.
+	 *
+	 * @param options
+	 *    the array of options of the selection control. It could be an array of
+	 *    strings, e.g., "['opt1', 'opt2']"; or an array of objects specifying
+	 *    the text and value of each option, e.g.,
+	 *    "[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]";
+	 *    or it could be an array of objects specifying the option group, e.g.
+	 *    "[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},
+	 *      {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]".
+	 * @param model
+	 *    the model bind to the control, which must be a two way binding variable.
+	 * @param searchable
+	 *    the optional flag indicates whether to show the search box. Default value
+	 *    is false.
+	 * @param matchValue
+	 *    the optional flag indicates whether the searching should match both the
+	 *    texts and values of options. Default value is true.
+	 * @param language
+	 *    the optional code of language used by the select2 plugin. If it is not set,
+	 *    and the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin is used,
+	 *    the component will use the language code `$language` provided by the
+	 *    [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin; otherwise, the
+	 *    component will use the default value "en-US".
+	 * @param theme
+	 *    the optional name of the theme of the select2. Default value is "bootstrap".
+	 * @param name
+	 *    the optional name of the selection control.
+	 * @author Haixing Hu
+	 */
+	module.exports = {
+	  replace: true,
+	  inherit: false,
+	  template: "<select class='form-control' v-model='model' :name='name' style='width: 100%'>"
+	          +   "<option v-if='optionsType === \"values\"' v-for='val in options' :value='val'>{{val}}</option>"
+	          +   "<option v-if='optionsType === \"options\"' v-for='opt in options' :value='opt.value'>{{opt.text}}</option>"
+	          +   "<optgroup v-if='optionsType === \"groups\"' v-for='group in options' :label='group.label'>"
+	          +     "<option v-for='opt in group.options' :value='opt.value'>{{opt.text}}</option>"
+	          +   "</optgroup>"
+	          + "</select>",
+	  props: {
+	    options: {
+	      type: Array,
+	      required: true
+	    },
+	    model: {
+	      required: true,
+	      twoWay: true
+	    },
+	    searchable: {
+	      type: Boolean,
+	      required: false,
+	      default: false
+	    },
+	    matchValue: {
+	      type: Boolean,
+	      required: false,
+	      default: true
+	    },
+	    name: {
+	      type: String,
+	      required: false,
+	      default: ""
+	    },
+	    language: {
+	      type: String,
+	      required: false,
+	      default: ""
+	    },
+	    theme: {
+	      type: String,
+	      required: false,
+	      default: "bootstrap"
+	    }
+	  },
+	  data: function() {
+	    return {
+	      optionsType: "unknown"
+	    }
+	  },
+	  beforeCompile: function() {
+	    this.isChanging = false;
+	    this.control = null;
+	    this.optionsType = this.getOptionsType();
+	  },
+	  watch: {
+	    "options": function(val, oldVal) {
+	      //console.debug("options.change");
+	      this.optionsType = this.getOptionsType();
+	      var found = this.inOptions(this.model);
+	      var newValue = (found ? this.model : null);
+	      this.control.removeData("data");  // remove the cached options data
+	      // note that setting the model will automatically changed in the "change"
+	      // event of the select2 control
+	      this.control.val(newValue).trigger("change");
+	    },
+	    "model": function(val, oldVal) {
+	      //console.debug("model.change");
+	      if (! this.isChanging) {
+	        this.isChanging = true;
+	        this.control.val(val).trigger("change");
+	        this.isChanging = false;
+	      }
+	    }
+	  },
+	  ready: function() {
+	    var language = this.language;
+	    if (language === null || language === "") {
+	      if (this.$language) {
+	        language = this.$language;
+	      } else {
+	        language = DEFAULT_LANGUAGE;
+	      }
+	    }
+	    var args = {
+	      theme: this.theme,
+	      language: this.getLanguageCode(language)
+	    };
+	    if (! this.searchable) {
+	      args.minimumResultsForSearch = Infinity;  // hide the search box
+	    } else {
+	      if (this.matchValue) {
+	        args.matcher = __webpack_require__(1);
+	      }
+	    }
+	    this.control = $(this.$el);
+	    this.control.select2(args);
+	    var me = this;
+	    this.control.on("change", function(e) {
+	      //console.debug("control.change");
+	      if (! me.isChanging) {
+	        me.isChanging = true;
+	        me.model = me.control.val();
+	        me.$nextTick(function () {
+	          me.isChanging = false;
+	        });
+	      }
+	    });
+	  },
+	  methods: {
+	
+	    /**
+	     * Gets the type of the `options` property of this component.
+	     *
+	     * The `options` property of this component may have the following types:
+	     * - "values": the `options` is an array of strings, e.g., `[value1, value2, value3]`;
+	     * - "options": the `options` is an array of options, e.g., `[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]`;
+	     * - "groups": the `options` is an array of option groups, e.g.,
+	     *   `[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},
+	     *     {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]`;
+	     *
+	     * @param options
+	     *    the new options.
+	     * @return
+	     *    the string representing the type of the `options` property of this
+	     *    component.
+	     */
+	    getOptionsType: function() {
+	      if (this.options.length === 0) {
+	        return "values";
+	      }
+	      var el = this.options[0];
+	      if (typeof el == "string" || el instanceof String) {
+	        return "values";
+	      } else if (typeof el.text !== "undefined") {
+	        return "options";
+	      } else if (typeof el.label !== "undefined") {
+	        return "groups";
+	      } else {
+	        return "unknown";
+	      }
+	    },
+	
+	    /**
+	     * Tests whether a specified value exists in the options.
+	     *
+	     * @param value
+	     *    the value to test.
+	     * @return
+	     *    true if the specified value exists in the options; false otherwise.
+	     */
+	    inOptions: function(value) {
+	      var type = this.getOptionsType();
+	      var list = this.options;
+	      var i, j;
+	      switch (type) {
+	      case "values":
+	        for (i = 0; i < list.length; ++i) {
+	          if (value === list[i]) {
+	            return true;
+	          }
+	        }
+	        break;
+	      case "options":
+	        for (i = 0; i < list.length; ++i) {
+	          if (value === list[i].value) {
+	            return true;
+	          }
+	        }
+	        break;
+	      case "groups":
+	        for (i = 0; i < list.length; ++i) {
+	          var options = list[i].options;
+	          for (j = 0; j < options.length; ++j) {
+	            if (value === options[j].value) {
+	              return true;
+	            }
+	          }
+	        }
+	        break;
+	      default:
+	        break;
+	      }
+	      return false;
+	    },
+	
+	    /**
+	     * Gets the language code from the "language-country" locale code.
+	     *
+	     * The function will strip the language code before the first "-" of a
+	     * locale code. For example, pass "en-US" will returns "en". But for some
+	     * special locales, the function reserves the locale code. For example,
+	     * the "zh-CN" for the simplified Chinese and the "zh-TW" for the
+	     * traditional Chinese.
+	     *
+	     * @param locale
+	     *    A locale code.
+	     * @return
+	     *    the language code of the locale.
+	     */
+	    getLanguageCode: function(locale) {
+	      if (locale === null || locale.length === 0) {
+	        return "en";
+	      }
+	      if (locale.length <= 2) {
+	        return locale;
+	      } else {
+	        switch (locale) {
+	          case "pt-BR":
+	          case "zh-CN":
+	          case "zh-TW":
+	            return locale;
+	          default:
+	            // reserve only the first two letters language code
+	            return locale.substr(0, 2);
+	        }
+	      }
+	    }
+	  }
+	};
+
+
+/***/ },
+/* 1 */
+/***/ function(module, exports) {
+
+	
+	var DIACRITICS = {
+	  '\u24B6': 'A',
+	  '\uFF21': 'A',
+	  '\u00C0': 'A',
+	  '\u00C1': 'A',
+	  '\u00C2': 'A',
+	  '\u1EA6': 'A',
+	  '\u1EA4': 'A',
+	  '\u1EAA': 'A',
+	  '\u1EA8': 'A',
+	  '\u00C3': 'A',
+	  '\u0100': 'A',
+	  '\u0102': 'A',
+	  '\u1EB0': 'A',
+	  '\u1EAE': 'A',
+	  '\u1EB4': 'A',
+	  '\u1EB2': 'A',
+	  '\u0226': 'A',
+	  '\u01E0': 'A',
+	  '\u00C4': 'A',
+	  '\u01DE': 'A',
+	  '\u1EA2': 'A',
+	  '\u00C5': 'A',
+	  '\u01FA': 'A',
+	  '\u01CD': 'A',
+	  '\u0200': 'A',
+	  '\u0202': 'A',
+	  '\u1EA0': 'A',
+	  '\u1EAC': 'A',
+	  '\u1EB6': 'A',
+	  '\u1E00': 'A',
+	  '\u0104': 'A',
+	  '\u023A': 'A',
+	  '\u2C6F': 'A',
+	  '\uA732': 'AA',
+	  '\u00C6': 'AE',
+	  '\u01FC': 'AE',
+	  '\u01E2': 'AE',
+	  '\uA734': 'AO',
+	  '\uA736': 'AU',
+	  '\uA738': 'AV',
+	  '\uA73A': 'AV',
+	  '\uA73C': 'AY',
+	  '\u24B7': 'B',
+	  '\uFF22': 'B',
+	  '\u1E02': 'B',
+	  '\u1E04': 'B',
+	  '\u1E06': 'B',
+	  '\u0243': 'B',
+	  '\u0182': 'B',
+	  '\u0181': 'B',
+	  '\u24B8': 'C',
+	  '\uFF23': 'C',
+	  '\u0106': 'C',
+	  '\u0108': 'C',
+	  '\u010A': 'C',
+	  '\u010C': 'C',
+	  '\u00C7': 'C',
+	  '\u1E08': 'C',
+	  '\u0187': 'C',
+	  '\u023B': 'C',
+	  '\uA73E': 'C',
+	  '\u24B9': 'D',
+	  '\uFF24': 'D',
+	  '\u1E0A': 'D',
+	  '\u010E': 'D',
+	  '\u1E0C': 'D',
+	  '\u1E10': 'D',
+	  '\u1E12': 'D',
+	  '\u1E0E': 'D',
+	  '\u0110': 'D',
+	  '\u018B': 'D',
+	  '\u018A': 'D',
+	  '\u0189': 'D',
+	  '\uA779': 'D',
+	  '\u01F1': 'DZ',
+	  '\u01C4': 'DZ',
+	  '\u01F2': 'Dz',
+	  '\u01C5': 'Dz',
+	  '\u24BA': 'E',
+	  '\uFF25': 'E',
+	  '\u00C8': 'E',
+	  '\u00C9': 'E',
+	  '\u00CA': 'E',
+	  '\u1EC0': 'E',
+	  '\u1EBE': 'E',
+	  '\u1EC4': 'E',
+	  '\u1EC2': 'E',
+	  '\u1EBC': 'E',
+	  '\u0112': 'E',
+	  '\u1E14': 'E',
+	  '\u1E16': 'E',
+	  '\u0114': 'E',
+	  '\u0116': 'E',
+	  '\u00CB': 'E',
+	  '\u1EBA': 'E',
+	  '\u011A': 'E',
+	  '\u0204': 'E',
+	  '\u0206': 'E',
+	  '\u1EB8': 'E',
+	  '\u1EC6': 'E',
+	  '\u0228': 'E',
+	  '\u1E1C': 'E',
+	  '\u0118': 'E',
+	  '\u1E18': 'E',
+	  '\u1E1A': 'E',
+	  '\u0190': 'E',
+	  '\u018E': 'E',
+	  '\u24BB': 'F',
+	  '\uFF26': 'F',
+	  '\u1E1E': 'F',
+	  '\u0191': 'F',
+	  '\uA77B': 'F',
+	  '\u24BC': 'G',
+	  '\uFF27': 'G',
+	  '\u01F4': 'G',
+	  '\u011C': 'G',
+	  '\u1E20': 'G',
+	  '\u011E': 'G',
+	  '\u0120': 'G',
+	  '\u01E6': 'G',
+	  '\u0122': 'G',
+	  '\u01E4': 'G',
+	  '\u0193': 'G',
+	  '\uA7A0': 'G',
+	  '\uA77D': 'G',
+	  '\uA77E': 'G',
+	  '\u24BD': 'H',
+	  '\uFF28': 'H',
+	  '\u0124': 'H',
+	  '\u1E22': 'H',
+	  '\u1E26': 'H',
+	  '\u021E': 'H',
+	  '\u1E24': 'H',
+	  '\u1E28': 'H',
+	  '\u1E2A': 'H',
+	  '\u0126': 'H',
+	  '\u2C67': 'H',
+	  '\u2C75': 'H',
+	  '\uA78D': 'H',
+	  '\u24BE': 'I',
+	  '\uFF29': 'I',
+	  '\u00CC': 'I',
+	  '\u00CD': 'I',
+	  '\u00CE': 'I',
+	  '\u0128': 'I',
+	  '\u012A': 'I',
+	  '\u012C': 'I',
+	  '\u0130': 'I',
+	  '\u00CF': 'I',
+	  '\u1E2E': 'I',
+	  '\u1EC8': 'I',
+	  '\u01CF': 'I',
+	  '\u0208': 'I',
+	  '\u020A': 'I',
+	  '\u1ECA': 'I',
+	  '\u012E': 'I',
+	  '\u1E2C': 'I',
+	  '\u0197': 'I',
+	  '\u24BF': 'J',
+	  '\uFF2A': 'J',
+	  '\u0134': 'J',
+	  '\u0248': 'J',
+	  '\u24C0': 'K',
+	  '\uFF2B': 'K',
+	  '\u1E30': 'K',
+	  '\u01E8': 'K',
+	  '\u1E32': 'K',
+	  '\u0136': 'K',
+	  '\u1E34': 'K',
+	  '\u0198': 'K',
+	  '\u2C69': 'K',
+	  '\uA740': 'K',
+	  '\uA742': 'K',
+	  '\uA744': 'K',
+	  '\uA7A2': 'K',
+	  '\u24C1': 'L',
+	  '\uFF2C': 'L',
+	  '\u013F': 'L',
+	  '\u0139': 'L',
+	  '\u013D': 'L',
+	  '\u1E36': 'L',
+	  '\u1E38': 'L',
+	  '\u013B': 'L',
+	  '\u1E3C': 'L',
+	  '\u1E3A': 'L',
+	  '\u0141': 'L',
+	  '\u023D': 'L',
+	  '\u2C62': 'L',
+	  '\u2C60': 'L',
+	  '\uA748': 'L',
+	  '\uA746': 'L',
+	  '\uA780': 'L',
+	  '\u01C7': 'LJ',
+	  '\u01C8': 'Lj',
+	  '\u24C2': 'M',
+	  '\uFF2D': 'M',
+	  '\u1E3E': 'M',
+	  '\u1E40': 'M',
+	  '\u1E42': 'M',
+	  '\u2C6E': 'M',
+	  '\u019C': 'M',
+	  '\u24C3': 'N',
+	  '\uFF2E': 'N',
+	  '\u01F8': 'N',
+	  '\u0143': 'N',
+	  '\u00D1': 'N',
+	  '\u1E44': 'N',
+	  '\u0147': 'N',
+	  '\u1E46': 'N',
+	  '\u0145': 'N',
+	  '\u1E4A': 'N',
+	  '\u1E48': 'N',
+	  '\u0220': 'N',
+	  '\u019D': 'N',
+	  '\uA790': 'N',
+	  '\uA7A4': 'N',
+	  '\u01CA': 'NJ',
+	  '\u01CB': 'Nj',
+	  '\u24C4': 'O',
+	  '\uFF2F': 'O',
+	  '\u00D2': 'O',
+	  '\u00D3': 'O',
+	  '\u00D4': 'O',
+	  '\u1ED2': 'O',
+	  '\u1ED0': 'O',
+	  '\u1ED6': 'O',
+	  '\u1ED4': 'O',
+	  '\u00D5': 'O',
+	  '\u1E4C': 'O',
+	  '\u022C': 'O',
+	  '\u1E4E': 'O',
+	  '\u014C': 'O',
+	  '\u1E50': 'O',
+	  '\u1E52': 'O',
+	  '\u014E': 'O',
+	  '\u022E': 'O',
+	  '\u0230': 'O',
+	  '\u00D6': 'O',
+	  '\u022A': 'O',
+	  '\u1ECE': 'O',
+	  '\u0150': 'O',
+	  '\u01D1': 'O',
+	  '\u020C': 'O',
+	  '\u020E': 'O',
+	  '\u01A0': 'O',
+	  '\u1EDC': 'O',
+	  '\u1EDA': 'O',
+	  '\u1EE0': 'O',
+	  '\u1EDE': 'O',
+	  '\u1EE2': 'O',
+	  '\u1ECC': 'O',
+	  '\u1ED8': 'O',
+	  '\u01EA': 'O',
+	  '\u01EC': 'O',
+	  '\u00D8': 'O',
+	  '\u01FE': 'O',
+	  '\u0186': 'O',
+	  '\u019F': 'O',
+	  '\uA74A': 'O',
+	  '\uA74C': 'O',
+	  '\u01A2': 'OI',
+	  '\uA74E': 'OO',
+	  '\u0222': 'OU',
+	  '\u24C5': 'P',
+	  '\uFF30': 'P',
+	  '\u1E54': 'P',
+	  '\u1E56': 'P',
+	  '\u01A4': 'P',
+	  '\u2C63': 'P',
+	  '\uA750': 'P',
+	  '\uA752': 'P',
+	  '\uA754': 'P',
+	  '\u24C6': 'Q',
+	  '\uFF31': 'Q',
+	  '\uA756': 'Q',
+	  '\uA758': 'Q',
+	  '\u024A': 'Q',
+	  '\u24C7': 'R',
+	  '\uFF32': 'R',
+	  '\u0154': 'R',
+	  '\u1E58': 'R',
+	  '\u0158': 'R',
+	  '\u0210': 'R',
+	  '\u0212': 'R',
+	  '\u1E5A': 'R',
+	  '\u1E5C': 'R',
+	  '\u0156': 'R',
+	  '\u1E5E': 'R',
+	  '\u024C': 'R',
+	  '\u2C64': 'R',
+	  '\uA75A': 'R',
+	  '\uA7A6': 'R',
+	  '\uA782': 'R',
+	  '\u24C8': 'S',
+	  '\uFF33': 'S',
+	  '\u1E9E': 'S',
+	  '\u015A': 'S',
+	  '\u1E64': 'S',
+	  '\u015C': 'S',
+	  '\u1E60': 'S',
+	  '\u0160': 'S',
+	  '\u1E66': 'S',
+	  '\u1E62': 'S',
+	  '\u1E68': 'S',
+	  '\u0218': 'S',
+	  '\u015E': 'S',
+	  '\u2C7E': 'S',
+	  '\uA7A8': 'S',
+	  '\uA784': 'S',
+	  '\u24C9': 'T',
+	  '\uFF34': 'T',
+	  '\u1E6A': 'T',
+	  '\u0164': 'T',
+	  '\u1E6C': 'T',
+	  '\u021A': 'T',
+	  '\u0162': 'T',
+	  '\u1E70': 'T',
+	  '\u1E6E': 'T',
+	  '\u0166': 'T',
+	  '\u01AC': 'T',
+	  '\u01AE': 'T',
+	  '\u023E': 'T',
+	  '\uA786': 'T',
+	  '\uA728': 'TZ',
+	  '\u24CA': 'U',
+	  '\uFF35': 'U',
+	  '\u00D9': 'U',
+	  '\u00DA': 'U',
+	  '\u00DB': 'U',
+	  '\u0168': 'U',
+	  '\u1E78': 'U',
+	  '\u016A': 'U',
+	  '\u1E7A': 'U',
+	  '\u016C': 'U',
+	  '\u00DC': 'U',
+	  '\u01DB': 'U',
+	  '\u01D7': 'U',
+	  '\u01D5': 'U',
+	  '\u01D9': 'U',
+	  '\u1EE6': 'U',
+	  '\u016E': 'U',
+	  '\u0170': 'U',
+	  '\u01D3': 'U',
+	  '\u0214': 'U',
+	  '\u0216': 'U',
+	  '\u01AF': 'U',
+	  '\u1EEA': 'U',
+	  '\u1EE8': 'U',
+	  '\u1EEE': 'U',
+	  '\u1EEC': 'U',
+	  '\u1EF0': 'U',
+	  '\u1EE4': 'U',
+	  '\u1E72': 'U',
+	  '\u0172': 'U',
+	  '\u1E76': 'U',
+	  '\u1E74': 'U',
+	  '\u0244': 'U',
+	  '\u24CB': 'V',
+	  '\uFF36': 'V',
+	  '\u1E7C': 'V',
+	  '\u1E7E': 'V',
+	  '\u01B2': 'V',
+	  '\uA75E': 'V',
+	  '\u0245': 'V',
+	  '\uA760': 'VY',
+	  '\u24CC': 'W',
+	  '\uFF37': 'W',
+	  '\u1E80': 'W',
+	  '\u1E82': 'W',
+	  '\u0174': 'W',
+	  '\u1E86': 'W',
+	  '\u1E84': 'W',
+	  '\u1E88': 'W',
+	  '\u2C72': 'W',
+	  '\u24CD': 'X',
+	  '\uFF38': 'X',
+	  '\u1E8A': 'X',
+	  '\u1E8C': 'X',
+	  '\u24CE': 'Y',
+	  '\uFF39': 'Y',
+	  '\u1EF2': 'Y',
+	  '\u00DD': 'Y',
+	  '\u0176': 'Y',
+	  '\u1EF8': 'Y',
+	  '\u0232': 'Y',
+	  '\u1E8E': 'Y',
+	  '\u0178': 'Y',
+	  '\u1EF6': 'Y',
+	  '\u1EF4': 'Y',
+	  '\u01B3': 'Y',
+	  '\u024E': 'Y',
+	  '\u1EFE': 'Y',
+	  '\u24CF': 'Z',
+	  '\uFF3A': 'Z',
+	  '\u0179': 'Z',
+	  '\u1E90': 'Z',
+	  '\u017B': 'Z',
+	  '\u017D': 'Z',
+	  '\u1E92': 'Z',
+	  '\u1E94': 'Z',
+	  '\u01B5': 'Z',
+	  '\u0224': 'Z',
+	  '\u2C7F': 'Z',
+	  '\u2C6B': 'Z',
+	  '\uA762': 'Z',
+	  '\u24D0': 'a',
+	  '\uFF41': 'a',
+	  '\u1E9A': 'a',
+	  '\u00E0': 'a',
+	  '\u00E1': 'a',
+	  '\u00E2': 'a',
+	  '\u1EA7': 'a',
+	  '\u1EA5': 'a',
+	  '\u1EAB': 'a',
+	  '\u1EA9': 'a',
+	  '\u00E3': 'a',
+	  '\u0101': 'a',
+	  '\u0103': 'a',
+	  '\u1EB1': 'a',
+	  '\u1EAF': 'a',
+	  '\u1EB5': 'a',
+	  '\u1EB3': 'a',
+	  '\u0227': 'a',
+	  '\u01E1': 'a',
+	  '\u00E4': 'a',
+	  '\u01DF': 'a',
+	  '\u1EA3': 'a',
+	  '\u00E5': 'a',
+	  '\u01FB': 'a',
+	  '\u01CE': 'a',
+	  '\u0201': 'a',
+	  '\u0203': 'a',
+	  '\u1EA1': 'a',
+	  '\u1EAD': 'a',
+	  '\u1EB7': 'a',
+	  '\u1E01': 'a',
+	  '\u0105': 'a',
+	  '\u2C65': 'a',
+	  '\u0250': 'a',
+	  '\uA733': 'aa',
+	  '\u00E6': 'ae',
+	  '\u01FD': 'ae',
+	  '\u01E3': 'ae',
+	  '\uA735': 'ao',
+	  '\uA737': 'au',
+	  '\uA739': 'av',
+	  '\uA73B': 'av',
+	  '\uA73D': 'ay',
+	  '\u24D1': 'b',
+	  '\uFF42': 'b',
+	  '\u1E03': 'b',
+	  '\u1E05': 'b',
+	  '\u1E07': 'b',
+	  '\u0180': 'b',
+	  '\u0183': 'b',
+	  '\u0253': 'b',
+	  '\u24D2': 'c',
+	  '\uFF43': 'c',
+	  '\u0107': 'c',
+	  '\u0109': 'c',
+	  '\u010B': 'c',
+	  '\u010D': 'c',
+	  '\u00E7': 'c',
+	  '\u1E09': 'c',
+	  '\u0188': 'c',
+	  '\u023C': 'c',
+	  '\uA73F': 'c',
+	  '\u2184': 'c',
+	  '\u24D3': 'd',
+	  '\uFF44': 'd',
+	  '\u1E0B': 'd',
+	  '\u010F': 'd',
+	  '\u1E0D': 'd',
+	  '\u1E11': 'd',
+	  '\u1E13': 'd',
+	  '\u1E0F': 'd',
+	  '\u0111': 'd',
+	  '\u018C': 'd',
+	  '\u0256': 'd',
+	  '\u0257': 'd',
+	  '\uA77A': 'd',
+	  '\u01F3': 'dz',
+	  '\u01C6': 'dz',
+	  '\u24D4': 'e',
+	  '\uFF45': 'e',
+	  '\u00E8': 'e',
+	  '\u00E9': 'e',
+	  '\u00EA': 'e',
+	  '\u1EC1': 'e',
+	  '\u1EBF': 'e',
+	  '\u1EC5': 'e',
+	  '\u1EC3': 'e',
+	  '\u1EBD': 'e',
+	  '\u0113': 'e',
+	  '\u1E15': 'e',
+	  '\u1E17': 'e',
+	  '\u0115': 'e',
+	  '\u0117': 'e',
+	  '\u00EB': 'e',
+	  '\u1EBB': 'e',
+	  '\u011B': 'e',
+	  '\u0205': 'e',
+	  '\u0207': 'e',
+	  '\u1EB9': 'e',
+	  '\u1EC7': 'e',
+	  '\u0229': 'e',
+	  '\u1E1D': 'e',
+	  '\u0119': 'e',
+	  '\u1E19': 'e',
+	  '\u1E1B': 'e',
+	  '\u0247': 'e',
+	  '\u025B': 'e',
+	  '\u01DD': 'e',
+	  '\u24D5': 'f',
+	  '\uFF46': 'f',
+	  '\u1E1F': 'f',
+	  '\u0192': 'f',
+	  '\uA77C': 'f',
+	  '\u24D6': 'g',
+	  '\uFF47': 'g',
+	  '\u01F5': 'g',
+	  '\u011D': 'g',
+	  '\u1E21': 'g',
+	  '\u011F': 'g',
+	  '\u0121': 'g',
+	  '\u01E7': 'g',
+	  '\u0123': 'g',
+	  '\u01E5': 'g',
+	  '\u0260': 'g',
+	  '\uA7A1': 'g',
+	  '\u1D79': 'g',
+	  '\uA77F': 'g',
+	  '\u24D7': 'h',
+	  '\uFF48': 'h',
+	  '\u0125': 'h',
+	  '\u1E23': 'h',
+	  '\u1E27': 'h',
+	  '\u021F': 'h',
+	  '\u1E25': 'h',
+	  '\u1E29': 'h',
+	  '\u1E2B': 'h',
+	  '\u1E96': 'h',
+	  '\u0127': 'h',
+	  '\u2C68': 'h',
+	  '\u2C76': 'h',
+	  '\u0265': 'h',
+	  '\u0195': 'hv',
+	  '\u24D8': 'i',
+	  '\uFF49': 'i',
+	  '\u00EC': 'i',
+	  '\u00ED': 'i',
+	  '\u00EE': 'i',
+	  '\u0129': 'i',
+	  '\u012B': 'i',
+	  '\u012D': 'i',
+	  '\u00EF': 'i',
+	  '\u1E2F': 'i',
+	  '\u1EC9': 'i',
+	  '\u01D0': 'i',
+	  '\u0209': 'i',
+	  '\u020B': 'i',
+	  '\u1ECB': 'i',
+	  '\u012F': 'i',
+	  '\u1E2D': 'i',
+	  '\u0268': 'i',
+	  '\u0131': 'i',
+	  '\u24D9': 'j',
+	  '\uFF4A': 'j',
+	  '\u0135': 'j',
+	  '\u01F0': 'j',
+	  '\u0249': 'j',
+	  '\u24DA': 'k',
+	  '\uFF4B': 'k',
+	  '\u1E31': 'k',
+	  '\u01E9': 'k',
+	  '\u1E33': 'k',
+	  '\u0137': 'k',
+	  '\u1E35': 'k',
+	  '\u0199': 'k',
+	  '\u2C6A': 'k',
+	  '\uA741': 'k',
+	  '\uA743': 'k',
+	  '\uA745': 'k',
+	  '\uA7A3': 'k',
+	  '\u24DB': 'l',
+	  '\uFF4C': 'l',
+	  '\u0140': 'l',
+	  '\u013A': 'l',
+	  '\u013E': 'l',
+	  '\u1E37': 'l',
+	  '\u1E39': 'l',
+	  '\u013C': 'l',
+	  '\u1E3D': 'l',
+	  '\u1E3B': 'l',
+	  '\u017F': 'l',
+	  '\u0142': 'l',
+	  '\u019A': 'l',
+	  '\u026B': 'l',
+	  '\u2C61': 'l',
+	  '\uA749': 'l',
+	  '\uA781': 'l',
+	  '\uA747': 'l',
+	  '\u01C9': 'lj',
+	  '\u24DC': 'm',
+	  '\uFF4D': 'm',
+	  '\u1E3F': 'm',
+	  '\u1E41': 'm',
+	  '\u1E43': 'm',
+	  '\u0271': 'm',
+	  '\u026F': 'm',
+	  '\u24DD': 'n',
+	  '\uFF4E': 'n',
+	  '\u01F9': 'n',
+	  '\u0144': 'n',
+	  '\u00F1': 'n',
+	  '\u1E45': 'n',
+	  '\u0148': 'n',
+	  '\u1E47': 'n',
+	  '\u0146': 'n',
+	  '\u1E4B': 'n',
+	  '\u1E49': 'n',
+	  '\u019E': 'n',
+	  '\u0272': 'n',
+	  '\u0149': 'n',
+	  '\uA791': 'n',
+	  '\uA7A5': 'n',
+	  '\u01CC': 'nj',
+	  '\u24DE': 'o',
+	  '\uFF4F': 'o',
+	  '\u00F2': 'o',
+	  '\u00F3': 'o',
+	  '\u00F4': 'o',
+	  '\u1ED3': 'o',
+	  '\u1ED1': 'o',
+	  '\u1ED7': 'o',
+	  '\u1ED5': 'o',
+	  '\u00F5': 'o',
+	  '\u1E4D': 'o',
+	  '\u022D': 'o',
+	  '\u1E4F': 'o',
+	  '\u014D': 'o',
+	  '\u1E51': 'o',
+	  '\u1E53': 'o',
+	  '\u014F': 'o',
+	  '\u022F': 'o',
+	  '\u0231': 'o',
+	  '\u00F6': 'o',
+	  '\u022B': 'o',
+	  '\u1ECF': 'o',
+	  '\u0151': 'o',
+	  '\u01D2': 'o',
+	  '\u020D': 'o',
+	  '\u020F': 'o',
+	  '\u01A1': 'o',
+	  '\u1EDD': 'o',
+	  '\u1EDB': 'o',
+	  '\u1EE1': 'o',
+	  '\u1EDF': 'o',
+	  '\u1EE3': 'o',
+	  '\u1ECD': 'o',
+	  '\u1ED9': 'o',
+	  '\u01EB': 'o',
+	  '\u01ED': 'o',
+	  '\u00F8': 'o',
+	  '\u01FF': 'o',
+	  '\u0254': 'o',
+	  '\uA74B': 'o',
+	  '\uA74D': 'o',
+	  '\u0275': 'o',
+	  '\u01A3': 'oi',
+	  '\u0223': 'ou',
+	  '\uA74F': 'oo',
+	  '\u24DF': 'p',
+	  '\uFF50': 'p',
+	  '\u1E55': 'p',
+	  '\u1E57': 'p',
+	  '\u01A5': 'p',
+	  '\u1D7D': 'p',
+	  '\uA751': 'p',
+	  '\uA753': 'p',
+	  '\uA755': 'p',
+	  '\u24E0': 'q',
+	  '\uFF51': 'q',
+	  '\u024B': 'q',
+	  '\uA757': 'q',
+	  '\uA759': 'q',
+	  '\u24E1': 'r',
+	  '\uFF52': 'r',
+	  '\u0155': 'r',
+	  '\u1E59': 'r',
+	  '\u0159': 'r',
+	  '\u0211': 'r',
+	  '\u0213': 'r',
+	  '\u1E5B': 'r',
+	  '\u1E5D': 'r',
+	  '\u0157': 'r',
+	  '\u1E5F': 'r',
+	  '\u024D': 'r',
+	  '\u027D': 'r',
+	  '\uA75B': 'r',
+	  '\uA7A7': 'r',
+	  '\uA783': 'r',
+	  '\u24E2': 's',
+	  '\uFF53': 's',
+	  '\u00DF': 's',
+	  '\u015B': 's',
+	  '\u1E65': 's',
+	  '\u015D': 's',
+	  '\u1E61': 's',
+	  '\u0161': 's',
+	  '\u1E67': 's',
+	  '\u1E63': 's',
+	  '\u1E69': 's',
+	  '\u0219': 's',
+	  '\u015F': 's',
+	  '\u023F': 's',
+	  '\uA7A9': 's',
+	  '\uA785': 's',
+	  '\u1E9B': 's',
+	  '\u24E3': 't',
+	  '\uFF54': 't',
+	  '\u1E6B': 't',
+	  '\u1E97': 't',
+	  '\u0165': 't',
+	  '\u1E6D': 't',
+	  '\u021B': 't',
+	  '\u0163': 't',
+	  '\u1E71': 't',
+	  '\u1E6F': 't',
+	  '\u0167': 't',
+	  '\u01AD': 't',
+	  '\u0288': 't',
+	  '\u2C66': 't',
+	  '\uA787': 't',
+	  '\uA729': 'tz',
+	  '\u24E4': 'u',
+	  '\uFF55': 'u',
+	  '\u00F9': 'u',
+	  '\u00FA': 'u',
+	  '\u00FB': 'u',
+	  '\u0169': 'u',
+	  '\u1E79': 'u',
+	  '\u016B': 'u',
+	  '\u1E7B': 'u',
+	  '\u016D': 'u',
+	  '\u00FC': 'u',
+	  '\u01DC': 'u',
+	  '\u01D8': 'u',
+	  '\u01D6': 'u',
+	  '\u01DA': 'u',
+	  '\u1EE7': 'u',
+	  '\u016F': 'u',
+	  '\u0171': 'u',
+	  '\u01D4': 'u',
+	  '\u0215': 'u',
+	  '\u0217': 'u',
+	  '\u01B0': 'u',
+	  '\u1EEB': 'u',
+	  '\u1EE9': 'u',
+	  '\u1EEF': 'u',
+	  '\u1EED': 'u',
+	  '\u1EF1': 'u',
+	  '\u1EE5': 'u',
+	  '\u1E73': 'u',
+	  '\u0173': 'u',
+	  '\u1E77': 'u',
+	  '\u1E75': 'u',
+	  '\u0289': 'u',
+	  '\u24E5': 'v',
+	  '\uFF56': 'v',
+	  '\u1E7D': 'v',
+	  '\u1E7F': 'v',
+	  '\u028B': 'v',
+	  '\uA75F': 'v',
+	  '\u028C': 'v',
+	  '\uA761': 'vy',
+	  '\u24E6': 'w',
+	  '\uFF57': 'w',
+	  '\u1E81': 'w',
+	  '\u1E83': 'w',
+	  '\u0175': 'w',
+	  '\u1E87': 'w',
+	  '\u1E85': 'w',
+	  '\u1E98': 'w',
+	  '\u1E89': 'w',
+	  '\u2C73': 'w',
+	  '\u24E7': 'x',
+	  '\uFF58': 'x',
+	  '\u1E8B': 'x',
+	  '\u1E8D': 'x',
+	  '\u24E8': 'y',
+	  '\uFF59': 'y',
+	  '\u1EF3': 'y',
+	  '\u00FD': 'y',
+	  '\u0177': 'y',
+	  '\u1EF9': 'y',
+	  '\u0233': 'y',
+	  '\u1E8F': 'y',
+	  '\u00FF': 'y',
+	  '\u1EF7': 'y',
+	  '\u1E99': 'y',
+	  '\u1EF5': 'y',
+	  '\u01B4': 'y',
+	  '\u024F': 'y',
+	  '\u1EFF': 'y',
+	  '\u24E9': 'z',
+	  '\uFF5A': 'z',
+	  '\u017A': 'z',
+	  '\u1E91': 'z',
+	  '\u017C': 'z',
+	  '\u017E': 'z',
+	  '\u1E93': 'z',
+	  '\u1E95': 'z',
+	  '\u01B6': 'z',
+	  '\u0225': 'z',
+	  '\u0240': 'z',
+	  '\u2C6C': 'z',
+	  '\uA763': 'z',
+	  '\u0386': '\u0391',
+	  '\u0388': '\u0395',
+	  '\u0389': '\u0397',
+	  '\u038A': '\u0399',
+	  '\u03AA': '\u0399',
+	  '\u038C': '\u039F',
+	  '\u038E': '\u03A5',
+	  '\u03AB': '\u03A5',
+	  '\u038F': '\u03A9',
+	  '\u03AC': '\u03B1',
+	  '\u03AD': '\u03B5',
+	  '\u03AE': '\u03B7',
+	  '\u03AF': '\u03B9',
+	  '\u03CA': '\u03B9',
+	  '\u0390': '\u03B9',
+	  '\u03CC': '\u03BF',
+	  '\u03CD': '\u03C5',
+	  '\u03CB': '\u03C5',
+	  '\u03B0': '\u03C5',
+	  '\u03C9': '\u03C9',
+	  '\u03C2': '\u03C3'
+	};
+	
+	
+	function stripDiacritics (text) {
+	  // Used 'uni range + named function' from http://jsperf.com/diacritics/18
+	  function match(a) {
+	    return DIACRITICS[a] || a;
+	  }
+	  return text.replace(/[^\u0000-\u007E]/g, match);
+	}
+	
+	// The following matcher is a modification version of the default matcher
+	// of select2
+	module.exports = matcher = function(params, data) {
+	  // Always return the object if there is nothing to compare
+	  if ($.trim(params.term) === '') {
+	    return data;
+	  }
+	
+	  // Do a recursive check for options with children
+	  if (data.children && data.children.length > 0) {
+	    // Clone the data object if there are children
+	    // This is required as we modify the object to remove any non-matches
+	    var match = $.extend(true, {}, data);
+	
+	    // Check each child of the option
+	    for (var c = data.children.length - 1; c >= 0; c--) {
+	      var child = data.children[c];
+	
+	      var matches = matcher(params, child);
+	
+	      // If there wasn't a match, remove the object in the array
+	      if (matches == null) {
+	        match.children.splice(c, 1);
+	      }
+	    }
+	
+	    // If any children matched, return the new object
+	    if (match.children.length > 0) {
+	      return match;
+	    }
+	
+	    // If there were no matching children, check just the plain object
+	    return matcher(params, match);
+	  }
+	
+	  var original = stripDiacritics(data.text).toUpperCase();
+	  var term = stripDiacritics(params.term).toUpperCase();
+	
+	  // Check if the text contains the term
+	  if (original.indexOf(term) > -1) {
+	    return data;
+	  }
+	
+	  // add by Haixing Hu: also match the value of an option
+	  if (data.id) {
+	    var originalValue = stripDiacritics(data.id).toUpperCase();
+	    if (originalValue.indexOf(term) > -1) {
+	      return data;
+	    }
+	  }
+	
+	  // If it doesn't contain the term, don't return anything
+	  return null;
+	}
+
+/***/ }
+/******/ ]);
+//# sourceMappingURL=vue-select.js.map
\ No newline at end of file
Index: public/node_modules/vue/src/server/render-context.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/render-context.js	(revision )
+++ public/node_modules/vue/src/server/render-context.js	(revision )
@@ -0,0 +1,109 @@
+/* @flow */
+
+type RenderState = {
+  type: 'Element';
+  rendered: number;
+  total: number;
+  endTag: string;
+  children: Array<VNode>;
+} | {
+  type: 'Component';
+  prevActive: Component;
+} | {
+  type: 'ComponentWithCache';
+  buffer: Array<string>;
+  bufferIndex: number;
+  key: string;
+};
+
+export class RenderContext {
+  activeInstance: Component;
+  renderStates: Array<RenderState>;
+  write: (text: string, next: Function) => void;
+  renderNode: (node: VNode, isRoot: boolean, context: RenderContext) => void;
+  next: () => void;
+  done: () => void;
+
+  modules: Array<() => ?string>;
+  directives: Object;
+  isUnaryTag: (tag: string) => boolean;
+
+  cache: any;
+  get: ?(key: string, cb: Function) => void;
+  has: ?(key: string, cb: Function) => void;
+
+  constructor (options: Object) {
+    this.activeInstance = options.activeInstance
+    this.renderStates = []
+
+    this.write = options.write
+    this.done = options.done
+    this.renderNode = options.renderNode
+
+    this.isUnaryTag = options.isUnaryTag
+    this.modules = options.modules
+    this.directives = options.directives
+
+    const cache = options.cache
+    if (cache && (!cache.get || !cache.set)) {
+      throw new Error('renderer cache must implement at least get & set.')
+    }
+    this.cache = cache
+    this.get = cache && normalizeAsync(cache, 'get')
+    this.has = cache && normalizeAsync(cache, 'has')
+
+    this.next = this.next.bind(this)
+  }
+
+  next () {
+    const lastState = this.renderStates[this.renderStates.length - 1]
+    if (!lastState) {
+      return this.done()
+    }
+    switch (lastState.type) {
+      case 'Element':
+        const { children, total } = lastState
+        const rendered = lastState.rendered++
+        if (rendered < total) {
+          this.renderNode(children[rendered], false, this)
+        } else {
+          this.renderStates.pop()
+          this.write(lastState.endTag, this.next)
+        }
+        break
+      case 'Component':
+        this.renderStates.pop()
+        this.activeInstance = lastState.prevActive
+        this.next()
+        break
+      case 'ComponentWithCache':
+        this.renderStates.pop()
+        const { buffer, bufferIndex, key } = lastState
+        const result = buffer[bufferIndex]
+        this.cache.set(key, result)
+        if (bufferIndex === 0) {
+          // this is a top-level cached component,
+          // exit caching mode.
+          this.write.caching = false
+        } else {
+          // parent component is also being cached,
+          // merge self into parent's result
+          buffer[bufferIndex - 1] += result
+        }
+        buffer.length = bufferIndex
+        this.next()
+        break
+    }
+  }
+}
+
+function normalizeAsync (cache, method) {
+  const fn = cache[method]
+  if (!fn) {
+    return
+  } else if (fn.length > 1) {
+    return (key, cb) => fn.call(cache, key, cb)
+  } else {
+    return (key, cb) => cb(fn.call(cache, key))
+  }
+}
Index: public/node_modules/vue/src/core/util/error.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/error.js	(revision )
+++ public/node_modules/vue/src/core/util/error.js	(revision )
@@ -0,0 +1,19 @@
+import config from '../config'
+import { warn } from './debug'
+import { inBrowser } from './env'
+
+export function handleError (err, vm, info) {
+  if (config.errorHandler) {
+    config.errorHandler.call(null, err, vm, info)
+  } else {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(`Error in ${info}:`, vm)
+    }
+    /* istanbul ignore else */
+    if (inBrowser && typeof console !== 'undefined') {
+      console.error(err)
+    } else {
+      throw err
+    }
+  }
+}
Index: public/node_modules/vue/src/platforms/web/compiler/directives/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/directives/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/directives/index.js	(revision )
@@ -0,0 +1,9 @@
+import model from './model'
+import text from './text'
+import html from './html'
+
+export default {
+  model,
+  text,
+  html
+}
Index: public/node_modules/vue/src/platforms/weex/compiler/modules/append.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/modules/append.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/modules/append.js	(revision )
@@ -0,0 +1,21 @@
+/* @flow */
+
+function preTransformNode (el: ASTElement, options: CompilerOptions) {
+  if (el.tag === 'cell' && !el.attrsList.some(item => item.name === 'append')) {
+    el.attrsMap.append = 'tree'
+    el.attrsList.push({ name: 'append', value: 'tree' })
+  }
+  if (el.attrsMap.append === 'tree') {
+    el.appendAsTree = true
+  }
+}
+
+function genData (el: ASTElement): string {
+  return el.appendAsTree ? `appendAsTree:true,` : ''
+}
+
+export default {
+  staticKeys: ['appendAsTree'],
+  preTransformNode,
+  genData
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/readme.md	(revision )
@@ -0,0 +1,42 @@
+# timed-out [![Build Status](https://travis-ci.org/floatdrop/timed-out.svg?branch=master)](https://travis-ci.org/floatdrop/timed-out)
+
+> Timeout HTTP/HTTPS requests
+
+Emit Error object with `code` property equal `ETIMEDOUT` or `ESOCKETTIMEDOUT` when ClientRequest is hanged.
+
+## Usage
+
+```js
+var get = require('http').get;
+var timeout = require('timed-out');
+
+var req = get('http://www.google.ru');
+timeout(req, 2000); // Set 2 seconds limit
+```
+
+### API
+
+#### timedout(request, time)
+
+##### request
+
+*Required*  
+Type: [`ClientRequest`](http://nodejs.org/api/http.html#http_class_http_clientrequest)
+
+The request to watch on.
+
+##### time
+
+*Required*  
+Type: `number` or `object`
+
+Time in milliseconds to wait for `connect` event on socket and also time to wait on inactive socket.
+
+Or you can pass Object with following fields:
+
+- `connect` - time to wait for connection
+- `socket`  - time to wait for activity on socket
+
+## License
+
+MIT  [Vsevolod Strukchinsky](floatdrop@gmail.com)
Index: public/node_modules/vue/src/platforms/web/runtime/modules/transition.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/modules/transition.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/modules/transition.js	(revision )
@@ -0,0 +1,329 @@
+/* @flow */
+
+import { once, isObject, toNumber } from 'shared/util'
+import { inBrowser, isIE9, warn } from 'core/util/index'
+import { mergeVNodeHook } from 'core/vdom/helpers/index'
+import { activeInstance } from 'core/instance/lifecycle'
+
+import {
+  nextFrame,
+  resolveTransition,
+  whenTransitionEnds,
+  addTransitionClass,
+  removeTransitionClass
+} from '../transition-util'
+
+export function enter (vnode: VNodeWithData, toggleDisplay: ?() => void) {
+  const el: any = vnode.elm
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true
+    el._leaveCb()
+  }
+
+  const data = resolveTransition(vnode.data.transition)
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb || el.nodeType !== 1) {
+    return
+  }
+
+  const {
+    css,
+    type,
+    enterClass,
+    enterToClass,
+    enterActiveClass,
+    appearClass,
+    appearToClass,
+    appearActiveClass,
+    beforeEnter,
+    enter,
+    afterEnter,
+    enterCancelled,
+    beforeAppear,
+    appear,
+    afterAppear,
+    appearCancelled,
+    duration
+  } = data
+
+  // activeInstance will always be the <transition> component managing this
+  // transition. One edge case to check is when the <transition> is placed
+  // as the root node of a child component. In that case we need to check
+  // <transition>'s parent for appear check.
+  let context = activeInstance
+  let transitionNode = activeInstance.$vnode
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent
+    context = transitionNode.context
+  }
+
+  const isAppear = !context._isMounted || !vnode.isRootInsert
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  const startClass = isAppear && appearClass
+    ? appearClass
+    : enterClass
+  const activeClass = isAppear && appearActiveClass
+    ? appearActiveClass
+    : enterActiveClass
+  const toClass = isAppear && appearToClass
+    ? appearToClass
+    : enterToClass
+
+  const beforeEnterHook = isAppear
+    ? (beforeAppear || beforeEnter)
+    : beforeEnter
+  const enterHook = isAppear
+    ? (typeof appear === 'function' ? appear : enter)
+    : enter
+  const afterEnterHook = isAppear
+    ? (afterAppear || afterEnter)
+    : afterEnter
+  const enterCancelledHook = isAppear
+    ? (appearCancelled || enterCancelled)
+    : enterCancelled
+
+  const explicitEnterDuration: any = toNumber(
+    isObject(duration)
+      ? duration.enter
+      : duration
+  )
+
+  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
+    checkDuration(explicitEnterDuration, 'enter', vnode)
+  }
+
+  const expectsCSS = css !== false && !isIE9
+  const userWantsControl = getHookArgumentsLength(enterHook)
+
+  const cb = el._enterCb = once(() => {
+    if (expectsCSS) {
+      removeTransitionClass(el, toClass)
+      removeTransitionClass(el, activeClass)
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, startClass)
+      }
+      enterCancelledHook && enterCancelledHook(el)
+    } else {
+      afterEnterHook && afterEnterHook(el)
+    }
+    el._enterCb = null
+  })
+
+  if (!vnode.data.show) {
+    // remove pending leave element on enter by injecting an insert hook
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', () => {
+      const parent = el.parentNode
+      const pendingNode = parent && parent._pending && parent._pending[vnode.key]
+      if (pendingNode &&
+          pendingNode.tag === vnode.tag &&
+          pendingNode.elm._leaveCb) {
+        pendingNode.elm._leaveCb()
+      }
+      enterHook && enterHook(el, cb)
+    })
+  }
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el)
+  if (expectsCSS) {
+    addTransitionClass(el, startClass)
+    addTransitionClass(el, activeClass)
+    nextFrame(() => {
+      addTransitionClass(el, toClass)
+      removeTransitionClass(el, startClass)
+      if (!cb.cancelled && !userWantsControl) {
+        if (isValidDuration(explicitEnterDuration)) {
+          setTimeout(cb, explicitEnterDuration)
+        } else {
+          whenTransitionEnds(el, type, cb)
+        }
+      }
+    })
+  }
+
+  if (vnode.data.show) {
+    toggleDisplay && toggleDisplay()
+    enterHook && enterHook(el, cb)
+  }
+
+  if (!expectsCSS && !userWantsControl) {
+    cb()
+  }
+}
+
+export function leave (vnode: VNodeWithData, rm: Function) {
+  const el: any = vnode.elm
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true
+    el._enterCb()
+  }
+
+  const data = resolveTransition(vnode.data.transition)
+  if (!data) {
+    return rm()
+  }
+
+  /* istanbul ignore if */
+  if (el._leaveCb || el.nodeType !== 1) {
+    return
+  }
+
+  const {
+    css,
+    type,
+    leaveClass,
+    leaveToClass,
+    leaveActiveClass,
+    beforeLeave,
+    leave,
+    afterLeave,
+    leaveCancelled,
+    delayLeave,
+    duration
+  } = data
+
+  const expectsCSS = css !== false && !isIE9
+  const userWantsControl = getHookArgumentsLength(leave)
+
+  const explicitLeaveDuration: any = toNumber(
+    isObject(duration)
+      ? duration.leave
+      : duration
+  )
+
+  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
+    checkDuration(explicitLeaveDuration, 'leave', vnode)
+  }
+
+  const cb = el._leaveCb = once(() => {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null
+    }
+    if (expectsCSS) {
+      removeTransitionClass(el, leaveToClass)
+      removeTransitionClass(el, leaveActiveClass)
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, leaveClass)
+      }
+      leaveCancelled && leaveCancelled(el)
+    } else {
+      rm()
+      afterLeave && afterLeave(el)
+    }
+    el._leaveCb = null
+  })
+
+  if (delayLeave) {
+    delayLeave(performLeave)
+  } else {
+    performLeave()
+  }
+
+  function performLeave () {
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode
+    }
+    beforeLeave && beforeLeave(el)
+    if (expectsCSS) {
+      addTransitionClass(el, leaveClass)
+      addTransitionClass(el, leaveActiveClass)
+      nextFrame(() => {
+        addTransitionClass(el, leaveToClass)
+        removeTransitionClass(el, leaveClass)
+        if (!cb.cancelled && !userWantsControl) {
+          if (isValidDuration(explicitLeaveDuration)) {
+            setTimeout(cb, explicitLeaveDuration)
+          } else {
+            whenTransitionEnds(el, type, cb)
+          }
+        }
+      })
+    }
+    leave && leave(el, cb)
+    if (!expectsCSS && !userWantsControl) {
+      cb()
+    }
+  }
+}
+
+// only used in dev mode
+function checkDuration (val, name, vnode) {
+  if (typeof val !== 'number') {
+    warn(
+      `<transition> explicit ${name} duration is not a valid number - ` +
+      `got ${JSON.stringify(val)}.`,
+      vnode.context
+    )
+  } else if (isNaN(val)) {
+    warn(
+      `<transition> explicit ${name} duration is NaN - ` +
+      'the duration expression might be incorrect.',
+      vnode.context
+    )
+  }
+}
+
+function isValidDuration (val) {
+  return typeof val === 'number' && !isNaN(val)
+}
+
+/**
+ * Normalize a transition hook's argument length. The hook may be:
+ * - a merged hook (invoker) with the original in .fns
+ * - a wrapped component method (check ._length)
+ * - a plain function (.length)
+ */
+function getHookArgumentsLength (fn: Function): boolean {
+  if (!fn) return false
+  const invokerFns = fn.fns
+  if (invokerFns) {
+    // invoker
+    return getHookArgumentsLength(
+      Array.isArray(invokerFns)
+        ? invokerFns[0]
+        : invokerFns
+    )
+  } else {
+    return (fn._length || fn.length) > 1
+  }
+}
+
+function _enter (_: any, vnode: VNodeWithData) {
+  if (!vnode.data.show) {
+    enter(vnode)
+  }
+}
+
+export default inBrowser ? {
+  create: _enter,
+  activate: _enter,
+  remove (vnode: VNode, rm: Function) {
+    /* istanbul ignore else */
+    if (!vnode.data.show) {
+      leave(vnode, rm)
+    } else {
+      rm()
+    }
+  }
+} : {}
Index: public/node_modules/vue/dist/vue.common.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.common.js	(revision )
+++ public/node_modules/vue/dist/vue.common.js	(revision )
@@ -0,0 +1,9193 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+'use strict';
+
+/*  */
+
+/**
+ * Convert a value to a string that is actually rendered.
+ */
+function _toString (val) {
+  return val == null
+    ? ''
+    : typeof val === 'object'
+      ? JSON.stringify(val, null, 2)
+      : String(val)
+}
+
+/**
+ * Convert a input value to a number for persistence.
+ * If the conversion fails, return original string.
+ */
+function toNumber (val) {
+  var n = parseFloat(val);
+  return isNaN(n) ? val : n
+}
+
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ */
+function makeMap (
+  str,
+  expectsLowerCase
+) {
+  var map = Object.create(null);
+  var list = str.split(',');
+  for (var i = 0; i < list.length; i++) {
+    map[list[i]] = true;
+  }
+  return expectsLowerCase
+    ? function (val) { return map[val.toLowerCase()]; }
+    : function (val) { return map[val]; }
+}
+
+/**
+ * Check if a tag is a built-in tag.
+ */
+var isBuiltInTag = makeMap('slot,component', true);
+
+/**
+ * Remove an item from an array
+ */
+function remove (arr, item) {
+  if (arr.length) {
+    var index = arr.indexOf(item);
+    if (index > -1) {
+      return arr.splice(index, 1)
+    }
+  }
+}
+
+/**
+ * Check whether the object has the property.
+ */
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+function hasOwn (obj, key) {
+  return hasOwnProperty.call(obj, key)
+}
+
+/**
+ * Check if value is primitive
+ */
+function isPrimitive (value) {
+  return typeof value === 'string' || typeof value === 'number'
+}
+
+/**
+ * Create a cached version of a pure function.
+ */
+function cached (fn) {
+  var cache = Object.create(null);
+  return (function cachedFn (str) {
+    var hit = cache[str];
+    return hit || (cache[str] = fn(str))
+  })
+}
+
+/**
+ * Camelize a hyphen-delimited string.
+ */
+var camelizeRE = /-(\w)/g;
+var camelize = cached(function (str) {
+  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
+});
+
+/**
+ * Capitalize a string.
+ */
+var capitalize = cached(function (str) {
+  return str.charAt(0).toUpperCase() + str.slice(1)
+});
+
+/**
+ * Hyphenate a camelCase string.
+ */
+var hyphenateRE = /([^-])([A-Z])/g;
+var hyphenate = cached(function (str) {
+  return str
+    .replace(hyphenateRE, '$1-$2')
+    .replace(hyphenateRE, '$1-$2')
+    .toLowerCase()
+});
+
+/**
+ * Simple bind, faster than native
+ */
+function bind (fn, ctx) {
+  function boundFn (a) {
+    var l = arguments.length;
+    return l
+      ? l > 1
+        ? fn.apply(ctx, arguments)
+        : fn.call(ctx, a)
+      : fn.call(ctx)
+  }
+  // record original fn length
+  boundFn._length = fn.length;
+  return boundFn
+}
+
+/**
+ * Convert an Array-like object to a real Array.
+ */
+function toArray (list, start) {
+  start = start || 0;
+  var i = list.length - start;
+  var ret = new Array(i);
+  while (i--) {
+    ret[i] = list[i + start];
+  }
+  return ret
+}
+
+/**
+ * Mix properties into target object.
+ */
+function extend (to, _from) {
+  for (var key in _from) {
+    to[key] = _from[key];
+  }
+  return to
+}
+
+/**
+ * Quick object check - this is primarily used to tell
+ * Objects from primitive values when we know the value
+ * is a JSON-compliant type.
+ */
+function isObject (obj) {
+  return obj !== null && typeof obj === 'object'
+}
+
+/**
+ * Strict object type check. Only returns true
+ * for plain JavaScript objects.
+ */
+var toString = Object.prototype.toString;
+var OBJECT_STRING = '[object Object]';
+function isPlainObject (obj) {
+  return toString.call(obj) === OBJECT_STRING
+}
+
+/**
+ * Merge an Array of Objects into a single Object.
+ */
+function toObject (arr) {
+  var res = {};
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i]);
+    }
+  }
+  return res
+}
+
+/**
+ * Perform no operation.
+ */
+function noop () {}
+
+/**
+ * Always return false.
+ */
+var no = function () { return false; };
+
+/**
+ * Return same value
+ */
+var identity = function (_) { return _; };
+
+/**
+ * Generate a static keys string from compiler modules.
+ */
+function genStaticKeys (modules) {
+  return modules.reduce(function (keys, m) {
+    return keys.concat(m.staticKeys || [])
+  }, []).join(',')
+}
+
+/**
+ * Check if two values are loosely equal - that is,
+ * if they are plain objects, do they have the same shape?
+ */
+function looseEqual (a, b) {
+  var isObjectA = isObject(a);
+  var isObjectB = isObject(b);
+  if (isObjectA && isObjectB) {
+    try {
+      return JSON.stringify(a) === JSON.stringify(b)
+    } catch (e) {
+      // possible circular reference
+      return a === b
+    }
+  } else if (!isObjectA && !isObjectB) {
+    return String(a) === String(b)
+  } else {
+    return false
+  }
+}
+
+function looseIndexOf (arr, val) {
+  for (var i = 0; i < arr.length; i++) {
+    if (looseEqual(arr[i], val)) { return i }
+  }
+  return -1
+}
+
+/**
+ * Ensure a function is called only once.
+ */
+function once (fn) {
+  var called = false;
+  return function () {
+    if (!called) {
+      called = true;
+      fn();
+    }
+  }
+}
+
+/*  */
+
+var config = {
+  /**
+   * Option merge strategies (used in core/util/options)
+   */
+  optionMergeStrategies: Object.create(null),
+
+  /**
+   * Whether to suppress warnings.
+   */
+  silent: false,
+
+  /**
+   * Show production mode tip message on boot?
+   */
+  productionTip: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to enable devtools
+   */
+  devtools: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to record perf
+   */
+  performance: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Error handler for watcher errors
+   */
+  errorHandler: null,
+
+  /**
+   * Ignore certain custom elements
+   */
+  ignoredElements: [],
+
+  /**
+   * Custom user key aliases for v-on
+   */
+  keyCodes: Object.create(null),
+
+  /**
+   * Check if a tag is reserved so that it cannot be registered as a
+   * component. This is platform-dependent and may be overwritten.
+   */
+  isReservedTag: no,
+
+  /**
+   * Check if a tag is an unknown element.
+   * Platform-dependent.
+   */
+  isUnknownElement: no,
+
+  /**
+   * Get the namespace of an element
+   */
+  getTagNamespace: noop,
+
+  /**
+   * Parse the real tag name for the specific platform.
+   */
+  parsePlatformTagName: identity,
+
+  /**
+   * Check if an attribute must be bound using property, e.g. value
+   * Platform-dependent.
+   */
+  mustUseProp: no,
+
+  /**
+   * List of asset types that a component can own.
+   */
+  _assetTypes: [
+    'component',
+    'directive',
+    'filter'
+  ],
+
+  /**
+   * List of lifecycle hooks.
+   */
+  _lifecycleHooks: [
+    'beforeCreate',
+    'created',
+    'beforeMount',
+    'mounted',
+    'beforeUpdate',
+    'updated',
+    'beforeDestroy',
+    'destroyed',
+    'activated',
+    'deactivated'
+  ],
+
+  /**
+   * Max circular updates allowed in a scheduler flush cycle.
+   */
+  _maxUpdateCount: 100
+};
+
+/*  */
+/* globals MutationObserver */
+
+// can we use __proto__?
+var hasProto = '__proto__' in {};
+
+// Browser environment sniffing
+var inBrowser = typeof window !== 'undefined';
+var UA = inBrowser && window.navigator.userAgent.toLowerCase();
+var isIE = UA && /msie|trident/.test(UA);
+var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
+var isEdge = UA && UA.indexOf('edge/') > 0;
+var isAndroid = UA && UA.indexOf('android') > 0;
+var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
+var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
+
+// this needs to be lazy-evaled because vue may be required before
+// vue-server-renderer can set VUE_ENV
+var _isServer;
+var isServerRendering = function () {
+  if (_isServer === undefined) {
+    /* istanbul ignore if */
+    if (!inBrowser && typeof global !== 'undefined') {
+      // detect presence of vue-server-renderer and avoid
+      // Webpack shimming the process
+      _isServer = global['process'].env.VUE_ENV === 'server';
+    } else {
+      _isServer = false;
+    }
+  }
+  return _isServer
+};
+
+// detect devtools
+var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
+
+/* istanbul ignore next */
+function isNative (Ctor) {
+  return /native code/.test(Ctor.toString())
+}
+
+var hasSymbol =
+  typeof Symbol !== 'undefined' && isNative(Symbol) &&
+  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
+
+/**
+ * Defer a task to execute it asynchronously.
+ */
+var nextTick = (function () {
+  var callbacks = [];
+  var pending = false;
+  var timerFunc;
+
+  function nextTickHandler () {
+    pending = false;
+    var copies = callbacks.slice(0);
+    callbacks.length = 0;
+    for (var i = 0; i < copies.length; i++) {
+      copies[i]();
+    }
+  }
+
+  // the nextTick behavior leverages the microtask queue, which can be accessed
+  // via either native Promise.then or MutationObserver.
+  // MutationObserver has wider support, however it is seriously bugged in
+  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
+  // completely stops working after triggering a few times... so, if native
+  // Promise is available, we will use it:
+  /* istanbul ignore if */
+  if (typeof Promise !== 'undefined' && isNative(Promise)) {
+    var p = Promise.resolve();
+    var logError = function (err) { console.error(err); };
+    timerFunc = function () {
+      p.then(nextTickHandler).catch(logError);
+      // in problematic UIWebViews, Promise.then doesn't completely break, but
+      // it can get stuck in a weird state where callbacks are pushed into the
+      // microtask queue but the queue isn't being flushed, until the browser
+      // needs to do some other work, e.g. handle a timer. Therefore we can
+      // "force" the microtask queue to be flushed by adding an empty timer.
+      if (isIOS) { setTimeout(noop); }
+    };
+  } else if (typeof MutationObserver !== 'undefined' && (
+    isNative(MutationObserver) ||
+    // PhantomJS and iOS 7.x
+    MutationObserver.toString() === '[object MutationObserverConstructor]'
+  )) {
+    // use MutationObserver where native Promise is not available,
+    // e.g. PhantomJS IE11, iOS7, Android 4.4
+    var counter = 1;
+    var observer = new MutationObserver(nextTickHandler);
+    var textNode = document.createTextNode(String(counter));
+    observer.observe(textNode, {
+      characterData: true
+    });
+    timerFunc = function () {
+      counter = (counter + 1) % 2;
+      textNode.data = String(counter);
+    };
+  } else {
+    // fallback to setTimeout
+    /* istanbul ignore next */
+    timerFunc = function () {
+      setTimeout(nextTickHandler, 0);
+    };
+  }
+
+  return function queueNextTick (cb, ctx) {
+    var _resolve;
+    callbacks.push(function () {
+      if (cb) { cb.call(ctx); }
+      if (_resolve) { _resolve(ctx); }
+    });
+    if (!pending) {
+      pending = true;
+      timerFunc();
+    }
+    if (!cb && typeof Promise !== 'undefined') {
+      return new Promise(function (resolve) {
+        _resolve = resolve;
+      })
+    }
+  }
+})();
+
+var _Set;
+/* istanbul ignore if */
+if (typeof Set !== 'undefined' && isNative(Set)) {
+  // use native Set when available.
+  _Set = Set;
+} else {
+  // a non-standard Set polyfill that only works with primitive keys.
+  _Set = (function () {
+    function Set () {
+      this.set = Object.create(null);
+    }
+    Set.prototype.has = function has (key) {
+      return this.set[key] === true
+    };
+    Set.prototype.add = function add (key) {
+      this.set[key] = true;
+    };
+    Set.prototype.clear = function clear () {
+      this.set = Object.create(null);
+    };
+
+    return Set;
+  }());
+}
+
+var perf;
+
+if (process.env.NODE_ENV !== 'production') {
+  perf = inBrowser && window.performance;
+  if (perf && (!perf.mark || !perf.measure)) {
+    perf = undefined;
+  }
+}
+
+/*  */
+
+var emptyObject = Object.freeze({});
+
+/**
+ * Check if a string starts with $ or _
+ */
+function isReserved (str) {
+  var c = (str + '').charCodeAt(0);
+  return c === 0x24 || c === 0x5F
+}
+
+/**
+ * Define a property.
+ */
+function def (obj, key, val, enumerable) {
+  Object.defineProperty(obj, key, {
+    value: val,
+    enumerable: !!enumerable,
+    writable: true,
+    configurable: true
+  });
+}
+
+/**
+ * Parse simple path.
+ */
+var bailRE = /[^\w.$]/;
+function parsePath (path) {
+  if (bailRE.test(path)) {
+    return
+  }
+  var segments = path.split('.');
+  return function (obj) {
+    for (var i = 0; i < segments.length; i++) {
+      if (!obj) { return }
+      obj = obj[segments[i]];
+    }
+    return obj
+  }
+}
+
+var warn = noop;
+var tip = noop;
+var formatComponentName;
+
+if (process.env.NODE_ENV !== 'production') {
+  var hasConsole = typeof console !== 'undefined';
+  var classifyRE = /(?:^|[-_])(\w)/g;
+  var classify = function (str) { return str
+    .replace(classifyRE, function (c) { return c.toUpperCase(); })
+    .replace(/[-_]/g, ''); };
+
+  warn = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.error("[Vue warn]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  tip = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.warn("[Vue tip]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  formatComponentName = function (vm, includeFile) {
+    if (vm.$root === vm) {
+      return '<Root>'
+    }
+    var name = vm._isVue
+      ? vm.$options.name || vm.$options._componentTag
+      : vm.name;
+
+    var file = vm._isVue && vm.$options.__file;
+    if (!name && file) {
+      var match = file.match(/([^/\\]+)\.vue$/);
+      name = match && match[1];
+    }
+
+    return (
+      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
+      (file && includeFile !== false ? (" at " + file) : '')
+    )
+  };
+
+  var formatLocation = function (str) {
+    if (str === "<Anonymous>") {
+      str += " - use the \"name\" option for better debugging messages.";
+    }
+    return ("\n(found in " + str + ")")
+  };
+}
+
+/*  */
+
+
+var uid$1 = 0;
+
+/**
+ * A dep is an observable that can have multiple
+ * directives subscribing to it.
+ */
+var Dep = function Dep () {
+  this.id = uid$1++;
+  this.subs = [];
+};
+
+Dep.prototype.addSub = function addSub (sub) {
+  this.subs.push(sub);
+};
+
+Dep.prototype.removeSub = function removeSub (sub) {
+  remove(this.subs, sub);
+};
+
+Dep.prototype.depend = function depend () {
+  if (Dep.target) {
+    Dep.target.addDep(this);
+  }
+};
+
+Dep.prototype.notify = function notify () {
+  // stabilize the subscriber list first
+  var subs = this.subs.slice();
+  for (var i = 0, l = subs.length; i < l; i++) {
+    subs[i].update();
+  }
+};
+
+// the current target watcher being evaluated.
+// this is globally unique because there could be only one
+// watcher being evaluated at any time.
+Dep.target = null;
+var targetStack = [];
+
+function pushTarget (_target) {
+  if (Dep.target) { targetStack.push(Dep.target); }
+  Dep.target = _target;
+}
+
+function popTarget () {
+  Dep.target = targetStack.pop();
+}
+
+/*
+ * not type checking this file because flow doesn't play well with
+ * dynamically accessing methods on Array prototype
+ */
+
+var arrayProto = Array.prototype;
+var arrayMethods = Object.create(arrayProto);[
+  'push',
+  'pop',
+  'shift',
+  'unshift',
+  'splice',
+  'sort',
+  'reverse'
+]
+.forEach(function (method) {
+  // cache original method
+  var original = arrayProto[method];
+  def(arrayMethods, method, function mutator () {
+    var arguments$1 = arguments;
+
+    // avoid leaking arguments:
+    // http://jsperf.com/closure-with-arguments
+    var i = arguments.length;
+    var args = new Array(i);
+    while (i--) {
+      args[i] = arguments$1[i];
+    }
+    var result = original.apply(this, args);
+    var ob = this.__ob__;
+    var inserted;
+    switch (method) {
+      case 'push':
+        inserted = args;
+        break
+      case 'unshift':
+        inserted = args;
+        break
+      case 'splice':
+        inserted = args.slice(2);
+        break
+    }
+    if (inserted) { ob.observeArray(inserted); }
+    // notify change
+    ob.dep.notify();
+    return result
+  });
+});
+
+/*  */
+
+var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
+
+/**
+ * By default, when a reactive property is set, the new value is
+ * also converted to become reactive. However when passing down props,
+ * we don't want to force conversion because the value may be a nested value
+ * under a frozen data structure. Converting it would defeat the optimization.
+ */
+var observerState = {
+  shouldConvert: true,
+  isSettingProps: false
+};
+
+/**
+ * Observer class that are attached to each observed
+ * object. Once attached, the observer converts target
+ * object's property keys into getter/setters that
+ * collect dependencies and dispatches updates.
+ */
+var Observer = function Observer (value) {
+  this.value = value;
+  this.dep = new Dep();
+  this.vmCount = 0;
+  def(value, '__ob__', this);
+  if (Array.isArray(value)) {
+    var augment = hasProto
+      ? protoAugment
+      : copyAugment;
+    augment(value, arrayMethods, arrayKeys);
+    this.observeArray(value);
+  } else {
+    this.walk(value);
+  }
+};
+
+/**
+ * Walk through each property and convert them into
+ * getter/setters. This method should only be called when
+ * value type is Object.
+ */
+Observer.prototype.walk = function walk (obj) {
+  var keys = Object.keys(obj);
+  for (var i = 0; i < keys.length; i++) {
+    defineReactive$$1(obj, keys[i], obj[keys[i]]);
+  }
+};
+
+/**
+ * Observe a list of Array items.
+ */
+Observer.prototype.observeArray = function observeArray (items) {
+  for (var i = 0, l = items.length; i < l; i++) {
+    observe(items[i]);
+  }
+};
+
+// helpers
+
+/**
+ * Augment an target Object or Array by intercepting
+ * the prototype chain using __proto__
+ */
+function protoAugment (target, src) {
+  /* eslint-disable no-proto */
+  target.__proto__ = src;
+  /* eslint-enable no-proto */
+}
+
+/**
+ * Augment an target Object or Array by defining
+ * hidden properties.
+ */
+/* istanbul ignore next */
+function copyAugment (target, src, keys) {
+  for (var i = 0, l = keys.length; i < l; i++) {
+    var key = keys[i];
+    def(target, key, src[key]);
+  }
+}
+
+/**
+ * Attempt to create an observer instance for a value,
+ * returns the new observer if successfully observed,
+ * or the existing observer if the value already has one.
+ */
+function observe (value, asRootData) {
+  if (!isObject(value)) {
+    return
+  }
+  var ob;
+  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+    ob = value.__ob__;
+  } else if (
+    observerState.shouldConvert &&
+    !isServerRendering() &&
+    (Array.isArray(value) || isPlainObject(value)) &&
+    Object.isExtensible(value) &&
+    !value._isVue
+  ) {
+    ob = new Observer(value);
+  }
+  if (asRootData && ob) {
+    ob.vmCount++;
+  }
+  return ob
+}
+
+/**
+ * Define a reactive property on an Object.
+ */
+function defineReactive$$1 (
+  obj,
+  key,
+  val,
+  customSetter
+) {
+  var dep = new Dep();
+
+  var property = Object.getOwnPropertyDescriptor(obj, key);
+  if (property && property.configurable === false) {
+    return
+  }
+
+  // cater for pre-defined getter/setters
+  var getter = property && property.get;
+  var setter = property && property.set;
+
+  var childOb = observe(val);
+  Object.defineProperty(obj, key, {
+    enumerable: true,
+    configurable: true,
+    get: function reactiveGetter () {
+      var value = getter ? getter.call(obj) : val;
+      if (Dep.target) {
+        dep.depend();
+        if (childOb) {
+          childOb.dep.depend();
+        }
+        if (Array.isArray(value)) {
+          dependArray(value);
+        }
+      }
+      return value
+    },
+    set: function reactiveSetter (newVal) {
+      var value = getter ? getter.call(obj) : val;
+      /* eslint-disable no-self-compare */
+      if (newVal === value || (newVal !== newVal && value !== value)) {
+        return
+      }
+      /* eslint-enable no-self-compare */
+      if (process.env.NODE_ENV !== 'production' && customSetter) {
+        customSetter();
+      }
+      if (setter) {
+        setter.call(obj, newVal);
+      } else {
+        val = newVal;
+      }
+      childOb = observe(newVal);
+      dep.notify();
+    }
+  });
+}
+
+/**
+ * Set a property on an object. Adds the new property and
+ * triggers change notification if the property doesn't
+ * already exist.
+ */
+function set (target, key, val) {
+  if (Array.isArray(target)) {
+    target.length = Math.max(target.length, key);
+    target.splice(key, 1, val);
+    return val
+  }
+  if (hasOwn(target, key)) {
+    target[key] = val;
+    return val
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid adding reactive properties to a Vue instance or its root $data ' +
+      'at runtime - declare it upfront in the data option.'
+    );
+    return val
+  }
+  if (!ob) {
+    target[key] = val;
+    return val
+  }
+  defineReactive$$1(ob.value, key, val);
+  ob.dep.notify();
+  return val
+}
+
+/**
+ * Delete a property and trigger change if necessary.
+ */
+function del (target, key) {
+  if (Array.isArray(target)) {
+    target.splice(key, 1);
+    return
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid deleting properties on a Vue instance or its root $data ' +
+      '- just set it to null.'
+    );
+    return
+  }
+  if (!hasOwn(target, key)) {
+    return
+  }
+  delete target[key];
+  if (!ob) {
+    return
+  }
+  ob.dep.notify();
+}
+
+/**
+ * Collect dependencies on array elements when the array is touched, since
+ * we cannot intercept array element access like property getters.
+ */
+function dependArray (value) {
+  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
+    e = value[i];
+    e && e.__ob__ && e.__ob__.dep.depend();
+    if (Array.isArray(e)) {
+      dependArray(e);
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Option overwriting strategies are functions that handle
+ * how to merge a parent option value and a child option
+ * value into the final value.
+ */
+var strats = config.optionMergeStrategies;
+
+/**
+ * Options with restrictions
+ */
+if (process.env.NODE_ENV !== 'production') {
+  strats.el = strats.propsData = function (parent, child, vm, key) {
+    if (!vm) {
+      warn(
+        "option \"" + key + "\" can only be used during instance " +
+        'creation with the `new` keyword.'
+      );
+    }
+    return defaultStrat(parent, child)
+  };
+}
+
+/**
+ * Helper that recursively merges two data objects together.
+ */
+function mergeData (to, from) {
+  if (!from) { return to }
+  var key, toVal, fromVal;
+  var keys = Object.keys(from);
+  for (var i = 0; i < keys.length; i++) {
+    key = keys[i];
+    toVal = to[key];
+    fromVal = from[key];
+    if (!hasOwn(to, key)) {
+      set(to, key, fromVal);
+    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
+      mergeData(toVal, fromVal);
+    }
+  }
+  return to
+}
+
+/**
+ * Data
+ */
+strats.data = function (
+  parentVal,
+  childVal,
+  vm
+) {
+  if (!vm) {
+    // in a Vue.extend merge, both should be functions
+    if (!childVal) {
+      return parentVal
+    }
+    if (typeof childVal !== 'function') {
+      process.env.NODE_ENV !== 'production' && warn(
+        'The "data" option should be a function ' +
+        'that returns a per-instance value in component ' +
+        'definitions.',
+        vm
+      );
+      return parentVal
+    }
+    if (!parentVal) {
+      return childVal
+    }
+    // when parentVal & childVal are both present,
+    // we need to return a function that returns the
+    // merged result of both functions... no need to
+    // check if parentVal is a function here because
+    // it has to be a function to pass previous merges.
+    return function mergedDataFn () {
+      return mergeData(
+        childVal.call(this),
+        parentVal.call(this)
+      )
+    }
+  } else if (parentVal || childVal) {
+    return function mergedInstanceDataFn () {
+      // instance merge
+      var instanceData = typeof childVal === 'function'
+        ? childVal.call(vm)
+        : childVal;
+      var defaultData = typeof parentVal === 'function'
+        ? parentVal.call(vm)
+        : undefined;
+      if (instanceData) {
+        return mergeData(instanceData, defaultData)
+      } else {
+        return defaultData
+      }
+    }
+  }
+};
+
+/**
+ * Hooks and props are merged as arrays.
+ */
+function mergeHook (
+  parentVal,
+  childVal
+) {
+  return childVal
+    ? parentVal
+      ? parentVal.concat(childVal)
+      : Array.isArray(childVal)
+        ? childVal
+        : [childVal]
+    : parentVal
+}
+
+config._lifecycleHooks.forEach(function (hook) {
+  strats[hook] = mergeHook;
+});
+
+/**
+ * Assets
+ *
+ * When a vm is present (instance creation), we need to do
+ * a three-way merge between constructor options, instance
+ * options and parent options.
+ */
+function mergeAssets (parentVal, childVal) {
+  var res = Object.create(parentVal || null);
+  return childVal
+    ? extend(res, childVal)
+    : res
+}
+
+config._assetTypes.forEach(function (type) {
+  strats[type + 's'] = mergeAssets;
+});
+
+/**
+ * Watchers.
+ *
+ * Watchers hashes should not overwrite one
+ * another, so we merge them as arrays.
+ */
+strats.watch = function (parentVal, childVal) {
+  /* istanbul ignore if */
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = {};
+  extend(ret, parentVal);
+  for (var key in childVal) {
+    var parent = ret[key];
+    var child = childVal[key];
+    if (parent && !Array.isArray(parent)) {
+      parent = [parent];
+    }
+    ret[key] = parent
+      ? parent.concat(child)
+      : [child];
+  }
+  return ret
+};
+
+/**
+ * Other object hashes.
+ */
+strats.props =
+strats.methods =
+strats.computed = function (parentVal, childVal) {
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = Object.create(null);
+  extend(ret, parentVal);
+  extend(ret, childVal);
+  return ret
+};
+
+/**
+ * Default strategy.
+ */
+var defaultStrat = function (parentVal, childVal) {
+  return childVal === undefined
+    ? parentVal
+    : childVal
+};
+
+/**
+ * Validate component names
+ */
+function checkComponents (options) {
+  for (var key in options.components) {
+    var lower = key.toLowerCase();
+    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
+      warn(
+        'Do not use built-in or reserved HTML elements as component ' +
+        'id: ' + key
+      );
+    }
+  }
+}
+
+/**
+ * Ensure all props option syntax are normalized into the
+ * Object-based format.
+ */
+function normalizeProps (options) {
+  var props = options.props;
+  if (!props) { return }
+  var res = {};
+  var i, val, name;
+  if (Array.isArray(props)) {
+    i = props.length;
+    while (i--) {
+      val = props[i];
+      if (typeof val === 'string') {
+        name = camelize(val);
+        res[name] = { type: null };
+      } else if (process.env.NODE_ENV !== 'production') {
+        warn('props must be strings when using array syntax.');
+      }
+    }
+  } else if (isPlainObject(props)) {
+    for (var key in props) {
+      val = props[key];
+      name = camelize(key);
+      res[name] = isPlainObject(val)
+        ? val
+        : { type: val };
+    }
+  }
+  options.props = res;
+}
+
+/**
+ * Normalize raw function directives into object format.
+ */
+function normalizeDirectives (options) {
+  var dirs = options.directives;
+  if (dirs) {
+    for (var key in dirs) {
+      var def = dirs[key];
+      if (typeof def === 'function') {
+        dirs[key] = { bind: def, update: def };
+      }
+    }
+  }
+}
+
+/**
+ * Merge two option objects into a new one.
+ * Core utility used in both instantiation and inheritance.
+ */
+function mergeOptions (
+  parent,
+  child,
+  vm
+) {
+  if (process.env.NODE_ENV !== 'production') {
+    checkComponents(child);
+  }
+  normalizeProps(child);
+  normalizeDirectives(child);
+  var extendsFrom = child.extends;
+  if (extendsFrom) {
+    parent = typeof extendsFrom === 'function'
+      ? mergeOptions(parent, extendsFrom.options, vm)
+      : mergeOptions(parent, extendsFrom, vm);
+  }
+  if (child.mixins) {
+    for (var i = 0, l = child.mixins.length; i < l; i++) {
+      var mixin = child.mixins[i];
+      if (mixin.prototype instanceof Vue$3) {
+        mixin = mixin.options;
+      }
+      parent = mergeOptions(parent, mixin, vm);
+    }
+  }
+  var options = {};
+  var key;
+  for (key in parent) {
+    mergeField(key);
+  }
+  for (key in child) {
+    if (!hasOwn(parent, key)) {
+      mergeField(key);
+    }
+  }
+  function mergeField (key) {
+    var strat = strats[key] || defaultStrat;
+    options[key] = strat(parent[key], child[key], vm, key);
+  }
+  return options
+}
+
+/**
+ * Resolve an asset.
+ * This function is used because child instances need access
+ * to assets defined in its ancestor chain.
+ */
+function resolveAsset (
+  options,
+  type,
+  id,
+  warnMissing
+) {
+  /* istanbul ignore if */
+  if (typeof id !== 'string') {
+    return
+  }
+  var assets = options[type];
+  // check local registration variations first
+  if (hasOwn(assets, id)) { return assets[id] }
+  var camelizedId = camelize(id);
+  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
+  var PascalCaseId = capitalize(camelizedId);
+  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
+  // fallback to prototype chain
+  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
+  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
+    warn(
+      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
+      options
+    );
+  }
+  return res
+}
+
+/*  */
+
+function validateProp (
+  key,
+  propOptions,
+  propsData,
+  vm
+) {
+  var prop = propOptions[key];
+  var absent = !hasOwn(propsData, key);
+  var value = propsData[key];
+  // handle boolean props
+  if (isType(Boolean, prop.type)) {
+    if (absent && !hasOwn(prop, 'default')) {
+      value = false;
+    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
+      value = true;
+    }
+  }
+  // check default value
+  if (value === undefined) {
+    value = getPropDefaultValue(vm, prop, key);
+    // since the default value is a fresh copy,
+    // make sure to observe it.
+    var prevShouldConvert = observerState.shouldConvert;
+    observerState.shouldConvert = true;
+    observe(value);
+    observerState.shouldConvert = prevShouldConvert;
+  }
+  if (process.env.NODE_ENV !== 'production') {
+    assertProp(prop, key, value, vm, absent);
+  }
+  return value
+}
+
+/**
+ * Get the default value of a prop.
+ */
+function getPropDefaultValue (vm, prop, key) {
+  // no default, return undefined
+  if (!hasOwn(prop, 'default')) {
+    return undefined
+  }
+  var def = prop.default;
+  // warn against non-factory defaults for Object & Array
+  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
+    warn(
+      'Invalid default value for prop "' + key + '": ' +
+      'Props with type Object/Array must use a factory function ' +
+      'to return the default value.',
+      vm
+    );
+  }
+  // the raw prop value was also undefined from previous render,
+  // return previous default value to avoid unnecessary watcher trigger
+  if (vm && vm.$options.propsData &&
+    vm.$options.propsData[key] === undefined &&
+    vm._props[key] !== undefined) {
+    return vm._props[key]
+  }
+  // call factory function for non-Function types
+  // a value is Function if its prototype is function even across different execution context
+  return typeof def === 'function' && getType(prop.type) !== 'Function'
+    ? def.call(vm)
+    : def
+}
+
+/**
+ * Assert whether a prop is valid.
+ */
+function assertProp (
+  prop,
+  name,
+  value,
+  vm,
+  absent
+) {
+  if (prop.required && absent) {
+    warn(
+      'Missing required prop: "' + name + '"',
+      vm
+    );
+    return
+  }
+  if (value == null && !prop.required) {
+    return
+  }
+  var type = prop.type;
+  var valid = !type || type === true;
+  var expectedTypes = [];
+  if (type) {
+    if (!Array.isArray(type)) {
+      type = [type];
+    }
+    for (var i = 0; i < type.length && !valid; i++) {
+      var assertedType = assertType(value, type[i]);
+      expectedTypes.push(assertedType.expectedType || '');
+      valid = assertedType.valid;
+    }
+  }
+  if (!valid) {
+    warn(
+      'Invalid prop: type check failed for prop "' + name + '".' +
+      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
+      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
+      vm
+    );
+    return
+  }
+  var validator = prop.validator;
+  if (validator) {
+    if (!validator(value)) {
+      warn(
+        'Invalid prop: custom validator check failed for prop "' + name + '".',
+        vm
+      );
+    }
+  }
+}
+
+/**
+ * Assert the type of a value
+ */
+function assertType (value, type) {
+  var valid;
+  var expectedType = getType(type);
+  if (expectedType === 'String') {
+    valid = typeof value === (expectedType = 'string');
+  } else if (expectedType === 'Number') {
+    valid = typeof value === (expectedType = 'number');
+  } else if (expectedType === 'Boolean') {
+    valid = typeof value === (expectedType = 'boolean');
+  } else if (expectedType === 'Function') {
+    valid = typeof value === (expectedType = 'function');
+  } else if (expectedType === 'Object') {
+    valid = isPlainObject(value);
+  } else if (expectedType === 'Array') {
+    valid = Array.isArray(value);
+  } else {
+    valid = value instanceof type;
+  }
+  return {
+    valid: valid,
+    expectedType: expectedType
+  }
+}
+
+/**
+ * Use function string name to check built-in types,
+ * because a simple equality check will fail when running
+ * across different vms / iframes.
+ */
+function getType (fn) {
+  var match = fn && fn.toString().match(/^\s*function (\w+)/);
+  return match && match[1]
+}
+
+function isType (type, fn) {
+  if (!Array.isArray(fn)) {
+    return getType(fn) === getType(type)
+  }
+  for (var i = 0, len = fn.length; i < len; i++) {
+    if (getType(fn[i]) === getType(type)) {
+      return true
+    }
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function handleError (err, vm, info) {
+  if (config.errorHandler) {
+    config.errorHandler.call(null, err, vm, info);
+  } else {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Error in " + info + ":"), vm);
+    }
+    /* istanbul ignore else */
+    if (inBrowser && typeof console !== 'undefined') {
+      console.error(err);
+    } else {
+      throw err
+    }
+  }
+}
+
+/* not type checking this file because flow doesn't play well with Proxy */
+
+var initProxy;
+
+if (process.env.NODE_ENV !== 'production') {
+  var allowedGlobals = makeMap(
+    'Infinity,undefined,NaN,isFinite,isNaN,' +
+    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
+    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
+    'require' // for Webpack/Browserify
+  );
+
+  var warnNonPresent = function (target, key) {
+    warn(
+      "Property or method \"" + key + "\" is not defined on the instance but " +
+      "referenced during render. Make sure to declare reactive data " +
+      "properties in the data option.",
+      target
+    );
+  };
+
+  var hasProxy =
+    typeof Proxy !== 'undefined' &&
+    Proxy.toString().match(/native code/);
+
+  if (hasProxy) {
+    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
+    config.keyCodes = new Proxy(config.keyCodes, {
+      set: function set (target, key, value) {
+        if (isBuiltInModifier(key)) {
+          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
+          return false
+        } else {
+          target[key] = value;
+          return true
+        }
+      }
+    });
+  }
+
+  var hasHandler = {
+    has: function has (target, key) {
+      var has = key in target;
+      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
+      if (!has && !isAllowed) {
+        warnNonPresent(target, key);
+      }
+      return has || !isAllowed
+    }
+  };
+
+  var getHandler = {
+    get: function get (target, key) {
+      if (typeof key === 'string' && !(key in target)) {
+        warnNonPresent(target, key);
+      }
+      return target[key]
+    }
+  };
+
+  initProxy = function initProxy (vm) {
+    if (hasProxy) {
+      // determine which proxy handler to use
+      var options = vm.$options;
+      var handlers = options.render && options.render._withStripped
+        ? getHandler
+        : hasHandler;
+      vm._renderProxy = new Proxy(vm, handlers);
+    } else {
+      vm._renderProxy = vm;
+    }
+  };
+}
+
+/*  */
+
+var VNode = function VNode (
+  tag,
+  data,
+  children,
+  text,
+  elm,
+  context,
+  componentOptions
+) {
+  this.tag = tag;
+  this.data = data;
+  this.children = children;
+  this.text = text;
+  this.elm = elm;
+  this.ns = undefined;
+  this.context = context;
+  this.functionalContext = undefined;
+  this.key = data && data.key;
+  this.componentOptions = componentOptions;
+  this.componentInstance = undefined;
+  this.parent = undefined;
+  this.raw = false;
+  this.isStatic = false;
+  this.isRootInsert = true;
+  this.isComment = false;
+  this.isCloned = false;
+  this.isOnce = false;
+};
+
+var prototypeAccessors = { child: {} };
+
+// DEPRECATED: alias for componentInstance for backwards compat.
+/* istanbul ignore next */
+prototypeAccessors.child.get = function () {
+  return this.componentInstance
+};
+
+Object.defineProperties( VNode.prototype, prototypeAccessors );
+
+var createEmptyVNode = function () {
+  var node = new VNode();
+  node.text = '';
+  node.isComment = true;
+  return node
+};
+
+function createTextVNode (val) {
+  return new VNode(undefined, undefined, undefined, String(val))
+}
+
+// optimized shallow clone
+// used for static nodes and slot nodes because they may be reused across
+// multiple renders, cloning them avoids errors when DOM manipulations rely
+// on their elm reference.
+function cloneVNode (vnode) {
+  var cloned = new VNode(
+    vnode.tag,
+    vnode.data,
+    vnode.children,
+    vnode.text,
+    vnode.elm,
+    vnode.context,
+    vnode.componentOptions
+  );
+  cloned.ns = vnode.ns;
+  cloned.isStatic = vnode.isStatic;
+  cloned.key = vnode.key;
+  cloned.isCloned = true;
+  return cloned
+}
+
+function cloneVNodes (vnodes) {
+  var len = vnodes.length;
+  var res = new Array(len);
+  for (var i = 0; i < len; i++) {
+    res[i] = cloneVNode(vnodes[i]);
+  }
+  return res
+}
+
+/*  */
+
+var normalizeEvent = cached(function (name) {
+  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
+  name = once$$1 ? name.slice(1) : name;
+  var capture = name.charAt(0) === '!';
+  name = capture ? name.slice(1) : name;
+  return {
+    name: name,
+    once: once$$1,
+    capture: capture
+  }
+});
+
+function createFnInvoker (fns) {
+  function invoker () {
+    var arguments$1 = arguments;
+
+    var fns = invoker.fns;
+    if (Array.isArray(fns)) {
+      for (var i = 0; i < fns.length; i++) {
+        fns[i].apply(null, arguments$1);
+      }
+    } else {
+      // return handler return value for single handlers
+      return fns.apply(null, arguments)
+    }
+  }
+  invoker.fns = fns;
+  return invoker
+}
+
+function updateListeners (
+  on,
+  oldOn,
+  add,
+  remove$$1,
+  vm
+) {
+  var name, cur, old, event;
+  for (name in on) {
+    cur = on[name];
+    old = oldOn[name];
+    event = normalizeEvent(name);
+    if (!cur) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
+        vm
+      );
+    } else if (!old) {
+      if (!cur.fns) {
+        cur = on[name] = createFnInvoker(cur);
+      }
+      add(event.name, cur, event.once, event.capture);
+    } else if (cur !== old) {
+      old.fns = cur;
+      on[name] = old;
+    }
+  }
+  for (name in oldOn) {
+    if (!on[name]) {
+      event = normalizeEvent(name);
+      remove$$1(event.name, oldOn[name], event.capture);
+    }
+  }
+}
+
+/*  */
+
+function mergeVNodeHook (def, hookKey, hook) {
+  var invoker;
+  var oldHook = def[hookKey];
+
+  function wrappedHook () {
+    hook.apply(this, arguments);
+    // important: remove merged hook to ensure it's called only once
+    // and prevent memory leak
+    remove(invoker.fns, wrappedHook);
+  }
+
+  if (!oldHook) {
+    // no existing hook
+    invoker = createFnInvoker([wrappedHook]);
+  } else {
+    /* istanbul ignore if */
+    if (oldHook.fns && oldHook.merged) {
+      // already a merged invoker
+      invoker = oldHook;
+      invoker.fns.push(wrappedHook);
+    } else {
+      // existing plain hook
+      invoker = createFnInvoker([oldHook, wrappedHook]);
+    }
+  }
+
+  invoker.merged = true;
+  def[hookKey] = invoker;
+}
+
+/*  */
+
+// The template compiler attempts to minimize the need for normalization by
+// statically analyzing the template at compile time.
+//
+// For plain HTML markup, normalization can be completely skipped because the
+// generated render function is guaranteed to return Array<VNode>. There are
+// two cases where extra normalization is needed:
+
+// 1. When the children contains components - because a functional component
+// may return an Array instead of a single root. In this case, just a simple
+// normalization is needed - if any child is an Array, we flatten the whole
+// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
+// because functional components already normalize their own children.
+function simpleNormalizeChildren (children) {
+  for (var i = 0; i < children.length; i++) {
+    if (Array.isArray(children[i])) {
+      return Array.prototype.concat.apply([], children)
+    }
+  }
+  return children
+}
+
+// 2. When the children contains constructs that always generated nested Arrays,
+// e.g. <template>, <slot>, v-for, or when the children is provided by user
+// with hand-written render functions / JSX. In such cases a full normalization
+// is needed to cater to all possible types of children values.
+function normalizeChildren (children) {
+  return isPrimitive(children)
+    ? [createTextVNode(children)]
+    : Array.isArray(children)
+      ? normalizeArrayChildren(children)
+      : undefined
+}
+
+function normalizeArrayChildren (children, nestedIndex) {
+  var res = [];
+  var i, c, last;
+  for (i = 0; i < children.length; i++) {
+    c = children[i];
+    if (c == null || typeof c === 'boolean') { continue }
+    last = res[res.length - 1];
+    //  nested
+    if (Array.isArray(c)) {
+      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
+    } else if (isPrimitive(c)) {
+      if (last && last.text) {
+        last.text += String(c);
+      } else if (c !== '') {
+        // convert primitive to vnode
+        res.push(createTextVNode(c));
+      }
+    } else {
+      if (c.text && last && last.text) {
+        res[res.length - 1] = createTextVNode(last.text + c.text);
+      } else {
+        // default key for nested array children (likely generated by v-for)
+        if (c.tag && c.key == null && nestedIndex != null) {
+          c.key = "__vlist" + nestedIndex + "_" + i + "__";
+        }
+        res.push(c);
+      }
+    }
+  }
+  return res
+}
+
+/*  */
+
+function getFirstComponentChild (children) {
+  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
+}
+
+/*  */
+
+function initEvents (vm) {
+  vm._events = Object.create(null);
+  vm._hasHookEvent = false;
+  // init parent attached events
+  var listeners = vm.$options._parentListeners;
+  if (listeners) {
+    updateComponentListeners(vm, listeners);
+  }
+}
+
+var target;
+
+function add (event, fn, once$$1) {
+  if (once$$1) {
+    target.$once(event, fn);
+  } else {
+    target.$on(event, fn);
+  }
+}
+
+function remove$1 (event, fn) {
+  target.$off(event, fn);
+}
+
+function updateComponentListeners (
+  vm,
+  listeners,
+  oldListeners
+) {
+  target = vm;
+  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
+}
+
+function eventsMixin (Vue) {
+  var hookRE = /^hook:/;
+  Vue.prototype.$on = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    if (Array.isArray(event)) {
+      for (var i = 0, l = event.length; i < l; i++) {
+        this$1.$on(event[i], fn);
+      }
+    } else {
+      (vm._events[event] || (vm._events[event] = [])).push(fn);
+      // optimize hook:event cost by using a boolean flag marked at registration
+      // instead of a hash lookup
+      if (hookRE.test(event)) {
+        vm._hasHookEvent = true;
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$once = function (event, fn) {
+    var vm = this;
+    function on () {
+      vm.$off(event, on);
+      fn.apply(vm, arguments);
+    }
+    on.fn = fn;
+    vm.$on(event, on);
+    return vm
+  };
+
+  Vue.prototype.$off = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    // all
+    if (!arguments.length) {
+      vm._events = Object.create(null);
+      return vm
+    }
+    // array of events
+    if (Array.isArray(event)) {
+      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
+        this$1.$off(event[i$1], fn);
+      }
+      return vm
+    }
+    // specific event
+    var cbs = vm._events[event];
+    if (!cbs) {
+      return vm
+    }
+    if (arguments.length === 1) {
+      vm._events[event] = null;
+      return vm
+    }
+    // specific handler
+    var cb;
+    var i = cbs.length;
+    while (i--) {
+      cb = cbs[i];
+      if (cb === fn || cb.fn === fn) {
+        cbs.splice(i, 1);
+        break
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$emit = function (event) {
+    var vm = this;
+    var cbs = vm._events[event];
+    if (cbs) {
+      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
+      var args = toArray(arguments, 1);
+      for (var i = 0, l = cbs.length; i < l; i++) {
+        cbs[i].apply(vm, args);
+      }
+    }
+    return vm
+  };
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving raw children VNodes into a slot object.
+ */
+function resolveSlots (
+  children,
+  context
+) {
+  var slots = {};
+  if (!children) {
+    return slots
+  }
+  var defaultSlot = [];
+  var name, child;
+  for (var i = 0, l = children.length; i < l; i++) {
+    child = children[i];
+    // named slots should only be respected if the vnode was rendered in the
+    // same context.
+    if ((child.context === context || child.functionalContext === context) &&
+        child.data && (name = child.data.slot)) {
+      var slot = (slots[name] || (slots[name] = []));
+      if (child.tag === 'template') {
+        slot.push.apply(slot, child.children);
+      } else {
+        slot.push(child);
+      }
+    } else {
+      defaultSlot.push(child);
+    }
+  }
+  // ignore whitespace
+  if (!defaultSlot.every(isWhitespace)) {
+    slots.default = defaultSlot;
+  }
+  return slots
+}
+
+function isWhitespace (node) {
+  return node.isComment || node.text === ' '
+}
+
+function resolveScopedSlots (
+  fns
+) {
+  var res = {};
+  for (var i = 0; i < fns.length; i++) {
+    res[fns[i][0]] = fns[i][1];
+  }
+  return res
+}
+
+/*  */
+
+var activeInstance = null;
+
+function initLifecycle (vm) {
+  var options = vm.$options;
+
+  // locate first non-abstract parent
+  var parent = options.parent;
+  if (parent && !options.abstract) {
+    while (parent.$options.abstract && parent.$parent) {
+      parent = parent.$parent;
+    }
+    parent.$children.push(vm);
+  }
+
+  vm.$parent = parent;
+  vm.$root = parent ? parent.$root : vm;
+
+  vm.$children = [];
+  vm.$refs = {};
+
+  vm._watcher = null;
+  vm._inactive = null;
+  vm._directInactive = false;
+  vm._isMounted = false;
+  vm._isDestroyed = false;
+  vm._isBeingDestroyed = false;
+}
+
+function lifecycleMixin (Vue) {
+  Vue.prototype._update = function (vnode, hydrating) {
+    var vm = this;
+    if (vm._isMounted) {
+      callHook(vm, 'beforeUpdate');
+    }
+    var prevEl = vm.$el;
+    var prevVnode = vm._vnode;
+    var prevActiveInstance = activeInstance;
+    activeInstance = vm;
+    vm._vnode = vnode;
+    // Vue.prototype.__patch__ is injected in entry points
+    // based on the rendering backend used.
+    if (!prevVnode) {
+      // initial render
+      vm.$el = vm.__patch__(
+        vm.$el, vnode, hydrating, false /* removeOnly */,
+        vm.$options._parentElm,
+        vm.$options._refElm
+      );
+    } else {
+      // updates
+      vm.$el = vm.__patch__(prevVnode, vnode);
+    }
+    activeInstance = prevActiveInstance;
+    // update __vue__ reference
+    if (prevEl) {
+      prevEl.__vue__ = null;
+    }
+    if (vm.$el) {
+      vm.$el.__vue__ = vm;
+    }
+    // if parent is an HOC, update its $el as well
+    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
+      vm.$parent.$el = vm.$el;
+    }
+    // updated hook is called by the scheduler to ensure that children are
+    // updated in a parent's updated hook.
+  };
+
+  Vue.prototype.$forceUpdate = function () {
+    var vm = this;
+    if (vm._watcher) {
+      vm._watcher.update();
+    }
+  };
+
+  Vue.prototype.$destroy = function () {
+    var vm = this;
+    if (vm._isBeingDestroyed) {
+      return
+    }
+    callHook(vm, 'beforeDestroy');
+    vm._isBeingDestroyed = true;
+    // remove self from parent
+    var parent = vm.$parent;
+    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
+      remove(parent.$children, vm);
+    }
+    // teardown watchers
+    if (vm._watcher) {
+      vm._watcher.teardown();
+    }
+    var i = vm._watchers.length;
+    while (i--) {
+      vm._watchers[i].teardown();
+    }
+    // remove reference from data ob
+    // frozen object may not have observer.
+    if (vm._data.__ob__) {
+      vm._data.__ob__.vmCount--;
+    }
+    // call the last hook...
+    vm._isDestroyed = true;
+    callHook(vm, 'destroyed');
+    // turn off all instance listeners.
+    vm.$off();
+    // remove __vue__ reference
+    if (vm.$el) {
+      vm.$el.__vue__ = null;
+    }
+    // invoke destroy hooks on current rendered tree
+    vm.__patch__(vm._vnode, null);
+  };
+}
+
+function mountComponent (
+  vm,
+  el,
+  hydrating
+) {
+  vm.$el = el;
+  if (!vm.$options.render) {
+    vm.$options.render = createEmptyVNode;
+    if (process.env.NODE_ENV !== 'production') {
+      /* istanbul ignore if */
+      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
+        vm.$options.el || el) {
+        warn(
+          'You are using the runtime-only build of Vue where the template ' +
+          'compiler is not available. Either pre-compile the templates into ' +
+          'render functions, or use the compiler-included build.',
+          vm
+        );
+      } else {
+        warn(
+          'Failed to mount component: template or render function not defined.',
+          vm
+        );
+      }
+    }
+  }
+  callHook(vm, 'beforeMount');
+
+  var updateComponent;
+  /* istanbul ignore if */
+  if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+    updateComponent = function () {
+      var name = vm._name;
+      var startTag = "start " + name;
+      var endTag = "end " + name;
+      perf.mark(startTag);
+      var vnode = vm._render();
+      perf.mark(endTag);
+      perf.measure((name + " render"), startTag, endTag);
+      perf.mark(startTag);
+      vm._update(vnode, hydrating);
+      perf.mark(endTag);
+      perf.measure((name + " patch"), startTag, endTag);
+    };
+  } else {
+    updateComponent = function () {
+      vm._update(vm._render(), hydrating);
+    };
+  }
+
+  vm._watcher = new Watcher(vm, updateComponent, noop);
+  hydrating = false;
+
+  // manually mounted instance, call mounted on self
+  // mounted is called for render-created child components in its inserted hook
+  if (vm.$vnode == null) {
+    vm._isMounted = true;
+    callHook(vm, 'mounted');
+  }
+  return vm
+}
+
+function updateChildComponent (
+  vm,
+  propsData,
+  listeners,
+  parentVnode,
+  renderChildren
+) {
+  // determine whether component has slot children
+  // we need to do this before overwriting $options._renderChildren
+  var hasChildren = !!(
+    renderChildren ||               // has new static slots
+    vm.$options._renderChildren ||  // has old static slots
+    parentVnode.data.scopedSlots || // has new scoped slots
+    vm.$scopedSlots !== emptyObject // has old scoped slots
+  );
+
+  vm.$options._parentVnode = parentVnode;
+  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
+  if (vm._vnode) { // update child tree's parent
+    vm._vnode.parent = parentVnode;
+  }
+  vm.$options._renderChildren = renderChildren;
+
+  // update props
+  if (propsData && vm.$options.props) {
+    observerState.shouldConvert = false;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = true;
+    }
+    var props = vm._props;
+    var propKeys = vm.$options._propKeys || [];
+    for (var i = 0; i < propKeys.length; i++) {
+      var key = propKeys[i];
+      props[key] = validateProp(key, vm.$options.props, propsData, vm);
+    }
+    observerState.shouldConvert = true;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = false;
+    }
+    // keep a copy of raw propsData
+    vm.$options.propsData = propsData;
+  }
+  // update listeners
+  if (listeners) {
+    var oldListeners = vm.$options._parentListeners;
+    vm.$options._parentListeners = listeners;
+    updateComponentListeners(vm, listeners, oldListeners);
+  }
+  // resolve slots + force update if has children
+  if (hasChildren) {
+    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
+    vm.$forceUpdate();
+  }
+}
+
+function isInInactiveTree (vm) {
+  while (vm && (vm = vm.$parent)) {
+    if (vm._inactive) { return true }
+  }
+  return false
+}
+
+function activateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = false;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  } else if (vm._directInactive) {
+    return
+  }
+  if (vm._inactive || vm._inactive == null) {
+    vm._inactive = false;
+    for (var i = 0; i < vm.$children.length; i++) {
+      activateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'activated');
+  }
+}
+
+function deactivateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = true;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  }
+  if (!vm._inactive) {
+    vm._inactive = true;
+    for (var i = 0; i < vm.$children.length; i++) {
+      deactivateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'deactivated');
+  }
+}
+
+function callHook (vm, hook) {
+  var handlers = vm.$options[hook];
+  if (handlers) {
+    for (var i = 0, j = handlers.length; i < j; i++) {
+      try {
+        handlers[i].call(vm);
+      } catch (e) {
+        handleError(e, vm, (hook + " hook"));
+      }
+    }
+  }
+  if (vm._hasHookEvent) {
+    vm.$emit('hook:' + hook);
+  }
+}
+
+/*  */
+
+
+var queue = [];
+var has = {};
+var circular = {};
+var waiting = false;
+var flushing = false;
+var index = 0;
+
+/**
+ * Reset the scheduler's state.
+ */
+function resetSchedulerState () {
+  queue.length = 0;
+  has = {};
+  if (process.env.NODE_ENV !== 'production') {
+    circular = {};
+  }
+  waiting = flushing = false;
+}
+
+/**
+ * Flush both queues and run the watchers.
+ */
+function flushSchedulerQueue () {
+  flushing = true;
+  var watcher, id, vm;
+
+  // Sort queue before flush.
+  // This ensures that:
+  // 1. Components are updated from parent to child. (because parent is always
+  //    created before the child)
+  // 2. A component's user watchers are run before its render watcher (because
+  //    user watchers are created before the render watcher)
+  // 3. If a component is destroyed during a parent component's watcher run,
+  //    its watchers can be skipped.
+  queue.sort(function (a, b) { return a.id - b.id; });
+
+  // do not cache length because more watchers might be pushed
+  // as we run existing watchers
+  for (index = 0; index < queue.length; index++) {
+    watcher = queue[index];
+    id = watcher.id;
+    has[id] = null;
+    watcher.run();
+    // in dev build, check and stop circular updates.
+    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
+      circular[id] = (circular[id] || 0) + 1;
+      if (circular[id] > config._maxUpdateCount) {
+        warn(
+          'You may have an infinite update loop ' + (
+            watcher.user
+              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
+              : "in a component render function."
+          ),
+          watcher.vm
+        );
+        break
+      }
+    }
+  }
+
+  // call updated hooks
+  index = queue.length;
+  while (index--) {
+    watcher = queue[index];
+    vm = watcher.vm;
+    if (vm._watcher === watcher && vm._isMounted) {
+      callHook(vm, 'updated');
+    }
+  }
+
+  // devtool hook
+  /* istanbul ignore if */
+  if (devtools && config.devtools) {
+    devtools.emit('flush');
+  }
+
+  resetSchedulerState();
+}
+
+/**
+ * Push a watcher into the watcher queue.
+ * Jobs with duplicate IDs will be skipped unless it's
+ * pushed when the queue is being flushed.
+ */
+function queueWatcher (watcher) {
+  var id = watcher.id;
+  if (has[id] == null) {
+    has[id] = true;
+    if (!flushing) {
+      queue.push(watcher);
+    } else {
+      // if already flushing, splice the watcher based on its id
+      // if already past its id, it will be run next immediately.
+      var i = queue.length - 1;
+      while (i >= 0 && queue[i].id > watcher.id) {
+        i--;
+      }
+      queue.splice(Math.max(i, index) + 1, 0, watcher);
+    }
+    // queue the flush
+    if (!waiting) {
+      waiting = true;
+      nextTick(flushSchedulerQueue);
+    }
+  }
+}
+
+/*  */
+
+var uid$2 = 0;
+
+/**
+ * A watcher parses an expression, collects dependencies,
+ * and fires callback when the expression value changes.
+ * This is used for both the $watch() api and directives.
+ */
+var Watcher = function Watcher (
+  vm,
+  expOrFn,
+  cb,
+  options
+) {
+  this.vm = vm;
+  vm._watchers.push(this);
+  // options
+  if (options) {
+    this.deep = !!options.deep;
+    this.user = !!options.user;
+    this.lazy = !!options.lazy;
+    this.sync = !!options.sync;
+  } else {
+    this.deep = this.user = this.lazy = this.sync = false;
+  }
+  this.cb = cb;
+  this.id = ++uid$2; // uid for batching
+  this.active = true;
+  this.dirty = this.lazy; // for lazy watchers
+  this.deps = [];
+  this.newDeps = [];
+  this.depIds = new _Set();
+  this.newDepIds = new _Set();
+  this.expression = process.env.NODE_ENV !== 'production'
+    ? expOrFn.toString()
+    : '';
+  // parse expression for getter
+  if (typeof expOrFn === 'function') {
+    this.getter = expOrFn;
+  } else {
+    this.getter = parsePath(expOrFn);
+    if (!this.getter) {
+      this.getter = function () {};
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed watching path: \"" + expOrFn + "\" " +
+        'Watcher only accepts simple dot-delimited paths. ' +
+        'For full control, use a function instead.',
+        vm
+      );
+    }
+  }
+  this.value = this.lazy
+    ? undefined
+    : this.get();
+};
+
+/**
+ * Evaluate the getter, and re-collect dependencies.
+ */
+Watcher.prototype.get = function get () {
+  pushTarget(this);
+  var value;
+  var vm = this.vm;
+  if (this.user) {
+    try {
+      value = this.getter.call(vm, vm);
+    } catch (e) {
+      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
+    }
+  } else {
+    value = this.getter.call(vm, vm);
+  }
+  // "touch" every property so they are all tracked as
+  // dependencies for deep watching
+  if (this.deep) {
+    traverse(value);
+  }
+  popTarget();
+  this.cleanupDeps();
+  return value
+};
+
+/**
+ * Add a dependency to this directive.
+ */
+Watcher.prototype.addDep = function addDep (dep) {
+  var id = dep.id;
+  if (!this.newDepIds.has(id)) {
+    this.newDepIds.add(id);
+    this.newDeps.push(dep);
+    if (!this.depIds.has(id)) {
+      dep.addSub(this);
+    }
+  }
+};
+
+/**
+ * Clean up for dependency collection.
+ */
+Watcher.prototype.cleanupDeps = function cleanupDeps () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    var dep = this$1.deps[i];
+    if (!this$1.newDepIds.has(dep.id)) {
+      dep.removeSub(this$1);
+    }
+  }
+  var tmp = this.depIds;
+  this.depIds = this.newDepIds;
+  this.newDepIds = tmp;
+  this.newDepIds.clear();
+  tmp = this.deps;
+  this.deps = this.newDeps;
+  this.newDeps = tmp;
+  this.newDeps.length = 0;
+};
+
+/**
+ * Subscriber interface.
+ * Will be called when a dependency changes.
+ */
+Watcher.prototype.update = function update () {
+  /* istanbul ignore else */
+  if (this.lazy) {
+    this.dirty = true;
+  } else if (this.sync) {
+    this.run();
+  } else {
+    queueWatcher(this);
+  }
+};
+
+/**
+ * Scheduler job interface.
+ * Will be called by the scheduler.
+ */
+Watcher.prototype.run = function run () {
+  if (this.active) {
+    var value = this.get();
+    if (
+      value !== this.value ||
+      // Deep watchers and watchers on Object/Arrays should fire even
+      // when the value is the same, because the value may
+      // have mutated.
+      isObject(value) ||
+      this.deep
+    ) {
+      // set new value
+      var oldValue = this.value;
+      this.value = value;
+      if (this.user) {
+        try {
+          this.cb.call(this.vm, value, oldValue);
+        } catch (e) {
+          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
+        }
+      } else {
+        this.cb.call(this.vm, value, oldValue);
+      }
+    }
+  }
+};
+
+/**
+ * Evaluate the value of the watcher.
+ * This only gets called for lazy watchers.
+ */
+Watcher.prototype.evaluate = function evaluate () {
+  this.value = this.get();
+  this.dirty = false;
+};
+
+/**
+ * Depend on all deps collected by this watcher.
+ */
+Watcher.prototype.depend = function depend () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    this$1.deps[i].depend();
+  }
+};
+
+/**
+ * Remove self from all dependencies' subscriber list.
+ */
+Watcher.prototype.teardown = function teardown () {
+    var this$1 = this;
+
+  if (this.active) {
+    // remove self from vm's watcher list
+    // this is a somewhat expensive operation so we skip it
+    // if the vm is being destroyed.
+    if (!this.vm._isBeingDestroyed) {
+      remove(this.vm._watchers, this);
+    }
+    var i = this.deps.length;
+    while (i--) {
+      this$1.deps[i].removeSub(this$1);
+    }
+    this.active = false;
+  }
+};
+
+/**
+ * Recursively traverse an object to evoke all converted
+ * getters, so that every nested property inside the object
+ * is collected as a "deep" dependency.
+ */
+var seenObjects = new _Set();
+function traverse (val) {
+  seenObjects.clear();
+  _traverse(val, seenObjects);
+}
+
+function _traverse (val, seen) {
+  var i, keys;
+  var isA = Array.isArray(val);
+  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
+    return
+  }
+  if (val.__ob__) {
+    var depId = val.__ob__.dep.id;
+    if (seen.has(depId)) {
+      return
+    }
+    seen.add(depId);
+  }
+  if (isA) {
+    i = val.length;
+    while (i--) { _traverse(val[i], seen); }
+  } else {
+    keys = Object.keys(val);
+    i = keys.length;
+    while (i--) { _traverse(val[keys[i]], seen); }
+  }
+}
+
+/*  */
+
+var sharedPropertyDefinition = {
+  enumerable: true,
+  configurable: true,
+  get: noop,
+  set: noop
+};
+
+function proxy (target, sourceKey, key) {
+  sharedPropertyDefinition.get = function proxyGetter () {
+    return this[sourceKey][key]
+  };
+  sharedPropertyDefinition.set = function proxySetter (val) {
+    this[sourceKey][key] = val;
+  };
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function initState (vm) {
+  vm._watchers = [];
+  var opts = vm.$options;
+  if (opts.props) { initProps(vm, opts.props); }
+  if (opts.methods) { initMethods(vm, opts.methods); }
+  if (opts.data) {
+    initData(vm);
+  } else {
+    observe(vm._data = {}, true /* asRootData */);
+  }
+  if (opts.computed) { initComputed(vm, opts.computed); }
+  if (opts.watch) { initWatch(vm, opts.watch); }
+}
+
+var isReservedProp = { key: 1, ref: 1, slot: 1 };
+
+function initProps (vm, propsOptions) {
+  var propsData = vm.$options.propsData || {};
+  var props = vm._props = {};
+  // cache prop keys so that future props updates can iterate using Array
+  // instead of dynamic object key enumeration.
+  var keys = vm.$options._propKeys = [];
+  var isRoot = !vm.$parent;
+  // root instance props should be converted
+  observerState.shouldConvert = isRoot;
+  var loop = function ( key ) {
+    keys.push(key);
+    var value = validateProp(key, propsOptions, propsData, vm);
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      if (isReservedProp[key]) {
+        warn(
+          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
+          vm
+        );
+      }
+      defineReactive$$1(props, key, value, function () {
+        if (vm.$parent && !observerState.isSettingProps) {
+          warn(
+            "Avoid mutating a prop directly since the value will be " +
+            "overwritten whenever the parent component re-renders. " +
+            "Instead, use a data or computed property based on the prop's " +
+            "value. Prop being mutated: \"" + key + "\"",
+            vm
+          );
+        }
+      });
+    } else {
+      defineReactive$$1(props, key, value);
+    }
+    // static props are already proxied on the component's prototype
+    // during Vue.extend(). We only need to proxy props defined at
+    // instantiation here.
+    if (!(key in vm)) {
+      proxy(vm, "_props", key);
+    }
+  };
+
+  for (var key in propsOptions) loop( key );
+  observerState.shouldConvert = true;
+}
+
+function initData (vm) {
+  var data = vm.$options.data;
+  data = vm._data = typeof data === 'function'
+    ? data.call(vm)
+    : data || {};
+  if (!isPlainObject(data)) {
+    data = {};
+    process.env.NODE_ENV !== 'production' && warn(
+      'data functions should return an object:\n' +
+      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
+      vm
+    );
+  }
+  // proxy data on instance
+  var keys = Object.keys(data);
+  var props = vm.$options.props;
+  var i = keys.length;
+  while (i--) {
+    if (props && hasOwn(props, keys[i])) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
+        "Use prop default value instead.",
+        vm
+      );
+    } else if (!isReserved(keys[i])) {
+      proxy(vm, "_data", keys[i]);
+    }
+  }
+  // observe data
+  observe(data, true /* asRootData */);
+}
+
+var computedWatcherOptions = { lazy: true };
+
+function initComputed (vm, computed) {
+  var watchers = vm._computedWatchers = Object.create(null);
+
+  for (var key in computed) {
+    var userDef = computed[key];
+    var getter = typeof userDef === 'function' ? userDef : userDef.get;
+    // create internal watcher for the computed property.
+    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);
+
+    // component-defined computed properties are already defined on the
+    // component prototype. We only need to define computed properties defined
+    // at instantiation here.
+    if (!(key in vm)) {
+      defineComputed(vm, key, userDef);
+    }
+  }
+}
+
+function defineComputed (target, key, userDef) {
+  if (typeof userDef === 'function') {
+    sharedPropertyDefinition.get = createComputedGetter(key);
+    sharedPropertyDefinition.set = noop;
+  } else {
+    sharedPropertyDefinition.get = userDef.get
+      ? userDef.cache !== false
+        ? createComputedGetter(key)
+        : userDef.get
+      : noop;
+    sharedPropertyDefinition.set = userDef.set
+      ? userDef.set
+      : noop;
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function createComputedGetter (key) {
+  return function computedGetter () {
+    var watcher = this._computedWatchers && this._computedWatchers[key];
+    if (watcher) {
+      if (watcher.dirty) {
+        watcher.evaluate();
+      }
+      if (Dep.target) {
+        watcher.depend();
+      }
+      return watcher.value
+    }
+  }
+}
+
+function initMethods (vm, methods) {
+  var props = vm.$options.props;
+  for (var key in methods) {
+    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
+    if (process.env.NODE_ENV !== 'production') {
+      if (methods[key] == null) {
+        warn(
+          "method \"" + key + "\" has an undefined value in the component definition. " +
+          "Did you reference the function correctly?",
+          vm
+        );
+      }
+      if (props && hasOwn(props, key)) {
+        warn(
+          ("method \"" + key + "\" has already been defined as a prop."),
+          vm
+        );
+      }
+    }
+  }
+}
+
+function initWatch (vm, watch) {
+  for (var key in watch) {
+    var handler = watch[key];
+    if (Array.isArray(handler)) {
+      for (var i = 0; i < handler.length; i++) {
+        createWatcher(vm, key, handler[i]);
+      }
+    } else {
+      createWatcher(vm, key, handler);
+    }
+  }
+}
+
+function createWatcher (vm, key, handler) {
+  var options;
+  if (isPlainObject(handler)) {
+    options = handler;
+    handler = handler.handler;
+  }
+  if (typeof handler === 'string') {
+    handler = vm[handler];
+  }
+  vm.$watch(key, handler, options);
+}
+
+function stateMixin (Vue) {
+  // flow somehow has problems with directly declared definition object
+  // when using Object.defineProperty, so we have to procedurally build up
+  // the object here.
+  var dataDef = {};
+  dataDef.get = function () { return this._data };
+  var propsDef = {};
+  propsDef.get = function () { return this._props };
+  if (process.env.NODE_ENV !== 'production') {
+    dataDef.set = function (newData) {
+      warn(
+        'Avoid replacing instance root $data. ' +
+        'Use nested data properties instead.',
+        this
+      );
+    };
+    propsDef.set = function () {
+      warn("$props is readonly.", this);
+    };
+  }
+  Object.defineProperty(Vue.prototype, '$data', dataDef);
+  Object.defineProperty(Vue.prototype, '$props', propsDef);
+
+  Vue.prototype.$set = set;
+  Vue.prototype.$delete = del;
+
+  Vue.prototype.$watch = function (
+    expOrFn,
+    cb,
+    options
+  ) {
+    var vm = this;
+    options = options || {};
+    options.user = true;
+    var watcher = new Watcher(vm, expOrFn, cb, options);
+    if (options.immediate) {
+      cb.call(vm, watcher.value);
+    }
+    return function unwatchFn () {
+      watcher.teardown();
+    }
+  };
+}
+
+/*  */
+
+var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy };
+var hooksToMerge = Object.keys(hooks);
+
+function createComponent (
+  Ctor,
+  data,
+  context,
+  children,
+  tag
+) {
+  if (!Ctor) {
+    return
+  }
+
+  var baseCtor = context.$options._base;
+  if (isObject(Ctor)) {
+    Ctor = baseCtor.extend(Ctor);
+  }
+
+  if (typeof Ctor !== 'function') {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Invalid Component definition: " + (String(Ctor))), context);
+    }
+    return
+  }
+
+  // async component
+  if (!Ctor.cid) {
+    if (Ctor.resolved) {
+      Ctor = Ctor.resolved;
+    } else {
+      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
+        // it's ok to queue this on every render because
+        // $forceUpdate is buffered by the scheduler.
+        context.$forceUpdate();
+      });
+      if (!Ctor) {
+        // return nothing if this is indeed an async component
+        // wait for the callback to trigger parent update.
+        return
+      }
+    }
+  }
+
+  // resolve constructor options in case global mixins are applied after
+  // component constructor creation
+  resolveConstructorOptions(Ctor);
+
+  data = data || {};
+
+  // transform component v-model data into props & events
+  if (data.model) {
+    transformModel(Ctor.options, data);
+  }
+
+  // extract props
+  var propsData = extractProps(data, Ctor);
+
+  // functional component
+  if (Ctor.options.functional) {
+    return createFunctionalComponent(Ctor, propsData, data, context, children)
+  }
+
+  // extract listeners, since these needs to be treated as
+  // child component listeners instead of DOM listeners
+  var listeners = data.on;
+  // replace with listeners with .native modifier
+  data.on = data.nativeOn;
+
+  if (Ctor.options.abstract) {
+    // abstract components do not keep anything
+    // other than props & listeners
+    data = {};
+  }
+
+  // merge component management hooks onto the placeholder node
+  mergeHooks(data);
+
+  // return a placeholder vnode
+  var name = Ctor.options.name || tag;
+  var vnode = new VNode(
+    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
+    data, undefined, undefined, undefined, context,
+    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
+  );
+  return vnode
+}
+
+function createFunctionalComponent (
+  Ctor,
+  propsData,
+  data,
+  context,
+  children
+) {
+  var props = {};
+  var propOptions = Ctor.options.props;
+  if (propOptions) {
+    for (var key in propOptions) {
+      props[key] = validateProp(key, propOptions, propsData);
+    }
+  }
+  // ensure the createElement function in functional components
+  // gets a unique context - this is necessary for correct named slot check
+  var _context = Object.create(context);
+  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
+  var vnode = Ctor.options.render.call(null, h, {
+    props: props,
+    data: data,
+    parent: context,
+    children: children,
+    slots: function () { return resolveSlots(children, context); }
+  });
+  if (vnode instanceof VNode) {
+    vnode.functionalContext = context;
+    if (data.slot) {
+      (vnode.data || (vnode.data = {})).slot = data.slot;
+    }
+  }
+  return vnode
+}
+
+function createComponentInstanceForVnode (
+  vnode, // we know it's MountedComponentVNode but flow doesn't
+  parent, // activeInstance in lifecycle state
+  parentElm,
+  refElm
+) {
+  var vnodeComponentOptions = vnode.componentOptions;
+  var options = {
+    _isComponent: true,
+    parent: parent,
+    propsData: vnodeComponentOptions.propsData,
+    _componentTag: vnodeComponentOptions.tag,
+    _parentVnode: vnode,
+    _parentListeners: vnodeComponentOptions.listeners,
+    _renderChildren: vnodeComponentOptions.children,
+    _parentElm: parentElm || null,
+    _refElm: refElm || null
+  };
+  // check inline-template render functions
+  var inlineTemplate = vnode.data.inlineTemplate;
+  if (inlineTemplate) {
+    options.render = inlineTemplate.render;
+    options.staticRenderFns = inlineTemplate.staticRenderFns;
+  }
+  return new vnodeComponentOptions.Ctor(options)
+}
+
+function init (
+  vnode,
+  hydrating,
+  parentElm,
+  refElm
+) {
+  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
+    var child = vnode.componentInstance = createComponentInstanceForVnode(
+      vnode,
+      activeInstance,
+      parentElm,
+      refElm
+    );
+    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
+  } else if (vnode.data.keepAlive) {
+    // kept-alive components, treat as a patch
+    var mountedNode = vnode; // work around flow
+    prepatch(mountedNode, mountedNode);
+  }
+}
+
+function prepatch (
+  oldVnode,
+  vnode
+) {
+  var options = vnode.componentOptions;
+  var child = vnode.componentInstance = oldVnode.componentInstance;
+  updateChildComponent(
+    child,
+    options.propsData, // updated props
+    options.listeners, // updated listeners
+    vnode, // new parent vnode
+    options.children // new children
+  );
+}
+
+function insert (vnode) {
+  if (!vnode.componentInstance._isMounted) {
+    vnode.componentInstance._isMounted = true;
+    callHook(vnode.componentInstance, 'mounted');
+  }
+  if (vnode.data.keepAlive) {
+    activateChildComponent(vnode.componentInstance, true /* direct */);
+  }
+}
+
+function destroy (vnode) {
+  if (!vnode.componentInstance._isDestroyed) {
+    if (!vnode.data.keepAlive) {
+      vnode.componentInstance.$destroy();
+    } else {
+      deactivateChildComponent(vnode.componentInstance, true /* direct */);
+    }
+  }
+}
+
+function resolveAsyncComponent (
+  factory,
+  baseCtor,
+  cb
+) {
+  if (factory.requested) {
+    // pool callbacks
+    factory.pendingCallbacks.push(cb);
+  } else {
+    factory.requested = true;
+    var cbs = factory.pendingCallbacks = [cb];
+    var sync = true;
+
+    var resolve = function (res) {
+      if (isObject(res)) {
+        res = baseCtor.extend(res);
+      }
+      // cache resolved
+      factory.resolved = res;
+      // invoke callbacks only if this is not a synchronous resolve
+      // (async resolves are shimmed as synchronous during SSR)
+      if (!sync) {
+        for (var i = 0, l = cbs.length; i < l; i++) {
+          cbs[i](res);
+        }
+      }
+    };
+
+    var reject = function (reason) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed to resolve async component: " + (String(factory)) +
+        (reason ? ("\nReason: " + reason) : '')
+      );
+    };
+
+    var res = factory(resolve, reject);
+
+    // handle promise
+    if (res && typeof res.then === 'function' && !factory.resolved) {
+      res.then(resolve, reject);
+    }
+
+    sync = false;
+    // return in case resolved synchronously
+    return factory.resolved
+  }
+}
+
+function extractProps (data, Ctor) {
+  // we are only extracting raw values here.
+  // validation and default values are handled in the child
+  // component itself.
+  var propOptions = Ctor.options.props;
+  if (!propOptions) {
+    return
+  }
+  var res = {};
+  var attrs = data.attrs;
+  var props = data.props;
+  var domProps = data.domProps;
+  if (attrs || props || domProps) {
+    for (var key in propOptions) {
+      var altKey = hyphenate(key);
+      checkProp(res, props, key, altKey, true) ||
+      checkProp(res, attrs, key, altKey) ||
+      checkProp(res, domProps, key, altKey);
+    }
+  }
+  return res
+}
+
+function checkProp (
+  res,
+  hash,
+  key,
+  altKey,
+  preserve
+) {
+  if (hash) {
+    if (hasOwn(hash, key)) {
+      res[key] = hash[key];
+      if (!preserve) {
+        delete hash[key];
+      }
+      return true
+    } else if (hasOwn(hash, altKey)) {
+      res[key] = hash[altKey];
+      if (!preserve) {
+        delete hash[altKey];
+      }
+      return true
+    }
+  }
+  return false
+}
+
+function mergeHooks (data) {
+  if (!data.hook) {
+    data.hook = {};
+  }
+  for (var i = 0; i < hooksToMerge.length; i++) {
+    var key = hooksToMerge[i];
+    var fromParent = data.hook[key];
+    var ours = hooks[key];
+    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
+  }
+}
+
+function mergeHook$1 (one, two) {
+  return function (a, b, c, d) {
+    one(a, b, c, d);
+    two(a, b, c, d);
+  }
+}
+
+// transform component v-model info (value and callback) into
+// prop and event handler respectively.
+function transformModel (options, data) {
+  var prop = (options.model && options.model.prop) || 'value';
+  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
+  var on = data.on || (data.on = {});
+  if (on[event]) {
+    on[event] = [data.model.callback].concat(on[event]);
+  } else {
+    on[event] = data.model.callback;
+  }
+}
+
+/*  */
+
+var SIMPLE_NORMALIZE = 1;
+var ALWAYS_NORMALIZE = 2;
+
+// wrapper function for providing a more flexible interface
+// without getting yelled at by flow
+function createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType,
+  alwaysNormalize
+) {
+  if (Array.isArray(data) || isPrimitive(data)) {
+    normalizationType = children;
+    children = data;
+    data = undefined;
+  }
+  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
+  return _createElement(context, tag, data, children, normalizationType)
+}
+
+function _createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType
+) {
+  if (data && data.__ob__) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
+      'Always create fresh vnode data objects in each render!',
+      context
+    );
+    return createEmptyVNode()
+  }
+  if (!tag) {
+    // in case of component :is set to falsy value
+    return createEmptyVNode()
+  }
+  // support single function children as default scoped slot
+  if (Array.isArray(children) &&
+      typeof children[0] === 'function') {
+    data = data || {};
+    data.scopedSlots = { default: children[0] };
+    children.length = 0;
+  }
+  if (normalizationType === ALWAYS_NORMALIZE) {
+    children = normalizeChildren(children);
+  } else if (normalizationType === SIMPLE_NORMALIZE) {
+    children = simpleNormalizeChildren(children);
+  }
+  var vnode, ns;
+  if (typeof tag === 'string') {
+    var Ctor;
+    ns = config.getTagNamespace(tag);
+    if (config.isReservedTag(tag)) {
+      // platform built-in elements
+      vnode = new VNode(
+        config.parsePlatformTagName(tag), data, children,
+        undefined, undefined, context
+      );
+    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
+      // component
+      vnode = createComponent(Ctor, data, context, children, tag);
+    } else {
+      // unknown or unlisted namespaced elements
+      // check at runtime because it may get assigned a namespace when its
+      // parent normalizes children
+      vnode = new VNode(
+        tag, data, children,
+        undefined, undefined, context
+      );
+    }
+  } else {
+    // direct component options / constructor
+    vnode = createComponent(tag, data, context, children);
+  }
+  if (vnode) {
+    if (ns) { applyNS(vnode, ns); }
+    return vnode
+  } else {
+    return createEmptyVNode()
+  }
+}
+
+function applyNS (vnode, ns) {
+  vnode.ns = ns;
+  if (vnode.tag === 'foreignObject') {
+    // use default namespace inside foreignObject
+    return
+  }
+  if (vnode.children) {
+    for (var i = 0, l = vnode.children.length; i < l; i++) {
+      var child = vnode.children[i];
+      if (child.tag && !child.ns) {
+        applyNS(child, ns);
+      }
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering v-for lists.
+ */
+function renderList (
+  val,
+  render
+) {
+  var ret, i, l, keys, key;
+  if (Array.isArray(val) || typeof val === 'string') {
+    ret = new Array(val.length);
+    for (i = 0, l = val.length; i < l; i++) {
+      ret[i] = render(val[i], i);
+    }
+  } else if (typeof val === 'number') {
+    ret = new Array(val);
+    for (i = 0; i < val; i++) {
+      ret[i] = render(i + 1, i);
+    }
+  } else if (isObject(val)) {
+    keys = Object.keys(val);
+    ret = new Array(keys.length);
+    for (i = 0, l = keys.length; i < l; i++) {
+      key = keys[i];
+      ret[i] = render(val[key], key, i);
+    }
+  }
+  return ret
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering <slot>
+ */
+function renderSlot (
+  name,
+  fallback,
+  props,
+  bindObject
+) {
+  var scopedSlotFn = this.$scopedSlots[name];
+  if (scopedSlotFn) { // scoped slot
+    props = props || {};
+    if (bindObject) {
+      extend(props, bindObject);
+    }
+    return scopedSlotFn(props) || fallback
+  } else {
+    var slotNodes = this.$slots[name];
+    // warn duplicate slot usage
+    if (slotNodes && process.env.NODE_ENV !== 'production') {
+      slotNodes._rendered && warn(
+        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
+        "- this will likely cause render errors.",
+        this
+      );
+      slotNodes._rendered = true;
+    }
+    return slotNodes || fallback
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving filters
+ */
+function resolveFilter (id) {
+  return resolveAsset(this.$options, 'filters', id, true) || identity
+}
+
+/*  */
+
+/**
+ * Runtime helper for checking keyCodes from config.
+ */
+function checkKeyCodes (
+  eventKeyCode,
+  key,
+  builtInAlias
+) {
+  var keyCodes = config.keyCodes[key] || builtInAlias;
+  if (Array.isArray(keyCodes)) {
+    return keyCodes.indexOf(eventKeyCode) === -1
+  } else {
+    return keyCodes !== eventKeyCode
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for merging v-bind="object" into a VNode's data.
+ */
+function bindObjectProps (
+  data,
+  tag,
+  value,
+  asProp
+) {
+  if (value) {
+    if (!isObject(value)) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'v-bind without argument expects an Object or Array value',
+        this
+      );
+    } else {
+      if (Array.isArray(value)) {
+        value = toObject(value);
+      }
+      for (var key in value) {
+        if (key === 'class' || key === 'style') {
+          data[key] = value[key];
+        } else {
+          var type = data.attrs && data.attrs.type;
+          var hash = asProp || config.mustUseProp(tag, type, key)
+            ? data.domProps || (data.domProps = {})
+            : data.attrs || (data.attrs = {});
+          hash[key] = value[key];
+        }
+      }
+    }
+  }
+  return data
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering static trees.
+ */
+function renderStatic (
+  index,
+  isInFor
+) {
+  var tree = this._staticTrees[index];
+  // if has already-rendered static tree and not inside v-for,
+  // we can reuse the same tree by doing a shallow clone.
+  if (tree && !isInFor) {
+    return Array.isArray(tree)
+      ? cloneVNodes(tree)
+      : cloneVNode(tree)
+  }
+  // otherwise, render a fresh tree.
+  tree = this._staticTrees[index] =
+    this.$options.staticRenderFns[index].call(this._renderProxy);
+  markStatic(tree, ("__static__" + index), false);
+  return tree
+}
+
+/**
+ * Runtime helper for v-once.
+ * Effectively it means marking the node as static with a unique key.
+ */
+function markOnce (
+  tree,
+  index,
+  key
+) {
+  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
+  return tree
+}
+
+function markStatic (
+  tree,
+  key,
+  isOnce
+) {
+  if (Array.isArray(tree)) {
+    for (var i = 0; i < tree.length; i++) {
+      if (tree[i] && typeof tree[i] !== 'string') {
+        markStaticNode(tree[i], (key + "_" + i), isOnce);
+      }
+    }
+  } else {
+    markStaticNode(tree, key, isOnce);
+  }
+}
+
+function markStaticNode (node, key, isOnce) {
+  node.isStatic = true;
+  node.key = key;
+  node.isOnce = isOnce;
+}
+
+/*  */
+
+function initRender (vm) {
+  vm.$vnode = null; // the placeholder node in parent tree
+  vm._vnode = null; // the root of the child tree
+  vm._staticTrees = null;
+  var parentVnode = vm.$options._parentVnode;
+  var renderContext = parentVnode && parentVnode.context;
+  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
+  vm.$scopedSlots = emptyObject;
+  // bind the createElement fn to this instance
+  // so that we get proper render context inside it.
+  // args order: tag, data, children, normalizationType, alwaysNormalize
+  // internal version is used by render functions compiled from templates
+  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
+  // normalization is always applied for the public version, used in
+  // user-written render functions.
+  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
+}
+
+function renderMixin (Vue) {
+  Vue.prototype.$nextTick = function (fn) {
+    return nextTick(fn, this)
+  };
+
+  Vue.prototype._render = function () {
+    var vm = this;
+    var ref = vm.$options;
+    var render = ref.render;
+    var staticRenderFns = ref.staticRenderFns;
+    var _parentVnode = ref._parentVnode;
+
+    if (vm._isMounted) {
+      // clone slot nodes on re-renders
+      for (var key in vm.$slots) {
+        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
+      }
+    }
+
+    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;
+
+    if (staticRenderFns && !vm._staticTrees) {
+      vm._staticTrees = [];
+    }
+    // set parent vnode. this allows render functions to have access
+    // to the data on the placeholder node.
+    vm.$vnode = _parentVnode;
+    // render self
+    var vnode;
+    try {
+      vnode = render.call(vm._renderProxy, vm.$createElement);
+    } catch (e) {
+      handleError(e, vm, "render function");
+      // return error render result,
+      // or previous vnode to prevent render error causing blank component
+      /* istanbul ignore else */
+      if (process.env.NODE_ENV !== 'production') {
+        vnode = vm.$options.renderError
+          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
+          : vm._vnode;
+      } else {
+        vnode = vm._vnode;
+      }
+    }
+    // return empty vnode in case the render function errored out
+    if (!(vnode instanceof VNode)) {
+      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
+        warn(
+          'Multiple root nodes returned from render function. Render function ' +
+          'should return a single root node.',
+          vm
+        );
+      }
+      vnode = createEmptyVNode();
+    }
+    // set parent
+    vnode.parent = _parentVnode;
+    return vnode
+  };
+
+  // internal render helpers.
+  // these are exposed on the instance prototype to reduce generated render
+  // code size.
+  Vue.prototype._o = markOnce;
+  Vue.prototype._n = toNumber;
+  Vue.prototype._s = _toString;
+  Vue.prototype._l = renderList;
+  Vue.prototype._t = renderSlot;
+  Vue.prototype._q = looseEqual;
+  Vue.prototype._i = looseIndexOf;
+  Vue.prototype._m = renderStatic;
+  Vue.prototype._f = resolveFilter;
+  Vue.prototype._k = checkKeyCodes;
+  Vue.prototype._b = bindObjectProps;
+  Vue.prototype._v = createTextVNode;
+  Vue.prototype._e = createEmptyVNode;
+  Vue.prototype._u = resolveScopedSlots;
+}
+
+/*  */
+
+function initProvide (vm) {
+  var provide = vm.$options.provide;
+  if (provide) {
+    vm._provided = typeof provide === 'function'
+      ? provide.call(vm)
+      : provide;
+  }
+}
+
+function initInjections (vm) {
+  var inject = vm.$options.inject;
+  if (inject) {
+    // inject is :any because flow is not smart enough to figure out cached
+    // isArray here
+    var isArray = Array.isArray(inject);
+    var keys = isArray
+      ? inject
+      : hasSymbol
+        ? Reflect.ownKeys(inject)
+        : Object.keys(inject);
+
+    for (var i = 0; i < keys.length; i++) {
+      var key = keys[i];
+      var provideKey = isArray ? key : inject[key];
+      var source = vm;
+      while (source) {
+        if (source._provided && provideKey in source._provided) {
+          vm[key] = source._provided[provideKey];
+          break
+        }
+        source = source.$parent;
+      }
+    }
+  }
+}
+
+/*  */
+
+var uid = 0;
+
+function initMixin (Vue) {
+  Vue.prototype._init = function (options) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      perf.mark('init');
+    }
+
+    var vm = this;
+    // a uid
+    vm._uid = uid++;
+    // a flag to avoid this being observed
+    vm._isVue = true;
+    // merge options
+    if (options && options._isComponent) {
+      // optimize internal component instantiation
+      // since dynamic options merging is pretty slow, and none of the
+      // internal component options needs special treatment.
+      initInternalComponent(vm, options);
+    } else {
+      vm.$options = mergeOptions(
+        resolveConstructorOptions(vm.constructor),
+        options || {},
+        vm
+      );
+    }
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      initProxy(vm);
+    } else {
+      vm._renderProxy = vm;
+    }
+    // expose real self
+    vm._self = vm;
+    initLifecycle(vm);
+    initEvents(vm);
+    initRender(vm);
+    callHook(vm, 'beforeCreate');
+    initInjections(vm); // resolve injections before data/props
+    initState(vm);
+    initProvide(vm); // resolve provide after data/props
+    callHook(vm, 'created');
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      vm._name = formatComponentName(vm, false);
+      perf.mark('init end');
+      perf.measure(((vm._name) + " init"), 'init', 'init end');
+    }
+
+    if (vm.$options.el) {
+      vm.$mount(vm.$options.el);
+    }
+  };
+}
+
+function initInternalComponent (vm, options) {
+  var opts = vm.$options = Object.create(vm.constructor.options);
+  // doing this because it's faster than dynamic enumeration.
+  opts.parent = options.parent;
+  opts.propsData = options.propsData;
+  opts._parentVnode = options._parentVnode;
+  opts._parentListeners = options._parentListeners;
+  opts._renderChildren = options._renderChildren;
+  opts._componentTag = options._componentTag;
+  opts._parentElm = options._parentElm;
+  opts._refElm = options._refElm;
+  if (options.render) {
+    opts.render = options.render;
+    opts.staticRenderFns = options.staticRenderFns;
+  }
+}
+
+function resolveConstructorOptions (Ctor) {
+  var options = Ctor.options;
+  if (Ctor.super) {
+    var superOptions = resolveConstructorOptions(Ctor.super);
+    var cachedSuperOptions = Ctor.superOptions;
+    if (superOptions !== cachedSuperOptions) {
+      // super option changed,
+      // need to resolve new options.
+      Ctor.superOptions = superOptions;
+      // check if there are any late-modified/attached options (#4976)
+      var modifiedOptions = resolveModifiedOptions(Ctor);
+      // update base extend options
+      if (modifiedOptions) {
+        extend(Ctor.extendOptions, modifiedOptions);
+      }
+      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
+      if (options.name) {
+        options.components[options.name] = Ctor;
+      }
+    }
+  }
+  return options
+}
+
+function resolveModifiedOptions (Ctor) {
+  var modified;
+  var latest = Ctor.options;
+  var sealed = Ctor.sealedOptions;
+  for (var key in latest) {
+    if (latest[key] !== sealed[key]) {
+      if (!modified) { modified = {}; }
+      modified[key] = dedupe(latest[key], sealed[key]);
+    }
+  }
+  return modified
+}
+
+function dedupe (latest, sealed) {
+  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
+  // between merges
+  if (Array.isArray(latest)) {
+    var res = [];
+    sealed = Array.isArray(sealed) ? sealed : [sealed];
+    for (var i = 0; i < latest.length; i++) {
+      if (sealed.indexOf(latest[i]) < 0) {
+        res.push(latest[i]);
+      }
+    }
+    return res
+  } else {
+    return latest
+  }
+}
+
+function Vue$3 (options) {
+  if (process.env.NODE_ENV !== 'production' &&
+    !(this instanceof Vue$3)) {
+    warn('Vue is a constructor and should be called with the `new` keyword');
+  }
+  this._init(options);
+}
+
+initMixin(Vue$3);
+stateMixin(Vue$3);
+eventsMixin(Vue$3);
+lifecycleMixin(Vue$3);
+renderMixin(Vue$3);
+
+/*  */
+
+function initUse (Vue) {
+  Vue.use = function (plugin) {
+    /* istanbul ignore if */
+    if (plugin.installed) {
+      return
+    }
+    // additional parameters
+    var args = toArray(arguments, 1);
+    args.unshift(this);
+    if (typeof plugin.install === 'function') {
+      plugin.install.apply(plugin, args);
+    } else if (typeof plugin === 'function') {
+      plugin.apply(null, args);
+    }
+    plugin.installed = true;
+    return this
+  };
+}
+
+/*  */
+
+function initMixin$1 (Vue) {
+  Vue.mixin = function (mixin) {
+    this.options = mergeOptions(this.options, mixin);
+  };
+}
+
+/*  */
+
+function initExtend (Vue) {
+  /**
+   * Each instance constructor, including Vue, has a unique
+   * cid. This enables us to create wrapped "child
+   * constructors" for prototypal inheritance and cache them.
+   */
+  Vue.cid = 0;
+  var cid = 1;
+
+  /**
+   * Class inheritance
+   */
+  Vue.extend = function (extendOptions) {
+    extendOptions = extendOptions || {};
+    var Super = this;
+    var SuperId = Super.cid;
+    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
+    if (cachedCtors[SuperId]) {
+      return cachedCtors[SuperId]
+    }
+
+    var name = extendOptions.name || Super.options.name;
+    if (process.env.NODE_ENV !== 'production') {
+      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+        warn(
+          'Invalid component name: "' + name + '". Component names ' +
+          'can only contain alphanumeric characters and the hyphen, ' +
+          'and must start with a letter.'
+        );
+      }
+    }
+
+    var Sub = function VueComponent (options) {
+      this._init(options);
+    };
+    Sub.prototype = Object.create(Super.prototype);
+    Sub.prototype.constructor = Sub;
+    Sub.cid = cid++;
+    Sub.options = mergeOptions(
+      Super.options,
+      extendOptions
+    );
+    Sub['super'] = Super;
+
+    // For props and computed properties, we define the proxy getters on
+    // the Vue instances at extension time, on the extended prototype. This
+    // avoids Object.defineProperty calls for each instance created.
+    if (Sub.options.props) {
+      initProps$1(Sub);
+    }
+    if (Sub.options.computed) {
+      initComputed$1(Sub);
+    }
+
+    // allow further extension/mixin/plugin usage
+    Sub.extend = Super.extend;
+    Sub.mixin = Super.mixin;
+    Sub.use = Super.use;
+
+    // create asset registers, so extended classes
+    // can have their private assets too.
+    config._assetTypes.forEach(function (type) {
+      Sub[type] = Super[type];
+    });
+    // enable recursive self-lookup
+    if (name) {
+      Sub.options.components[name] = Sub;
+    }
+
+    // keep a reference to the super options at extension time.
+    // later at instantiation we can check if Super's options have
+    // been updated.
+    Sub.superOptions = Super.options;
+    Sub.extendOptions = extendOptions;
+    Sub.sealedOptions = extend({}, Sub.options);
+
+    // cache constructor
+    cachedCtors[SuperId] = Sub;
+    return Sub
+  };
+}
+
+function initProps$1 (Comp) {
+  var props = Comp.options.props;
+  for (var key in props) {
+    proxy(Comp.prototype, "_props", key);
+  }
+}
+
+function initComputed$1 (Comp) {
+  var computed = Comp.options.computed;
+  for (var key in computed) {
+    defineComputed(Comp.prototype, key, computed[key]);
+  }
+}
+
+/*  */
+
+function initAssetRegisters (Vue) {
+  /**
+   * Create asset registration methods.
+   */
+  config._assetTypes.forEach(function (type) {
+    Vue[type] = function (
+      id,
+      definition
+    ) {
+      if (!definition) {
+        return this.options[type + 's'][id]
+      } else {
+        /* istanbul ignore if */
+        if (process.env.NODE_ENV !== 'production') {
+          if (type === 'component' && config.isReservedTag(id)) {
+            warn(
+              'Do not use built-in or reserved HTML elements as component ' +
+              'id: ' + id
+            );
+          }
+        }
+        if (type === 'component' && isPlainObject(definition)) {
+          definition.name = definition.name || id;
+          definition = this.options._base.extend(definition);
+        }
+        if (type === 'directive' && typeof definition === 'function') {
+          definition = { bind: definition, update: definition };
+        }
+        this.options[type + 's'][id] = definition;
+        return definition
+      }
+    };
+  });
+}
+
+/*  */
+
+var patternTypes = [String, RegExp];
+
+function getComponentName (opts) {
+  return opts && (opts.Ctor.options.name || opts.tag)
+}
+
+function matches (pattern, name) {
+  if (typeof pattern === 'string') {
+    return pattern.split(',').indexOf(name) > -1
+  } else if (pattern instanceof RegExp) {
+    return pattern.test(name)
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function pruneCache (cache, filter) {
+  for (var key in cache) {
+    var cachedNode = cache[key];
+    if (cachedNode) {
+      var name = getComponentName(cachedNode.componentOptions);
+      if (name && !filter(name)) {
+        pruneCacheEntry(cachedNode);
+        cache[key] = null;
+      }
+    }
+  }
+}
+
+function pruneCacheEntry (vnode) {
+  if (vnode) {
+    if (!vnode.componentInstance._inactive) {
+      callHook(vnode.componentInstance, 'deactivated');
+    }
+    vnode.componentInstance.$destroy();
+  }
+}
+
+var KeepAlive = {
+  name: 'keep-alive',
+  abstract: true,
+
+  props: {
+    include: patternTypes,
+    exclude: patternTypes
+  },
+
+  created: function created () {
+    this.cache = Object.create(null);
+  },
+
+  destroyed: function destroyed () {
+    var this$1 = this;
+
+    for (var key in this$1.cache) {
+      pruneCacheEntry(this$1.cache[key]);
+    }
+  },
+
+  watch: {
+    include: function include (val) {
+      pruneCache(this.cache, function (name) { return matches(val, name); });
+    },
+    exclude: function exclude (val) {
+      pruneCache(this.cache, function (name) { return !matches(val, name); });
+    }
+  },
+
+  render: function render () {
+    var vnode = getFirstComponentChild(this.$slots.default);
+    var componentOptions = vnode && vnode.componentOptions;
+    if (componentOptions) {
+      // check pattern
+      var name = getComponentName(componentOptions);
+      if (name && (
+        (this.include && !matches(this.include, name)) ||
+        (this.exclude && matches(this.exclude, name))
+      )) {
+        return vnode
+      }
+      var key = vnode.key == null
+        // same constructor may get registered as different local components
+        // so cid alone is not enough (#3269)
+        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
+        : vnode.key;
+      if (this.cache[key]) {
+        vnode.componentInstance = this.cache[key].componentInstance;
+      } else {
+        this.cache[key] = vnode;
+      }
+      vnode.data.keepAlive = true;
+    }
+    return vnode
+  }
+};
+
+var builtInComponents = {
+  KeepAlive: KeepAlive
+};
+
+/*  */
+
+function initGlobalAPI (Vue) {
+  // config
+  var configDef = {};
+  configDef.get = function () { return config; };
+  if (process.env.NODE_ENV !== 'production') {
+    configDef.set = function () {
+      warn(
+        'Do not replace the Vue.config object, set individual fields instead.'
+      );
+    };
+  }
+  Object.defineProperty(Vue, 'config', configDef);
+
+  // exposed util methods.
+  // NOTE: these are not considered part of the public API - avoid relying on
+  // them unless you are aware of the risk.
+  Vue.util = {
+    warn: warn,
+    extend: extend,
+    mergeOptions: mergeOptions,
+    defineReactive: defineReactive$$1
+  };
+
+  Vue.set = set;
+  Vue.delete = del;
+  Vue.nextTick = nextTick;
+
+  Vue.options = Object.create(null);
+  config._assetTypes.forEach(function (type) {
+    Vue.options[type + 's'] = Object.create(null);
+  });
+
+  // this is used to identify the "base" constructor to extend all plain-object
+  // components with in Weex's multi-instance scenarios.
+  Vue.options._base = Vue;
+
+  extend(Vue.options.components, builtInComponents);
+
+  initUse(Vue);
+  initMixin$1(Vue);
+  initExtend(Vue);
+  initAssetRegisters(Vue);
+}
+
+initGlobalAPI(Vue$3);
+
+Object.defineProperty(Vue$3.prototype, '$isServer', {
+  get: isServerRendering
+});
+
+Vue$3.version = '2.2.2';
+
+/*  */
+
+// attributes that should be using props for binding
+var acceptValue = makeMap('input,textarea,option,select');
+var mustUseProp = function (tag, type, attr) {
+  return (
+    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
+    (attr === 'selected' && tag === 'option') ||
+    (attr === 'checked' && tag === 'input') ||
+    (attr === 'muted' && tag === 'video')
+  )
+};
+
+var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
+
+var isBooleanAttr = makeMap(
+  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
+  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
+  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
+  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
+  'required,reversed,scoped,seamless,selected,sortable,translate,' +
+  'truespeed,typemustmatch,visible'
+);
+
+var xlinkNS = 'http://www.w3.org/1999/xlink';
+
+var isXlink = function (name) {
+  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
+};
+
+var getXlinkProp = function (name) {
+  return isXlink(name) ? name.slice(6, name.length) : ''
+};
+
+var isFalsyAttrValue = function (val) {
+  return val == null || val === false
+};
+
+/*  */
+
+function genClassForVnode (vnode) {
+  var data = vnode.data;
+  var parentNode = vnode;
+  var childNode = vnode;
+  while (childNode.componentInstance) {
+    childNode = childNode.componentInstance._vnode;
+    if (childNode.data) {
+      data = mergeClassData(childNode.data, data);
+    }
+  }
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data) {
+      data = mergeClassData(data, parentNode.data);
+    }
+  }
+  return genClassFromData(data)
+}
+
+function mergeClassData (child, parent) {
+  return {
+    staticClass: concat(child.staticClass, parent.staticClass),
+    class: child.class
+      ? [child.class, parent.class]
+      : parent.class
+  }
+}
+
+function genClassFromData (data) {
+  var dynamicClass = data.class;
+  var staticClass = data.staticClass;
+  if (staticClass || dynamicClass) {
+    return concat(staticClass, stringifyClass(dynamicClass))
+  }
+  /* istanbul ignore next */
+  return ''
+}
+
+function concat (a, b) {
+  return a ? b ? (a + ' ' + b) : a : (b || '')
+}
+
+function stringifyClass (value) {
+  var res = '';
+  if (!value) {
+    return res
+  }
+  if (typeof value === 'string') {
+    return value
+  }
+  if (Array.isArray(value)) {
+    var stringified;
+    for (var i = 0, l = value.length; i < l; i++) {
+      if (value[i]) {
+        if ((stringified = stringifyClass(value[i]))) {
+          res += stringified + ' ';
+        }
+      }
+    }
+    return res.slice(0, -1)
+  }
+  if (isObject(value)) {
+    for (var key in value) {
+      if (value[key]) { res += key + ' '; }
+    }
+    return res.slice(0, -1)
+  }
+  /* istanbul ignore next */
+  return res
+}
+
+/*  */
+
+var namespaceMap = {
+  svg: 'http://www.w3.org/2000/svg',
+  math: 'http://www.w3.org/1998/Math/MathML'
+};
+
+var isHTMLTag = makeMap(
+  'html,body,base,head,link,meta,style,title,' +
+  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
+  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
+  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
+  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
+  'embed,object,param,source,canvas,script,noscript,del,ins,' +
+  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
+  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
+  'output,progress,select,textarea,' +
+  'details,dialog,menu,menuitem,summary,' +
+  'content,element,shadow,template'
+);
+
+// this map is intentionally selective, only covering SVG elements that may
+// contain child elements.
+var isSVG = makeMap(
+  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
+  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
+  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
+  true
+);
+
+var isPreTag = function (tag) { return tag === 'pre'; };
+
+var isReservedTag = function (tag) {
+  return isHTMLTag(tag) || isSVG(tag)
+};
+
+function getTagNamespace (tag) {
+  if (isSVG(tag)) {
+    return 'svg'
+  }
+  // basic support for MathML
+  // note it doesn't support other MathML elements being component roots
+  if (tag === 'math') {
+    return 'math'
+  }
+}
+
+var unknownElementCache = Object.create(null);
+function isUnknownElement (tag) {
+  /* istanbul ignore if */
+  if (!inBrowser) {
+    return true
+  }
+  if (isReservedTag(tag)) {
+    return false
+  }
+  tag = tag.toLowerCase();
+  /* istanbul ignore if */
+  if (unknownElementCache[tag] != null) {
+    return unknownElementCache[tag]
+  }
+  var el = document.createElement(tag);
+  if (tag.indexOf('-') > -1) {
+    // http://stackoverflow.com/a/28210364/1070244
+    return (unknownElementCache[tag] = (
+      el.constructor === window.HTMLUnknownElement ||
+      el.constructor === window.HTMLElement
+    ))
+  } else {
+    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
+  }
+}
+
+/*  */
+
+/**
+ * Query an element selector if it's not an element already.
+ */
+function query (el) {
+  if (typeof el === 'string') {
+    var selected = document.querySelector(el);
+    if (!selected) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'Cannot find element: ' + el
+      );
+      return document.createElement('div')
+    }
+    return selected
+  } else {
+    return el
+  }
+}
+
+/*  */
+
+function createElement$1 (tagName, vnode) {
+  var elm = document.createElement(tagName);
+  if (tagName !== 'select') {
+    return elm
+  }
+  // false or null will remove the attribute but undefined will not
+  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
+    elm.setAttribute('multiple', 'multiple');
+  }
+  return elm
+}
+
+function createElementNS (namespace, tagName) {
+  return document.createElementNS(namespaceMap[namespace], tagName)
+}
+
+function createTextNode (text) {
+  return document.createTextNode(text)
+}
+
+function createComment (text) {
+  return document.createComment(text)
+}
+
+function insertBefore (parentNode, newNode, referenceNode) {
+  parentNode.insertBefore(newNode, referenceNode);
+}
+
+function removeChild (node, child) {
+  node.removeChild(child);
+}
+
+function appendChild (node, child) {
+  node.appendChild(child);
+}
+
+function parentNode (node) {
+  return node.parentNode
+}
+
+function nextSibling (node) {
+  return node.nextSibling
+}
+
+function tagName (node) {
+  return node.tagName
+}
+
+function setTextContent (node, text) {
+  node.textContent = text;
+}
+
+function setAttribute (node, key, val) {
+  node.setAttribute(key, val);
+}
+
+
+var nodeOps = Object.freeze({
+	createElement: createElement$1,
+	createElementNS: createElementNS,
+	createTextNode: createTextNode,
+	createComment: createComment,
+	insertBefore: insertBefore,
+	removeChild: removeChild,
+	appendChild: appendChild,
+	parentNode: parentNode,
+	nextSibling: nextSibling,
+	tagName: tagName,
+	setTextContent: setTextContent,
+	setAttribute: setAttribute
+});
+
+/*  */
+
+var ref = {
+  create: function create (_, vnode) {
+    registerRef(vnode);
+  },
+  update: function update (oldVnode, vnode) {
+    if (oldVnode.data.ref !== vnode.data.ref) {
+      registerRef(oldVnode, true);
+      registerRef(vnode);
+    }
+  },
+  destroy: function destroy (vnode) {
+    registerRef(vnode, true);
+  }
+};
+
+function registerRef (vnode, isRemoval) {
+  var key = vnode.data.ref;
+  if (!key) { return }
+
+  var vm = vnode.context;
+  var ref = vnode.componentInstance || vnode.elm;
+  var refs = vm.$refs;
+  if (isRemoval) {
+    if (Array.isArray(refs[key])) {
+      remove(refs[key], ref);
+    } else if (refs[key] === ref) {
+      refs[key] = undefined;
+    }
+  } else {
+    if (vnode.data.refInFor) {
+      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
+        refs[key].push(ref);
+      } else {
+        refs[key] = [ref];
+      }
+    } else {
+      refs[key] = ref;
+    }
+  }
+}
+
+/**
+ * Virtual DOM patching algorithm based on Snabbdom by
+ * Simon Friis Vindum (@paldepind)
+ * Licensed under the MIT License
+ * https://github.com/paldepind/snabbdom/blob/master/LICENSE
+ *
+ * modified by Evan You (@yyx990803)
+ *
+
+/*
+ * Not type-checking this because this file is perf-critical and the cost
+ * of making flow understand it is not worth it.
+ */
+
+var emptyNode = new VNode('', {}, []);
+
+var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];
+
+function isUndef (s) {
+  return s == null
+}
+
+function isDef (s) {
+  return s != null
+}
+
+function sameVnode (vnode1, vnode2) {
+  return (
+    vnode1.key === vnode2.key &&
+    vnode1.tag === vnode2.tag &&
+    vnode1.isComment === vnode2.isComment &&
+    !vnode1.data === !vnode2.data
+  )
+}
+
+function createKeyToOldIdx (children, beginIdx, endIdx) {
+  var i, key;
+  var map = {};
+  for (i = beginIdx; i <= endIdx; ++i) {
+    key = children[i].key;
+    if (isDef(key)) { map[key] = i; }
+  }
+  return map
+}
+
+function createPatchFunction (backend) {
+  var i, j;
+  var cbs = {};
+
+  var modules = backend.modules;
+  var nodeOps = backend.nodeOps;
+
+  for (i = 0; i < hooks$1.length; ++i) {
+    cbs[hooks$1[i]] = [];
+    for (j = 0; j < modules.length; ++j) {
+      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
+    }
+  }
+
+  function emptyNodeAt (elm) {
+    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
+  }
+
+  function createRmCb (childElm, listeners) {
+    function remove$$1 () {
+      if (--remove$$1.listeners === 0) {
+        removeNode(childElm);
+      }
+    }
+    remove$$1.listeners = listeners;
+    return remove$$1
+  }
+
+  function removeNode (el) {
+    var parent = nodeOps.parentNode(el);
+    // element may have already been removed due to v-html / v-text
+    if (parent) {
+      nodeOps.removeChild(parent, el);
+    }
+  }
+
+  var inPre = 0;
+  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
+    vnode.isRootInsert = !nested; // for transition enter check
+    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
+      return
+    }
+
+    var data = vnode.data;
+    var children = vnode.children;
+    var tag = vnode.tag;
+    if (isDef(tag)) {
+      if (process.env.NODE_ENV !== 'production') {
+        if (data && data.pre) {
+          inPre++;
+        }
+        if (
+          !inPre &&
+          !vnode.ns &&
+          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
+          config.isUnknownElement(tag)
+        ) {
+          warn(
+            'Unknown custom element: <' + tag + '> - did you ' +
+            'register the component correctly? For recursive components, ' +
+            'make sure to provide the "name" option.',
+            vnode.context
+          );
+        }
+      }
+      vnode.elm = vnode.ns
+        ? nodeOps.createElementNS(vnode.ns, tag)
+        : nodeOps.createElement(tag, vnode);
+      setScope(vnode);
+
+      /* istanbul ignore if */
+      {
+        createChildren(vnode, children, insertedVnodeQueue);
+        if (isDef(data)) {
+          invokeCreateHooks(vnode, insertedVnodeQueue);
+        }
+        insert(parentElm, vnode.elm, refElm);
+      }
+
+      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
+        inPre--;
+      }
+    } else if (vnode.isComment) {
+      vnode.elm = nodeOps.createComment(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    } else {
+      vnode.elm = nodeOps.createTextNode(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    }
+  }
+
+  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i = vnode.data;
+    if (isDef(i)) {
+      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
+      if (isDef(i = i.hook) && isDef(i = i.init)) {
+        i(vnode, false /* hydrating */, parentElm, refElm);
+      }
+      // after calling the init hook, if the vnode is a child component
+      // it should've created a child instance and mounted it. the child
+      // component also has set the placeholder vnode's elm.
+      // in that case we can just return the element and be done.
+      if (isDef(vnode.componentInstance)) {
+        initComponent(vnode, insertedVnodeQueue);
+        if (isReactivated) {
+          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
+        }
+        return true
+      }
+    }
+  }
+
+  function initComponent (vnode, insertedVnodeQueue) {
+    if (vnode.data.pendingInsert) {
+      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
+    }
+    vnode.elm = vnode.componentInstance.$el;
+    if (isPatchable(vnode)) {
+      invokeCreateHooks(vnode, insertedVnodeQueue);
+      setScope(vnode);
+    } else {
+      // empty component root.
+      // skip all element-related modules except for ref (#3455)
+      registerRef(vnode);
+      // make sure to invoke the insert hook
+      insertedVnodeQueue.push(vnode);
+    }
+  }
+
+  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i;
+    // hack for #4339: a reactivated component with inner transition
+    // does not trigger because the inner node's created hooks are not called
+    // again. It's not ideal to involve module-specific logic in here but
+    // there doesn't seem to be a better way to do it.
+    var innerNode = vnode;
+    while (innerNode.componentInstance) {
+      innerNode = innerNode.componentInstance._vnode;
+      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
+        for (i = 0; i < cbs.activate.length; ++i) {
+          cbs.activate[i](emptyNode, innerNode);
+        }
+        insertedVnodeQueue.push(innerNode);
+        break
+      }
+    }
+    // unlike a newly created component,
+    // a reactivated keep-alive component doesn't insert itself
+    insert(parentElm, vnode.elm, refElm);
+  }
+
+  function insert (parent, elm, ref) {
+    if (parent) {
+      if (ref) {
+        nodeOps.insertBefore(parent, elm, ref);
+      } else {
+        nodeOps.appendChild(parent, elm);
+      }
+    }
+  }
+
+  function createChildren (vnode, children, insertedVnodeQueue) {
+    if (Array.isArray(children)) {
+      for (var i = 0; i < children.length; ++i) {
+        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
+      }
+    } else if (isPrimitive(vnode.text)) {
+      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
+    }
+  }
+
+  function isPatchable (vnode) {
+    while (vnode.componentInstance) {
+      vnode = vnode.componentInstance._vnode;
+    }
+    return isDef(vnode.tag)
+  }
+
+  function invokeCreateHooks (vnode, insertedVnodeQueue) {
+    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
+      cbs.create[i$1](emptyNode, vnode);
+    }
+    i = vnode.data.hook; // Reuse variable
+    if (isDef(i)) {
+      if (i.create) { i.create(emptyNode, vnode); }
+      if (i.insert) { insertedVnodeQueue.push(vnode); }
+    }
+  }
+
+  // set scope id attribute for scoped CSS.
+  // this is implemented as a special case to avoid the overhead
+  // of going through the normal attribute patching process.
+  function setScope (vnode) {
+    var i;
+    var ancestor = vnode;
+    while (ancestor) {
+      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
+        nodeOps.setAttribute(vnode.elm, i, '');
+      }
+      ancestor = ancestor.parent;
+    }
+    // for slot content they should also get the scopeId from the host instance.
+    if (isDef(i = activeInstance) &&
+        i !== vnode.context &&
+        isDef(i = i.$options._scopeId)) {
+      nodeOps.setAttribute(vnode.elm, i, '');
+    }
+  }
+
+  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
+    }
+  }
+
+  function invokeDestroyHook (vnode) {
+    var i, j;
+    var data = vnode.data;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
+      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
+    }
+    if (isDef(i = vnode.children)) {
+      for (j = 0; j < vnode.children.length; ++j) {
+        invokeDestroyHook(vnode.children[j]);
+      }
+    }
+  }
+
+  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      var ch = vnodes[startIdx];
+      if (isDef(ch)) {
+        if (isDef(ch.tag)) {
+          removeAndInvokeRemoveHook(ch);
+          invokeDestroyHook(ch);
+        } else { // Text node
+          removeNode(ch.elm);
+        }
+      }
+    }
+  }
+
+  function removeAndInvokeRemoveHook (vnode, rm) {
+    if (rm || isDef(vnode.data)) {
+      var listeners = cbs.remove.length + 1;
+      if (!rm) {
+        // directly removing
+        rm = createRmCb(vnode.elm, listeners);
+      } else {
+        // we have a recursively passed down rm callback
+        // increase the listeners count
+        rm.listeners += listeners;
+      }
+      // recursively invoke hooks on child component root node
+      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
+        removeAndInvokeRemoveHook(i, rm);
+      }
+      for (i = 0; i < cbs.remove.length; ++i) {
+        cbs.remove[i](vnode, rm);
+      }
+      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
+        i(vnode, rm);
+      } else {
+        rm();
+      }
+    } else {
+      removeNode(vnode.elm);
+    }
+  }
+
+  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
+    var oldStartIdx = 0;
+    var newStartIdx = 0;
+    var oldEndIdx = oldCh.length - 1;
+    var oldStartVnode = oldCh[0];
+    var oldEndVnode = oldCh[oldEndIdx];
+    var newEndIdx = newCh.length - 1;
+    var newStartVnode = newCh[0];
+    var newEndVnode = newCh[newEndIdx];
+    var oldKeyToIdx, idxInOld, elmToMove, refElm;
+
+    // removeOnly is a special flag used only by <transition-group>
+    // to ensure removed elements stay in correct relative positions
+    // during leaving transitions
+    var canMove = !removeOnly;
+
+    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
+      if (isUndef(oldStartVnode)) {
+        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
+      } else if (isUndef(oldEndVnode)) {
+        oldEndVnode = oldCh[--oldEndIdx];
+      } else if (sameVnode(oldStartVnode, newStartVnode)) {
+        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
+        oldStartVnode = oldCh[++oldStartIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else if (sameVnode(oldEndVnode, newEndVnode)) {
+        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
+        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
+        oldStartVnode = oldCh[++oldStartIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
+        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else {
+        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
+        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
+        if (isUndef(idxInOld)) { // New element
+          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+          newStartVnode = newCh[++newStartIdx];
+        } else {
+          elmToMove = oldCh[idxInOld];
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
+            warn(
+              'It seems there are duplicate keys that is causing an update error. ' +
+              'Make sure each v-for item has a unique key.'
+            );
+          }
+          if (sameVnode(elmToMove, newStartVnode)) {
+            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
+            oldCh[idxInOld] = undefined;
+            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          } else {
+            // same key but different element. treat as new element
+            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          }
+        }
+      }
+    }
+    if (oldStartIdx > oldEndIdx) {
+      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
+      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
+    } else if (newStartIdx > newEndIdx) {
+      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
+    }
+  }
+
+  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
+    if (oldVnode === vnode) {
+      return
+    }
+    // reuse element for static trees.
+    // note we only do this if the vnode is cloned -
+    // if the new node is not cloned it means the render functions have been
+    // reset by the hot-reload-api and we need to do a proper re-render.
+    if (vnode.isStatic &&
+        oldVnode.isStatic &&
+        vnode.key === oldVnode.key &&
+        (vnode.isCloned || vnode.isOnce)) {
+      vnode.elm = oldVnode.elm;
+      vnode.componentInstance = oldVnode.componentInstance;
+      return
+    }
+    var i;
+    var data = vnode.data;
+    var hasData = isDef(data);
+    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
+      i(oldVnode, vnode);
+    }
+    var elm = vnode.elm = oldVnode.elm;
+    var oldCh = oldVnode.children;
+    var ch = vnode.children;
+    if (hasData && isPatchable(vnode)) {
+      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
+      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
+    }
+    if (isUndef(vnode.text)) {
+      if (isDef(oldCh) && isDef(ch)) {
+        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
+      } else if (isDef(ch)) {
+        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
+        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
+      } else if (isDef(oldCh)) {
+        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
+      } else if (isDef(oldVnode.text)) {
+        nodeOps.setTextContent(elm, '');
+      }
+    } else if (oldVnode.text !== vnode.text) {
+      nodeOps.setTextContent(elm, vnode.text);
+    }
+    if (hasData) {
+      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
+    }
+  }
+
+  function invokeInsertHook (vnode, queue, initial) {
+    // delay insert hooks for component root nodes, invoke them after the
+    // element is really inserted
+    if (initial && vnode.parent) {
+      vnode.parent.data.pendingInsert = queue;
+    } else {
+      for (var i = 0; i < queue.length; ++i) {
+        queue[i].data.hook.insert(queue[i]);
+      }
+    }
+  }
+
+  var bailed = false;
+  // list of modules that can skip create hook during hydration because they
+  // are already rendered on the client or has no need for initialization
+  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
+
+  // Note: this is a browser-only function so we can assume elms are DOM nodes.
+  function hydrate (elm, vnode, insertedVnodeQueue) {
+    if (process.env.NODE_ENV !== 'production') {
+      if (!assertNodeMatch(elm, vnode)) {
+        return false
+      }
+    }
+    vnode.elm = elm;
+    var tag = vnode.tag;
+    var data = vnode.data;
+    var children = vnode.children;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
+      if (isDef(i = vnode.componentInstance)) {
+        // child component. it should have hydrated its own tree.
+        initComponent(vnode, insertedVnodeQueue);
+        return true
+      }
+    }
+    if (isDef(tag)) {
+      if (isDef(children)) {
+        // empty element, allow client to pick up and populate children
+        if (!elm.hasChildNodes()) {
+          createChildren(vnode, children, insertedVnodeQueue);
+        } else {
+          var childrenMatch = true;
+          var childNode = elm.firstChild;
+          for (var i$1 = 0; i$1 < children.length; i$1++) {
+            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
+              childrenMatch = false;
+              break
+            }
+            childNode = childNode.nextSibling;
+          }
+          // if childNode is not null, it means the actual childNodes list is
+          // longer than the virtual children list.
+          if (!childrenMatch || childNode) {
+            if (process.env.NODE_ENV !== 'production' &&
+                typeof console !== 'undefined' &&
+                !bailed) {
+              bailed = true;
+              console.warn('Parent: ', elm);
+              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
+            }
+            return false
+          }
+        }
+      }
+      if (isDef(data)) {
+        for (var key in data) {
+          if (!isRenderedModule(key)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue);
+            break
+          }
+        }
+      }
+    } else if (elm.data !== vnode.text) {
+      elm.data = vnode.text;
+    }
+    return true
+  }
+
+  function assertNodeMatch (node, vnode) {
+    if (vnode.tag) {
+      return (
+        vnode.tag.indexOf('vue-component') === 0 ||
+        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
+      )
+    } else {
+      return node.nodeType === (vnode.isComment ? 8 : 3)
+    }
+  }
+
+  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
+    if (!vnode) {
+      if (oldVnode) { invokeDestroyHook(oldVnode); }
+      return
+    }
+
+    var isInitialPatch = false;
+    var insertedVnodeQueue = [];
+
+    if (!oldVnode) {
+      // empty mount (likely as component), create new root element
+      isInitialPatch = true;
+      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
+    } else {
+      var isRealElement = isDef(oldVnode.nodeType);
+      if (!isRealElement && sameVnode(oldVnode, vnode)) {
+        // patch existing root node
+        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
+      } else {
+        if (isRealElement) {
+          // mounting to a real element
+          // check if this is server-rendered content and if we can perform
+          // a successful hydration.
+          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
+            oldVnode.removeAttribute('server-rendered');
+            hydrating = true;
+          }
+          if (hydrating) {
+            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
+              invokeInsertHook(vnode, insertedVnodeQueue, true);
+              return oldVnode
+            } else if (process.env.NODE_ENV !== 'production') {
+              warn(
+                'The client-side rendered virtual DOM tree is not matching ' +
+                'server-rendered content. This is likely caused by incorrect ' +
+                'HTML markup, for example nesting block-level elements inside ' +
+                '<p>, or missing <tbody>. Bailing hydration and performing ' +
+                'full client-side render.'
+              );
+            }
+          }
+          // either not server-rendered, or hydration failed.
+          // create an empty node and replace it
+          oldVnode = emptyNodeAt(oldVnode);
+        }
+        // replacing existing element
+        var oldElm = oldVnode.elm;
+        var parentElm$1 = nodeOps.parentNode(oldElm);
+        createElm(
+          vnode,
+          insertedVnodeQueue,
+          // extremely rare edge case: do not insert if old element is in a
+          // leaving transition. Only happens when combining transition +
+          // keep-alive + HOCs. (#4590)
+          oldElm._leaveCb ? null : parentElm$1,
+          nodeOps.nextSibling(oldElm)
+        );
+
+        if (vnode.parent) {
+          // component root element replaced.
+          // update parent placeholder node element, recursively
+          var ancestor = vnode.parent;
+          while (ancestor) {
+            ancestor.elm = vnode.elm;
+            ancestor = ancestor.parent;
+          }
+          if (isPatchable(vnode)) {
+            for (var i = 0; i < cbs.create.length; ++i) {
+              cbs.create[i](emptyNode, vnode.parent);
+            }
+          }
+        }
+
+        if (parentElm$1 !== null) {
+          removeVnodes(parentElm$1, [oldVnode], 0, 0);
+        } else if (isDef(oldVnode.tag)) {
+          invokeDestroyHook(oldVnode);
+        }
+      }
+    }
+
+    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
+    return vnode.elm
+  }
+}
+
+/*  */
+
+var directives = {
+  create: updateDirectives,
+  update: updateDirectives,
+  destroy: function unbindDirectives (vnode) {
+    updateDirectives(vnode, emptyNode);
+  }
+};
+
+function updateDirectives (oldVnode, vnode) {
+  if (oldVnode.data.directives || vnode.data.directives) {
+    _update(oldVnode, vnode);
+  }
+}
+
+function _update (oldVnode, vnode) {
+  var isCreate = oldVnode === emptyNode;
+  var isDestroy = vnode === emptyNode;
+  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
+  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
+
+  var dirsWithInsert = [];
+  var dirsWithPostpatch = [];
+
+  var key, oldDir, dir;
+  for (key in newDirs) {
+    oldDir = oldDirs[key];
+    dir = newDirs[key];
+    if (!oldDir) {
+      // new directive, bind
+      callHook$1(dir, 'bind', vnode, oldVnode);
+      if (dir.def && dir.def.inserted) {
+        dirsWithInsert.push(dir);
+      }
+    } else {
+      // existing directive, update
+      dir.oldValue = oldDir.value;
+      callHook$1(dir, 'update', vnode, oldVnode);
+      if (dir.def && dir.def.componentUpdated) {
+        dirsWithPostpatch.push(dir);
+      }
+    }
+  }
+
+  if (dirsWithInsert.length) {
+    var callInsert = function () {
+      for (var i = 0; i < dirsWithInsert.length; i++) {
+        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
+      }
+    };
+    if (isCreate) {
+      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
+    } else {
+      callInsert();
+    }
+  }
+
+  if (dirsWithPostpatch.length) {
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
+      for (var i = 0; i < dirsWithPostpatch.length; i++) {
+        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
+      }
+    });
+  }
+
+  if (!isCreate) {
+    for (key in oldDirs) {
+      if (!newDirs[key]) {
+        // no longer present, unbind
+        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
+      }
+    }
+  }
+}
+
+var emptyModifiers = Object.create(null);
+
+function normalizeDirectives$1 (
+  dirs,
+  vm
+) {
+  var res = Object.create(null);
+  if (!dirs) {
+    return res
+  }
+  var i, dir;
+  for (i = 0; i < dirs.length; i++) {
+    dir = dirs[i];
+    if (!dir.modifiers) {
+      dir.modifiers = emptyModifiers;
+    }
+    res[getRawDirName(dir)] = dir;
+    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
+  }
+  return res
+}
+
+function getRawDirName (dir) {
+  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
+}
+
+function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
+  var fn = dir.def && dir.def[hook];
+  if (fn) {
+    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
+  }
+}
+
+var baseModules = [
+  ref,
+  directives
+];
+
+/*  */
+
+function updateAttrs (oldVnode, vnode) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  var key, cur, old;
+  var elm = vnode.elm;
+  var oldAttrs = oldVnode.data.attrs || {};
+  var attrs = vnode.data.attrs || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs);
+  }
+
+  for (key in attrs) {
+    cur = attrs[key];
+    old = oldAttrs[key];
+    if (old !== cur) {
+      setAttr(elm, key, cur);
+    }
+  }
+  // #4391: in IE9, setting type can reset value for input[type=radio]
+  /* istanbul ignore if */
+  if (isIE9 && attrs.value !== oldAttrs.value) {
+    setAttr(elm, 'value', attrs.value);
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      if (isXlink(key)) {
+        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
+      } else if (!isEnumeratedAttr(key)) {
+        elm.removeAttribute(key);
+      }
+    }
+  }
+}
+
+function setAttr (el, key, value) {
+  if (isBooleanAttr(key)) {
+    // set attribute for blank value
+    // e.g. <option disabled>Select one</option>
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, key);
+    }
+  } else if (isEnumeratedAttr(key)) {
+    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
+  } else if (isXlink(key)) {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
+    } else {
+      el.setAttributeNS(xlinkNS, key, value);
+    }
+  } else {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, value);
+    }
+  }
+}
+
+var attrs = {
+  create: updateAttrs,
+  update: updateAttrs
+};
+
+/*  */
+
+function updateClass (oldVnode, vnode) {
+  var el = vnode.elm;
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  var cls = genClassForVnode(vnode);
+
+  // handle transition classes
+  var transitionClass = el._transitionClasses;
+  if (transitionClass) {
+    cls = concat(cls, stringifyClass(transitionClass));
+  }
+
+  // set the class
+  if (cls !== el._prevClass) {
+    el.setAttribute('class', cls);
+    el._prevClass = cls;
+  }
+}
+
+var klass = {
+  create: updateClass,
+  update: updateClass
+};
+
+/*  */
+
+var validDivisionCharRE = /[\w).+\-_$\]]/;
+
+function parseFilters (exp) {
+  var inSingle = false;
+  var inDouble = false;
+  var inTemplateString = false;
+  var inRegex = false;
+  var curly = 0;
+  var square = 0;
+  var paren = 0;
+  var lastFilterIndex = 0;
+  var c, prev, i, expression, filters;
+
+  for (i = 0; i < exp.length; i++) {
+    prev = c;
+    c = exp.charCodeAt(i);
+    if (inSingle) {
+      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
+    } else if (inDouble) {
+      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
+    } else if (inTemplateString) {
+      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
+    } else if (inRegex) {
+      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
+    } else if (
+      c === 0x7C && // pipe
+      exp.charCodeAt(i + 1) !== 0x7C &&
+      exp.charCodeAt(i - 1) !== 0x7C &&
+      !curly && !square && !paren
+    ) {
+      if (expression === undefined) {
+        // first filter, end of expression
+        lastFilterIndex = i + 1;
+        expression = exp.slice(0, i).trim();
+      } else {
+        pushFilter();
+      }
+    } else {
+      switch (c) {
+        case 0x22: inDouble = true; break         // "
+        case 0x27: inSingle = true; break         // '
+        case 0x60: inTemplateString = true; break // `
+        case 0x28: paren++; break                 // (
+        case 0x29: paren--; break                 // )
+        case 0x5B: square++; break                // [
+        case 0x5D: square--; break                // ]
+        case 0x7B: curly++; break                 // {
+        case 0x7D: curly--; break                 // }
+      }
+      if (c === 0x2f) { // /
+        var j = i - 1;
+        var p = (void 0);
+        // find first non-whitespace prev char
+        for (; j >= 0; j--) {
+          p = exp.charAt(j);
+          if (p !== ' ') { break }
+        }
+        if (!p || !validDivisionCharRE.test(p)) {
+          inRegex = true;
+        }
+      }
+    }
+  }
+
+  if (expression === undefined) {
+    expression = exp.slice(0, i).trim();
+  } else if (lastFilterIndex !== 0) {
+    pushFilter();
+  }
+
+  function pushFilter () {
+    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
+    lastFilterIndex = i + 1;
+  }
+
+  if (filters) {
+    for (i = 0; i < filters.length; i++) {
+      expression = wrapFilter(expression, filters[i]);
+    }
+  }
+
+  return expression
+}
+
+function wrapFilter (exp, filter) {
+  var i = filter.indexOf('(');
+  if (i < 0) {
+    // _f: resolveFilter
+    return ("_f(\"" + filter + "\")(" + exp + ")")
+  } else {
+    var name = filter.slice(0, i);
+    var args = filter.slice(i + 1);
+    return ("_f(\"" + name + "\")(" + exp + "," + args)
+  }
+}
+
+/*  */
+
+function baseWarn (msg) {
+  console.error(("[Vue compiler]: " + msg));
+}
+
+function pluckModuleFunction (
+  modules,
+  key
+) {
+  return modules
+    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
+    : []
+}
+
+function addProp (el, name, value) {
+  (el.props || (el.props = [])).push({ name: name, value: value });
+}
+
+function addAttr (el, name, value) {
+  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
+}
+
+function addDirective (
+  el,
+  name,
+  rawName,
+  value,
+  arg,
+  modifiers
+) {
+  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
+}
+
+function addHandler (
+  el,
+  name,
+  value,
+  modifiers,
+  important
+) {
+  // check capture modifier
+  if (modifiers && modifiers.capture) {
+    delete modifiers.capture;
+    name = '!' + name; // mark the event as captured
+  }
+  if (modifiers && modifiers.once) {
+    delete modifiers.once;
+    name = '~' + name; // mark the event as once
+  }
+  var events;
+  if (modifiers && modifiers.native) {
+    delete modifiers.native;
+    events = el.nativeEvents || (el.nativeEvents = {});
+  } else {
+    events = el.events || (el.events = {});
+  }
+  var newHandler = { value: value, modifiers: modifiers };
+  var handlers = events[name];
+  /* istanbul ignore if */
+  if (Array.isArray(handlers)) {
+    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
+  } else if (handlers) {
+    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
+  } else {
+    events[name] = newHandler;
+  }
+}
+
+function getBindingAttr (
+  el,
+  name,
+  getStatic
+) {
+  var dynamicValue =
+    getAndRemoveAttr(el, ':' + name) ||
+    getAndRemoveAttr(el, 'v-bind:' + name);
+  if (dynamicValue != null) {
+    return parseFilters(dynamicValue)
+  } else if (getStatic !== false) {
+    var staticValue = getAndRemoveAttr(el, name);
+    if (staticValue != null) {
+      return JSON.stringify(staticValue)
+    }
+  }
+}
+
+function getAndRemoveAttr (el, name) {
+  var val;
+  if ((val = el.attrsMap[name]) != null) {
+    var list = el.attrsList;
+    for (var i = 0, l = list.length; i < l; i++) {
+      if (list[i].name === name) {
+        list.splice(i, 1);
+        break
+      }
+    }
+  }
+  return val
+}
+
+/*  */
+
+/**
+ * Cross-platform code generation for component v-model
+ */
+function genComponentModel (
+  el,
+  value,
+  modifiers
+) {
+  var ref = modifiers || {};
+  var number = ref.number;
+  var trim = ref.trim;
+
+  var baseValueExpression = '$$v';
+  var valueExpression = baseValueExpression;
+  if (trim) {
+    valueExpression =
+      "(typeof " + baseValueExpression + " === 'string'" +
+        "? " + baseValueExpression + ".trim()" +
+        ": " + baseValueExpression + ")";
+  }
+  if (number) {
+    valueExpression = "_n(" + valueExpression + ")";
+  }
+  var assignment = genAssignmentCode(value, valueExpression);
+
+  el.model = {
+    value: ("(" + value + ")"),
+    expression: ("\"" + value + "\""),
+    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
+  };
+}
+
+/**
+ * Cross-platform codegen helper for generating v-model value assignment code.
+ */
+function genAssignmentCode (
+  value,
+  assignment
+) {
+  var modelRs = parseModel(value);
+  if (modelRs.idx === null) {
+    return (value + "=" + assignment)
+  } else {
+    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
+      "if (!Array.isArray($$exp)){" +
+        value + "=" + assignment + "}" +
+      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
+  }
+}
+
+/**
+ * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
+ *
+ * for loop possible cases:
+ *
+ * - test
+ * - test[idx]
+ * - test[test1[idx]]
+ * - test["a"][idx]
+ * - xxx.test[a[a].test1[idx]]
+ * - test.xxx.a["asa"][test1[idx]]
+ *
+ */
+
+var len;
+var str;
+var chr;
+var index$1;
+var expressionPos;
+var expressionEndPos;
+
+function parseModel (val) {
+  str = val;
+  len = str.length;
+  index$1 = expressionPos = expressionEndPos = 0;
+
+  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
+    return {
+      exp: val,
+      idx: null
+    }
+  }
+
+  while (!eof()) {
+    chr = next();
+    /* istanbul ignore if */
+    if (isStringStart(chr)) {
+      parseString(chr);
+    } else if (chr === 0x5B) {
+      parseBracket(chr);
+    }
+  }
+
+  return {
+    exp: val.substring(0, expressionPos),
+    idx: val.substring(expressionPos + 1, expressionEndPos)
+  }
+}
+
+function next () {
+  return str.charCodeAt(++index$1)
+}
+
+function eof () {
+  return index$1 >= len
+}
+
+function isStringStart (chr) {
+  return chr === 0x22 || chr === 0x27
+}
+
+function parseBracket (chr) {
+  var inBracket = 1;
+  expressionPos = index$1;
+  while (!eof()) {
+    chr = next();
+    if (isStringStart(chr)) {
+      parseString(chr);
+      continue
+    }
+    if (chr === 0x5B) { inBracket++; }
+    if (chr === 0x5D) { inBracket--; }
+    if (inBracket === 0) {
+      expressionEndPos = index$1;
+      break
+    }
+  }
+}
+
+function parseString (chr) {
+  var stringQuote = chr;
+  while (!eof()) {
+    chr = next();
+    if (chr === stringQuote) {
+      break
+    }
+  }
+}
+
+/*  */
+
+var warn$1;
+
+// in some cases, the event used has to be determined at runtime
+// so we used some reserved tokens during compile.
+var RANGE_TOKEN = '__r';
+var CHECKBOX_RADIO_TOKEN = '__c';
+
+function model (
+  el,
+  dir,
+  _warn
+) {
+  warn$1 = _warn;
+  var value = dir.value;
+  var modifiers = dir.modifiers;
+  var tag = el.tag;
+  var type = el.attrsMap.type;
+
+  if (process.env.NODE_ENV !== 'production') {
+    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
+    if (tag === 'input' && dynamicType) {
+      warn$1(
+        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
+        "v-model does not support dynamic input types. Use v-if branches instead."
+      );
+    }
+    // inputs with type="file" are read only and setting the input's
+    // value will throw an error.
+    if (tag === 'input' && type === 'file') {
+      warn$1(
+        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
+        "File inputs are read only. Use a v-on:change listener instead."
+      );
+    }
+  }
+
+  if (tag === 'select') {
+    genSelect(el, value, modifiers);
+  } else if (tag === 'input' && type === 'checkbox') {
+    genCheckboxModel(el, value, modifiers);
+  } else if (tag === 'input' && type === 'radio') {
+    genRadioModel(el, value, modifiers);
+  } else if (tag === 'input' || tag === 'textarea') {
+    genDefaultModel(el, value, modifiers);
+  } else if (!config.isReservedTag(tag)) {
+    genComponentModel(el, value, modifiers);
+    // component v-model doesn't need extra runtime
+    return false
+  } else if (process.env.NODE_ENV !== 'production') {
+    warn$1(
+      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
+      "v-model is not supported on this element type. " +
+      'If you are working with contenteditable, it\'s recommended to ' +
+      'wrap a library dedicated for that purpose inside a custom component.'
+    );
+  }
+
+  // ensure runtime directive metadata
+  return true
+}
+
+function genCheckboxModel (
+  el,
+  value,
+  modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var valueBinding = getBindingAttr(el, 'value') || 'null';
+  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
+  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
+  addProp(el, 'checked',
+    "Array.isArray(" + value + ")" +
+      "?_i(" + value + "," + valueBinding + ")>-1" + (
+        trueValueBinding === 'true'
+          ? (":(" + value + ")")
+          : (":_q(" + value + "," + trueValueBinding + ")")
+      )
+  );
+  addHandler(el, CHECKBOX_RADIO_TOKEN,
+    "var $$a=" + value + "," +
+        '$$el=$event.target,' +
+        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
+    'if(Array.isArray($$a)){' +
+      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
+          '$$i=_i($$a,$$v);' +
+      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
+      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
+    "}else{" + value + "=$$c}",
+    null, true
+  );
+}
+
+function genRadioModel (
+    el,
+    value,
+    modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var valueBinding = getBindingAttr(el, 'value') || 'null';
+  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
+  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
+  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
+}
+
+function genSelect (
+    el,
+    value,
+    modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var selectedVal = "Array.prototype.filter" +
+    ".call($event.target.options,function(o){return o.selected})" +
+    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
+    "return " + (number ? '_n(val)' : 'val') + "})";
+
+  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
+  var code = "var $$selectedVal = " + selectedVal + ";";
+  code = code + " " + (genAssignmentCode(value, assignment));
+  addHandler(el, 'change', code, null, true);
+}
+
+function genDefaultModel (
+  el,
+  value,
+  modifiers
+) {
+  var type = el.attrsMap.type;
+  var ref = modifiers || {};
+  var lazy = ref.lazy;
+  var number = ref.number;
+  var trim = ref.trim;
+  var needCompositionGuard = !lazy && type !== 'range';
+  var event = lazy
+    ? 'change'
+    : type === 'range'
+      ? RANGE_TOKEN
+      : 'input';
+
+  var valueExpression = '$event.target.value';
+  if (trim) {
+    valueExpression = "$event.target.value.trim()";
+  }
+  if (number) {
+    valueExpression = "_n(" + valueExpression + ")";
+  }
+
+  var code = genAssignmentCode(value, valueExpression);
+  if (needCompositionGuard) {
+    code = "if($event.target.composing)return;" + code;
+  }
+
+  addProp(el, 'value', ("(" + value + ")"));
+  addHandler(el, event, code, null, true);
+  if (trim || number || type === 'number') {
+    addHandler(el, 'blur', '$forceUpdate()');
+  }
+}
+
+/*  */
+
+// normalize v-model event tokens that can only be determined at runtime.
+// it's important to place the event as the first in the array because
+// the whole point is ensuring the v-model callback gets called before
+// user-attached handlers.
+function normalizeEvents (on) {
+  var event;
+  /* istanbul ignore if */
+  if (on[RANGE_TOKEN]) {
+    // IE input[type=range] only supports `change` event
+    event = isIE ? 'change' : 'input';
+    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
+    delete on[RANGE_TOKEN];
+  }
+  if (on[CHECKBOX_RADIO_TOKEN]) {
+    // Chrome fires microtasks in between click/change, leads to #4521
+    event = isChrome ? 'click' : 'change';
+    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
+    delete on[CHECKBOX_RADIO_TOKEN];
+  }
+}
+
+var target$1;
+
+function add$1 (
+  event,
+  handler,
+  once,
+  capture
+) {
+  if (once) {
+    var oldHandler = handler;
+    var _target = target$1; // save current target element in closure
+    handler = function (ev) {
+      var res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments);
+      if (res !== null) {
+        remove$2(event, handler, capture, _target);
+      }
+    };
+  }
+  target$1.addEventListener(event, handler, capture);
+}
+
+function remove$2 (
+  event,
+  handler,
+  capture,
+  _target
+) {
+  (_target || target$1).removeEventListener(event, handler, capture);
+}
+
+function updateDOMListeners (oldVnode, vnode) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  var on = vnode.data.on || {};
+  var oldOn = oldVnode.data.on || {};
+  target$1 = vnode.elm;
+  normalizeEvents(on);
+  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
+}
+
+var events = {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+};
+
+/*  */
+
+function updateDOMProps (oldVnode, vnode) {
+  if (!oldVnode.data.domProps && !vnode.data.domProps) {
+    return
+  }
+  var key, cur;
+  var elm = vnode.elm;
+  var oldProps = oldVnode.data.domProps || {};
+  var props = vnode.data.domProps || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (props.__ob__) {
+    props = vnode.data.domProps = extend({}, props);
+  }
+
+  for (key in oldProps) {
+    if (props[key] == null) {
+      elm[key] = '';
+    }
+  }
+  for (key in props) {
+    cur = props[key];
+    // ignore children if the node has textContent or innerHTML,
+    // as these will throw away existing DOM nodes and cause removal errors
+    // on subsequent patches (#3360)
+    if (key === 'textContent' || key === 'innerHTML') {
+      if (vnode.children) { vnode.children.length = 0; }
+      if (cur === oldProps[key]) { continue }
+    }
+
+    if (key === 'value') {
+      // store value as _value as well since
+      // non-string values will be stringified
+      elm._value = cur;
+      // avoid resetting cursor position when value is the same
+      var strCur = cur == null ? '' : String(cur);
+      if (shouldUpdateValue(elm, vnode, strCur)) {
+        elm.value = strCur;
+      }
+    } else {
+      elm[key] = cur;
+    }
+  }
+}
+
+// check platforms/web/util/attrs.js acceptValue
+
+
+function shouldUpdateValue (
+  elm,
+  vnode,
+  checkVal
+) {
+  return (!elm.composing && (
+    vnode.tag === 'option' ||
+    isDirty(elm, checkVal) ||
+    isInputChanged(elm, checkVal)
+  ))
+}
+
+function isDirty (elm, checkVal) {
+  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
+  return document.activeElement !== elm && elm.value !== checkVal
+}
+
+function isInputChanged (elm, newVal) {
+  var value = elm.value;
+  var modifiers = elm._vModifiers; // injected by v-model runtime
+  if ((modifiers && modifiers.number) || elm.type === 'number') {
+    return toNumber(value) !== toNumber(newVal)
+  }
+  if (modifiers && modifiers.trim) {
+    return value.trim() !== newVal.trim()
+  }
+  return value !== newVal
+}
+
+var domProps = {
+  create: updateDOMProps,
+  update: updateDOMProps
+};
+
+/*  */
+
+var parseStyleText = cached(function (cssText) {
+  var res = {};
+  var listDelimiter = /;(?![^(]*\))/g;
+  var propertyDelimiter = /:(.+)/;
+  cssText.split(listDelimiter).forEach(function (item) {
+    if (item) {
+      var tmp = item.split(propertyDelimiter);
+      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
+    }
+  });
+  return res
+});
+
+// merge static and dynamic style data on the same vnode
+function normalizeStyleData (data) {
+  var style = normalizeStyleBinding(data.style);
+  // static style is pre-processed into an object during compilation
+  // and is always a fresh object, so it's safe to merge into it
+  return data.staticStyle
+    ? extend(data.staticStyle, style)
+    : style
+}
+
+// normalize possible array / string values into Object
+function normalizeStyleBinding (bindingStyle) {
+  if (Array.isArray(bindingStyle)) {
+    return toObject(bindingStyle)
+  }
+  if (typeof bindingStyle === 'string') {
+    return parseStyleText(bindingStyle)
+  }
+  return bindingStyle
+}
+
+/**
+ * parent component style should be after child's
+ * so that parent component's style could override it
+ */
+function getStyle (vnode, checkChild) {
+  var res = {};
+  var styleData;
+
+  if (checkChild) {
+    var childNode = vnode;
+    while (childNode.componentInstance) {
+      childNode = childNode.componentInstance._vnode;
+      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
+        extend(res, styleData);
+      }
+    }
+  }
+
+  if ((styleData = normalizeStyleData(vnode.data))) {
+    extend(res, styleData);
+  }
+
+  var parentNode = vnode;
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
+      extend(res, styleData);
+    }
+  }
+  return res
+}
+
+/*  */
+
+var cssVarRE = /^--/;
+var importantRE = /\s*!important$/;
+var setProp = function (el, name, val) {
+  /* istanbul ignore if */
+  if (cssVarRE.test(name)) {
+    el.style.setProperty(name, val);
+  } else if (importantRE.test(val)) {
+    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
+  } else {
+    el.style[normalize(name)] = val;
+  }
+};
+
+var prefixes = ['Webkit', 'Moz', 'ms'];
+
+var testEl;
+var normalize = cached(function (prop) {
+  testEl = testEl || document.createElement('div');
+  prop = camelize(prop);
+  if (prop !== 'filter' && (prop in testEl.style)) {
+    return prop
+  }
+  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
+  for (var i = 0; i < prefixes.length; i++) {
+    var prefixed = prefixes[i] + upper;
+    if (prefixed in testEl.style) {
+      return prefixed
+    }
+  }
+});
+
+function updateStyle (oldVnode, vnode) {
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+
+  if (!data.staticStyle && !data.style &&
+      !oldData.staticStyle && !oldData.style) {
+    return
+  }
+
+  var cur, name;
+  var el = vnode.elm;
+  var oldStaticStyle = oldVnode.data.staticStyle;
+  var oldStyleBinding = oldVnode.data.style || {};
+
+  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
+  var oldStyle = oldStaticStyle || oldStyleBinding;
+
+  var style = normalizeStyleBinding(vnode.data.style) || {};
+
+  vnode.data.style = style.__ob__ ? extend({}, style) : style;
+
+  var newStyle = getStyle(vnode, true);
+
+  for (name in oldStyle) {
+    if (newStyle[name] == null) {
+      setProp(el, name, '');
+    }
+  }
+  for (name in newStyle) {
+    cur = newStyle[name];
+    if (cur !== oldStyle[name]) {
+      // ie9 setting to null has no effect, must use empty string
+      setProp(el, name, cur == null ? '' : cur);
+    }
+  }
+}
+
+var style = {
+  create: updateStyle,
+  update: updateStyle
+};
+
+/*  */
+
+/**
+ * Add class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function addClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
+    } else {
+      el.classList.add(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    if (cur.indexOf(' ' + cls + ' ') < 0) {
+      el.setAttribute('class', (cur + cls).trim());
+    }
+  }
+}
+
+/**
+ * Remove class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function removeClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
+    } else {
+      el.classList.remove(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    var tar = ' ' + cls + ' ';
+    while (cur.indexOf(tar) >= 0) {
+      cur = cur.replace(tar, ' ');
+    }
+    el.setAttribute('class', cur.trim());
+  }
+}
+
+/*  */
+
+function resolveTransition (def$$1) {
+  if (!def$$1) {
+    return
+  }
+  /* istanbul ignore else */
+  if (typeof def$$1 === 'object') {
+    var res = {};
+    if (def$$1.css !== false) {
+      extend(res, autoCssTransition(def$$1.name || 'v'));
+    }
+    extend(res, def$$1);
+    return res
+  } else if (typeof def$$1 === 'string') {
+    return autoCssTransition(def$$1)
+  }
+}
+
+var autoCssTransition = cached(function (name) {
+  return {
+    enterClass: (name + "-enter"),
+    enterToClass: (name + "-enter-to"),
+    enterActiveClass: (name + "-enter-active"),
+    leaveClass: (name + "-leave"),
+    leaveToClass: (name + "-leave-to"),
+    leaveActiveClass: (name + "-leave-active")
+  }
+});
+
+var hasTransition = inBrowser && !isIE9;
+var TRANSITION = 'transition';
+var ANIMATION = 'animation';
+
+// Transition property/event sniffing
+var transitionProp = 'transition';
+var transitionEndEvent = 'transitionend';
+var animationProp = 'animation';
+var animationEndEvent = 'animationend';
+if (hasTransition) {
+  /* istanbul ignore if */
+  if (window.ontransitionend === undefined &&
+    window.onwebkittransitionend !== undefined) {
+    transitionProp = 'WebkitTransition';
+    transitionEndEvent = 'webkitTransitionEnd';
+  }
+  if (window.onanimationend === undefined &&
+    window.onwebkitanimationend !== undefined) {
+    animationProp = 'WebkitAnimation';
+    animationEndEvent = 'webkitAnimationEnd';
+  }
+}
+
+// binding to window is necessary to make hot reload work in IE in strict mode
+var raf = inBrowser && window.requestAnimationFrame
+  ? window.requestAnimationFrame.bind(window)
+  : setTimeout;
+
+function nextFrame (fn) {
+  raf(function () {
+    raf(fn);
+  });
+}
+
+function addTransitionClass (el, cls) {
+  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
+  addClass(el, cls);
+}
+
+function removeTransitionClass (el, cls) {
+  if (el._transitionClasses) {
+    remove(el._transitionClasses, cls);
+  }
+  removeClass(el, cls);
+}
+
+function whenTransitionEnds (
+  el,
+  expectedType,
+  cb
+) {
+  var ref = getTransitionInfo(el, expectedType);
+  var type = ref.type;
+  var timeout = ref.timeout;
+  var propCount = ref.propCount;
+  if (!type) { return cb() }
+  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
+  var ended = 0;
+  var end = function () {
+    el.removeEventListener(event, onEnd);
+    cb();
+  };
+  var onEnd = function (e) {
+    if (e.target === el) {
+      if (++ended >= propCount) {
+        end();
+      }
+    }
+  };
+  setTimeout(function () {
+    if (ended < propCount) {
+      end();
+    }
+  }, timeout + 1);
+  el.addEventListener(event, onEnd);
+}
+
+var transformRE = /\b(transform|all)(,|$)/;
+
+function getTransitionInfo (el, expectedType) {
+  var styles = window.getComputedStyle(el);
+  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
+  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
+  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
+  var animationDelays = styles[animationProp + 'Delay'].split(', ');
+  var animationDurations = styles[animationProp + 'Duration'].split(', ');
+  var animationTimeout = getTimeout(animationDelays, animationDurations);
+
+  var type;
+  var timeout = 0;
+  var propCount = 0;
+  /* istanbul ignore if */
+  if (expectedType === TRANSITION) {
+    if (transitionTimeout > 0) {
+      type = TRANSITION;
+      timeout = transitionTimeout;
+      propCount = transitionDurations.length;
+    }
+  } else if (expectedType === ANIMATION) {
+    if (animationTimeout > 0) {
+      type = ANIMATION;
+      timeout = animationTimeout;
+      propCount = animationDurations.length;
+    }
+  } else {
+    timeout = Math.max(transitionTimeout, animationTimeout);
+    type = timeout > 0
+      ? transitionTimeout > animationTimeout
+        ? TRANSITION
+        : ANIMATION
+      : null;
+    propCount = type
+      ? type === TRANSITION
+        ? transitionDurations.length
+        : animationDurations.length
+      : 0;
+  }
+  var hasTransform =
+    type === TRANSITION &&
+    transformRE.test(styles[transitionProp + 'Property']);
+  return {
+    type: type,
+    timeout: timeout,
+    propCount: propCount,
+    hasTransform: hasTransform
+  }
+}
+
+function getTimeout (delays, durations) {
+  /* istanbul ignore next */
+  while (delays.length < durations.length) {
+    delays = delays.concat(delays);
+  }
+
+  return Math.max.apply(null, durations.map(function (d, i) {
+    return toMs(d) + toMs(delays[i])
+  }))
+}
+
+function toMs (s) {
+  return Number(s.slice(0, -1)) * 1000
+}
+
+/*  */
+
+function enter (vnode, toggleDisplay) {
+  var el = vnode.elm;
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true;
+    el._leaveCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var enterClass = data.enterClass;
+  var enterToClass = data.enterToClass;
+  var enterActiveClass = data.enterActiveClass;
+  var appearClass = data.appearClass;
+  var appearToClass = data.appearToClass;
+  var appearActiveClass = data.appearActiveClass;
+  var beforeEnter = data.beforeEnter;
+  var enter = data.enter;
+  var afterEnter = data.afterEnter;
+  var enterCancelled = data.enterCancelled;
+  var beforeAppear = data.beforeAppear;
+  var appear = data.appear;
+  var afterAppear = data.afterAppear;
+  var appearCancelled = data.appearCancelled;
+  var duration = data.duration;
+
+  // activeInstance will always be the <transition> component managing this
+  // transition. One edge case to check is when the <transition> is placed
+  // as the root node of a child component. In that case we need to check
+  // <transition>'s parent for appear check.
+  var context = activeInstance;
+  var transitionNode = activeInstance.$vnode;
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent;
+    context = transitionNode.context;
+  }
+
+  var isAppear = !context._isMounted || !vnode.isRootInsert;
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  var startClass = isAppear && appearClass
+    ? appearClass
+    : enterClass;
+  var activeClass = isAppear && appearActiveClass
+    ? appearActiveClass
+    : enterActiveClass;
+  var toClass = isAppear && appearToClass
+    ? appearToClass
+    : enterToClass;
+
+  var beforeEnterHook = isAppear
+    ? (beforeAppear || beforeEnter)
+    : beforeEnter;
+  var enterHook = isAppear
+    ? (typeof appear === 'function' ? appear : enter)
+    : enter;
+  var afterEnterHook = isAppear
+    ? (afterAppear || afterEnter)
+    : afterEnter;
+  var enterCancelledHook = isAppear
+    ? (appearCancelled || enterCancelled)
+    : enterCancelled;
+
+  var explicitEnterDuration = toNumber(
+    isObject(duration)
+      ? duration.enter
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
+    checkDuration(explicitEnterDuration, 'enter', vnode);
+  }
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(enterHook);
+
+  var cb = el._enterCb = once(function () {
+    if (expectsCSS) {
+      removeTransitionClass(el, toClass);
+      removeTransitionClass(el, activeClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, startClass);
+      }
+      enterCancelledHook && enterCancelledHook(el);
+    } else {
+      afterEnterHook && afterEnterHook(el);
+    }
+    el._enterCb = null;
+  });
+
+  if (!vnode.data.show) {
+    // remove pending leave element on enter by injecting an insert hook
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
+      var parent = el.parentNode;
+      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
+      if (pendingNode &&
+          pendingNode.tag === vnode.tag &&
+          pendingNode.elm._leaveCb) {
+        pendingNode.elm._leaveCb();
+      }
+      enterHook && enterHook(el, cb);
+    });
+  }
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el);
+  if (expectsCSS) {
+    addTransitionClass(el, startClass);
+    addTransitionClass(el, activeClass);
+    nextFrame(function () {
+      addTransitionClass(el, toClass);
+      removeTransitionClass(el, startClass);
+      if (!cb.cancelled && !userWantsControl) {
+        if (isValidDuration(explicitEnterDuration)) {
+          setTimeout(cb, explicitEnterDuration);
+        } else {
+          whenTransitionEnds(el, type, cb);
+        }
+      }
+    });
+  }
+
+  if (vnode.data.show) {
+    toggleDisplay && toggleDisplay();
+    enterHook && enterHook(el, cb);
+  }
+
+  if (!expectsCSS && !userWantsControl) {
+    cb();
+  }
+}
+
+function leave (vnode, rm) {
+  var el = vnode.elm;
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true;
+    el._enterCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return rm()
+  }
+
+  /* istanbul ignore if */
+  if (el._leaveCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var leaveClass = data.leaveClass;
+  var leaveToClass = data.leaveToClass;
+  var leaveActiveClass = data.leaveActiveClass;
+  var beforeLeave = data.beforeLeave;
+  var leave = data.leave;
+  var afterLeave = data.afterLeave;
+  var leaveCancelled = data.leaveCancelled;
+  var delayLeave = data.delayLeave;
+  var duration = data.duration;
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(leave);
+
+  var explicitLeaveDuration = toNumber(
+    isObject(duration)
+      ? duration.leave
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
+    checkDuration(explicitLeaveDuration, 'leave', vnode);
+  }
+
+  var cb = el._leaveCb = once(function () {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null;
+    }
+    if (expectsCSS) {
+      removeTransitionClass(el, leaveToClass);
+      removeTransitionClass(el, leaveActiveClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, leaveClass);
+      }
+      leaveCancelled && leaveCancelled(el);
+    } else {
+      rm();
+      afterLeave && afterLeave(el);
+    }
+    el._leaveCb = null;
+  });
+
+  if (delayLeave) {
+    delayLeave(performLeave);
+  } else {
+    performLeave();
+  }
+
+  function performLeave () {
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
+    }
+    beforeLeave && beforeLeave(el);
+    if (expectsCSS) {
+      addTransitionClass(el, leaveClass);
+      addTransitionClass(el, leaveActiveClass);
+      nextFrame(function () {
+        addTransitionClass(el, leaveToClass);
+        removeTransitionClass(el, leaveClass);
+        if (!cb.cancelled && !userWantsControl) {
+          if (isValidDuration(explicitLeaveDuration)) {
+            setTimeout(cb, explicitLeaveDuration);
+          } else {
+            whenTransitionEnds(el, type, cb);
+          }
+        }
+      });
+    }
+    leave && leave(el, cb);
+    if (!expectsCSS && !userWantsControl) {
+      cb();
+    }
+  }
+}
+
+// only used in dev mode
+function checkDuration (val, name, vnode) {
+  if (typeof val !== 'number') {
+    warn(
+      "<transition> explicit " + name + " duration is not a valid number - " +
+      "got " + (JSON.stringify(val)) + ".",
+      vnode.context
+    );
+  } else if (isNaN(val)) {
+    warn(
+      "<transition> explicit " + name + " duration is NaN - " +
+      'the duration expression might be incorrect.',
+      vnode.context
+    );
+  }
+}
+
+function isValidDuration (val) {
+  return typeof val === 'number' && !isNaN(val)
+}
+
+/**
+ * Normalize a transition hook's argument length. The hook may be:
+ * - a merged hook (invoker) with the original in .fns
+ * - a wrapped component method (check ._length)
+ * - a plain function (.length)
+ */
+function getHookArgumentsLength (fn) {
+  if (!fn) { return false }
+  var invokerFns = fn.fns;
+  if (invokerFns) {
+    // invoker
+    return getHookArgumentsLength(
+      Array.isArray(invokerFns)
+        ? invokerFns[0]
+        : invokerFns
+    )
+  } else {
+    return (fn._length || fn.length) > 1
+  }
+}
+
+function _enter (_, vnode) {
+  if (!vnode.data.show) {
+    enter(vnode);
+  }
+}
+
+var transition = inBrowser ? {
+  create: _enter,
+  activate: _enter,
+  remove: function remove$$1 (vnode, rm) {
+    /* istanbul ignore else */
+    if (!vnode.data.show) {
+      leave(vnode, rm);
+    } else {
+      rm();
+    }
+  }
+} : {};
+
+var platformModules = [
+  attrs,
+  klass,
+  events,
+  domProps,
+  style,
+  transition
+];
+
+/*  */
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+var modules = platformModules.concat(baseModules);
+
+var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
+
+/**
+ * Not type checking this file because flow doesn't like attaching
+ * properties to Elements.
+ */
+
+/* istanbul ignore if */
+if (isIE9) {
+  // http://www.matts411.com/post/internet-explorer-9-oninput/
+  document.addEventListener('selectionchange', function () {
+    var el = document.activeElement;
+    if (el && el.vmodel) {
+      trigger(el, 'input');
+    }
+  });
+}
+
+var model$1 = {
+  inserted: function inserted (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      var cb = function () {
+        setSelected(el, binding, vnode.context);
+      };
+      cb();
+      /* istanbul ignore if */
+      if (isIE || isEdge) {
+        setTimeout(cb, 0);
+      }
+    } else if (vnode.tag === 'textarea' || el.type === 'text') {
+      el._vModifiers = binding.modifiers;
+      if (!binding.modifiers.lazy) {
+        if (!isAndroid) {
+          el.addEventListener('compositionstart', onCompositionStart);
+          el.addEventListener('compositionend', onCompositionEnd);
+        }
+        /* istanbul ignore if */
+        if (isIE9) {
+          el.vmodel = true;
+        }
+      }
+    }
+  },
+  componentUpdated: function componentUpdated (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      setSelected(el, binding, vnode.context);
+      // in case the options rendered by v-for have changed,
+      // it's possible that the value is out-of-sync with the rendered options.
+      // detect such cases and filter out values that no longer has a matching
+      // option in the DOM.
+      var needReset = el.multiple
+        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
+        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
+      if (needReset) {
+        trigger(el, 'change');
+      }
+    }
+  }
+};
+
+function setSelected (el, binding, vm) {
+  var value = binding.value;
+  var isMultiple = el.multiple;
+  if (isMultiple && !Array.isArray(value)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
+      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
+      vm
+    );
+    return
+  }
+  var selected, option;
+  for (var i = 0, l = el.options.length; i < l; i++) {
+    option = el.options[i];
+    if (isMultiple) {
+      selected = looseIndexOf(value, getValue(option)) > -1;
+      if (option.selected !== selected) {
+        option.selected = selected;
+      }
+    } else {
+      if (looseEqual(getValue(option), value)) {
+        if (el.selectedIndex !== i) {
+          el.selectedIndex = i;
+        }
+        return
+      }
+    }
+  }
+  if (!isMultiple) {
+    el.selectedIndex = -1;
+  }
+}
+
+function hasNoMatchingOption (value, options) {
+  for (var i = 0, l = options.length; i < l; i++) {
+    if (looseEqual(getValue(options[i]), value)) {
+      return false
+    }
+  }
+  return true
+}
+
+function getValue (option) {
+  return '_value' in option
+    ? option._value
+    : option.value
+}
+
+function onCompositionStart (e) {
+  e.target.composing = true;
+}
+
+function onCompositionEnd (e) {
+  e.target.composing = false;
+  trigger(e.target, 'input');
+}
+
+function trigger (el, type) {
+  var e = document.createEvent('HTMLEvents');
+  e.initEvent(type, true, true);
+  el.dispatchEvent(e);
+}
+
+/*  */
+
+// recursively search for possible transition defined inside the component root
+function locateNode (vnode) {
+  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
+    ? locateNode(vnode.componentInstance._vnode)
+    : vnode
+}
+
+var show = {
+  bind: function bind (el, ref, vnode) {
+    var value = ref.value;
+
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    var originalDisplay = el.__vOriginalDisplay =
+      el.style.display === 'none' ? '' : el.style.display;
+    if (value && transition && !isIE9) {
+      vnode.data.show = true;
+      enter(vnode, function () {
+        el.style.display = originalDisplay;
+      });
+    } else {
+      el.style.display = value ? originalDisplay : 'none';
+    }
+  },
+
+  update: function update (el, ref, vnode) {
+    var value = ref.value;
+    var oldValue = ref.oldValue;
+
+    /* istanbul ignore if */
+    if (value === oldValue) { return }
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    if (transition && !isIE9) {
+      vnode.data.show = true;
+      if (value) {
+        enter(vnode, function () {
+          el.style.display = el.__vOriginalDisplay;
+        });
+      } else {
+        leave(vnode, function () {
+          el.style.display = 'none';
+        });
+      }
+    } else {
+      el.style.display = value ? el.__vOriginalDisplay : 'none';
+    }
+  },
+
+  unbind: function unbind (
+    el,
+    binding,
+    vnode,
+    oldVnode,
+    isDestroy
+  ) {
+    if (!isDestroy) {
+      el.style.display = el.__vOriginalDisplay;
+    }
+  }
+};
+
+var platformDirectives = {
+  model: model$1,
+  show: show
+};
+
+/*  */
+
+// Provides transition support for a single element/component.
+// supports transition mode (out-in / in-out)
+
+var transitionProps = {
+  name: String,
+  appear: Boolean,
+  css: Boolean,
+  mode: String,
+  type: String,
+  enterClass: String,
+  leaveClass: String,
+  enterToClass: String,
+  leaveToClass: String,
+  enterActiveClass: String,
+  leaveActiveClass: String,
+  appearClass: String,
+  appearActiveClass: String,
+  appearToClass: String,
+  duration: [Number, String, Object]
+};
+
+// in case the child is also an abstract component, e.g. <keep-alive>
+// we want to recursively retrieve the real component to be rendered
+function getRealChild (vnode) {
+  var compOptions = vnode && vnode.componentOptions;
+  if (compOptions && compOptions.Ctor.options.abstract) {
+    return getRealChild(getFirstComponentChild(compOptions.children))
+  } else {
+    return vnode
+  }
+}
+
+function extractTransitionData (comp) {
+  var data = {};
+  var options = comp.$options;
+  // props
+  for (var key in options.propsData) {
+    data[key] = comp[key];
+  }
+  // events.
+  // extract listeners and pass them directly to the transition methods
+  var listeners = options._parentListeners;
+  for (var key$1 in listeners) {
+    data[camelize(key$1)] = listeners[key$1];
+  }
+  return data
+}
+
+function placeholder (h, rawChild) {
+  return /\d-keep-alive$/.test(rawChild.tag)
+    ? h('keep-alive')
+    : null
+}
+
+function hasParentTransition (vnode) {
+  while ((vnode = vnode.parent)) {
+    if (vnode.data.transition) {
+      return true
+    }
+  }
+}
+
+function isSameChild (child, oldChild) {
+  return oldChild.key === child.key && oldChild.tag === child.tag
+}
+
+var Transition = {
+  name: 'transition',
+  props: transitionProps,
+  abstract: true,
+
+  render: function render (h) {
+    var this$1 = this;
+
+    var children = this.$slots.default;
+    if (!children) {
+      return
+    }
+
+    // filter out text nodes (possible whitespaces)
+    children = children.filter(function (c) { return c.tag; });
+    /* istanbul ignore if */
+    if (!children.length) {
+      return
+    }
+
+    // warn multiple elements
+    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
+      warn(
+        '<transition> can only be used on a single element. Use ' +
+        '<transition-group> for lists.',
+        this.$parent
+      );
+    }
+
+    var mode = this.mode;
+
+    // warn invalid mode
+    if (process.env.NODE_ENV !== 'production' &&
+        mode && mode !== 'in-out' && mode !== 'out-in') {
+      warn(
+        'invalid <transition> mode: ' + mode,
+        this.$parent
+      );
+    }
+
+    var rawChild = children[0];
+
+    // if this is a component root node and the component's
+    // parent container node also has transition, skip.
+    if (hasParentTransition(this.$vnode)) {
+      return rawChild
+    }
+
+    // apply transition data to child
+    // use getRealChild() to ignore abstract components e.g. keep-alive
+    var child = getRealChild(rawChild);
+    /* istanbul ignore if */
+    if (!child) {
+      return rawChild
+    }
+
+    if (this._leaving) {
+      return placeholder(h, rawChild)
+    }
+
+    // ensure a key that is unique to the vnode type and to this transition
+    // component instance. This key will be used to remove pending leaving nodes
+    // during entering.
+    var id = "__transition-" + (this._uid) + "-";
+    child.key = child.key == null
+      ? id + child.tag
+      : isPrimitive(child.key)
+        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
+        : child.key;
+
+    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
+    var oldRawChild = this._vnode;
+    var oldChild = getRealChild(oldRawChild);
+
+    // mark v-show
+    // so that the transition module can hand over the control to the directive
+    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
+      child.data.show = true;
+    }
+
+    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
+      // replace old child transition data with fresh one
+      // important for dynamic transitions!
+      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
+      // handle transition mode
+      if (mode === 'out-in') {
+        // return placeholder node and queue update when leave finishes
+        this._leaving = true;
+        mergeVNodeHook(oldData, 'afterLeave', function () {
+          this$1._leaving = false;
+          this$1.$forceUpdate();
+        });
+        return placeholder(h, rawChild)
+      } else if (mode === 'in-out') {
+        var delayedLeave;
+        var performLeave = function () { delayedLeave(); };
+        mergeVNodeHook(data, 'afterEnter', performLeave);
+        mergeVNodeHook(data, 'enterCancelled', performLeave);
+        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
+      }
+    }
+
+    return rawChild
+  }
+};
+
+/*  */
+
+// Provides transition support for list items.
+// supports move transitions using the FLIP technique.
+
+// Because the vdom's children update algorithm is "unstable" - i.e.
+// it doesn't guarantee the relative positioning of removed elements,
+// we force transition-group to update its children into two passes:
+// in the first pass, we remove all nodes that need to be removed,
+// triggering their leaving transition; in the second pass, we insert/move
+// into the final desired state. This way in the second pass removed
+// nodes will remain where they should be.
+
+var props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps);
+
+delete props.mode;
+
+var TransitionGroup = {
+  props: props,
+
+  render: function render (h) {
+    var tag = this.tag || this.$vnode.data.tag || 'span';
+    var map = Object.create(null);
+    var prevChildren = this.prevChildren = this.children;
+    var rawChildren = this.$slots.default || [];
+    var children = this.children = [];
+    var transitionData = extractTransitionData(this);
+
+    for (var i = 0; i < rawChildren.length; i++) {
+      var c = rawChildren[i];
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c);
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData;
+        } else if (process.env.NODE_ENV !== 'production') {
+          var opts = c.componentOptions;
+          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
+          warn(("<transition-group> children must be keyed: <" + name + ">"));
+        }
+      }
+    }
+
+    if (prevChildren) {
+      var kept = [];
+      var removed = [];
+      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
+        var c$1 = prevChildren[i$1];
+        c$1.data.transition = transitionData;
+        c$1.data.pos = c$1.elm.getBoundingClientRect();
+        if (map[c$1.key]) {
+          kept.push(c$1);
+        } else {
+          removed.push(c$1);
+        }
+      }
+      this.kept = h(tag, null, kept);
+      this.removed = removed;
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate: function beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    );
+    this._vnode = this.kept;
+  },
+
+  updated: function updated () {
+    var children = this.prevChildren;
+    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
+    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
+      return
+    }
+
+    // we divide the work into three loops to avoid mixing DOM reads and writes
+    // in each iteration - which helps prevent layout thrashing.
+    children.forEach(callPendingCbs);
+    children.forEach(recordPosition);
+    children.forEach(applyTranslation);
+
+    // force reflow to put everything in position
+    var body = document.body;
+    var f = body.offsetHeight; // eslint-disable-line
+
+    children.forEach(function (c) {
+      if (c.data.moved) {
+        var el = c.elm;
+        var s = el.style;
+        addTransitionClass(el, moveClass);
+        s.transform = s.WebkitTransform = s.transitionDuration = '';
+        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
+          if (!e || /transform$/.test(e.propertyName)) {
+            el.removeEventListener(transitionEndEvent, cb);
+            el._moveCb = null;
+            removeTransitionClass(el, moveClass);
+          }
+        });
+      }
+    });
+  },
+
+  methods: {
+    hasMove: function hasMove (el, moveClass) {
+      /* istanbul ignore if */
+      if (!hasTransition) {
+        return false
+      }
+      if (this._hasMove != null) {
+        return this._hasMove
+      }
+      // Detect whether an element with the move class applied has
+      // CSS transitions. Since the element may be inside an entering
+      // transition at this very moment, we make a clone of it and remove
+      // all other transition classes applied to ensure only the move class
+      // is applied.
+      var clone = el.cloneNode();
+      if (el._transitionClasses) {
+        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
+      }
+      addClass(clone, moveClass);
+      clone.style.display = 'none';
+      this.$el.appendChild(clone);
+      var info = getTransitionInfo(clone);
+      this.$el.removeChild(clone);
+      return (this._hasMove = info.hasTransform)
+    }
+  }
+};
+
+function callPendingCbs (c) {
+  /* istanbul ignore if */
+  if (c.elm._moveCb) {
+    c.elm._moveCb();
+  }
+  /* istanbul ignore if */
+  if (c.elm._enterCb) {
+    c.elm._enterCb();
+  }
+}
+
+function recordPosition (c) {
+  c.data.newPos = c.elm.getBoundingClientRect();
+}
+
+function applyTranslation (c) {
+  var oldPos = c.data.pos;
+  var newPos = c.data.newPos;
+  var dx = oldPos.left - newPos.left;
+  var dy = oldPos.top - newPos.top;
+  if (dx || dy) {
+    c.data.moved = true;
+    var s = c.elm.style;
+    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
+    s.transitionDuration = '0s';
+  }
+}
+
+var platformComponents = {
+  Transition: Transition,
+  TransitionGroup: TransitionGroup
+};
+
+/*  */
+
+// install platform specific utils
+Vue$3.config.mustUseProp = mustUseProp;
+Vue$3.config.isReservedTag = isReservedTag;
+Vue$3.config.getTagNamespace = getTagNamespace;
+Vue$3.config.isUnknownElement = isUnknownElement;
+
+// install platform runtime directives & components
+extend(Vue$3.options.directives, platformDirectives);
+extend(Vue$3.options.components, platformComponents);
+
+// install platform patch function
+Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
+
+// public mount method
+Vue$3.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && inBrowser ? query(el) : undefined;
+  return mountComponent(this, el, hydrating)
+};
+
+// devtools global hook
+/* istanbul ignore next */
+setTimeout(function () {
+  if (config.devtools) {
+    if (devtools) {
+      devtools.emit('init', Vue$3);
+    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
+      console[console.info ? 'info' : 'log'](
+        'Download the Vue Devtools extension for a better development experience:\n' +
+        'https://github.com/vuejs/vue-devtools'
+      );
+    }
+  }
+  if (process.env.NODE_ENV !== 'production' &&
+      config.productionTip !== false &&
+      inBrowser && typeof console !== 'undefined') {
+    console[console.info ? 'info' : 'log'](
+      "You are running Vue in development mode.\n" +
+      "Make sure to turn on production mode when deploying for production.\n" +
+      "See more tips at https://vuejs.org/guide/deployment.html"
+    );
+  }
+}, 0);
+
+/*  */
+
+// check whether current browser encodes a char inside attribute values
+function shouldDecode (content, encoded) {
+  var div = document.createElement('div');
+  div.innerHTML = "<div a=\"" + content + "\">";
+  return div.innerHTML.indexOf(encoded) > 0
+}
+
+// #3663
+// IE encodes newlines inside attribute values while other browsers don't
+var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;
+
+/*  */
+
+var isUnaryTag = makeMap(
+  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
+  'link,meta,param,source,track,wbr'
+);
+
+// Elements that you can, intentionally, leave open
+// (and which close themselves)
+var canBeLeftOpenTag = makeMap(
+  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
+);
+
+// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
+// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
+var isNonPhrasingTag = makeMap(
+  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
+  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
+  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
+  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
+  'title,tr,track'
+);
+
+/*  */
+
+var decoder;
+
+function decode (html) {
+  decoder = decoder || document.createElement('div');
+  decoder.innerHTML = html;
+  return decoder.textContent
+}
+
+/**
+ * Not type-checking this file because it's mostly vendor code.
+ */
+
+/*!
+ * HTML Parser By John Resig (ejohn.org)
+ * Modified by Juriy "kangax" Zaytsev
+ * Original code by Erik Arvidsson, Mozilla Public License
+ * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
+ */
+
+// Regular Expressions for parsing tags and attributes
+var singleAttrIdentifier = /([^\s"'<>/=]+)/;
+var singleAttrAssign = /(?:=)/;
+var singleAttrValues = [
+  // attr value double quotes
+  /"([^"]*)"+/.source,
+  // attr value, single quotes
+  /'([^']*)'+/.source,
+  // attr value, no quotes
+  /([^\s"'=<>`]+)/.source
+];
+var attribute = new RegExp(
+  '^\\s*' + singleAttrIdentifier.source +
+  '(?:\\s*(' + singleAttrAssign.source + ')' +
+  '\\s*(?:' + singleAttrValues.join('|') + '))?'
+);
+
+// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
+// but for Vue templates we can enforce a simple charset
+var ncname = '[a-zA-Z_][\\w\\-\\.]*';
+var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
+var startTagOpen = new RegExp('^<' + qnameCapture);
+var startTagClose = /^\s*(\/?)>/;
+var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
+var doctype = /^<!DOCTYPE [^>]+>/i;
+var comment = /^<!--/;
+var conditionalComment = /^<!\[/;
+
+var IS_REGEX_CAPTURING_BROKEN = false;
+'x'.replace(/x(.)?/g, function (m, g) {
+  IS_REGEX_CAPTURING_BROKEN = g === '';
+});
+
+// Special Elements (can contain anything)
+var isScriptOrStyle = makeMap('script,style', true);
+var reCache = {};
+
+var decodingMap = {
+  '&lt;': '<',
+  '&gt;': '>',
+  '&quot;': '"',
+  '&amp;': '&',
+  '&#10;': '\n'
+};
+var encodedAttr = /&(?:lt|gt|quot|amp);/g;
+var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;
+
+function decodeAttr (value, shouldDecodeNewlines) {
+  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
+  return value.replace(re, function (match) { return decodingMap[match]; })
+}
+
+function parseHTML (html, options) {
+  var stack = [];
+  var expectHTML = options.expectHTML;
+  var isUnaryTag$$1 = options.isUnaryTag || no;
+  var index = 0;
+  var last, lastTag;
+  while (html) {
+    last = html;
+    // Make sure we're not in a script or style element
+    if (!lastTag || !isScriptOrStyle(lastTag)) {
+      var textEnd = html.indexOf('<');
+      if (textEnd === 0) {
+        // Comment:
+        if (comment.test(html)) {
+          var commentEnd = html.indexOf('-->');
+
+          if (commentEnd >= 0) {
+            advance(commentEnd + 3);
+            continue
+          }
+        }
+
+        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
+        if (conditionalComment.test(html)) {
+          var conditionalEnd = html.indexOf(']>');
+
+          if (conditionalEnd >= 0) {
+            advance(conditionalEnd + 2);
+            continue
+          }
+        }
+
+        // Doctype:
+        var doctypeMatch = html.match(doctype);
+        if (doctypeMatch) {
+          advance(doctypeMatch[0].length);
+          continue
+        }
+
+        // End tag:
+        var endTagMatch = html.match(endTag);
+        if (endTagMatch) {
+          var curIndex = index;
+          advance(endTagMatch[0].length);
+          parseEndTag(endTagMatch[1], curIndex, index);
+          continue
+        }
+
+        // Start tag:
+        var startTagMatch = parseStartTag();
+        if (startTagMatch) {
+          handleStartTag(startTagMatch);
+          continue
+        }
+      }
+
+      var text = (void 0), rest$1 = (void 0), next = (void 0);
+      if (textEnd >= 0) {
+        rest$1 = html.slice(textEnd);
+        while (
+          !endTag.test(rest$1) &&
+          !startTagOpen.test(rest$1) &&
+          !comment.test(rest$1) &&
+          !conditionalComment.test(rest$1)
+        ) {
+          // < in plain text, be forgiving and treat it as text
+          next = rest$1.indexOf('<', 1);
+          if (next < 0) { break }
+          textEnd += next;
+          rest$1 = html.slice(textEnd);
+        }
+        text = html.substring(0, textEnd);
+        advance(textEnd);
+      }
+
+      if (textEnd < 0) {
+        text = html;
+        html = '';
+      }
+
+      if (options.chars && text) {
+        options.chars(text);
+      }
+    } else {
+      var stackedTag = lastTag.toLowerCase();
+      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
+      var endTagLength = 0;
+      var rest = html.replace(reStackedTag, function (all, text, endTag) {
+        endTagLength = endTag.length;
+        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
+          text = text
+            .replace(/<!--([\s\S]*?)-->/g, '$1')
+            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
+        }
+        if (options.chars) {
+          options.chars(text);
+        }
+        return ''
+      });
+      index += html.length - rest.length;
+      html = rest;
+      parseEndTag(stackedTag, index - endTagLength, index);
+    }
+
+    if (html === last) {
+      options.chars && options.chars(html);
+      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {
+        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
+      }
+      break
+    }
+  }
+
+  // Clean up any remaining tags
+  parseEndTag();
+
+  function advance (n) {
+    index += n;
+    html = html.substring(n);
+  }
+
+  function parseStartTag () {
+    var start = html.match(startTagOpen);
+    if (start) {
+      var match = {
+        tagName: start[1],
+        attrs: [],
+        start: index
+      };
+      advance(start[0].length);
+      var end, attr;
+      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
+        advance(attr[0].length);
+        match.attrs.push(attr);
+      }
+      if (end) {
+        match.unarySlash = end[1];
+        advance(end[0].length);
+        match.end = index;
+        return match
+      }
+    }
+  }
+
+  function handleStartTag (match) {
+    var tagName = match.tagName;
+    var unarySlash = match.unarySlash;
+
+    if (expectHTML) {
+      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
+        parseEndTag(lastTag);
+      }
+      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
+        parseEndTag(tagName);
+      }
+    }
+
+    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;
+
+    var l = match.attrs.length;
+    var attrs = new Array(l);
+    for (var i = 0; i < l; i++) {
+      var args = match.attrs[i];
+      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
+      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
+        if (args[3] === '') { delete args[3]; }
+        if (args[4] === '') { delete args[4]; }
+        if (args[5] === '') { delete args[5]; }
+      }
+      var value = args[3] || args[4] || args[5] || '';
+      attrs[i] = {
+        name: args[1],
+        value: decodeAttr(
+          value,
+          options.shouldDecodeNewlines
+        )
+      };
+    }
+
+    if (!unary) {
+      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
+      lastTag = tagName;
+    }
+
+    if (options.start) {
+      options.start(tagName, attrs, unary, match.start, match.end);
+    }
+  }
+
+  function parseEndTag (tagName, start, end) {
+    var pos, lowerCasedTagName;
+    if (start == null) { start = index; }
+    if (end == null) { end = index; }
+
+    if (tagName) {
+      lowerCasedTagName = tagName.toLowerCase();
+    }
+
+    // Find the closest opened tag of the same type
+    if (tagName) {
+      for (pos = stack.length - 1; pos >= 0; pos--) {
+        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
+          break
+        }
+      }
+    } else {
+      // If no tag name is provided, clean shop
+      pos = 0;
+    }
+
+    if (pos >= 0) {
+      // Close all the open elements, up the stack
+      for (var i = stack.length - 1; i >= pos; i--) {
+        if (process.env.NODE_ENV !== 'production' &&
+            (i > pos || !tagName) &&
+            options.warn) {
+          options.warn(
+            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
+          );
+        }
+        if (options.end) {
+          options.end(stack[i].tag, start, end);
+        }
+      }
+
+      // Remove the open elements from the stack
+      stack.length = pos;
+      lastTag = pos && stack[pos - 1].tag;
+    } else if (lowerCasedTagName === 'br') {
+      if (options.start) {
+        options.start(tagName, [], true, start, end);
+      }
+    } else if (lowerCasedTagName === 'p') {
+      if (options.start) {
+        options.start(tagName, [], false, start, end);
+      }
+      if (options.end) {
+        options.end(tagName, start, end);
+      }
+    }
+  }
+}
+
+/*  */
+
+var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
+var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
+
+var buildRegex = cached(function (delimiters) {
+  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
+  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
+  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
+});
+
+function parseText (
+  text,
+  delimiters
+) {
+  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
+  if (!tagRE.test(text)) {
+    return
+  }
+  var tokens = [];
+  var lastIndex = tagRE.lastIndex = 0;
+  var match, index;
+  while ((match = tagRE.exec(text))) {
+    index = match.index;
+    // push text token
+    if (index > lastIndex) {
+      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
+    }
+    // tag token
+    var exp = parseFilters(match[1].trim());
+    tokens.push(("_s(" + exp + ")"));
+    lastIndex = index + match[0].length;
+  }
+  if (lastIndex < text.length) {
+    tokens.push(JSON.stringify(text.slice(lastIndex)));
+  }
+  return tokens.join('+')
+}
+
+/*  */
+
+var dirRE = /^v-|^@|^:/;
+var onRE = /^@|^v-on:/;
+var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
+var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
+var bindRE = /^:|^v-bind:/;
+var argRE = /:(.*)$/;
+var modifierRE = /\.[^.]+/g;
+
+var decodeHTMLCached = cached(decode);
+
+// configurable state
+var warn$2;
+var platformGetTagNamespace;
+var platformMustUseProp;
+var platformIsPreTag;
+var preTransforms;
+var transforms;
+var postTransforms;
+var delimiters;
+
+/**
+ * Convert HTML string to AST.
+ */
+function parse (
+  template,
+  options
+) {
+  warn$2 = options.warn || baseWarn;
+  platformGetTagNamespace = options.getTagNamespace || no;
+  platformMustUseProp = options.mustUseProp || no;
+  platformIsPreTag = options.isPreTag || no;
+  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
+  transforms = pluckModuleFunction(options.modules, 'transformNode');
+  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
+  delimiters = options.delimiters;
+
+  var stack = [];
+  var preserveWhitespace = options.preserveWhitespace !== false;
+  var root;
+  var currentParent;
+  var inVPre = false;
+  var inPre = false;
+  var warned = false;
+
+  function endPre (element) {
+    // check pre state
+    if (element.pre) {
+      inVPre = false;
+    }
+    if (platformIsPreTag(element.tag)) {
+      inPre = false;
+    }
+  }
+
+  parseHTML(template, {
+    warn: warn$2,
+    expectHTML: options.expectHTML,
+    isUnaryTag: options.isUnaryTag,
+    shouldDecodeNewlines: options.shouldDecodeNewlines,
+    start: function start (tag, attrs, unary) {
+      // check namespace.
+      // inherit parent ns if there is one
+      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);
+
+      // handle IE svg bug
+      /* istanbul ignore if */
+      if (isIE && ns === 'svg') {
+        attrs = guardIESVGBug(attrs);
+      }
+
+      var element = {
+        type: 1,
+        tag: tag,
+        attrsList: attrs,
+        attrsMap: makeAttrsMap(attrs),
+        parent: currentParent,
+        children: []
+      };
+      if (ns) {
+        element.ns = ns;
+      }
+
+      if (isForbiddenTag(element) && !isServerRendering()) {
+        element.forbidden = true;
+        process.env.NODE_ENV !== 'production' && warn$2(
+          'Templates should only be responsible for mapping the state to the ' +
+          'UI. Avoid placing tags with side-effects in your templates, such as ' +
+          "<" + tag + ">" + ', as they will not be parsed.'
+        );
+      }
+
+      // apply pre-transforms
+      for (var i = 0; i < preTransforms.length; i++) {
+        preTransforms[i](element, options);
+      }
+
+      if (!inVPre) {
+        processPre(element);
+        if (element.pre) {
+          inVPre = true;
+        }
+      }
+      if (platformIsPreTag(element.tag)) {
+        inPre = true;
+      }
+      if (inVPre) {
+        processRawAttrs(element);
+      } else {
+        processFor(element);
+        processIf(element);
+        processOnce(element);
+        processKey(element);
+
+        // determine whether this is a plain element after
+        // removing structural attributes
+        element.plain = !element.key && !attrs.length;
+
+        processRef(element);
+        processSlot(element);
+        processComponent(element);
+        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
+          transforms[i$1](element, options);
+        }
+        processAttrs(element);
+      }
+
+      function checkRootConstraints (el) {
+        if (process.env.NODE_ENV !== 'production' && !warned) {
+          if (el.tag === 'slot' || el.tag === 'template') {
+            warned = true;
+            warn$2(
+              "Cannot use <" + (el.tag) + "> as component root element because it may " +
+              'contain multiple nodes.'
+            );
+          }
+          if (el.attrsMap.hasOwnProperty('v-for')) {
+            warned = true;
+            warn$2(
+              'Cannot use v-for on stateful component root element because ' +
+              'it renders multiple elements.'
+            );
+          }
+        }
+      }
+
+      // tree management
+      if (!root) {
+        root = element;
+        checkRootConstraints(root);
+      } else if (!stack.length) {
+        // allow root elements with v-if, v-else-if and v-else
+        if (root.if && (element.elseif || element.else)) {
+          checkRootConstraints(element);
+          addIfCondition(root, {
+            exp: element.elseif,
+            block: element
+          });
+        } else if (process.env.NODE_ENV !== 'production' && !warned) {
+          warned = true;
+          warn$2(
+            "Component template should contain exactly one root element. " +
+            "If you are using v-if on multiple elements, " +
+            "use v-else-if to chain them instead."
+          );
+        }
+      }
+      if (currentParent && !element.forbidden) {
+        if (element.elseif || element.else) {
+          processIfConditions(element, currentParent);
+        } else if (element.slotScope) { // scoped slot
+          currentParent.plain = false;
+          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
+        } else {
+          currentParent.children.push(element);
+          element.parent = currentParent;
+        }
+      }
+      if (!unary) {
+        currentParent = element;
+        stack.push(element);
+      } else {
+        endPre(element);
+      }
+      // apply post-transforms
+      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
+        postTransforms[i$2](element, options);
+      }
+    },
+
+    end: function end () {
+      // remove trailing whitespace
+      var element = stack[stack.length - 1];
+      var lastNode = element.children[element.children.length - 1];
+      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
+        element.children.pop();
+      }
+      // pop stack
+      stack.length -= 1;
+      currentParent = stack[stack.length - 1];
+      endPre(element);
+    },
+
+    chars: function chars (text) {
+      if (!currentParent) {
+        if (process.env.NODE_ENV !== 'production' && !warned && text === template) {
+          warned = true;
+          warn$2(
+            'Component template requires a root element, rather than just text.'
+          );
+        }
+        return
+      }
+      // IE textarea placeholder bug
+      /* istanbul ignore if */
+      if (isIE &&
+          currentParent.tag === 'textarea' &&
+          currentParent.attrsMap.placeholder === text) {
+        return
+      }
+      var children = currentParent.children;
+      text = inPre || text.trim()
+        ? decodeHTMLCached(text)
+        // only preserve whitespace if its not right after a starting tag
+        : preserveWhitespace && children.length ? ' ' : '';
+      if (text) {
+        var expression;
+        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
+          children.push({
+            type: 2,
+            expression: expression,
+            text: text
+          });
+        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
+          children.push({
+            type: 3,
+            text: text
+          });
+        }
+      }
+    }
+  });
+  return root
+}
+
+function processPre (el) {
+  if (getAndRemoveAttr(el, 'v-pre') != null) {
+    el.pre = true;
+  }
+}
+
+function processRawAttrs (el) {
+  var l = el.attrsList.length;
+  if (l) {
+    var attrs = el.attrs = new Array(l);
+    for (var i = 0; i < l; i++) {
+      attrs[i] = {
+        name: el.attrsList[i].name,
+        value: JSON.stringify(el.attrsList[i].value)
+      };
+    }
+  } else if (!el.pre) {
+    // non root node in pre blocks with no attributes
+    el.plain = true;
+  }
+}
+
+function processKey (el) {
+  var exp = getBindingAttr(el, 'key');
+  if (exp) {
+    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
+      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
+    }
+    el.key = exp;
+  }
+}
+
+function processRef (el) {
+  var ref = getBindingAttr(el, 'ref');
+  if (ref) {
+    el.ref = ref;
+    el.refInFor = checkInFor(el);
+  }
+}
+
+function processFor (el) {
+  var exp;
+  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
+    var inMatch = exp.match(forAliasRE);
+    if (!inMatch) {
+      process.env.NODE_ENV !== 'production' && warn$2(
+        ("Invalid v-for expression: " + exp)
+      );
+      return
+    }
+    el.for = inMatch[2].trim();
+    var alias = inMatch[1].trim();
+    var iteratorMatch = alias.match(forIteratorRE);
+    if (iteratorMatch) {
+      el.alias = iteratorMatch[1].trim();
+      el.iterator1 = iteratorMatch[2].trim();
+      if (iteratorMatch[3]) {
+        el.iterator2 = iteratorMatch[3].trim();
+      }
+    } else {
+      el.alias = alias;
+    }
+  }
+}
+
+function processIf (el) {
+  var exp = getAndRemoveAttr(el, 'v-if');
+  if (exp) {
+    el.if = exp;
+    addIfCondition(el, {
+      exp: exp,
+      block: el
+    });
+  } else {
+    if (getAndRemoveAttr(el, 'v-else') != null) {
+      el.else = true;
+    }
+    var elseif = getAndRemoveAttr(el, 'v-else-if');
+    if (elseif) {
+      el.elseif = elseif;
+    }
+  }
+}
+
+function processIfConditions (el, parent) {
+  var prev = findPrevElement(parent.children);
+  if (prev && prev.if) {
+    addIfCondition(prev, {
+      exp: el.elseif,
+      block: el
+    });
+  } else if (process.env.NODE_ENV !== 'production') {
+    warn$2(
+      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
+      "used on element <" + (el.tag) + "> without corresponding v-if."
+    );
+  }
+}
+
+function findPrevElement (children) {
+  var i = children.length;
+  while (i--) {
+    if (children[i].type === 1) {
+      return children[i]
+    } else {
+      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
+        warn$2(
+          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
+          "will be ignored."
+        );
+      }
+      children.pop();
+    }
+  }
+}
+
+function addIfCondition (el, condition) {
+  if (!el.ifConditions) {
+    el.ifConditions = [];
+  }
+  el.ifConditions.push(condition);
+}
+
+function processOnce (el) {
+  var once$$1 = getAndRemoveAttr(el, 'v-once');
+  if (once$$1 != null) {
+    el.once = true;
+  }
+}
+
+function processSlot (el) {
+  if (el.tag === 'slot') {
+    el.slotName = getBindingAttr(el, 'name');
+    if (process.env.NODE_ENV !== 'production' && el.key) {
+      warn$2(
+        "`key` does not work on <slot> because slots are abstract outlets " +
+        "and can possibly expand into multiple elements. " +
+        "Use the key on a wrapping element instead."
+      );
+    }
+  } else {
+    var slotTarget = getBindingAttr(el, 'slot');
+    if (slotTarget) {
+      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
+    }
+    if (el.tag === 'template') {
+      el.slotScope = getAndRemoveAttr(el, 'scope');
+    }
+  }
+}
+
+function processComponent (el) {
+  var binding;
+  if ((binding = getBindingAttr(el, 'is'))) {
+    el.component = binding;
+  }
+  if (getAndRemoveAttr(el, 'inline-template') != null) {
+    el.inlineTemplate = true;
+  }
+}
+
+function processAttrs (el) {
+  var list = el.attrsList;
+  var i, l, name, rawName, value, arg, modifiers, isProp;
+  for (i = 0, l = list.length; i < l; i++) {
+    name = rawName = list[i].name;
+    value = list[i].value;
+    if (dirRE.test(name)) {
+      // mark element as dynamic
+      el.hasBindings = true;
+      // modifiers
+      modifiers = parseModifiers(name);
+      if (modifiers) {
+        name = name.replace(modifierRE, '');
+      }
+      if (bindRE.test(name)) { // v-bind
+        name = name.replace(bindRE, '');
+        value = parseFilters(value);
+        isProp = false;
+        if (modifiers) {
+          if (modifiers.prop) {
+            isProp = true;
+            name = camelize(name);
+            if (name === 'innerHtml') { name = 'innerHTML'; }
+          }
+          if (modifiers.camel) {
+            name = camelize(name);
+          }
+        }
+        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
+          addProp(el, name, value);
+        } else {
+          addAttr(el, name, value);
+        }
+      } else if (onRE.test(name)) { // v-on
+        name = name.replace(onRE, '');
+        addHandler(el, name, value, modifiers);
+      } else { // normal directives
+        name = name.replace(dirRE, '');
+        // parse arg
+        var argMatch = name.match(argRE);
+        if (argMatch && (arg = argMatch[1])) {
+          name = name.slice(0, -(arg.length + 1));
+        }
+        addDirective(el, name, rawName, value, arg, modifiers);
+        if (process.env.NODE_ENV !== 'production' && name === 'model') {
+          checkForAliasModel(el, value);
+        }
+      }
+    } else {
+      // literal attribute
+      if (process.env.NODE_ENV !== 'production') {
+        var expression = parseText(value, delimiters);
+        if (expression) {
+          warn$2(
+            name + "=\"" + value + "\": " +
+            'Interpolation inside attributes has been removed. ' +
+            'Use v-bind or the colon shorthand instead. For example, ' +
+            'instead of <div id="{{ val }}">, use <div :id="val">.'
+          );
+        }
+      }
+      addAttr(el, name, JSON.stringify(value));
+    }
+  }
+}
+
+function checkInFor (el) {
+  var parent = el;
+  while (parent) {
+    if (parent.for !== undefined) {
+      return true
+    }
+    parent = parent.parent;
+  }
+  return false
+}
+
+function parseModifiers (name) {
+  var match = name.match(modifierRE);
+  if (match) {
+    var ret = {};
+    match.forEach(function (m) { ret[m.slice(1)] = true; });
+    return ret
+  }
+}
+
+function makeAttrsMap (attrs) {
+  var map = {};
+  for (var i = 0, l = attrs.length; i < l; i++) {
+    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
+      warn$2('duplicate attribute: ' + attrs[i].name);
+    }
+    map[attrs[i].name] = attrs[i].value;
+  }
+  return map
+}
+
+function isForbiddenTag (el) {
+  return (
+    el.tag === 'style' ||
+    (el.tag === 'script' && (
+      !el.attrsMap.type ||
+      el.attrsMap.type === 'text/javascript'
+    ))
+  )
+}
+
+var ieNSBug = /^xmlns:NS\d+/;
+var ieNSPrefix = /^NS\d+:/;
+
+/* istanbul ignore next */
+function guardIESVGBug (attrs) {
+  var res = [];
+  for (var i = 0; i < attrs.length; i++) {
+    var attr = attrs[i];
+    if (!ieNSBug.test(attr.name)) {
+      attr.name = attr.name.replace(ieNSPrefix, '');
+      res.push(attr);
+    }
+  }
+  return res
+}
+
+function checkForAliasModel (el, value) {
+  var _el = el;
+  while (_el) {
+    if (_el.for && _el.alias === value) {
+      warn$2(
+        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
+        "You are binding v-model directly to a v-for iteration alias. " +
+        "This will not be able to modify the v-for source array because " +
+        "writing to the alias is like modifying a function local variable. " +
+        "Consider using an array of objects and use v-model on an object property instead."
+      );
+    }
+    _el = _el.parent;
+  }
+}
+
+/*  */
+
+var isStaticKey;
+var isPlatformReservedTag;
+
+var genStaticKeysCached = cached(genStaticKeys$1);
+
+/**
+ * Goal of the optimizer: walk the generated template AST tree
+ * and detect sub-trees that are purely static, i.e. parts of
+ * the DOM that never needs to change.
+ *
+ * Once we detect these sub-trees, we can:
+ *
+ * 1. Hoist them into constants, so that we no longer need to
+ *    create fresh nodes for them on each re-render;
+ * 2. Completely skip them in the patching process.
+ */
+function optimize (root, options) {
+  if (!root) { return }
+  isStaticKey = genStaticKeysCached(options.staticKeys || '');
+  isPlatformReservedTag = options.isReservedTag || no;
+  // first pass: mark all non-static nodes.
+  markStatic$1(root);
+  // second pass: mark static roots.
+  markStaticRoots(root, false);
+}
+
+function genStaticKeys$1 (keys) {
+  return makeMap(
+    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
+    (keys ? ',' + keys : '')
+  )
+}
+
+function markStatic$1 (node) {
+  node.static = isStatic(node);
+  if (node.type === 1) {
+    // do not make component slot content static. this avoids
+    // 1. components not able to mutate slot nodes
+    // 2. static slot content fails for hot-reloading
+    if (
+      !isPlatformReservedTag(node.tag) &&
+      node.tag !== 'slot' &&
+      node.attrsMap['inline-template'] == null
+    ) {
+      return
+    }
+    for (var i = 0, l = node.children.length; i < l; i++) {
+      var child = node.children[i];
+      markStatic$1(child);
+      if (!child.static) {
+        node.static = false;
+      }
+    }
+  }
+}
+
+function markStaticRoots (node, isInFor) {
+  if (node.type === 1) {
+    if (node.static || node.once) {
+      node.staticInFor = isInFor;
+    }
+    // For a node to qualify as a static root, it should have children that
+    // are not just static text. Otherwise the cost of hoisting out will
+    // outweigh the benefits and it's better off to just always render it fresh.
+    if (node.static && node.children.length && !(
+      node.children.length === 1 &&
+      node.children[0].type === 3
+    )) {
+      node.staticRoot = true;
+      return
+    } else {
+      node.staticRoot = false;
+    }
+    if (node.children) {
+      for (var i = 0, l = node.children.length; i < l; i++) {
+        markStaticRoots(node.children[i], isInFor || !!node.for);
+      }
+    }
+    if (node.ifConditions) {
+      walkThroughConditionsBlocks(node.ifConditions, isInFor);
+    }
+  }
+}
+
+function walkThroughConditionsBlocks (conditionBlocks, isInFor) {
+  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
+    markStaticRoots(conditionBlocks[i].block, isInFor);
+  }
+}
+
+function isStatic (node) {
+  if (node.type === 2) { // expression
+    return false
+  }
+  if (node.type === 3) { // text
+    return true
+  }
+  return !!(node.pre || (
+    !node.hasBindings && // no dynamic bindings
+    !node.if && !node.for && // not v-if or v-for or v-else
+    !isBuiltInTag(node.tag) && // not a built-in
+    isPlatformReservedTag(node.tag) && // not a component
+    !isDirectChildOfTemplateFor(node) &&
+    Object.keys(node).every(isStaticKey)
+  ))
+}
+
+function isDirectChildOfTemplateFor (node) {
+  while (node.parent) {
+    node = node.parent;
+    if (node.tag !== 'template') {
+      return false
+    }
+    if (node.for) {
+      return true
+    }
+  }
+  return false
+}
+
+/*  */
+
+var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
+var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
+
+// keyCode aliases
+var keyCodes = {
+  esc: 27,
+  tab: 9,
+  enter: 13,
+  space: 32,
+  up: 38,
+  left: 37,
+  right: 39,
+  down: 40,
+  'delete': [8, 46]
+};
+
+// #4868: modifiers that prevent the execution of the listener
+// need to explicitly return null so that we can determine whether to remove
+// the listener for .once
+var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };
+
+var modifierCode = {
+  stop: '$event.stopPropagation();',
+  prevent: '$event.preventDefault();',
+  self: genGuard("$event.target !== $event.currentTarget"),
+  ctrl: genGuard("!$event.ctrlKey"),
+  shift: genGuard("!$event.shiftKey"),
+  alt: genGuard("!$event.altKey"),
+  meta: genGuard("!$event.metaKey"),
+  left: genGuard("'button' in $event && $event.button !== 0"),
+  middle: genGuard("'button' in $event && $event.button !== 1"),
+  right: genGuard("'button' in $event && $event.button !== 2")
+};
+
+function genHandlers (events, native) {
+  var res = native ? 'nativeOn:{' : 'on:{';
+  for (var name in events) {
+    res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
+  }
+  return res.slice(0, -1) + '}'
+}
+
+function genHandler (
+  name,
+  handler
+) {
+  if (!handler) {
+    return 'function(){}'
+  }
+
+  if (Array.isArray(handler)) {
+    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
+  }
+
+  var isMethodPath = simplePathRE.test(handler.value);
+  var isFunctionExpression = fnExpRE.test(handler.value);
+
+  if (!handler.modifiers) {
+    return isMethodPath || isFunctionExpression
+      ? handler.value
+      : ("function($event){" + (handler.value) + "}") // inline statement
+  } else {
+    var code = '';
+    var keys = [];
+    for (var key in handler.modifiers) {
+      if (modifierCode[key]) {
+        code += modifierCode[key];
+        // left/right
+        if (keyCodes[key]) {
+          keys.push(key);
+        }
+      } else {
+        keys.push(key);
+      }
+    }
+    if (keys.length) {
+      code += genKeyFilter(keys);
+    }
+    var handlerCode = isMethodPath
+      ? handler.value + '($event)'
+      : isFunctionExpression
+        ? ("(" + (handler.value) + ")($event)")
+        : handler.value;
+    return ("function($event){" + code + handlerCode + "}")
+  }
+}
+
+function genKeyFilter (keys) {
+  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
+}
+
+function genFilterCode (key) {
+  var keyVal = parseInt(key, 10);
+  if (keyVal) {
+    return ("$event.keyCode!==" + keyVal)
+  }
+  var alias = keyCodes[key];
+  return ("_k($event.keyCode," + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + ")")
+}
+
+/*  */
+
+function bind$1 (el, dir) {
+  el.wrapData = function (code) {
+    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
+  };
+}
+
+/*  */
+
+var baseDirectives = {
+  bind: bind$1,
+  cloak: noop
+};
+
+/*  */
+
+// configurable state
+var warn$3;
+var transforms$1;
+var dataGenFns;
+var platformDirectives$1;
+var isPlatformReservedTag$1;
+var staticRenderFns;
+var onceCount;
+var currentOptions;
+
+function generate (
+  ast,
+  options
+) {
+  // save previous staticRenderFns so generate calls can be nested
+  var prevStaticRenderFns = staticRenderFns;
+  var currentStaticRenderFns = staticRenderFns = [];
+  var prevOnceCount = onceCount;
+  onceCount = 0;
+  currentOptions = options;
+  warn$3 = options.warn || baseWarn;
+  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
+  dataGenFns = pluckModuleFunction(options.modules, 'genData');
+  platformDirectives$1 = options.directives || {};
+  isPlatformReservedTag$1 = options.isReservedTag || no;
+  var code = ast ? genElement(ast) : '_c("div")';
+  staticRenderFns = prevStaticRenderFns;
+  onceCount = prevOnceCount;
+  return {
+    render: ("with(this){return " + code + "}"),
+    staticRenderFns: currentStaticRenderFns
+  }
+}
+
+function genElement (el) {
+  if (el.staticRoot && !el.staticProcessed) {
+    return genStatic(el)
+  } else if (el.once && !el.onceProcessed) {
+    return genOnce(el)
+  } else if (el.for && !el.forProcessed) {
+    return genFor(el)
+  } else if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.tag === 'template' && !el.slotTarget) {
+    return genChildren(el) || 'void 0'
+  } else if (el.tag === 'slot') {
+    return genSlot(el)
+  } else {
+    // component or element
+    var code;
+    if (el.component) {
+      code = genComponent(el.component, el);
+    } else {
+      var data = el.plain ? undefined : genData(el);
+
+      var children = el.inlineTemplate ? null : genChildren(el, true);
+      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
+    }
+    // module transforms
+    for (var i = 0; i < transforms$1.length; i++) {
+      code = transforms$1[i](el, code);
+    }
+    return code
+  }
+}
+
+// hoist static sub-trees out
+function genStatic (el) {
+  el.staticProcessed = true;
+  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
+  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
+}
+
+// v-once
+function genOnce (el) {
+  el.onceProcessed = true;
+  if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.staticInFor) {
+    var key = '';
+    var parent = el.parent;
+    while (parent) {
+      if (parent.for) {
+        key = parent.key;
+        break
+      }
+      parent = parent.parent;
+    }
+    if (!key) {
+      process.env.NODE_ENV !== 'production' && warn$3(
+        "v-once can only be used inside v-for that is keyed. "
+      );
+      return genElement(el)
+    }
+    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
+  } else {
+    return genStatic(el)
+  }
+}
+
+function genIf (el) {
+  el.ifProcessed = true; // avoid recursion
+  return genIfConditions(el.ifConditions.slice())
+}
+
+function genIfConditions (conditions) {
+  if (!conditions.length) {
+    return '_e()'
+  }
+
+  var condition = conditions.shift();
+  if (condition.exp) {
+    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions)))
+  } else {
+    return ("" + (genTernaryExp(condition.block)))
+  }
+
+  // v-if with v-once should generate code like (a)?_m(0):_m(1)
+  function genTernaryExp (el) {
+    return el.once ? genOnce(el) : genElement(el)
+  }
+}
+
+function genFor (el) {
+  var exp = el.for;
+  var alias = el.alias;
+  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
+  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
+
+  if (
+    process.env.NODE_ENV !== 'production' &&
+    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key
+  ) {
+    warn$3(
+      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
+      "v-for should have explicit keys. " +
+      "See https://vuejs.org/guide/list.html#key for more info.",
+      true /* tip */
+    );
+  }
+
+  el.forProcessed = true; // avoid recursion
+  return "_l((" + exp + ")," +
+    "function(" + alias + iterator1 + iterator2 + "){" +
+      "return " + (genElement(el)) +
+    '})'
+}
+
+function genData (el) {
+  var data = '{';
+
+  // directives first.
+  // directives may mutate the el's other properties before they are generated.
+  var dirs = genDirectives(el);
+  if (dirs) { data += dirs + ','; }
+
+  // key
+  if (el.key) {
+    data += "key:" + (el.key) + ",";
+  }
+  // ref
+  if (el.ref) {
+    data += "ref:" + (el.ref) + ",";
+  }
+  if (el.refInFor) {
+    data += "refInFor:true,";
+  }
+  // pre
+  if (el.pre) {
+    data += "pre:true,";
+  }
+  // record original tag name for components using "is" attribute
+  if (el.component) {
+    data += "tag:\"" + (el.tag) + "\",";
+  }
+  // module data generation functions
+  for (var i = 0; i < dataGenFns.length; i++) {
+    data += dataGenFns[i](el);
+  }
+  // attributes
+  if (el.attrs) {
+    data += "attrs:{" + (genProps(el.attrs)) + "},";
+  }
+  // DOM props
+  if (el.props) {
+    data += "domProps:{" + (genProps(el.props)) + "},";
+  }
+  // event handlers
+  if (el.events) {
+    data += (genHandlers(el.events)) + ",";
+  }
+  if (el.nativeEvents) {
+    data += (genHandlers(el.nativeEvents, true)) + ",";
+  }
+  // slot target
+  if (el.slotTarget) {
+    data += "slot:" + (el.slotTarget) + ",";
+  }
+  // scoped slots
+  if (el.scopedSlots) {
+    data += (genScopedSlots(el.scopedSlots)) + ",";
+  }
+  // component v-model
+  if (el.model) {
+    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
+  }
+  // inline-template
+  if (el.inlineTemplate) {
+    var inlineTemplate = genInlineTemplate(el);
+    if (inlineTemplate) {
+      data += inlineTemplate + ",";
+    }
+  }
+  data = data.replace(/,$/, '') + '}';
+  // v-bind data wrap
+  if (el.wrapData) {
+    data = el.wrapData(data);
+  }
+  return data
+}
+
+function genDirectives (el) {
+  var dirs = el.directives;
+  if (!dirs) { return }
+  var res = 'directives:[';
+  var hasRuntime = false;
+  var i, l, dir, needRuntime;
+  for (i = 0, l = dirs.length; i < l; i++) {
+    dir = dirs[i];
+    needRuntime = true;
+    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
+    if (gen) {
+      // compile-time directive that manipulates AST.
+      // returns true if it also needs a runtime counterpart.
+      needRuntime = !!gen(el, dir, warn$3);
+    }
+    if (needRuntime) {
+      hasRuntime = true;
+      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
+    }
+  }
+  if (hasRuntime) {
+    return res.slice(0, -1) + ']'
+  }
+}
+
+function genInlineTemplate (el) {
+  var ast = el.children[0];
+  if (process.env.NODE_ENV !== 'production' && (
+    el.children.length > 1 || ast.type !== 1
+  )) {
+    warn$3('Inline-template components must have exactly one child element.');
+  }
+  if (ast.type === 1) {
+    var inlineRenderFns = generate(ast, currentOptions);
+    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
+  }
+}
+
+function genScopedSlots (slots) {
+  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + "])")
+}
+
+function genScopedSlot (key, el) {
+  return "[" + key + ",function(" + (String(el.attrsMap.scope)) + "){" +
+    "return " + (el.tag === 'template'
+      ? genChildren(el) || 'void 0'
+      : genElement(el)) + "}]"
+}
+
+function genChildren (el, checkSkip) {
+  var children = el.children;
+  if (children.length) {
+    var el$1 = children[0];
+    // optimize single v-for
+    if (children.length === 1 &&
+        el$1.for &&
+        el$1.tag !== 'template' &&
+        el$1.tag !== 'slot') {
+      return genElement(el$1)
+    }
+    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
+    return ("[" + (children.map(genNode).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
+  }
+}
+
+// determine the normalization needed for the children array.
+// 0: no normalization needed
+// 1: simple normalization needed (possible 1-level deep nested array)
+// 2: full normalization needed
+function getNormalizationType (children) {
+  var res = 0;
+  for (var i = 0; i < children.length; i++) {
+    var el = children[i];
+    if (el.type !== 1) {
+      continue
+    }
+    if (needsNormalization(el) ||
+        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
+      res = 2;
+      break
+    }
+    if (maybeComponent(el) ||
+        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
+      res = 1;
+    }
+  }
+  return res
+}
+
+function needsNormalization (el) {
+  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
+}
+
+function maybeComponent (el) {
+  return !isPlatformReservedTag$1(el.tag)
+}
+
+function genNode (node) {
+  if (node.type === 1) {
+    return genElement(node)
+  } else {
+    return genText(node)
+  }
+}
+
+function genText (text) {
+  return ("_v(" + (text.type === 2
+    ? text.expression // no need for () because already wrapped in _s()
+    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
+}
+
+function genSlot (el) {
+  var slotName = el.slotName || '"default"';
+  var children = genChildren(el);
+  var res = "_t(" + slotName + (children ? ("," + children) : '');
+  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
+  var bind$$1 = el.attrsMap['v-bind'];
+  if ((attrs || bind$$1) && !children) {
+    res += ",null";
+  }
+  if (attrs) {
+    res += "," + attrs;
+  }
+  if (bind$$1) {
+    res += (attrs ? '' : ',null') + "," + bind$$1;
+  }
+  return res + ')'
+}
+
+// componentName is el.component, take it as argument to shun flow's pessimistic refinement
+function genComponent (componentName, el) {
+  var children = el.inlineTemplate ? null : genChildren(el, true);
+  return ("_c(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
+}
+
+function genProps (props) {
+  var res = '';
+  for (var i = 0; i < props.length; i++) {
+    var prop = props[i];
+    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
+  }
+  return res.slice(0, -1)
+}
+
+// #3895, #4268
+function transformSpecialNewlines (text) {
+  return text
+    .replace(/\u2028/g, '\\u2028')
+    .replace(/\u2029/g, '\\u2029')
+}
+
+/*  */
+
+// these keywords should not appear inside expressions, but operators like
+// typeof, instanceof and in are allowed
+var prohibitedKeywordRE = new RegExp('\\b' + (
+  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
+  'super,throw,while,yield,delete,export,import,return,switch,default,' +
+  'extends,finally,continue,debugger,function,arguments'
+).split(',').join('\\b|\\b') + '\\b');
+
+// these unary operators should not be used as property/method names
+var unaryOperatorsRE = new RegExp('\\b' + (
+  'delete,typeof,void'
+).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');
+
+// check valid identifier for v-for
+var identRE = /[A-Za-z_$][\w$]*/;
+
+// strip strings in expressions
+var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
+
+// detect problematic expressions in a template
+function detectErrors (ast) {
+  var errors = [];
+  if (ast) {
+    checkNode(ast, errors);
+  }
+  return errors
+}
+
+function checkNode (node, errors) {
+  if (node.type === 1) {
+    for (var name in node.attrsMap) {
+      if (dirRE.test(name)) {
+        var value = node.attrsMap[name];
+        if (value) {
+          if (name === 'v-for') {
+            checkFor(node, ("v-for=\"" + value + "\""), errors);
+          } else if (onRE.test(name)) {
+            checkEvent(value, (name + "=\"" + value + "\""), errors);
+          } else {
+            checkExpression(value, (name + "=\"" + value + "\""), errors);
+          }
+        }
+      }
+    }
+    if (node.children) {
+      for (var i = 0; i < node.children.length; i++) {
+        checkNode(node.children[i], errors);
+      }
+    }
+  } else if (node.type === 2) {
+    checkExpression(node.expression, node.text, errors);
+  }
+}
+
+function checkEvent (exp, text, errors) {
+  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
+  if (keywordMatch) {
+    errors.push(
+      "avoid using JavaScript unary operator as property name: " +
+      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
+    );
+  }
+  checkExpression(exp, text, errors);
+}
+
+function checkFor (node, text, errors) {
+  checkExpression(node.for || '', text, errors);
+  checkIdentifier(node.alias, 'v-for alias', text, errors);
+  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
+  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
+}
+
+function checkIdentifier (ident, type, text, errors) {
+  if (typeof ident === 'string' && !identRE.test(ident)) {
+    errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
+  }
+}
+
+function checkExpression (exp, text, errors) {
+  try {
+    new Function(("return " + exp));
+  } catch (e) {
+    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
+    if (keywordMatch) {
+      errors.push(
+        "avoid using JavaScript keyword as property name: " +
+        "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
+      );
+    } else {
+      errors.push(("invalid expression: " + (text.trim())));
+    }
+  }
+}
+
+/*  */
+
+function baseCompile (
+  template,
+  options
+) {
+  var ast = parse(template.trim(), options);
+  optimize(ast, options);
+  var code = generate(ast, options);
+  return {
+    ast: ast,
+    render: code.render,
+    staticRenderFns: code.staticRenderFns
+  }
+}
+
+function makeFunction (code, errors) {
+  try {
+    return new Function(code)
+  } catch (err) {
+    errors.push({ err: err, code: code });
+    return noop
+  }
+}
+
+function createCompiler (baseOptions) {
+  var functionCompileCache = Object.create(null);
+
+  function compile (
+    template,
+    options
+  ) {
+    var finalOptions = Object.create(baseOptions);
+    var errors = [];
+    var tips = [];
+    finalOptions.warn = function (msg, tip$$1) {
+      (tip$$1 ? tips : errors).push(msg);
+    };
+
+    if (options) {
+      // merge custom modules
+      if (options.modules) {
+        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
+      }
+      // merge custom directives
+      if (options.directives) {
+        finalOptions.directives = extend(
+          Object.create(baseOptions.directives),
+          options.directives
+        );
+      }
+      // copy other options
+      for (var key in options) {
+        if (key !== 'modules' && key !== 'directives') {
+          finalOptions[key] = options[key];
+        }
+      }
+    }
+
+    var compiled = baseCompile(template, finalOptions);
+    if (process.env.NODE_ENV !== 'production') {
+      errors.push.apply(errors, detectErrors(compiled.ast));
+    }
+    compiled.errors = errors;
+    compiled.tips = tips;
+    return compiled
+  }
+
+  function compileToFunctions (
+    template,
+    options,
+    vm
+  ) {
+    options = options || {};
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      // detect possible CSP restriction
+      try {
+        new Function('return 1');
+      } catch (e) {
+        if (e.toString().match(/unsafe-eval|CSP/)) {
+          warn(
+            'It seems you are using the standalone build of Vue.js in an ' +
+            'environment with Content Security Policy that prohibits unsafe-eval. ' +
+            'The template compiler cannot work in this environment. Consider ' +
+            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
+            'templates into render functions.'
+          );
+        }
+      }
+    }
+
+    // check cache
+    var key = options.delimiters
+      ? String(options.delimiters) + template
+      : template;
+    if (functionCompileCache[key]) {
+      return functionCompileCache[key]
+    }
+
+    // compile
+    var compiled = compile(template, options);
+
+    // check compilation errors/tips
+    if (process.env.NODE_ENV !== 'production') {
+      if (compiled.errors && compiled.errors.length) {
+        warn(
+          "Error compiling template:\n\n" + template + "\n\n" +
+          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
+          vm
+        );
+      }
+      if (compiled.tips && compiled.tips.length) {
+        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
+      }
+    }
+
+    // turn code into functions
+    var res = {};
+    var fnGenErrors = [];
+    res.render = makeFunction(compiled.render, fnGenErrors);
+    var l = compiled.staticRenderFns.length;
+    res.staticRenderFns = new Array(l);
+    for (var i = 0; i < l; i++) {
+      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
+    }
+
+    // check function generation errors.
+    // this should only happen if there is a bug in the compiler itself.
+    // mostly for codegen development use
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
+        warn(
+          "Failed to generate render function:\n\n" +
+          fnGenErrors.map(function (ref) {
+            var err = ref.err;
+            var code = ref.code;
+
+            return ((err.toString()) + " in\n\n" + code + "\n");
+        }).join('\n'),
+          vm
+        );
+      }
+    }
+
+    return (functionCompileCache[key] = res)
+  }
+
+  return {
+    compile: compile,
+    compileToFunctions: compileToFunctions
+  }
+}
+
+/*  */
+
+function transformNode (el, options) {
+  var warn = options.warn || baseWarn;
+  var staticClass = getAndRemoveAttr(el, 'class');
+  if (process.env.NODE_ENV !== 'production' && staticClass) {
+    var expression = parseText(staticClass, options.delimiters);
+    if (expression) {
+      warn(
+        "class=\"" + staticClass + "\": " +
+        'Interpolation inside attributes has been removed. ' +
+        'Use v-bind or the colon shorthand instead. For example, ' +
+        'instead of <div class="{{ val }}">, use <div :class="val">.'
+      );
+    }
+  }
+  if (staticClass) {
+    el.staticClass = JSON.stringify(staticClass);
+  }
+  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
+  if (classBinding) {
+    el.classBinding = classBinding;
+  }
+}
+
+function genData$1 (el) {
+  var data = '';
+  if (el.staticClass) {
+    data += "staticClass:" + (el.staticClass) + ",";
+  }
+  if (el.classBinding) {
+    data += "class:" + (el.classBinding) + ",";
+  }
+  return data
+}
+
+var klass$1 = {
+  staticKeys: ['staticClass'],
+  transformNode: transformNode,
+  genData: genData$1
+};
+
+/*  */
+
+function transformNode$1 (el, options) {
+  var warn = options.warn || baseWarn;
+  var staticStyle = getAndRemoveAttr(el, 'style');
+  if (staticStyle) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production') {
+      var expression = parseText(staticStyle, options.delimiters);
+      if (expression) {
+        warn(
+          "style=\"" + staticStyle + "\": " +
+          'Interpolation inside attributes has been removed. ' +
+          'Use v-bind or the colon shorthand instead. For example, ' +
+          'instead of <div style="{{ val }}">, use <div :style="val">.'
+        );
+      }
+    }
+    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
+  }
+
+  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
+  if (styleBinding) {
+    el.styleBinding = styleBinding;
+  }
+}
+
+function genData$2 (el) {
+  var data = '';
+  if (el.staticStyle) {
+    data += "staticStyle:" + (el.staticStyle) + ",";
+  }
+  if (el.styleBinding) {
+    data += "style:(" + (el.styleBinding) + "),";
+  }
+  return data
+}
+
+var style$1 = {
+  staticKeys: ['staticStyle'],
+  transformNode: transformNode$1,
+  genData: genData$2
+};
+
+var modules$1 = [
+  klass$1,
+  style$1
+];
+
+/*  */
+
+function text (el, dir) {
+  if (dir.value) {
+    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
+  }
+}
+
+/*  */
+
+function html (el, dir) {
+  if (dir.value) {
+    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
+  }
+}
+
+var directives$1 = {
+  model: model,
+  text: text,
+  html: html
+};
+
+/*  */
+
+var baseOptions = {
+  expectHTML: true,
+  modules: modules$1,
+  directives: directives$1,
+  isPreTag: isPreTag,
+  isUnaryTag: isUnaryTag,
+  mustUseProp: mustUseProp,
+  isReservedTag: isReservedTag,
+  getTagNamespace: getTagNamespace,
+  staticKeys: genStaticKeys(modules$1)
+};
+
+var ref$1 = createCompiler(baseOptions);
+var compileToFunctions = ref$1.compileToFunctions;
+
+/*  */
+
+var idToTemplate = cached(function (id) {
+  var el = query(id);
+  return el && el.innerHTML
+});
+
+var mount = Vue$3.prototype.$mount;
+Vue$3.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && query(el);
+
+  /* istanbul ignore if */
+  if (el === document.body || el === document.documentElement) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
+    );
+    return this
+  }
+
+  var options = this.$options;
+  // resolve template/el and convert to render function
+  if (!options.render) {
+    var template = options.template;
+    if (template) {
+      if (typeof template === 'string') {
+        if (template.charAt(0) === '#') {
+          template = idToTemplate(template);
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !template) {
+            warn(
+              ("Template element not found or is empty: " + (options.template)),
+              this
+            );
+          }
+        }
+      } else if (template.nodeType) {
+        template = template.innerHTML;
+      } else {
+        if (process.env.NODE_ENV !== 'production') {
+          warn('invalid template option:' + template, this);
+        }
+        return this
+      }
+    } else if (el) {
+      template = getOuterHTML(el);
+    }
+    if (template) {
+      /* istanbul ignore if */
+      if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+        perf.mark('compile');
+      }
+
+      var ref = compileToFunctions(template, {
+        shouldDecodeNewlines: shouldDecodeNewlines,
+        delimiters: options.delimiters
+      }, this);
+      var render = ref.render;
+      var staticRenderFns = ref.staticRenderFns;
+      options.render = render;
+      options.staticRenderFns = staticRenderFns;
+
+      /* istanbul ignore if */
+      if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+        perf.mark('compile end');
+        perf.measure(((this._name) + " compile"), 'compile', 'compile end');
+      }
+    }
+  }
+  return mount.call(this, el, hydrating)
+};
+
+/**
+ * Get outerHTML of elements, taking care
+ * of SVG elements in IE as well.
+ */
+function getOuterHTML (el) {
+  if (el.outerHTML) {
+    return el.outerHTML
+  } else {
+    var container = document.createElement('div');
+    container.appendChild(el.cloneNode(true));
+    return container.innerHTML
+  }
+}
+
+Vue$3.compile = compileToFunctions;
+
+module.exports = Vue$3;
Index: public/node_modules/vue/src/compiler/error-detector.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/error-detector.js	(revision )
+++ public/node_modules/vue/src/compiler/error-detector.js	(revision )
@@ -0,0 +1,97 @@
+/* @flow */
+
+import { dirRE, onRE } from './parser/index'
+
+// these keywords should not appear inside expressions, but operators like
+// typeof, instanceof and in are allowed
+const prohibitedKeywordRE = new RegExp('\\b' + (
+  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
+  'super,throw,while,yield,delete,export,import,return,switch,default,' +
+  'extends,finally,continue,debugger,function,arguments'
+).split(',').join('\\b|\\b') + '\\b')
+
+// these unary operators should not be used as property/method names
+const unaryOperatorsRE = new RegExp('\\b' + (
+  'delete,typeof,void'
+).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)')
+
+// check valid identifier for v-for
+const identRE = /[A-Za-z_$][\w$]*/
+
+// strip strings in expressions
+const stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g
+
+// detect problematic expressions in a template
+export function detectErrors (ast: ?ASTNode): Array<string> {
+  const errors: Array<string> = []
+  if (ast) {
+    checkNode(ast, errors)
+  }
+  return errors
+}
+
+function checkNode (node: ASTNode, errors: Array<string>) {
+  if (node.type === 1) {
+    for (const name in node.attrsMap) {
+      if (dirRE.test(name)) {
+        const value = node.attrsMap[name]
+        if (value) {
+          if (name === 'v-for') {
+            checkFor(node, `v-for="${value}"`, errors)
+          } else if (onRE.test(name)) {
+            checkEvent(value, `${name}="${value}"`, errors)
+          } else {
+            checkExpression(value, `${name}="${value}"`, errors)
+          }
+        }
+      }
+    }
+    if (node.children) {
+      for (let i = 0; i < node.children.length; i++) {
+        checkNode(node.children[i], errors)
+      }
+    }
+  } else if (node.type === 2) {
+    checkExpression(node.expression, node.text, errors)
+  }
+}
+
+function checkEvent (exp: string, text: string, errors: Array<string>) {
+  const keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE)
+  if (keywordMatch) {
+    errors.push(
+      `avoid using JavaScript unary operator as property name: ` +
+      `"${keywordMatch[0]}" in expression ${text.trim()}`
+    )
+  }
+  checkExpression(exp, text, errors)
+}
+
+function checkFor (node: ASTElement, text: string, errors: Array<string>) {
+  checkExpression(node.for || '', text, errors)
+  checkIdentifier(node.alias, 'v-for alias', text, errors)
+  checkIdentifier(node.iterator1, 'v-for iterator', text, errors)
+  checkIdentifier(node.iterator2, 'v-for iterator', text, errors)
+}
+
+function checkIdentifier (ident: ?string, type: string, text: string, errors: Array<string>) {
+  if (typeof ident === 'string' && !identRE.test(ident)) {
+    errors.push(`invalid ${type} "${ident}" in expression: ${text.trim()}`)
+  }
+}
+
+function checkExpression (exp: string, text: string, errors: Array<string>) {
+  try {
+    new Function(`return ${exp}`)
+  } catch (e) {
+    const keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE)
+    if (keywordMatch) {
+      errors.push(
+        `avoid using JavaScript keyword as property name: ` +
+        `"${keywordMatch[0]}" in expression ${text.trim()}`
+      )
+    } else {
+      errors.push(`invalid expression: ${text.trim()}`)
+    }
+  }
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/buffer-stream.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/buffer-stream.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/buffer-stream.js	(revision )
@@ -0,0 +1,51 @@
+'use strict';
+const PassThrough = require('stream').PassThrough;
+
+module.exports = opts => {
+	opts = Object.assign({}, opts);
+
+	const array = opts.array;
+	let encoding = opts.encoding;
+	const buffer = encoding === 'buffer';
+	let objectMode = false;
+
+	if (array) {
+		objectMode = !(encoding || buffer);
+	} else {
+		encoding = encoding || 'utf8';
+	}
+
+	if (buffer) {
+		encoding = null;
+	}
+
+	let len = 0;
+	const ret = [];
+	const stream = new PassThrough({objectMode});
+
+	if (encoding) {
+		stream.setEncoding(encoding);
+	}
+
+	stream.on('data', chunk => {
+		ret.push(chunk);
+
+		if (objectMode) {
+			len = ret.length;
+		} else {
+			len += chunk.length;
+		}
+	});
+
+	stream.getBufferedValue = () => {
+		if (array) {
+			return ret;
+		}
+
+		return buffer ? Buffer.concat(ret, len) : ret.join('');
+	};
+
+	stream.getBufferedLength = () => len;
+
+	return stream;
+};
Index: public/node_modules/vue/src/core/vdom/create-component.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/create-component.js	(revision )
+++ public/node_modules/vue/src/core/vdom/create-component.js	(revision )
@@ -0,0 +1,354 @@
+/* @flow */
+
+import VNode from './vnode'
+import { createElement } from './create-element'
+import { resolveConstructorOptions } from '../instance/init'
+import { resolveSlots } from '../instance/render-helpers/resolve-slots'
+
+import {
+  warn,
+  isObject,
+  hasOwn,
+  hyphenate,
+  validateProp
+} from '../util/index'
+
+import {
+  callHook,
+  activeInstance,
+  updateChildComponent,
+  activateChildComponent,
+  deactivateChildComponent
+} from '../instance/lifecycle'
+
+const hooks = { init, prepatch, insert, destroy }
+const hooksToMerge = Object.keys(hooks)
+
+export function createComponent (
+  Ctor: Class<Component> | Function | Object | void,
+  data?: VNodeData,
+  context: Component,
+  children: ?Array<VNode>,
+  tag?: string
+): VNode | void {
+  if (!Ctor) {
+    return
+  }
+
+  const baseCtor = context.$options._base
+  if (isObject(Ctor)) {
+    Ctor = baseCtor.extend(Ctor)
+  }
+
+  if (typeof Ctor !== 'function') {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(`Invalid Component definition: ${String(Ctor)}`, context)
+    }
+    return
+  }
+
+  // async component
+  if (!Ctor.cid) {
+    if (Ctor.resolved) {
+      Ctor = Ctor.resolved
+    } else {
+      Ctor = resolveAsyncComponent(Ctor, baseCtor, () => {
+        // it's ok to queue this on every render because
+        // $forceUpdate is buffered by the scheduler.
+        context.$forceUpdate()
+      })
+      if (!Ctor) {
+        // return nothing if this is indeed an async component
+        // wait for the callback to trigger parent update.
+        return
+      }
+    }
+  }
+
+  // resolve constructor options in case global mixins are applied after
+  // component constructor creation
+  resolveConstructorOptions(Ctor)
+
+  data = data || {}
+
+  // transform component v-model data into props & events
+  if (data.model) {
+    transformModel(Ctor.options, data)
+  }
+
+  // extract props
+  const propsData = extractProps(data, Ctor)
+
+  // functional component
+  if (Ctor.options.functional) {
+    return createFunctionalComponent(Ctor, propsData, data, context, children)
+  }
+
+  // extract listeners, since these needs to be treated as
+  // child component listeners instead of DOM listeners
+  const listeners = data.on
+  // replace with listeners with .native modifier
+  data.on = data.nativeOn
+
+  if (Ctor.options.abstract) {
+    // abstract components do not keep anything
+    // other than props & listeners
+    data = {}
+  }
+
+  // merge component management hooks onto the placeholder node
+  mergeHooks(data)
+
+  // return a placeholder vnode
+  const name = Ctor.options.name || tag
+  const vnode = new VNode(
+    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
+    data, undefined, undefined, undefined, context,
+    { Ctor, propsData, listeners, tag, children }
+  )
+  return vnode
+}
+
+function createFunctionalComponent (
+  Ctor: Class<Component>,
+  propsData: ?Object,
+  data: VNodeData,
+  context: Component,
+  children: ?Array<VNode>
+): VNode | void {
+  const props = {}
+  const propOptions = Ctor.options.props
+  if (propOptions) {
+    for (const key in propOptions) {
+      props[key] = validateProp(key, propOptions, propsData)
+    }
+  }
+  // ensure the createElement function in functional components
+  // gets a unique context - this is necessary for correct named slot check
+  const _context = Object.create(context)
+  const h = (a, b, c, d) => createElement(_context, a, b, c, d, true)
+  const vnode = Ctor.options.render.call(null, h, {
+    props,
+    data,
+    parent: context,
+    children,
+    slots: () => resolveSlots(children, context)
+  })
+  if (vnode instanceof VNode) {
+    vnode.functionalContext = context
+    if (data.slot) {
+      (vnode.data || (vnode.data = {})).slot = data.slot
+    }
+  }
+  return vnode
+}
+
+export function createComponentInstanceForVnode (
+  vnode: any, // we know it's MountedComponentVNode but flow doesn't
+  parent: any, // activeInstance in lifecycle state
+  parentElm?: ?Node,
+  refElm?: ?Node
+): Component {
+  const vnodeComponentOptions = vnode.componentOptions
+  const options: InternalComponentOptions = {
+    _isComponent: true,
+    parent,
+    propsData: vnodeComponentOptions.propsData,
+    _componentTag: vnodeComponentOptions.tag,
+    _parentVnode: vnode,
+    _parentListeners: vnodeComponentOptions.listeners,
+    _renderChildren: vnodeComponentOptions.children,
+    _parentElm: parentElm || null,
+    _refElm: refElm || null
+  }
+  // check inline-template render functions
+  const inlineTemplate = vnode.data.inlineTemplate
+  if (inlineTemplate) {
+    options.render = inlineTemplate.render
+    options.staticRenderFns = inlineTemplate.staticRenderFns
+  }
+  return new vnodeComponentOptions.Ctor(options)
+}
+
+function init (
+  vnode: VNodeWithData,
+  hydrating: boolean,
+  parentElm: ?Node,
+  refElm: ?Node
+): ?boolean {
+  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
+    const child = vnode.componentInstance = createComponentInstanceForVnode(
+      vnode,
+      activeInstance,
+      parentElm,
+      refElm
+    )
+    child.$mount(hydrating ? vnode.elm : undefined, hydrating)
+  } else if (vnode.data.keepAlive) {
+    // kept-alive components, treat as a patch
+    const mountedNode: any = vnode // work around flow
+    prepatch(mountedNode, mountedNode)
+  }
+}
+
+function prepatch (
+  oldVnode: MountedComponentVNode,
+  vnode: MountedComponentVNode
+) {
+  const options = vnode.componentOptions
+  const child = vnode.componentInstance = oldVnode.componentInstance
+  updateChildComponent(
+    child,
+    options.propsData, // updated props
+    options.listeners, // updated listeners
+    vnode, // new parent vnode
+    options.children // new children
+  )
+}
+
+function insert (vnode: MountedComponentVNode) {
+  if (!vnode.componentInstance._isMounted) {
+    vnode.componentInstance._isMounted = true
+    callHook(vnode.componentInstance, 'mounted')
+  }
+  if (vnode.data.keepAlive) {
+    activateChildComponent(vnode.componentInstance, true /* direct */)
+  }
+}
+
+function destroy (vnode: MountedComponentVNode) {
+  if (!vnode.componentInstance._isDestroyed) {
+    if (!vnode.data.keepAlive) {
+      vnode.componentInstance.$destroy()
+    } else {
+      deactivateChildComponent(vnode.componentInstance, true /* direct */)
+    }
+  }
+}
+
+function resolveAsyncComponent (
+  factory: Function,
+  baseCtor: Class<Component>,
+  cb: Function
+): Class<Component> | void {
+  if (factory.requested) {
+    // pool callbacks
+    factory.pendingCallbacks.push(cb)
+  } else {
+    factory.requested = true
+    const cbs = factory.pendingCallbacks = [cb]
+    let sync = true
+
+    const resolve = (res: Object | Class<Component>) => {
+      if (isObject(res)) {
+        res = baseCtor.extend(res)
+      }
+      // cache resolved
+      factory.resolved = res
+      // invoke callbacks only if this is not a synchronous resolve
+      // (async resolves are shimmed as synchronous during SSR)
+      if (!sync) {
+        for (let i = 0, l = cbs.length; i < l; i++) {
+          cbs[i](res)
+        }
+      }
+    }
+
+    const reject = reason => {
+      process.env.NODE_ENV !== 'production' && warn(
+        `Failed to resolve async component: ${String(factory)}` +
+        (reason ? `\nReason: ${reason}` : '')
+      )
+    }
+
+    const res = factory(resolve, reject)
+
+    // handle promise
+    if (res && typeof res.then === 'function' && !factory.resolved) {
+      res.then(resolve, reject)
+    }
+
+    sync = false
+    // return in case resolved synchronously
+    return factory.resolved
+  }
+}
+
+function extractProps (data: VNodeData, Ctor: Class<Component>): ?Object {
+  // we are only extracting raw values here.
+  // validation and default values are handled in the child
+  // component itself.
+  const propOptions = Ctor.options.props
+  if (!propOptions) {
+    return
+  }
+  const res = {}
+  const { attrs, props, domProps } = data
+  if (attrs || props || domProps) {
+    for (const key in propOptions) {
+      const altKey = hyphenate(key)
+      checkProp(res, props, key, altKey, true) ||
+      checkProp(res, attrs, key, altKey) ||
+      checkProp(res, domProps, key, altKey)
+    }
+  }
+  return res
+}
+
+function checkProp (
+  res: Object,
+  hash: ?Object,
+  key: string,
+  altKey: string,
+  preserve?: boolean
+): boolean {
+  if (hash) {
+    if (hasOwn(hash, key)) {
+      res[key] = hash[key]
+      if (!preserve) {
+        delete hash[key]
+      }
+      return true
+    } else if (hasOwn(hash, altKey)) {
+      res[key] = hash[altKey]
+      if (!preserve) {
+        delete hash[altKey]
+      }
+      return true
+    }
+  }
+  return false
+}
+
+function mergeHooks (data: VNodeData) {
+  if (!data.hook) {
+    data.hook = {}
+  }
+  for (let i = 0; i < hooksToMerge.length; i++) {
+    const key = hooksToMerge[i]
+    const fromParent = data.hook[key]
+    const ours = hooks[key]
+    data.hook[key] = fromParent ? mergeHook(ours, fromParent) : ours
+  }
+}
+
+function mergeHook (one: Function, two: Function): Function {
+  return function (a, b, c, d) {
+    one(a, b, c, d)
+    two(a, b, c, d)
+  }
+}
+
+// transform component v-model info (value and callback) into
+// prop and event handler respectively.
+function transformModel (options, data: any) {
+  const prop = (options.model && options.model.prop) || 'value'
+  const event = (options.model && options.model.event) || 'input'
+  ;(data.props || (data.props = {}))[prop] = data.model.value
+  const on = data.on || (data.on = {})
+  if (on[event]) {
+    on[event] = [data.model.callback].concat(on[event])
+  } else {
+    on[event] = data.model.callback
+  }
+}
Index: public/node_modules/vue/src/entries/weex-compiler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/entries/weex-compiler.js	(revision )
+++ public/node_modules/vue/src/entries/weex-compiler.js	(revision )
@@ -0,0 +1,3 @@
+/* @flow */
+
+export { compile } from 'weex/compiler/index'
Index: public/node_modules/vue/src/core/vdom/vnode.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/vnode.js	(revision )
+++ public/node_modules/vue/src/core/vdom/vnode.js	(revision )
@@ -0,0 +1,98 @@
+/* @flow */
+
+export default class VNode {
+  tag: string | void;
+  data: VNodeData | void;
+  children: ?Array<VNode>;
+  text: string | void;
+  elm: Node | void;
+  ns: string | void;
+  context: Component | void; // rendered in this component's scope
+  functionalContext: Component | void; // only for functional component root nodes
+  key: string | number | void;
+  componentOptions: VNodeComponentOptions | void;
+  componentInstance: Component | void; // component instance
+  parent: VNode | void; // component placeholder node
+  raw: boolean; // contains raw HTML? (server only)
+  isStatic: boolean; // hoisted static node
+  isRootInsert: boolean; // necessary for enter transition check
+  isComment: boolean; // empty comment placeholder?
+  isCloned: boolean; // is a cloned node?
+  isOnce: boolean; // is a v-once node?
+
+  constructor (
+    tag?: string,
+    data?: VNodeData,
+    children?: ?Array<VNode>,
+    text?: string,
+    elm?: Node,
+    context?: Component,
+    componentOptions?: VNodeComponentOptions
+  ) {
+    this.tag = tag
+    this.data = data
+    this.children = children
+    this.text = text
+    this.elm = elm
+    this.ns = undefined
+    this.context = context
+    this.functionalContext = undefined
+    this.key = data && data.key
+    this.componentOptions = componentOptions
+    this.componentInstance = undefined
+    this.parent = undefined
+    this.raw = false
+    this.isStatic = false
+    this.isRootInsert = true
+    this.isComment = false
+    this.isCloned = false
+    this.isOnce = false
+  }
+
+  // DEPRECATED: alias for componentInstance for backwards compat.
+  /* istanbul ignore next */
+  get child (): Component | void {
+    return this.componentInstance
+  }
+}
+
+export const createEmptyVNode = () => {
+  const node = new VNode()
+  node.text = ''
+  node.isComment = true
+  return node
+}
+
+export function createTextVNode (val: string | number) {
+  return new VNode(undefined, undefined, undefined, String(val))
+}
+
+// optimized shallow clone
+// used for static nodes and slot nodes because they may be reused across
+// multiple renders, cloning them avoids errors when DOM manipulations rely
+// on their elm reference.
+export function cloneVNode (vnode: VNode): VNode {
+  const cloned = new VNode(
+    vnode.tag,
+    vnode.data,
+    vnode.children,
+    vnode.text,
+    vnode.elm,
+    vnode.context,
+    vnode.componentOptions
+  )
+  cloned.ns = vnode.ns
+  cloned.isStatic = vnode.isStatic
+  cloned.key = vnode.key
+  cloned.isCloned = true
+  return cloned
+}
+
+export function cloneVNodes (vnodes: Array<VNode>): Array<VNode> {
+  const len = vnodes.length
+  const res = new Array(len)
+  for (let i = 0; i < len; i++) {
+    res[i] = cloneVNode(vnodes[i])
+  }
+  return res
+}
Index: public/node_modules/vue/src/platforms/weex/runtime/modules/events.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/modules/events.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/modules/events.js	(revision )
@@ -0,0 +1,54 @@
+/* @flow */
+
+import { updateListeners } from 'core/vdom/helpers/update-listeners'
+
+let target: any
+
+function add (
+  event: string,
+  handler: Function,
+  once: boolean,
+  capture: boolean
+) {
+  if (capture) {
+    console.log('Weex do not support event in bubble phase.')
+    return
+  }
+  if (once) {
+    const oldHandler = handler
+    const _target = target // save current target element in closure
+    handler = function (ev) {
+      const res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments)
+      if (res !== null) {
+        remove(event, null, null, _target)
+      }
+    }
+  }
+  target.addEvent(event, handler)
+}
+
+function remove (
+  event: string,
+  handler: any,
+  capture: any,
+  _target?: any
+) {
+  (_target || target).removeEvent(event)
+}
+
+function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  const on = vnode.data.on || {}
+  const oldOn = oldVnode.data.on || {}
+  target = vnode.elm
+  updateListeners(on, oldOn, add, remove, vnode.context)
+}
+
+export default {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+}
Index: public/node_modules/vue-resource/dist/vue-resource.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/dist/vue-resource.js	(revision )
+++ public/node_modules/vue-resource/dist/vue-resource.js	(revision )
@@ -0,0 +1,1534 @@
+/*!
+ * vue-resource v1.2.1
+ * https://github.com/pagekit/vue-resource
+ * Released under the MIT License.
+ */
+
+(function (global, factory) {
+	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
+	typeof define === 'function' && define.amd ? define(factory) :
+	(global.VueResource = factory());
+}(this, (function () { 'use strict';
+
+/**
+ * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
+ */
+
+var RESOLVED = 0;
+var REJECTED = 1;
+var PENDING  = 2;
+
+function Promise$1(executor) {
+
+    this.state = PENDING;
+    this.value = undefined;
+    this.deferred = [];
+
+    var promise = this;
+
+    try {
+        executor(function (x) {
+            promise.resolve(x);
+        }, function (r) {
+            promise.reject(r);
+        });
+    } catch (e) {
+        promise.reject(e);
+    }
+}
+
+Promise$1.reject = function (r) {
+    return new Promise$1(function (resolve, reject) {
+        reject(r);
+    });
+};
+
+Promise$1.resolve = function (x) {
+    return new Promise$1(function (resolve, reject) {
+        resolve(x);
+    });
+};
+
+Promise$1.all = function all(iterable) {
+    return new Promise$1(function (resolve, reject) {
+        var count = 0, result = [];
+
+        if (iterable.length === 0) {
+            resolve(result);
+        }
+
+        function resolver(i) {
+            return function (x) {
+                result[i] = x;
+                count += 1;
+
+                if (count === iterable.length) {
+                    resolve(result);
+                }
+            };
+        }
+
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise$1.resolve(iterable[i]).then(resolver(i), reject);
+        }
+    });
+};
+
+Promise$1.race = function race(iterable) {
+    return new Promise$1(function (resolve, reject) {
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise$1.resolve(iterable[i]).then(resolve, reject);
+        }
+    });
+};
+
+var p$1 = Promise$1.prototype;
+
+p$1.resolve = function resolve(x) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (x === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        var called = false;
+
+        try {
+            var then = x && x['then'];
+
+            if (x !== null && typeof x === 'object' && typeof then === 'function') {
+                then.call(x, function (x) {
+                    if (!called) {
+                        promise.resolve(x);
+                    }
+                    called = true;
+
+                }, function (r) {
+                    if (!called) {
+                        promise.reject(r);
+                    }
+                    called = true;
+                });
+                return;
+            }
+        } catch (e) {
+            if (!called) {
+                promise.reject(e);
+            }
+            return;
+        }
+
+        promise.state = RESOLVED;
+        promise.value = x;
+        promise.notify();
+    }
+};
+
+p$1.reject = function reject(reason) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (reason === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        promise.state = REJECTED;
+        promise.value = reason;
+        promise.notify();
+    }
+};
+
+p$1.notify = function notify() {
+    var promise = this;
+
+    nextTick(function () {
+        if (promise.state !== PENDING) {
+            while (promise.deferred.length) {
+                var deferred = promise.deferred.shift(),
+                    onResolved = deferred[0],
+                    onRejected = deferred[1],
+                    resolve = deferred[2],
+                    reject = deferred[3];
+
+                try {
+                    if (promise.state === RESOLVED) {
+                        if (typeof onResolved === 'function') {
+                            resolve(onResolved.call(undefined, promise.value));
+                        } else {
+                            resolve(promise.value);
+                        }
+                    } else if (promise.state === REJECTED) {
+                        if (typeof onRejected === 'function') {
+                            resolve(onRejected.call(undefined, promise.value));
+                        } else {
+                            reject(promise.value);
+                        }
+                    }
+                } catch (e) {
+                    reject(e);
+                }
+            }
+        }
+    });
+};
+
+p$1.then = function then(onResolved, onRejected) {
+    var promise = this;
+
+    return new Promise$1(function (resolve, reject) {
+        promise.deferred.push([onResolved, onRejected, resolve, reject]);
+        promise.notify();
+    });
+};
+
+p$1.catch = function (onRejected) {
+    return this.then(undefined, onRejected);
+};
+
+/**
+ * Promise adapter.
+ */
+
+if (typeof Promise === 'undefined') {
+    window.Promise = Promise$1;
+}
+
+function PromiseObj(executor, context) {
+
+    if (executor instanceof Promise) {
+        this.promise = executor;
+    } else {
+        this.promise = new Promise(executor.bind(context));
+    }
+
+    this.context = context;
+}
+
+PromiseObj.all = function (iterable, context) {
+    return new PromiseObj(Promise.all(iterable), context);
+};
+
+PromiseObj.resolve = function (value, context) {
+    return new PromiseObj(Promise.resolve(value), context);
+};
+
+PromiseObj.reject = function (reason, context) {
+    return new PromiseObj(Promise.reject(reason), context);
+};
+
+PromiseObj.race = function (iterable, context) {
+    return new PromiseObj(Promise.race(iterable), context);
+};
+
+var p = PromiseObj.prototype;
+
+p.bind = function (context) {
+    this.context = context;
+    return this;
+};
+
+p.then = function (fulfilled, rejected) {
+
+    if (fulfilled && fulfilled.bind && this.context) {
+        fulfilled = fulfilled.bind(this.context);
+    }
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
+};
+
+p.catch = function (rejected) {
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.catch(rejected), this.context);
+};
+
+p.finally = function (callback) {
+
+    return this.then(function (value) {
+            callback.call(this);
+            return value;
+        }, function (reason) {
+            callback.call(this);
+            return Promise.reject(reason);
+        }
+    );
+};
+
+/**
+ * Utility functions.
+ */
+
+var ref = {};
+var hasOwnProperty = ref.hasOwnProperty;
+
+var ref$1 = [];
+var slice = ref$1.slice;
+var debug = false;
+var ntick;
+
+var inBrowser = typeof window !== 'undefined';
+
+var Util = function (ref) {
+    var config = ref.config;
+    var nextTick = ref.nextTick;
+
+    ntick = nextTick;
+    debug = config.debug || !config.silent;
+};
+
+function warn(msg) {
+    if (typeof console !== 'undefined' && debug) {
+        console.warn('[VueResource warn]: ' + msg);
+    }
+}
+
+function error(msg) {
+    if (typeof console !== 'undefined') {
+        console.error(msg);
+    }
+}
+
+function nextTick(cb, ctx) {
+    return ntick(cb, ctx);
+}
+
+function trim(str) {
+    return str ? str.replace(/^\s*|\s*$/g, '') : '';
+}
+
+function toLower(str) {
+    return str ? str.toLowerCase() : '';
+}
+
+function toUpper(str) {
+    return str ? str.toUpperCase() : '';
+}
+
+var isArray = Array.isArray;
+
+function isString(val) {
+    return typeof val === 'string';
+}
+
+
+
+function isFunction(val) {
+    return typeof val === 'function';
+}
+
+function isObject(obj) {
+    return obj !== null && typeof obj === 'object';
+}
+
+function isPlainObject(obj) {
+    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
+}
+
+function isBlob(obj) {
+    return typeof Blob !== 'undefined' && obj instanceof Blob;
+}
+
+function isFormData(obj) {
+    return typeof FormData !== 'undefined' && obj instanceof FormData;
+}
+
+function when(value, fulfilled, rejected) {
+
+    var promise = PromiseObj.resolve(value);
+
+    if (arguments.length < 2) {
+        return promise;
+    }
+
+    return promise.then(fulfilled, rejected);
+}
+
+function options(fn, obj, opts) {
+
+    opts = opts || {};
+
+    if (isFunction(opts)) {
+        opts = opts.call(obj);
+    }
+
+    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
+}
+
+function each(obj, iterator) {
+
+    var i, key;
+
+    if (isArray(obj)) {
+        for (i = 0; i < obj.length; i++) {
+            iterator.call(obj[i], obj[i], i);
+        }
+    } else if (isObject(obj)) {
+        for (key in obj) {
+            if (hasOwnProperty.call(obj, key)) {
+                iterator.call(obj[key], obj[key], key);
+            }
+        }
+    }
+
+    return obj;
+}
+
+var assign = Object.assign || _assign;
+
+function merge(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+        _merge(target, source, true);
+    });
+
+    return target;
+}
+
+function defaults(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+
+        for (var key in source) {
+            if (target[key] === undefined) {
+                target[key] = source[key];
+            }
+        }
+
+    });
+
+    return target;
+}
+
+function _assign(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+        _merge(target, source);
+    });
+
+    return target;
+}
+
+function _merge(target, source, deep) {
+    for (var key in source) {
+        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
+            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
+                target[key] = {};
+            }
+            if (isArray(source[key]) && !isArray(target[key])) {
+                target[key] = [];
+            }
+            _merge(target[key], source[key], deep);
+        } else if (source[key] !== undefined) {
+            target[key] = source[key];
+        }
+    }
+}
+
+/**
+ * Root Prefix Transform.
+ */
+
+var root = function (options$$1, next) {
+
+    var url = next(options$$1);
+
+    if (isString(options$$1.root) && !url.match(/^(https?:)?\//)) {
+        url = options$$1.root + '/' + url;
+    }
+
+    return url;
+};
+
+/**
+ * Query Parameter Transform.
+ */
+
+var query = function (options$$1, next) {
+
+    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);
+
+    each(options$$1.params, function (value, key) {
+        if (urlParams.indexOf(key) === -1) {
+            query[key] = value;
+        }
+    });
+
+    query = Url.params(query);
+
+    if (query) {
+        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
+    }
+
+    return url;
+};
+
+/**
+ * URL Template v2.0.6 (https://github.com/bramstein/url-template)
+ */
+
+function expand(url, params, variables) {
+
+    var tmpl = parse(url), expanded = tmpl.expand(params);
+
+    if (variables) {
+        variables.push.apply(variables, tmpl.vars);
+    }
+
+    return expanded;
+}
+
+function parse(template) {
+
+    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];
+
+    return {
+        vars: variables,
+        expand: function expand(context) {
+            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
+                if (expression) {
+
+                    var operator = null, values = [];
+
+                    if (operators.indexOf(expression.charAt(0)) !== -1) {
+                        operator = expression.charAt(0);
+                        expression = expression.substr(1);
+                    }
+
+                    expression.split(/,/g).forEach(function (variable) {
+                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
+                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
+                        variables.push(tmp[1]);
+                    });
+
+                    if (operator && operator !== '+') {
+
+                        var separator = ',';
+
+                        if (operator === '?') {
+                            separator = '&';
+                        } else if (operator !== '#') {
+                            separator = operator;
+                        }
+
+                        return (values.length !== 0 ? operator : '') + values.join(separator);
+                    } else {
+                        return values.join(',');
+                    }
+
+                } else {
+                    return encodeReserved(literal);
+                }
+            });
+        }
+    };
+}
+
+function getValues(context, operator, key, modifier) {
+
+    var value = context[key], result = [];
+
+    if (isDefined(value) && value !== '') {
+        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
+            value = value.toString();
+
+            if (modifier && modifier !== '*') {
+                value = value.substring(0, parseInt(modifier, 10));
+            }
+
+            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+        } else {
+            if (modifier === '*') {
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach(function (value) {
+                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+                    });
+                } else {
+                    Object.keys(value).forEach(function (k) {
+                        if (isDefined(value[k])) {
+                            result.push(encodeValue(operator, value[k], k));
+                        }
+                    });
+                }
+            } else {
+                var tmp = [];
+
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach(function (value) {
+                        tmp.push(encodeValue(operator, value));
+                    });
+                } else {
+                    Object.keys(value).forEach(function (k) {
+                        if (isDefined(value[k])) {
+                            tmp.push(encodeURIComponent(k));
+                            tmp.push(encodeValue(operator, value[k].toString()));
+                        }
+                    });
+                }
+
+                if (isKeyOperator(operator)) {
+                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
+                } else if (tmp.length !== 0) {
+                    result.push(tmp.join(','));
+                }
+            }
+        }
+    } else {
+        if (operator === ';') {
+            result.push(encodeURIComponent(key));
+        } else if (value === '' && (operator === '&' || operator === '?')) {
+            result.push(encodeURIComponent(key) + '=');
+        } else if (value === '') {
+            result.push('');
+        }
+    }
+
+    return result;
+}
+
+function isDefined(value) {
+    return value !== undefined && value !== null;
+}
+
+function isKeyOperator(operator) {
+    return operator === ';' || operator === '&' || operator === '?';
+}
+
+function encodeValue(operator, value, key) {
+
+    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);
+
+    if (key) {
+        return encodeURIComponent(key) + '=' + value;
+    } else {
+        return value;
+    }
+}
+
+function encodeReserved(str) {
+    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
+        if (!/%[0-9A-Fa-f]/.test(part)) {
+            part = encodeURI(part);
+        }
+        return part;
+    }).join('');
+}
+
+/**
+ * URL Template (RFC 6570) Transform.
+ */
+
+var template = function (options) {
+
+    var variables = [], url = expand(options.url, options.params, variables);
+
+    variables.forEach(function (key) {
+        delete options.params[key];
+    });
+
+    return url;
+};
+
+/**
+ * Service for URL templating.
+ */
+
+function Url(url, params) {
+
+    var self = this || {}, options$$1 = url, transform;
+
+    if (isString(url)) {
+        options$$1 = {url: url, params: params};
+    }
+
+    options$$1 = merge({}, Url.options, self.$options, options$$1);
+
+    Url.transforms.forEach(function (handler) {
+        transform = factory(handler, transform, self.$vm);
+    });
+
+    return transform(options$$1);
+}
+
+/**
+ * Url options.
+ */
+
+Url.options = {
+    url: '',
+    root: null,
+    params: {}
+};
+
+/**
+ * Url transforms.
+ */
+
+Url.transforms = [template, query, root];
+
+/**
+ * Encodes a Url parameter string.
+ *
+ * @param {Object} obj
+ */
+
+Url.params = function (obj) {
+
+    var params = [], escape = encodeURIComponent;
+
+    params.add = function (key, value) {
+
+        if (isFunction(value)) {
+            value = value();
+        }
+
+        if (value === null) {
+            value = '';
+        }
+
+        this.push(escape(key) + '=' + escape(value));
+    };
+
+    serialize(params, obj);
+
+    return params.join('&').replace(/%20/g, '+');
+};
+
+/**
+ * Parse a URL and return its components.
+ *
+ * @param {String} url
+ */
+
+Url.parse = function (url) {
+
+    var el = document.createElement('a');
+
+    if (document.documentMode) {
+        el.href = url;
+        url = el.href;
+    }
+
+    el.href = url;
+
+    return {
+        href: el.href,
+        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
+        port: el.port,
+        host: el.host,
+        hostname: el.hostname,
+        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
+        search: el.search ? el.search.replace(/^\?/, '') : '',
+        hash: el.hash ? el.hash.replace(/^#/, '') : ''
+    };
+};
+
+function factory(handler, next, vm) {
+    return function (options$$1) {
+        return handler.call(vm, options$$1, next);
+    };
+}
+
+function serialize(params, obj, scope) {
+
+    var array = isArray(obj), plain = isPlainObject(obj), hash;
+
+    each(obj, function (value, key) {
+
+        hash = isObject(value) || isArray(value);
+
+        if (scope) {
+            key = scope + '[' + (plain || hash ? key : '') + ']';
+        }
+
+        if (!scope && array) {
+            params.add(value.name, value.value);
+        } else if (hash) {
+            serialize(params, value, key);
+        } else {
+            params.add(key, value);
+        }
+    });
+}
+
+/**
+ * XDomain client (Internet Explorer).
+ */
+
+var xdrClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var xdr = new XDomainRequest(), handler = function (ref) {
+            var type = ref.type;
+
+
+            var status = 0;
+
+            if (type === 'load') {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            resolve(request.respondWith(xdr.responseText, {status: status}));
+        };
+
+        request.abort = function () { return xdr.abort(); };
+
+        xdr.open(request.method, request.getUrl());
+
+        if (request.timeout) {
+            xdr.timeout = request.timeout;
+        }
+
+        xdr.onload = handler;
+        xdr.onabort = handler;
+        xdr.onerror = handler;
+        xdr.ontimeout = handler;
+        xdr.onprogress = function () {};
+        xdr.send(request.getBody());
+    });
+};
+
+/**
+ * CORS Interceptor.
+ */
+
+var SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();
+
+var cors = function (request, next) {
+
+    if (inBrowser) {
+
+        var orgUrl = Url.parse(location.href);
+        var reqUrl = Url.parse(request.getUrl());
+
+        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {
+
+            request.crossOrigin = true;
+            request.emulateHTTP = false;
+
+            if (!SUPPORTS_CORS) {
+                request.client = xdrClient;
+            }
+        }
+    }
+
+    next();
+};
+
+/**
+ * Body Interceptor.
+ */
+
+var body = function (request, next) {
+
+    if (isFormData(request.body)) {
+
+        request.headers.delete('Content-Type');
+
+    } else if (isObject(request.body) || isArray(request.body)) {
+
+        if (request.emulateJSON) {
+            request.body = Url.params(request.body);
+            request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
+        } else {
+            request.body = JSON.stringify(request.body);
+        }
+    }
+
+    next(function (response) {
+
+        Object.defineProperty(response, 'data', {
+
+            get: function get() {
+                return this.body;
+            },
+
+            set: function set(body) {
+                this.body = body;
+            }
+
+        });
+
+        return response.bodyText ? when(response.text(), function (text) {
+
+            var type = response.headers.get('Content-Type') || '';
+
+            if (type.indexOf('application/json') === 0 || isJson(text)) {
+
+                try {
+                    response.body = JSON.parse(text);
+                } catch (e) {
+                    response.body = null;
+                }
+
+            } else {
+                response.body = text;
+            }
+
+            return response;
+
+        }) : response;
+
+    });
+};
+
+function isJson(str) {
+
+    var start = str.match(/^\[|^\{(?!\{)/), end = {'[': /]$/, '{': /}$/};
+
+    return start && end[start[0]].test(str);
+}
+
+/**
+ * JSONP client (Browser).
+ */
+
+var jsonpClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;
+
+        handler = function (ref) {
+            var type = ref.type;
+
+
+            var status = 0;
+
+            if (type === 'load' && body !== null) {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            if (status && window[callback]) {
+                delete window[callback];
+                document.body.removeChild(script);
+            }
+
+            resolve(request.respondWith(body, {status: status}));
+        };
+
+        window[callback] = function (result) {
+            body = JSON.stringify(result);
+        };
+
+        request.abort = function () {
+            handler({type: 'abort'});
+        };
+
+        request.params[name] = callback;
+
+        if (request.timeout) {
+            setTimeout(request.abort, request.timeout);
+        }
+
+        script = document.createElement('script');
+        script.src = request.getUrl();
+        script.type = 'text/javascript';
+        script.async = true;
+        script.onload = handler;
+        script.onerror = handler;
+
+        document.body.appendChild(script);
+    });
+};
+
+/**
+ * JSONP Interceptor.
+ */
+
+var jsonp = function (request, next) {
+
+    if (request.method == 'JSONP') {
+        request.client = jsonpClient;
+    }
+
+    next();
+};
+
+/**
+ * Before Interceptor.
+ */
+
+var before = function (request, next) {
+
+    if (isFunction(request.before)) {
+        request.before.call(this, request);
+    }
+
+    next();
+};
+
+/**
+ * HTTP method override Interceptor.
+ */
+
+var method = function (request, next) {
+
+    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
+        request.headers.set('X-HTTP-Method-Override', request.method);
+        request.method = 'POST';
+    }
+
+    next();
+};
+
+/**
+ * Header Interceptor.
+ */
+
+var header = function (request, next) {
+
+    var headers = assign({}, Http.headers.common,
+        !request.crossOrigin ? Http.headers.custom : {},
+        Http.headers[toLower(request.method)]
+    );
+
+    each(headers, function (value, name) {
+        if (!request.headers.has(name)) {
+            request.headers.set(name, value);
+        }
+    });
+
+    next();
+};
+
+/**
+ * XMLHttp client (Browser).
+ */
+
+var SUPPORTS_BLOB = typeof Blob !== 'undefined' && typeof FileReader !== 'undefined';
+
+var xhrClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var xhr = new XMLHttpRequest(), handler = function (event) {
+
+            var response = request.respondWith(
+                'response' in xhr ? xhr.response : xhr.responseText, {
+                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
+                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
+                }
+            );
+
+            each(trim(xhr.getAllResponseHeaders()).split('\n'), function (row) {
+                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
+            });
+
+            resolve(response);
+        };
+
+        request.abort = function () { return xhr.abort(); };
+
+        if (request.progress) {
+            if (request.method === 'GET') {
+                xhr.addEventListener('progress', request.progress);
+            } else if (/^(POST|PUT)$/i.test(request.method)) {
+                xhr.upload.addEventListener('progress', request.progress);
+            }
+        }
+
+        xhr.open(request.method, request.getUrl(), true);
+
+        if (request.timeout) {
+            xhr.timeout = request.timeout;
+        }
+
+        if (request.credentials === true) {
+            xhr.withCredentials = true;
+        }
+
+        if (!request.crossOrigin) {
+            request.headers.set('X-Requested-With', 'XMLHttpRequest');
+        }
+
+        if ('responseType' in xhr && SUPPORTS_BLOB) {
+            xhr.responseType = 'blob';
+        }
+
+        request.headers.forEach(function (value, name) {
+            xhr.setRequestHeader(name, value);
+        });
+
+        xhr.onload = handler;
+        xhr.onabort = handler;
+        xhr.onerror = handler;
+        xhr.ontimeout = handler;
+        xhr.send(request.getBody());
+    });
+};
+
+/**
+ * Http client (Node).
+ */
+
+var nodeClient = function (request) {
+
+    var client = require('got');
+
+    return new PromiseObj(function (resolve) {
+
+        var url = request.getUrl();
+        var body = request.getBody();
+        var method = request.method;
+        var headers = {}, handler;
+
+        request.headers.forEach(function (value, name) {
+            headers[name] = value;
+        });
+
+        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {
+
+            var response = request.respondWith(resp.body, {
+                    status: resp.statusCode,
+                    statusText: trim(resp.statusMessage)
+                }
+            );
+
+            each(resp.headers, function (value, name) {
+                response.headers.set(name, value);
+            });
+
+            resolve(response);
+
+        }, function (error$$1) { return handler(error$$1.response); });
+    });
+};
+
+/**
+ * Base client.
+ */
+
+var Client = function (context) {
+
+    var reqHandlers = [sendRequest], resHandlers = [], handler;
+
+    if (!isObject(context)) {
+        context = null;
+    }
+
+    function Client(request) {
+        return new PromiseObj(function (resolve) {
+
+            function exec() {
+
+                handler = reqHandlers.pop();
+
+                if (isFunction(handler)) {
+                    handler.call(context, request, next);
+                } else {
+                    warn(("Invalid interceptor of type " + (typeof handler) + ", must be a function"));
+                    next();
+                }
+            }
+
+            function next(response) {
+
+                if (isFunction(response)) {
+
+                    resHandlers.unshift(response);
+
+                } else if (isObject(response)) {
+
+                    resHandlers.forEach(function (handler) {
+                        response = when(response, function (response) {
+                            return handler.call(context, response) || response;
+                        });
+                    });
+
+                    when(response, resolve);
+
+                    return;
+                }
+
+                exec();
+            }
+
+            exec();
+
+        }, context);
+    }
+
+    Client.use = function (handler) {
+        reqHandlers.push(handler);
+    };
+
+    return Client;
+};
+
+function sendRequest(request, resolve) {
+
+    var client = request.client || (inBrowser ? xhrClient : nodeClient);
+
+    resolve(client(request));
+}
+
+/**
+ * HTTP Headers.
+ */
+
+var Headers = function Headers(headers) {
+    var this$1 = this;
+
+
+    this.map = {};
+
+    each(headers, function (value, name) { return this$1.append(name, value); });
+};
+
+Headers.prototype.has = function has (name) {
+    return getName(this.map, name) !== null;
+};
+
+Headers.prototype.get = function get (name) {
+
+    var list = this.map[getName(this.map, name)];
+
+    return list ? list.join() : null;
+};
+
+Headers.prototype.getAll = function getAll (name) {
+    return this.map[getName(this.map, name)] || [];
+};
+
+Headers.prototype.set = function set (name, value) {
+    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
+};
+
+Headers.prototype.append = function append (name, value){
+
+    var list = this.map[getName(this.map, name)];
+
+    if (list) {
+        list.push(trim(value));
+    } else {
+        this.set(name, value);
+    }
+};
+
+Headers.prototype.delete = function delete$1 (name){
+    delete this.map[getName(this.map, name)];
+};
+
+Headers.prototype.deleteAll = function deleteAll (){
+    this.map = {};
+};
+
+Headers.prototype.forEach = function forEach (callback, thisArg) {
+        var this$1 = this;
+
+    each(this.map, function (list, name) {
+        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });
+    });
+};
+
+function getName(map, name) {
+    return Object.keys(map).reduce(function (prev, curr) {
+        return toLower(name) === toLower(curr) ? curr : prev;
+    }, null);
+}
+
+function normalizeName(name) {
+
+    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
+        throw new TypeError('Invalid character in header field name');
+    }
+
+    return trim(name);
+}
+
+/**
+ * HTTP Response.
+ */
+
+var Response = function Response(body, ref) {
+    var url = ref.url;
+    var headers = ref.headers;
+    var status = ref.status;
+    var statusText = ref.statusText;
+
+
+    this.url = url;
+    this.ok = status >= 200 && status < 300;
+    this.status = status || 0;
+    this.statusText = statusText || '';
+    this.headers = new Headers(headers);
+    this.body = body;
+
+    if (isString(body)) {
+
+        this.bodyText = body;
+
+    } else if (isBlob(body)) {
+
+        this.bodyBlob = body;
+
+        if (isBlobText(body)) {
+            this.bodyText = blobText(body);
+        }
+    }
+};
+
+Response.prototype.blob = function blob () {
+    return when(this.bodyBlob);
+};
+
+Response.prototype.text = function text () {
+    return when(this.bodyText);
+};
+
+Response.prototype.json = function json () {
+    return when(this.text(), function (text) { return JSON.parse(text); });
+};
+
+function blobText(body) {
+    return new PromiseObj(function (resolve) {
+
+        var reader = new FileReader();
+
+        reader.readAsText(body);
+        reader.onload = function () {
+            resolve(reader.result);
+        };
+
+    });
+}
+
+function isBlobText(body) {
+    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
+}
+
+/**
+ * HTTP Request.
+ */
+
+var Request = function Request(options$$1) {
+
+    this.body = null;
+    this.params = {};
+
+    assign(this, options$$1, {
+        method: toUpper(options$$1.method || 'GET')
+    });
+
+    if (!(this.headers instanceof Headers)) {
+        this.headers = new Headers(this.headers);
+    }
+};
+
+Request.prototype.getUrl = function getUrl (){
+    return Url(this);
+};
+
+Request.prototype.getBody = function getBody (){
+    return this.body;
+};
+
+Request.prototype.respondWith = function respondWith (body, options$$1) {
+    return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));
+};
+
+/**
+ * Service for sending network requests.
+ */
+
+var COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
+var JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};
+
+function Http(options$$1) {
+
+    var self = this || {}, client = Client(self.$vm);
+
+    defaults(options$$1 || {}, self.$options, Http.options);
+
+    Http.interceptors.forEach(function (handler) {
+        client.use(handler);
+    });
+
+    return client(new Request(options$$1)).then(function (response) {
+
+        return response.ok ? response : PromiseObj.reject(response);
+
+    }, function (response) {
+
+        if (response instanceof Error) {
+            error(response);
+        }
+
+        return PromiseObj.reject(response);
+    });
+}
+
+Http.options = {};
+
+Http.headers = {
+    put: JSON_CONTENT_TYPE,
+    post: JSON_CONTENT_TYPE,
+    patch: JSON_CONTENT_TYPE,
+    delete: JSON_CONTENT_TYPE,
+    common: COMMON_HEADERS,
+    custom: {}
+};
+
+Http.interceptors = [before, method, body, jsonp, header, cors];
+
+['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {
+
+    Http[method$$1] = function (url, options$$1) {
+        return this(assign(options$$1 || {}, {url: url, method: method$$1}));
+    };
+
+});
+
+['post', 'put', 'patch'].forEach(function (method$$1) {
+
+    Http[method$$1] = function (url, body$$1, options$$1) {
+        return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body$$1}));
+    };
+
+});
+
+/**
+ * Service for interacting with RESTful services.
+ */
+
+function Resource(url, params, actions, options$$1) {
+
+    var self = this || {}, resource = {};
+
+    actions = assign({},
+        Resource.actions,
+        actions
+    );
+
+    each(actions, function (action, name) {
+
+        action = merge({url: url, params: assign({}, params)}, options$$1, action);
+
+        resource[name] = function () {
+            return (self.$http || Http)(opts(action, arguments));
+        };
+    });
+
+    return resource;
+}
+
+function opts(action, args) {
+
+    var options$$1 = assign({}, action), params = {}, body;
+
+    switch (args.length) {
+
+        case 2:
+
+            params = args[0];
+            body = args[1];
+
+            break;
+
+        case 1:
+
+            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
+                body = args[0];
+            } else {
+                params = args[0];
+            }
+
+            break;
+
+        case 0:
+
+            break;
+
+        default:
+
+            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
+    }
+
+    options$$1.body = body;
+    options$$1.params = assign({}, options$$1.params, params);
+
+    return options$$1;
+}
+
+Resource.actions = {
+
+    get: {method: 'GET'},
+    save: {method: 'POST'},
+    query: {method: 'GET'},
+    update: {method: 'PUT'},
+    remove: {method: 'DELETE'},
+    delete: {method: 'DELETE'}
+
+};
+
+/**
+ * Install plugin.
+ */
+
+function plugin(Vue) {
+
+    if (plugin.installed) {
+        return;
+    }
+
+    Util(Vue);
+
+    Vue.url = Url;
+    Vue.http = Http;
+    Vue.resource = Resource;
+    Vue.Promise = PromiseObj;
+
+    Object.defineProperties(Vue.prototype, {
+
+        $url: {
+            get: function get() {
+                return options(Vue.url, this, this.$options.url);
+            }
+        },
+
+        $http: {
+            get: function get() {
+                return options(Vue.http, this, this.$options.http);
+            }
+        },
+
+        $resource: {
+            get: function get() {
+                return Vue.resource.bind(this);
+            }
+        },
+
+        $promise: {
+            get: function get() {
+                var this$1 = this;
+
+                return function (executor) { return new Vue.Promise(executor, this$1); };
+            }
+        }
+
+    });
+}
+
+if (typeof window !== 'undefined' && window.Vue) {
+    window.Vue.use(plugin);
+}
+
+return plugin;
+
+})));
Index: public/node_modules/vue/src/entries/web-runtime.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/entries/web-runtime.js	(revision )
+++ public/node_modules/vue/src/entries/web-runtime.js	(revision )
@@ -0,0 +1,66 @@
+/* @flow */
+
+import Vue from 'core/index'
+import config from 'core/config'
+import { patch } from 'web/runtime/patch'
+import { extend, noop } from 'shared/util'
+import { mountComponent } from 'core/instance/lifecycle'
+import { devtools, inBrowser, isChrome } from 'core/util/index'
+import platformDirectives from 'web/runtime/directives/index'
+import platformComponents from 'web/runtime/components/index'
+
+import {
+  query,
+  mustUseProp,
+  isReservedTag,
+  getTagNamespace,
+  isUnknownElement
+} from 'web/util/index'
+
+// install platform specific utils
+Vue.config.mustUseProp = mustUseProp
+Vue.config.isReservedTag = isReservedTag
+Vue.config.getTagNamespace = getTagNamespace
+Vue.config.isUnknownElement = isUnknownElement
+
+// install platform runtime directives & components
+extend(Vue.options.directives, platformDirectives)
+extend(Vue.options.components, platformComponents)
+
+// install platform patch function
+Vue.prototype.__patch__ = inBrowser ? patch : noop
+
+// public mount method
+Vue.prototype.$mount = function (
+  el?: string | Element,
+  hydrating?: boolean
+): Component {
+  el = el && inBrowser ? query(el) : undefined
+  return mountComponent(this, el, hydrating)
+}
+
+// devtools global hook
+/* istanbul ignore next */
+setTimeout(() => {
+  if (config.devtools) {
+    if (devtools) {
+      devtools.emit('init', Vue)
+    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
+      console[console.info ? 'info' : 'log'](
+        'Download the Vue Devtools extension for a better development experience:\n' +
+        'https://github.com/vuejs/vue-devtools'
+      )
+    }
+  }
+  if (process.env.NODE_ENV !== 'production' &&
+      config.productionTip !== false &&
+      inBrowser && typeof console !== 'undefined') {
+    console[console.info ? 'info' : 'log'](
+      `You are running Vue in development mode.\n` +
+      `Make sure to turn on production mode when deploying for production.\n` +
+      `See more tips at https://vuejs.org/guide/deployment.html`
+    )
+  }
+}, 0)
+
+export default Vue
Index: public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/package.json	(revision )
@@ -0,0 +1,43 @@
+{
+  "name": "capture-stack-trace",
+  "version": "1.0.0",
+  "description": "Error.captureStackTrace ponyfill",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/floatdrop/capture-stack-trace"
+  },
+  "author": {
+    "name": "Vsevolod Strukchinsky",
+    "email": "floatdrop@gmail.com",
+    "url": "github.com/floatdrop"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "mocha"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "Error",
+    "captureStackTrace"
+  ],
+  "dependencies": {},
+  "devDependencies": {
+    "mocha": "*"
+  },
+  "readme": "# capture-stack-trace [![Build Status](https://travis-ci.org/floatdrop/capture-stack-trace.svg?branch=master)](https://travis-ci.org/floatdrop/capture-stack-trace)\n\n> Ponyfill for Error.captureStackTrace\n\n\n## Install\n\n```\n$ npm install --save capture-stack-trace\n```\n\n\n## Usage\n\n```js\nvar captureStackTrace = require('capture-stack-trace');\n\ncaptureStackTrace({});\n// => {stack: ...}\n```\n\n\n## API\n\n### captureStackTrace(error)\n\n#### error\n\n*Required*  \nType: `Object`\n\nTarget Object, that will recieve stack property.\n\n## License\n\nMIT  [Vsevolod Strukchinsky](http://github.com/floatdrop)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/floatdrop/capture-stack-trace/issues"
+  },
+  "_id": "capture-stack-trace@1.0.0",
+  "dist": {
+    "shasum": "00f3ebe1b1cb78e4f9920e301ddc07eb0ca3bbde"
+  },
+  "_from": "capture-stack-trace@^1.0.0",
+  "_resolved": "https://registry.npmjs.org/capture-stack-trace/-/capture-stack-trace-1.0.0.tgz"
+}
Index: public/node_modules/vue/src/platforms/web/runtime/components/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/components/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/components/index.js	(revision )
@@ -0,0 +1,7 @@
+import Transition from './transition'
+import TransitionGroup from './transition-group'
+
+export default {
+  Transition,
+  TransitionGroup
+}
Index: public/node_modules/vue-select2/demo/demo.all.min.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/demo/demo.all.min.js	(revision )
+++ public/node_modules/vue-select2/demo/demo.all.min.js	(revision )
@@ -0,0 +1,14 @@
+/*!
+ * vue-select2 v0.2.0
+ * (c) 2016 Haixing Hu
+ * Released under the MIT License.
+ */
+!function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p="",e(0)}([function(t,e,i){var n=i(1),r=new n({components:{demo:i(3)},data:{result1:null,result2:"value2",result3:"value6"}});r.$mount("#app")},function(t,e,i){t.exports=i(2)},function(t,e,i){(function(e){/*!
+	 * Vue.js v1.0.24
+	 * (c) 2016 Evan You
+	 * Released under the MIT License.
+	 */
+!function(e,i){t.exports=i()}(this,function(){"use strict";function t(e,i,r){if(n(e,i))return void(e[i]=r);if(e._isVue)return void t(e._data,i,r);var s=e.__ob__;if(!s)return void(e[i]=r);if(s.convert(i,r),s.dep.notify(),s.vms)for(var o=s.vms.length;o--;){var a=s.vms[o];a._proxy(i),a._digest()}return r}function i(t,e){if(n(t,e)){delete t[e];var i=t.__ob__;if(!i)return void(t._isVue&&(delete t._data[e],t._digest()));if(i.dep.notify(),i.vms)for(var r=i.vms.length;r--;){var s=i.vms[r];s._unproxy(e),s._digest()}}}function n(t,e){return Ei.call(t,e)}function r(t){return Ni.test(t)}function s(t){var e=(t+"").charCodeAt(0);return 36===e||95===e}function o(t){return null==t?"":t.toString()}function a(t){if("string"!=typeof t)return t;var e=Number(t);return isNaN(e)?t:e}function l(t){return"true"===t?!0:"false"===t?!1:t}function h(t){var e=t.charCodeAt(0),i=t.charCodeAt(t.length-1);return e!==i||34!==e&&39!==e?t:t.slice(1,-1)}function u(t){return t.replace(ji,c)}function c(t,e){return e?e.toUpperCase():""}function f(t){return t.replace(Si,"$1-$2").toLowerCase()}function p(t){return t.replace(Di,c)}function d(t,e){return function(i){var n=arguments.length;return n?n>1?t.apply(e,arguments):t.call(e,i):t.call(e)}}function v(t,e){e=e||0;for(var i=t.length-e,n=new Array(i);i--;)n[i]=t[i+e];return n}function m(t,e){for(var i=Object.keys(e),n=i.length;n--;)t[i[n]]=e[i[n]];return t}function g(t){return null!==t&&"object"==typeof t}function y(t){return Fi.call(t)===Ri}function b(t,e,i,n){Object.defineProperty(t,e,{value:i,enumerable:!!n,writable:!0,configurable:!0})}function _(t,e){var i,n,r,s,o,a=function l(){var a=Date.now()-s;e>a&&a>=0?i=setTimeout(l,e-a):(i=null,o=t.apply(r,n),i||(r=n=null))};return function(){return r=this,n=arguments,s=Date.now(),i||(i=setTimeout(a,e)),o}}function w(t,e){for(var i=t.length;i--;)if(t[i]===e)return i;return-1}function C(t){var e=function i(){return i.cancelled?void 0:t.apply(this,arguments)};return e.cancel=function(){e.cancelled=!0},e}function $(t,e){return t==e||(g(t)&&g(e)?JSON.stringify(t)===JSON.stringify(e):!1)}function k(t){this.size=0,this.limit=t,this.head=this.tail=void 0,this._keymap=Object.create(null)}function x(){var t,e=tn.slice(an,sn).trim();if(e){t={};var i=e.match(dn);t.name=i[0],i.length>1&&(t.args=i.slice(1).map(A))}t&&(en.filters=en.filters||[]).push(t),an=sn+1}function A(t){if(vn.test(t))return{value:a(t),dynamic:!1};var e=h(t),i=e===t;return{value:i?t:e,dynamic:i}}function O(t){var e=pn.get(t);if(e)return e;for(tn=t,ln=hn=!1,un=cn=fn=0,an=0,en={},sn=0,on=tn.length;on>sn;sn++)if(rn=nn,nn=tn.charCodeAt(sn),ln)39===nn&&92!==rn&&(ln=!ln);else if(hn)34===nn&&92!==rn&&(hn=!hn);else if(124===nn&&124!==tn.charCodeAt(sn+1)&&124!==tn.charCodeAt(sn-1))null==en.expression?(an=sn+1,en.expression=tn.slice(0,sn).trim()):x();else switch(nn){case 34:hn=!0;break;case 39:ln=!0;break;case 40:fn++;break;case 41:fn--;break;case 91:cn++;break;case 93:cn--;break;case 123:un++;break;case 125:un--}return null==en.expression?en.expression=tn.slice(0,sn).trim():0!==an&&x(),pn.put(t,en),en}function T(t){return t.replace(gn,"\\$&")}function E(){var t=T(xn.delimiters[0]),e=T(xn.delimiters[1]),i=T(xn.unsafeDelimiters[0]),n=T(xn.unsafeDelimiters[1]);bn=new RegExp(i+"((?:.|\\n)+?)"+n+"|"+t+"((?:.|\\n)+?)"+e,"g"),_n=new RegExp("^"+i+".*"+n+"$"),yn=new k(1e3)}function N(t){yn||E();var e=yn.get(t);if(e)return e;if(!bn.test(t))return null;for(var i,n,r,s,o,a,l=[],h=bn.lastIndex=0;i=bn.exec(t);)n=i.index,n>h&&l.push({value:t.slice(h,n)}),r=_n.test(i[0]),s=r?i[1]:i[2],o=s.charCodeAt(0),a=42===o,s=a?s.slice(1):s,l.push({tag:!0,value:s.trim(),html:r,oneTime:a}),h=n+i[0].length;return h<t.length&&l.push({value:t.slice(h)}),yn.put(t,l),l}function j(t,e){return t.length>1?t.map(function(t){return S(t,e)}).join("+"):S(t[0],e,!0)}function S(t,e,i){return t.tag?t.oneTime&&e?'"'+e.$eval(t.value)+'"':D(t.value,i):'"'+t.value+'"'}function D(t,e){if(wn.test(t)){var i=O(t);return i.filters?"this._applyFilters("+i.expression+",null,"+JSON.stringify(i.filters)+",false)":"("+t+")"}return e?t:"("+t+")"}function F(t,e,i,n){L(t,1,function(){e.appendChild(t)},i,n)}function R(t,e,i,n){L(t,1,function(){M(t,e)},i,n)}function P(t,e,i){L(t,-1,function(){B(t)},e,i)}function L(t,e,i,n,r){var s=t.__v_trans;if(!s||!s.hooks&&!qi||!n._isCompiled||n.$parent&&!n.$parent._isCompiled)return i(),void(r&&r());var o=e>0?"enter":"leave";s[o](i,r)}function U(t){if("string"==typeof t){var e=t;t=document.querySelector(t),t||An("Cannot find element: "+e)}return t}function I(t){if(!t)return!1;var e=t.ownerDocument.documentElement,i=t.parentNode;return e===t||e===i||!(!i||1!==i.nodeType||!e.contains(i))}function H(t,e){var i=t.getAttribute(e);return null!==i&&t.removeAttribute(e),i}function z(t,e){var i=H(t,":"+e);return null===i&&(i=H(t,"v-bind:"+e)),i}function W(t,e){return t.hasAttribute(e)||t.hasAttribute(":"+e)||t.hasAttribute("v-bind:"+e)}function M(t,e){e.parentNode.insertBefore(t,e)}function V(t,e){e.nextSibling?M(t,e.nextSibling):e.parentNode.appendChild(t)}function B(t){t.parentNode.removeChild(t)}function q(t,e){e.firstChild?M(t,e.firstChild):e.appendChild(t)}function Y(t,e){var i=t.parentNode;i&&i.replaceChild(e,t)}function Z(t,e,i,n){t.addEventListener(e,i,n)}function J(t,e,i){t.removeEventListener(e,i)}function G(t){var e=t.className;return"object"==typeof e&&(e=e.baseVal||""),e}function K(t,e){zi&&!/svg$/.test(t.namespaceURI)?t.className=e:t.setAttribute("class",e)}function Q(t,e){if(t.classList)t.classList.add(e);else{var i=" "+G(t)+" ";i.indexOf(" "+e+" ")<0&&K(t,(i+e).trim())}}function X(t,e){if(t.classList)t.classList.remove(e);else{for(var i=" "+G(t)+" ",n=" "+e+" ";i.indexOf(n)>=0;)i=i.replace(n," ");K(t,i.trim())}t.className||t.removeAttribute("class")}function tt(t,e){var i,n;if(nt(t)&&lt(t.content)&&(t=t.content),t.hasChildNodes())for(et(t),n=e?document.createDocumentFragment():document.createElement("div");i=t.firstChild;)n.appendChild(i);return n}function et(t){for(var e;e=t.firstChild,it(e);)t.removeChild(e);for(;e=t.lastChild,it(e);)t.removeChild(e)}function it(t){return t&&(3===t.nodeType&&!t.data.trim()||8===t.nodeType)}function nt(t){return t.tagName&&"template"===t.tagName.toLowerCase()}function rt(t,e){var i=xn.debug?document.createComment(t):document.createTextNode(e?" ":"");return i.__v_anchor=!0,i}function st(t){if(t.hasAttributes())for(var e=t.attributes,i=0,n=e.length;n>i;i++){var r=e[i].name;if(En.test(r))return u(r.replace(En,""))}}function ot(t,e,i){for(var n;t!==e;)n=t.nextSibling,i(t),t=n;i(e)}function at(t,e,i,n,r){function s(){if(a++,o&&a>=l.length){for(var t=0;t<l.length;t++)n.appendChild(l[t]);r&&r()}}var o=!1,a=0,l=[];ot(t,e,function(t){t===e&&(o=!0),l.push(t),P(t,i,s)})}function lt(t){return t&&11===t.nodeType}function ht(t){if(t.outerHTML)return t.outerHTML;var e=document.createElement("div");return e.appendChild(t.cloneNode(!0)),e.innerHTML}function ut(t,e){var i=t.tagName.toLowerCase(),n=t.hasAttributes();if(Nn.test(i)||jn.test(i)){if(n)return ct(t,e)}else{if(yt(e,"components",i))return{id:i};var r=n&&ct(t,e);if(r)return r;var s=e._componentNameMap&&e._componentNameMap[i];s?An("Unknown custom element: <"+i+"> - did you mean <"+s+">? HTML is case-insensitive, remember to use kebab-case in templates."):Sn(t,i)&&An("Unknown custom element: <"+i+'> - did you register the component correctly? For recursive components, make sure to provide the "name" option.')}}function ct(t,e){var i=t.getAttribute("is");if(null!=i){if(yt(e,"components",i))return t.removeAttribute("is"),{id:i}}else if(i=z(t,"is"),null!=i)return{id:i,dynamic:!0}}function ft(e,i){var r,s,o;for(r in i)s=e[r],o=i[r],n(e,r)?g(s)&&g(o)&&ft(s,o):t(e,r,o);return e}function pt(t,e){var i=Object.create(t||null);return e?m(i,mt(e)):i}function dt(t){if(t.components)for(var e,i=t.components=mt(t.components),n=Object.keys(i),r=t._componentNameMap={},s=0,o=n.length;o>s;s++){var a=n[s];Nn.test(a)||jn.test(a)?An("Do not use built-in or reserved HTML elements as component id: "+a):(r[a.replace(/-/g,"").toLowerCase()]=f(a),e=i[a],y(e)&&(i[a]=$i.extend(e)))}}function vt(t){var e,i,n=t.props;if(Pi(n))for(t.props={},e=n.length;e--;)i=n[e],"string"==typeof i?t.props[i]=null:i.name&&(t.props[i.name]=i);else if(y(n)){var r=Object.keys(n);for(e=r.length;e--;)i=n[r[e]],"function"==typeof i&&(n[r[e]]={type:i})}}function mt(t){if(Pi(t)){for(var e,i={},n=t.length;n--;){e=t[n];var r="function"==typeof e?e.options&&e.options.name||e.id:e.name||e.id;r?i[r]=e:An('Array-syntax assets must provide a "name" or "id" field.')}return i}return t}function gt(t,e,i){function r(n){var r=Dn[n]||Fn;o[n]=r(t[n],e[n],i,n)}dt(e),vt(e),e.propsData&&!i&&An("propsData can only be used as an instantiation option.");var s,o={};if(e["extends"]&&(t="function"==typeof e["extends"]?gt(t,e["extends"].options,i):gt(t,e["extends"],i)),e.mixins)for(var a=0,l=e.mixins.length;l>a;a++)t=gt(t,e.mixins[a],i);for(s in t)r(s);for(s in e)n(t,s)||r(s);return o}function yt(t,e,i,n){if("string"==typeof i){var r,s=t[e],o=s[i]||s[r=u(i)]||s[r.charAt(0).toUpperCase()+r.slice(1)];return n&&!o&&An("Failed to resolve "+e.slice(0,-1)+": "+i,t),o}}function bt(){this.id=Rn++,this.subs=[]}function _t(t){In=!1,t(),In=!0}function wt(t){if(this.value=t,this.dep=new bt,b(t,"__ob__",this),Pi(t)){var e=Li?Ct:$t;e(t,Ln,Un),this.observeArray(t)}else this.walk(t)}function Ct(t,e){t.__proto__=e}function $t(t,e,i){for(var n=0,r=i.length;r>n;n++){var s=i[n];b(t,s,e[s])}}function kt(t,e){if(t&&"object"==typeof t){var i;return n(t,"__ob__")&&t.__ob__ instanceof wt?i=t.__ob__:In&&(Pi(t)||y(t))&&Object.isExtensible(t)&&!t._isVue&&(i=new wt(t)),i&&e&&i.addVm(e),i}}function xt(t,e,i){var n=new bt,r=Object.getOwnPropertyDescriptor(t,e);if(!r||r.configurable!==!1){var s=r&&r.get,o=r&&r.set,a=kt(i);Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(t):i;if(bt.target&&(n.depend(),a&&a.dep.depend(),Pi(e)))for(var r,o=0,l=e.length;l>o;o++)r=e[o],r&&r.__ob__&&r.__ob__.dep.depend();return e},set:function(e){var r=s?s.call(t):i;e!==r&&(o?o.call(t,e):i=e,a=kt(e),n.notify())}})}}function At(t){t.prototype._init=function(t){t=t||{},this.$el=null,this.$parent=t.parent,this.$root=this.$parent?this.$parent.$root:this,this.$children=[],this.$refs={},this.$els={},this._watchers=[],this._directives=[],this._uid=zn++,this._isVue=!0,this._events={},this._eventsCount={},this._isFragment=!1,this._fragment=this._fragmentStart=this._fragmentEnd=null,this._isCompiled=this._isDestroyed=this._isReady=this._isAttached=this._isBeingDestroyed=this._vForRemoving=!1,this._unlinkFn=null,this._context=t._context||this.$parent,this._scope=t._scope,this._frag=t._frag,this._frag&&this._frag.children.push(this),this.$parent&&this.$parent.$children.push(this),t=this.$options=gt(this.constructor.options,t,this),this._updateRef(),this._data={},this._callHook("init"),this._initState(),this._initEvents(),this._callHook("created"),t.el&&this.$mount(t.el)}}function Ot(t){if(void 0===t)return"eof";var e=t.charCodeAt(0);switch(e){case 91:case 93:case 46:case 34:case 39:case 48:return t;case 95:case 36:return"ident";case 32:case 9:case 10:case 13:case 160:case 65279:case 8232:case 8233:return"ws"}return e>=97&&122>=e||e>=65&&90>=e?"ident":e>=49&&57>=e?"number":"else"}function Tt(t){var e=t.trim();return"0"===t.charAt(0)&&isNaN(t)?!1:r(e)?h(e):"*"+e}function Et(t){function e(){var e=t[u+1];return c===Qn&&"'"===e||c===Xn&&'"'===e?(u++,n="\\"+e,p[Mn](),!0):void 0}var i,n,r,s,o,a,l,h=[],u=-1,c=Yn,f=0,p=[];for(p[Vn]=function(){void 0!==r&&(h.push(r),r=void 0)},p[Mn]=function(){void 0===r?r=n:r+=n},p[Bn]=function(){p[Mn](),f++},p[qn]=function(){if(f>0)f--,c=Kn,p[Mn]();else{if(f=0,r=Tt(r),r===!1)return!1;p[Vn]()}};null!=c;)if(u++,i=t[u],"\\"!==i||!e()){if(s=Ot(i),l=ir[c],o=l[s]||l["else"]||er,o===er)return;if(c=o[0],a=p[o[1]],a&&(n=o[2],n=void 0===n?i:n,a()===!1))return;if(c===tr)return h.raw=t,h}}function Nt(t){var e=Wn.get(t);return e||(e=Et(t),e&&Wn.put(t,e)),e}function jt(t,e){return It(e).get(t)}function St(e,i,n){var r=e;if("string"==typeof i&&(i=Et(i)),!i||!g(e))return!1;for(var s,o,a=0,l=i.length;l>a;a++)s=e,o=i[a],"*"===o.charAt(0)&&(o=It(o.slice(1)).get.call(r,r)),l-1>a?(e=e[o],g(e)||(e={},s._isVue&&nr(i,s),t(s,o,e))):Pi(e)?e.$set(o,n):o in e?e[o]=n:(e._isVue&&nr(i,e),t(e,o,n));return!0}function Dt(t,e){var i=gr.length;return gr[i]=e?t.replace(cr,"\\n"):t,'"'+i+'"'}function Ft(t){var e=t.charAt(0),i=t.slice(1);return ar.test(i)?t:(i=i.indexOf('"')>-1?i.replace(pr,Rt):i,e+"scope."+i)}function Rt(t,e){return gr[e]}function Pt(t){hr.test(t)&&An("Avoid using reserved keywords in expression: "+t),gr.length=0;var e=t.replace(fr,Dt).replace(ur,"");return e=(" "+e).replace(vr,Ft).replace(pr,Rt),Lt(e)}function Lt(t){try{return new Function("scope","return "+t+";")}catch(e){An("Invalid expression. Generated function body: "+t)}}function Ut(t){var e=Nt(t);return e?function(t,i){St(t,e,i)}:void An("Invalid setter expression: "+t)}function It(t,e){t=t.trim();var i=sr.get(t);if(i)return e&&!i.set&&(i.set=Ut(i.exp)),i;var n={exp:t};return n.get=Ht(t)&&t.indexOf("[")<0?Lt("scope."+t):Pt(t),e&&(n.set=Ut(t)),sr.put(t,n),n}function Ht(t){return dr.test(t)&&!mr.test(t)&&"Math."!==t.slice(0,5)}function zt(){br.length=0,_r.length=0,wr={},Cr={},$r=!1}function Wt(){for(var t=!0;t;)t=!1,Mt(br),Mt(_r),br.length?t=!0:(Ii&&xn.devtools&&Ii.emit("flush"),zt())}function Mt(t){for(var e=0;e<t.length;e++){var i=t[e],n=i.id;if(wr[n]=null,i.run(),null!=wr[n]&&(Cr[n]=(Cr[n]||0)+1,Cr[n]>xn._maxUpdateCount)){An('You may have an infinite update loop for watcher with expression "'+i.expression+'"',i.vm);break}}t.length=0}function Vt(t){var e=t.id;if(null==wr[e]){var i=t.user?_r:br;wr[e]=i.length,i.push(t),$r||($r=!0,Ki(Wt))}}function Bt(t,e,i,n){n&&m(this,n);var r="function"==typeof e;if(this.vm=t,t._watchers.push(this),this.expression=e,this.cb=i,this.id=++kr,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new Qi,this.newDepIds=new Qi,this.prevError=null,r)this.getter=e,this.setter=void 0;else{var s=It(e,this.twoWay);this.getter=s.get,this.setter=s.set}this.value=this.lazy?void 0:this.get(),this.queued=this.shallow=!1}function qt(t,e){var i=void 0,n=void 0;e||(e=xr,e.clear());var r=Pi(t),s=g(t);if(r||s){if(t.__ob__){var o=t.__ob__.dep.id;if(e.has(o))return;e.add(o)}if(r)for(i=t.length;i--;)qt(t[i],e);else if(s)for(n=Object.keys(t),i=n.length;i--;)qt(t[n[i]],e)}}function Yt(t){return nt(t)&&lt(t.content)}function Zt(t,e){var i=e?t:t.trim(),n=Or.get(i);if(n)return n;var r=document.createDocumentFragment(),s=t.match(Nr),o=jr.test(t);if(s||o){var a=s&&s[1],l=Er[a]||Er.efault,h=l[0],u=l[1],c=l[2],f=document.createElement("div");for(f.innerHTML=u+t+c;h--;)f=f.lastChild;for(var p;p=f.firstChild;)r.appendChild(p)}else r.appendChild(document.createTextNode(t));return e||et(r),Or.put(i,r),r}function Jt(t){if(Yt(t))return Zt(t.innerHTML);if("SCRIPT"===t.tagName)return Zt(t.textContent);for(var e,i=Gt(t),n=document.createDocumentFragment();e=i.firstChild;)n.appendChild(e);return et(n),n}function Gt(t){if(!t.querySelectorAll)return t.cloneNode();var e,i,n,r=t.cloneNode(!0);if(Sr){var s=r;if(Yt(t)&&(t=t.content,s=r.content),i=t.querySelectorAll("template"),i.length)for(n=s.querySelectorAll("template"),e=n.length;e--;)n[e].parentNode.replaceChild(Gt(i[e]),n[e])}if(Dr)if("TEXTAREA"===t.tagName)r.value=t.value;else if(i=t.querySelectorAll("textarea"),i.length)for(n=r.querySelectorAll("textarea"),e=n.length;e--;)n[e].value=i[e].value;return r}function Kt(t,e,i){var n,r;return lt(t)?(et(t),e?Gt(t):t):("string"==typeof t?i||"#"!==t.charAt(0)?r=Zt(t,i):(r=Tr.get(t),r||(n=document.getElementById(t.slice(1)),n&&(r=Jt(n),Tr.put(t,r)))):t.nodeType&&(r=Jt(t)),r&&e?Gt(r):r)}function Qt(t,e,i,n,r,s){this.children=[],this.childFrags=[],this.vm=e,this.scope=r,this.inserted=!1,this.parentFrag=s,s&&s.childFrags.push(this),this.unlink=t(e,i,n,r,this);var o=this.single=1===i.childNodes.length&&!i.childNodes[0].__v_anchor;o?(this.node=i.childNodes[0],this.before=Xt,this.remove=te):(this.node=rt("fragment-start"),this.end=rt("fragment-end"),this.frag=i,q(this.node,i),i.appendChild(this.end),this.before=ee,this.remove=ie),this.node.__v_frag=this}function Xt(t,e){this.inserted=!0;var i=e!==!1?R:M;i(this.node,t,this.vm),I(this.node)&&this.callHook(ne)}function te(){this.inserted=!1;var t=I(this.node),e=this;this.beforeRemove(),P(this.node,this.vm,function(){t&&e.callHook(re),e.destroy()})}function ee(t,e){this.inserted=!0;var i=this.vm,n=e!==!1?R:M;ot(this.node,this.end,function(e){n(e,t,i)}),I(this.node)&&this.callHook(ne)}function ie(){this.inserted=!1;var t=this,e=I(this.node);this.beforeRemove(),at(this.node,this.end,this.vm,this.frag,function(){e&&t.callHook(re),t.destroy()})}function ne(t){!t._isAttached&&I(t.$el)&&t._callHook("attached")}function re(t){t._isAttached&&!I(t.$el)&&t._callHook("detached")}function se(t,e){this.vm=t;var i,n="string"==typeof e;n||nt(e)&&!e.hasAttribute("v-if")?i=Kt(e,!0):(i=document.createDocumentFragment(),i.appendChild(e)),this.template=i;var r,s=t.constructor.cid;if(s>0){var o=s+(n?e:ht(e));r=Pr.get(o),r||(r=Pe(i,t.$options,!0),Pr.put(o,r))}else r=Pe(i,t.$options,!0);this.linker=r}function oe(t,e,i){var n=t.node.previousSibling;if(n){for(t=n.__v_frag;!(t&&t.forId===i&&t.inserted||n===e);){if(n=n.previousSibling,!n)return;t=n.__v_frag}return t}}function ae(t){var e=t.node;if(t.end)for(;!e.__vue__&&e!==t.end&&e.nextSibling;)e=e.nextSibling;return e.__vue__}function le(t){for(var e=-1,i=new Array(Math.floor(t));++e<t;)i[e]=e;return i}function he(t,e,i,n){return n?"$index"===n?t:n.charAt(0).match(/\w/)?jt(i,n):i[n]:e||i}function ue(t,e,i){for(var n,r,s,o=e?[]:null,a=0,l=t.options.length;l>a;a++)if(n=t.options[a],s=i?n.hasAttribute("selected"):n.selected){if(r=n.hasOwnProperty("_value")?n._value:n.value,!e)return r;o.push(r)}return o}function ce(t,e){for(var i=t.length;i--;)if($(t[i],e))return i;return-1}function fe(t,e){var i=e.map(function(t){var e=t.charCodeAt(0);return e>47&&58>e?parseInt(t,10):1===t.length&&(e=t.toUpperCase().charCodeAt(0),e>64&&91>e)?e:ns[t]});return i=[].concat.apply([],i),function(e){return i.indexOf(e.keyCode)>-1?t.call(this,e):void 0}}function pe(t){return function(e){return e.stopPropagation(),t.call(this,e)}}function de(t){return function(e){return e.preventDefault(),t.call(this,e)}}function ve(t){return function(e){return e.target===e.currentTarget?t.call(this,e):void 0}}function me(t){if(ls[t])return ls[t];var e=ge(t);return ls[t]=ls[e]=e,e}function ge(t){t=f(t);var e=u(t),i=e.charAt(0).toUpperCase()+e.slice(1);hs||(hs=document.createElement("div"));var n,r=ss.length;if("filter"!==e&&e in hs.style)return{kebab:t,camel:e};for(;r--;)if(n=os[r]+i,n in hs.style)return{kebab:ss[r]+t,camel:n}}function ye(t){var e=[];if(Pi(t))for(var i=0,n=t.length;n>i;i++){var r=t[i];if(r)if("string"==typeof r)e.push(r);else for(var s in r)r[s]&&e.push(s)}else if(g(t))for(var o in t)t[o]&&e.push(o);return e}function be(t,e,i){if(e=e.trim(),-1===e.indexOf(" "))return void i(t,e);for(var n=e.split(/\s+/),r=0,s=n.length;s>r;r++)i(t,n[r])}function _e(t,e,i){function n(){++s>=r?i():t[s].call(e,n)}var r=t.length,s=0;t[0].call(e,n)}function we(t,e,i){for(var n,s,o,a,l,h,c,p=[],d=Object.keys(e),v=d.length;v--;)if(s=d[v],n=e[s]||xs,"$data"!==s)if(l=u(s),As.test(l)){if(c={name:s,path:l,options:n,mode:ks.ONE_WAY,raw:null},o=f(s),null===(a=z(t,o))&&(null!==(a=z(t,o+".sync"))?c.mode=ks.TWO_WAY:null!==(a=z(t,o+".once"))&&(c.mode=ks.ONE_TIME)),null!==a)c.raw=a,h=O(a),a=h.expression,c.filters=h.filters,r(a)&&!h.filters?c.optimizedLiteral=!0:(c.dynamic=!0,c.mode!==ks.TWO_WAY||Os.test(a)||(c.mode=ks.ONE_WAY,An("Cannot bind two-way prop with non-settable parent path: "+a,i))),c.parentPath=a,n.twoWay&&c.mode!==ks.TWO_WAY&&An('Prop "'+s+'" expects a two-way binding type.',i);else if(null!==(a=H(t,o)))c.raw=a;else{var m=l.toLowerCase();a=/[A-Z\-]/.test(s)&&(t.getAttribute(m)||t.getAttribute(":"+m)||t.getAttribute("v-bind:"+m)||t.getAttribute(":"+m+".once")||t.getAttribute("v-bind:"+m+".once")||t.getAttribute(":"+m+".sync")||t.getAttribute("v-bind:"+m+".sync")),a?An("Possible usage error for prop `"+m+"` - did you mean `"+o+"`? HTML is case-insensitive, remember to use kebab-case for props in templates.",i):n.required&&An("Missing required prop: "+s,i)}p.push(c)}else An('Invalid prop key: "'+s+'". Prop keys must be valid identifiers.',i);else An("Do not use $data as prop.",i);return Ce(p)}function Ce(t){return function(e,i){e._props={};for(var r,s,o,u,c,p=e.$options.propsData,d=t.length;d--;)if(r=t[d],c=r.raw,s=r.path,o=r.options,e._props[s]=r,p&&n(p,s)&&ke(e,r,p[s]),null===c)ke(e,r,void 0);else if(r.dynamic)r.mode===ks.ONE_TIME?(u=(i||e._context||e).$get(r.parentPath),ke(e,r,u)):e._context?e._bindDir({name:"prop",def:Es,prop:r},null,null,i):ke(e,r,e.$get(r.parentPath));else if(r.optimizedLiteral){var v=h(c);u=v===c?l(a(c)):v,ke(e,r,u)}else u=o.type!==Boolean||""!==c&&c!==f(r.name)?c:!0,ke(e,r,u)}}function $e(t,e,i,n){var r=e.dynamic&&Ht(e.parentPath),s=i;void 0===s&&(s=Ae(t,e)),s=Te(e,s);var o=s!==i;Oe(e,s,t)||(s=void 0),r&&!o?_t(function(){n(s)}):n(s)}function ke(t,e,i){$e(t,e,i,function(i){xt(t,e.path,i)})}function xe(t,e,i){$e(t,e,i,function(i){t[e.path]=i})}function Ae(t,e){var i=e.options;if(!n(i,"default"))return i.type===Boolean?!1:void 0;var r=i["default"];return g(r)&&An('Invalid default value for prop "'+e.name+'": Props with type Object/Array must use a factory function to return the default value.',t),"function"==typeof r&&i.type!==Function?r.call(t):r}function Oe(t,e,i){if(!t.options.required&&(null===t.raw||null==e))return!0;var n=t.options,r=n.type,s=!r,o=[];if(r){Pi(r)||(r=[r]);for(var a=0;a<r.length&&!s;a++){var l=Ee(e,r[a]);o.push(l.expectedType),s=l.valid}}if(!s)return An('Invalid prop: type check failed for prop "'+t.name+'". Expected '+o.map(Ne).join(", ")+", got "+je(e)+".",i),!1;var h=n.validator;return h&&!h(e)?(An('Invalid prop: custom validator check failed for prop "'+t.name+'".',i),!1):!0}function Te(t,e){var i=t.options.coerce;return i?i(e):e}function Ee(t,e){var i,n;return e===String?(n="string",i=typeof t===n):e===Number?(n="number",i=typeof t===n):e===Boolean?(n="boolean",i=typeof t===n):e===Function?(n="function",i=typeof t===n):e===Object?(n="object",i=y(t)):e===Array?(n="array",i=Pi(t)):i=t instanceof e,{valid:i,expectedType:n}}function Ne(t){return t?t.charAt(0).toUpperCase()+t.slice(1):"custom type"}function je(t){return Object.prototype.toString.call(t).slice(8,-1)}function Se(t){Ns.push(t),js||(js=!0,Ki(De))}function De(){for(var t=document.documentElement.offsetHeight,e=0;e<Ns.length;e++)Ns[e]();return Ns=[],js=!1,t}function Fe(t,e,i,n){this.id=e,this.el=t,this.enterClass=i&&i.enterClass||e+"-enter",this.leaveClass=i&&i.leaveClass||e+"-leave",this.hooks=i,this.vm=n,this.pendingCssEvent=this.pendingCssCb=this.cancel=this.pendingJsCb=this.op=this.cb=null,this.justEntered=!1,this.entered=this.left=!1,this.typeCache={},this.type=i&&i.type,this.type&&this.type!==Ss&&this.type!==Ds&&An('invalid CSS transition type for transition="'+this.id+'": '+this.type,n);var r=this;["enterNextTick","enterDone","leaveNextTick","leaveDone"].forEach(function(t){r[t]=d(r[t],r)})}function Re(t){if(/svg$/.test(t.namespaceURI)){var e=t.getBoundingClientRect();return!(e.width||e.height)}return!(t.offsetWidth||t.offsetHeight||t.getClientRects().length)}function Pe(t,e,i){var n=i||!e._asComponent?Me(t,e):null,r=n&&n.terminal||oi(t)||!t.hasChildNodes()?null:Je(t.childNodes,e);return function(t,e,i,s,o){var a=v(e.childNodes),l=Le(function(){n&&n(t,e,i,s,o),r&&r(t,a,i,s,o)},t);return Ie(t,l)}}function Le(t,e){var i=e._directives.length;t();var n=e._directives.slice(i);n.sort(Ue);for(var r=0,s=n.length;s>r;r++)n[r]._bind();return n}function Ue(t,e){return t=t.descriptor.def.priority||qs,e=e.descriptor.def.priority||qs,t>e?-1:t===e?0:1}function Ie(t,e,i,n){function r(r){He(t,e,r),i&&n&&He(i,n)}return r.dirs=e,r}function He(t,e,i){for(var n=e.length;n--;)e[n]._teardown(),i||t._directives.$remove(e[n])}function ze(t,e,i,n){var r=we(e,i,t),s=Le(function(){r(t,n)},t);return Ie(t,s)}function We(t,e,i){var n,r,s=e._containerAttrs,o=e._replacerAttrs;if(11!==t.nodeType)e._asComponent?(s&&i&&(n=ii(s,i)),o&&(r=ii(o,e))):r=ii(t.attributes,e);else if(s){var a=s.filter(function(t){return t.name.indexOf("_v-")<0&&!Ws.test(t.name)&&"slot"!==t.name}).map(function(t){return'"'+t.name+'"'});if(a.length){var l=a.length>1;An("Attribute"+(l?"s ":" ")+a.join(", ")+(l?" are":" is")+" ignored on component <"+e.el.tagName.toLowerCase()+"> because the component is a fragment instance: http://vuejs.org/guide/components.html#Fragment-Instance")}}return e._containerAttrs=e._replacerAttrs=null,function(t,e,i){var s,o=t._context;o&&n&&(s=Le(function(){n(o,e,null,i)},o));var a=Le(function(){r&&r(t,e)},t);return Ie(t,a,o,s)}}function Me(t,e){var i=t.nodeType;return 1!==i||oi(t)?3===i&&t.data.trim()?Be(t,e):null:Ve(t,e)}function Ve(t,e){if("TEXTAREA"===t.tagName){var i=N(t.value);i&&(t.setAttribute(":value",j(i)),t.value="")}var n,r=t.hasAttributes(),s=r&&v(t.attributes);return r&&(n=Xe(t,s,e)),n||(n=Ke(t,e)),n||(n=Qe(t,e)),!n&&r&&(n=ii(s,e)),n}function Be(t,e){if(t._skip)return qe;var i=N(t.wholeText);if(!i)return null;for(var n=t.nextSibling;n&&3===n.nodeType;)n._skip=!0,n=n.nextSibling;for(var r,s,o=document.createDocumentFragment(),a=0,l=i.length;l>a;a++)s=i[a],r=s.tag?Ye(s,e):document.createTextNode(s.value),o.appendChild(r);return Ze(i,o,e)}function qe(t,e){B(e)}function Ye(t,e){function i(e){if(!t.descriptor){var i=O(t.value);t.descriptor={name:e,def:ws[e],expression:i.expression,filters:i.filters}}}var n;return t.oneTime?n=document.createTextNode(t.value):t.html?(n=document.createComment("v-html"),i("html")):(n=document.createTextNode(" "),i("text")),n}function Ze(t,e){return function(i,n,r,s){for(var o,a,l,h=e.cloneNode(!0),u=v(h.childNodes),c=0,f=t.length;f>c;c++)o=t[c],a=o.value,o.tag&&(l=u[c],o.oneTime?(a=(s||i).$eval(a),o.html?Y(l,Kt(a,!0)):l.data=a):i._bindDir(o.descriptor,l,r,s));Y(n,h)}}function Je(t,e){for(var i,n,r,s=[],o=0,a=t.length;a>o;o++)r=t[o],i=Me(r,e),n=i&&i.terminal||"SCRIPT"===r.tagName||!r.hasChildNodes()?null:Je(r.childNodes,e),s.push(i,n);return s.length?Ge(s):null}function Ge(t){return function(e,i,n,r,s){for(var o,a,l,h=0,u=0,c=t.length;c>h;u++){o=i[u],a=t[h++],l=t[h++];var f=v(o.childNodes);a&&a(e,o,n,r,s),l&&l(e,f,n,r,s)}}}function Ke(t,e){var i=t.tagName.toLowerCase();if(!Nn.test(i)){var n=yt(e,"elementDirectives",i);return n?ei(t,i,"",e,n):void 0}}function Qe(t,e){var i=ut(t,e);if(i){var n=st(t),r={name:"component",ref:n,expression:i.id,def:Hs.component,modifiers:{literal:!i.dynamic}},s=function(t,e,i,s,o){n&&xt((s||t).$refs,n,null),t._bindDir(r,e,i,s,o)};return s.terminal=!0,s}}function Xe(t,e,i){if(null!==H(t,"v-pre"))return ti;if(t.hasAttribute("v-else")){var n=t.previousElementSibling;if(n&&n.hasAttribute("v-if"))return ti}for(var r,s,o,a,l,h,u,c,f,p,d=0,v=e.length;v>d;d++)r=e[d],s=r.name.replace(Vs,""),(l=s.match(Ms))&&(f=yt(i,"directives",l[1]),f&&f.terminal&&(!p||(f.priority||Ys)>p.priority)&&(p=f,u=r.name,a=ni(r.name),o=r.value,h=l[1],c=l[2]));return p?ei(t,h,o,i,p,u,c,a):void 0}function ti(){}function ei(t,e,i,n,r,s,o,a){var l=O(i),h={name:e,arg:o,expression:l.expression,filters:l.filters,raw:i,attr:s,modifiers:a,def:r};"for"!==e&&"router-view"!==e||(h.ref=st(t));var u=function(t,e,i,n,r){h.ref&&xt((n||t).$refs,h.ref,null),t._bindDir(h,e,i,n,r)};return u.terminal=!0,u}function ii(t,e){function i(t,e,i){var n=i&&si(i),r=!n&&O(s);v.push({name:t,attr:o,raw:a,def:e,arg:h,modifiers:u,expression:r&&r.expression,filters:r&&r.filters,interp:i,hasOneTime:n})}for(var n,r,s,o,a,l,h,u,c,f,p,d=t.length,v=[];d--;)if(n=t[d],r=o=n.name,s=a=n.value,f=N(s),h=null,u=ni(r),r=r.replace(Vs,""),f)s=j(f),h=r,i("bind",ws.bind,f),"class"===r&&Array.prototype.some.call(t,function(t){return":class"===t.name||"v-bind:class"===t.name})&&An('class="'+a+'": Do not mix mustache interpolation and v-bind for "class" on the same element. Use one or the other.',e);else if(Bs.test(r))u.literal=!zs.test(r),i("transition",Hs.transition);else if(Ws.test(r))h=r.replace(Ws,""),i("on",ws.on);else if(zs.test(r))l=r.replace(zs,""),"style"===l||"class"===l?i(l,Hs[l]):(h=l,i("bind",ws.bind));else if(p=r.match(Ms)){if(l=p[1],h=p[2],"else"===l)continue;c=yt(e,"directives",l,!0),c&&i(l,c)}return v.length?ri(v):void 0}function ni(t){var e=Object.create(null),i=t.match(Vs);if(i)for(var n=i.length;n--;)e[i[n].slice(1)]=!0;return e}function ri(t){return function(e,i,n,r,s){for(var o=t.length;o--;)e._bindDir(t[o],i,n,r,s)}}function si(t){for(var e=t.length;e--;)if(t[e].oneTime)return!0}function oi(t){return"SCRIPT"===t.tagName&&(!t.hasAttribute("type")||"text/javascript"===t.getAttribute("type"))}function ai(t,e){return e&&(e._containerAttrs=hi(t)),nt(t)&&(t=Kt(t)),e&&(e._asComponent&&!e.template&&(e.template="<slot></slot>"),e.template&&(e._content=tt(t),t=li(t,e))),lt(t)&&(q(rt("v-start",!0),t),t.appendChild(rt("v-end",!0))),t}function li(t,e){var i=e.template,n=Kt(i,!0);if(n){var r=n.firstChild,s=r.tagName&&r.tagName.toLowerCase();return e.replace?(t===document.body&&An("You are mounting an instance with a template to <body>. This will replace <body> entirely. You should probably use `replace: false` here."),n.childNodes.length>1||1!==r.nodeType||"component"===s||yt(e,"components",s)||W(r,"is")||yt(e,"elementDirectives",s)||r.hasAttribute("v-for")||r.hasAttribute("v-if")?n:(e._replacerAttrs=hi(r),ui(t,r),r)):(t.appendChild(n),t)}An("Invalid template option: "+i)}function hi(t){return 1===t.nodeType&&t.hasAttributes()?v(t.attributes):void 0}function ui(t,e){for(var i,n,r=t.attributes,s=r.length;s--;)i=r[s].name,n=r[s].value,e.hasAttribute(i)||Zs.test(i)?"class"===i&&!N(n)&&(n=n.trim())&&n.split(/\s+/).forEach(function(t){Q(e,t)}):e.setAttribute(i,n)}function ci(t,e){if(e){for(var i,n,r=t._slotContents=Object.create(null),s=0,o=e.children.length;o>s;s++)i=e.children[s],(n=i.getAttribute("slot"))&&(r[n]||(r[n]=[])).push(i),z(i,"slot")&&An('The "slot" attribute must be static.',t.$parent);for(n in r)r[n]=fi(r[n],e);if(e.hasChildNodes()){var a=e.childNodes;if(1===a.length&&3===a[0].nodeType&&!a[0].data.trim())return;r["default"]=fi(e.childNodes,e)}}}function fi(t,e){var i=document.createDocumentFragment();t=v(t);for(var n=0,r=t.length;r>n;n++){var s=t[n];!nt(s)||s.hasAttribute("v-if")||s.hasAttribute("v-for")||(e.removeChild(s),s=Kt(s,!0)),i.appendChild(s)}return i}function pi(t){function e(){}function i(t,e){var i=new Bt(e,t,null,{lazy:!0});return function(){return i.dirty&&i.evaluate(),bt.target&&i.depend(),i.value}}Object.defineProperty(t.prototype,"$data",{get:function(){return this._data},set:function(t){t!==this._data&&this._setData(t)}}),t.prototype._initState=function(){this._initProps(),this._initMeta(),this._initMethods(),this._initData(),this._initComputed()},t.prototype._initProps=function(){var t=this.$options,e=t.el,i=t.props;i&&!e&&An("Props will not be compiled if no `el` option is provided at instantiation.",this),e=t.el=U(e),this._propsUnlinkFn=e&&1===e.nodeType&&i?ze(this,e,i,this._scope):null},t.prototype._initData=function(){var t=this.$options.data,e=this._data=t?t():{};y(e)||(e={},An("data functions should return an object.",this));var i,r,s=this._props,o=Object.keys(e);for(i=o.length;i--;)r=o[i],s&&n(s,r)?An('Data field "'+r+'" is already defined as a prop. To provide default value for a prop, use the "default" prop option; if you want to pass prop values to an instantiation call, use the "propsData" option.',this):this._proxy(r);kt(e,this)},t.prototype._setData=function(t){t=t||{};var e=this._data;this._data=t;var i,r,s;for(i=Object.keys(e),s=i.length;s--;)r=i[s],r in t||this._unproxy(r);for(i=Object.keys(t),s=i.length;s--;)r=i[s],n(this,r)||this._proxy(r);e.__ob__.removeVm(this),kt(t,this),this._digest()},t.prototype._proxy=function(t){if(!s(t)){var e=this;Object.defineProperty(e,t,{configurable:!0,enumerable:!0,get:function(){return e._data[t]},set:function(i){
+e._data[t]=i}})}},t.prototype._unproxy=function(t){s(t)||delete this[t]},t.prototype._digest=function(){for(var t=0,e=this._watchers.length;e>t;t++)this._watchers[t].update(!0)},t.prototype._initComputed=function(){var t=this.$options.computed;if(t)for(var n in t){var r=t[n],s={enumerable:!0,configurable:!0};"function"==typeof r?(s.get=i(r,this),s.set=e):(s.get=r.get?r.cache!==!1?i(r.get,this):d(r.get,this):e,s.set=r.set?d(r.set,this):e),Object.defineProperty(this,n,s)}},t.prototype._initMethods=function(){var t=this.$options.methods;if(t)for(var e in t)this[e]=d(t[e],this)},t.prototype._initMeta=function(){var t=this.$options._meta;if(t)for(var e in t)xt(this,e,t[e])}}function di(t){function e(t,e){for(var i,n,r,s=e.attributes,o=0,a=s.length;a>o;o++)i=s[o].name,Gs.test(i)&&(i=i.replace(Gs,""),n=s[o].value,Ht(n)&&(n+=".apply(this, $arguments)"),r=(t._scope||t._context).$eval(n,!0),r._fromParent=!0,t.$on(i.replace(Gs),r))}function i(t,e,i){if(i){var r,s,o,a;for(s in i)if(r=i[s],Pi(r))for(o=0,a=r.length;a>o;o++)n(t,e,s,r[o]);else n(t,e,s,r)}}function n(t,e,i,r,s){var o=typeof r;if("function"===o)t[e](i,r,s);else if("string"===o){var a=t.$options.methods,l=a&&a[r];l?t[e](i,l,s):An('Unknown method: "'+r+'" when registering callback for '+e+': "'+i+'".',t)}else r&&"object"===o&&n(t,e,i,r.handler,r)}function r(){this._isAttached||(this._isAttached=!0,this.$children.forEach(s))}function s(t){!t._isAttached&&I(t.$el)&&t._callHook("attached")}function o(){this._isAttached&&(this._isAttached=!1,this.$children.forEach(a))}function a(t){t._isAttached&&!I(t.$el)&&t._callHook("detached")}t.prototype._initEvents=function(){var t=this.$options;t._asComponent&&e(this,t.el),i(this,"$on",t.events),i(this,"$watch",t.watch)},t.prototype._initDOMHooks=function(){this.$on("hook:attached",r),this.$on("hook:detached",o)},t.prototype._callHook=function(t){this.$emit("pre-hook:"+t);var e=this.$options[t];if(e)for(var i=0,n=e.length;n>i;i++)e[i].call(this);this.$emit("hook:"+t)}}function vi(){}function mi(t,e,i,n,r,s){this.vm=e,this.el=i,this.descriptor=t,this.name=t.name,this.expression=t.expression,this.arg=t.arg,this.modifiers=t.modifiers,this.filters=t.filters,this.literal=this.modifiers&&this.modifiers.literal,this._locked=!1,this._bound=!1,this._listeners=null,this._host=n,this._scope=r,this._frag=s,this.el&&(this.el._vue_directives=this.el._vue_directives||[],this.el._vue_directives.push(this))}function gi(t){t.prototype._updateRef=function(t){var e=this.$options._ref;if(e){var i=(this._scope||this._context).$refs;t?i[e]===this&&(i[e]=null):i[e]=this}},t.prototype._compile=function(t){var e=this.$options,i=t;if(t=ai(t,e),this._initElement(t),1!==t.nodeType||null===H(t,"v-pre")){var n=this._context&&this._context.$options,r=We(t,e,n);ci(this,e._content);var s,o=this.constructor;e._linkerCachable&&(s=o.linker,s||(s=o.linker=Pe(t,e)));var a=r(this,t,this._scope),l=s?s(this,t):Pe(t,e)(this,t);this._unlinkFn=function(){a(),l(!0)},e.replace&&Y(i,t),this._isCompiled=!0,this._callHook("compiled")}},t.prototype._initElement=function(t){lt(t)?(this._isFragment=!0,this.$el=this._fragmentStart=t.firstChild,this._fragmentEnd=t.lastChild,3===this._fragmentStart.nodeType&&(this._fragmentStart.data=this._fragmentEnd.data=""),this._fragment=t):this.$el=t,this.$el.__vue__=this,this._callHook("beforeCompile")},t.prototype._bindDir=function(t,e,i,n,r){this._directives.push(new mi(t,this,e,i,n,r))},t.prototype._destroy=function(t,e){if(this._isBeingDestroyed)return void(e||this._cleanup());var i,n,r=this,s=function(){!i||n||e||r._cleanup()};t&&this.$el&&(n=!0,this.$remove(function(){n=!1,s()})),this._callHook("beforeDestroy"),this._isBeingDestroyed=!0;var o,a=this.$parent;for(a&&!a._isBeingDestroyed&&(a.$children.$remove(this),this._updateRef(!0)),o=this.$children.length;o--;)this.$children[o].$destroy();for(this._propsUnlinkFn&&this._propsUnlinkFn(),this._unlinkFn&&this._unlinkFn(),o=this._watchers.length;o--;)this._watchers[o].teardown();this.$el&&(this.$el.__vue__=null),i=!0,s()},t.prototype._cleanup=function(){this._isDestroyed||(this._frag&&this._frag.children.$remove(this),this._data&&this._data.__ob__&&this._data.__ob__.removeVm(this),this.$el=this.$parent=this.$root=this.$children=this._watchers=this._context=this._scope=this._directives=null,this._isDestroyed=!0,this._callHook("destroyed"),this.$off())}}function yi(t){t.prototype._applyFilters=function(t,e,i,n){var r,s,o,a,l,h,u,c,f;for(h=0,u=i.length;u>h;h++)if(r=i[n?u-h-1:h],s=yt(this.$options,"filters",r.name,!0),s&&(s=n?s.write:s.read||s,"function"==typeof s)){if(o=n?[t,e]:[t],l=n?2:1,r.args)for(c=0,f=r.args.length;f>c;c++)a=r.args[c],o[c+l]=a.dynamic?this.$get(a.value):a.value;t=s.apply(this,o)}return t},t.prototype._resolveComponent=function(e,i){var n;if(n="function"==typeof e?e:yt(this.$options,"components",e,!0))if(n.options)i(n);else if(n.resolved)i(n.resolved);else if(n.requested)n.pendingCallbacks.push(i);else{n.requested=!0;var r=n.pendingCallbacks=[i];n.call(this,function(e){y(e)&&(e=t.extend(e)),n.resolved=e;for(var i=0,s=r.length;s>i;i++)r[i](e)},function(t){An("Failed to resolve async component"+("string"==typeof e?": "+e:"")+". "+(t?"\nReason: "+t:""))})}}}function bi(t){function e(t){return JSON.parse(JSON.stringify(t))}t.prototype.$get=function(t,e){var i=It(t);if(i){if(e){var n=this;return function(){n.$arguments=v(arguments);var t=i.get.call(n,n);return n.$arguments=null,t}}try{return i.get.call(this,this)}catch(r){}}},t.prototype.$set=function(t,e){var i=It(t,!0);i&&i.set&&i.set.call(this,this,e)},t.prototype.$delete=function(t){i(this._data,t)},t.prototype.$watch=function(t,e,i){var n,r=this;"string"==typeof t&&(n=O(t),t=n.expression);var s=new Bt(r,t,e,{deep:i&&i.deep,sync:i&&i.sync,filters:n&&n.filters,user:!i||i.user!==!1});return i&&i.immediate&&e.call(r,s.value),function(){s.teardown()}},t.prototype.$eval=function(t,e){if(Ks.test(t)){var i=O(t),n=this.$get(i.expression,e);return i.filters?this._applyFilters(n,null,i.filters):n}return this.$get(t,e)},t.prototype.$interpolate=function(t){var e=N(t),i=this;return e?1===e.length?i.$eval(e[0].value)+"":e.map(function(t){return t.tag?i.$eval(t.value):t.value}).join(""):t},t.prototype.$log=function(t){var i=t?jt(this._data,t):this._data;if(i&&(i=e(i)),!t){var n;for(n in this.$options.computed)i[n]=e(this[n]);if(this._props)for(n in this._props)i[n]=e(this[n])}console.log(i)}}function _i(t){function e(t,e,n,r,s,o){e=i(e);var a=!I(e),l=r===!1||a?s:o,h=!a&&!t._isAttached&&!I(t.$el);return t._isFragment?(ot(t._fragmentStart,t._fragmentEnd,function(i){l(i,e,t)}),n&&n()):l(t.$el,e,t,n),h&&t._callHook("attached"),t}function i(t){return"string"==typeof t?document.querySelector(t):t}function n(t,e,i,n){e.appendChild(t),n&&n()}function r(t,e,i,n){M(t,e),n&&n()}function s(t,e,i){B(t),i&&i()}t.prototype.$nextTick=function(t){Ki(t,this)},t.prototype.$appendTo=function(t,i,r){return e(this,t,i,r,n,F)},t.prototype.$prependTo=function(t,e,n){return t=i(t),t.hasChildNodes()?this.$before(t.firstChild,e,n):this.$appendTo(t,e,n),this},t.prototype.$before=function(t,i,n){return e(this,t,i,n,r,R)},t.prototype.$after=function(t,e,n){return t=i(t),t.nextSibling?this.$before(t.nextSibling,e,n):this.$appendTo(t.parentNode,e,n),this},t.prototype.$remove=function(t,e){if(!this.$el.parentNode)return t&&t();var i=this._isAttached&&I(this.$el);i||(e=!1);var n=this,r=function(){i&&n._callHook("detached"),t&&t()};if(this._isFragment)at(this._fragmentStart,this._fragmentEnd,this,this._fragment,r);else{var o=e===!1?s:P;o(this.$el,this,r)}return this}}function wi(t){function e(t,e,n){var r=t.$parent;if(r&&n&&!i.test(e))for(;r;)r._eventsCount[e]=(r._eventsCount[e]||0)+n,r=r.$parent}t.prototype.$on=function(t,i){return(this._events[t]||(this._events[t]=[])).push(i),e(this,t,1),this},t.prototype.$once=function(t,e){function i(){n.$off(t,i),e.apply(this,arguments)}var n=this;return i.fn=e,this.$on(t,i),this},t.prototype.$off=function(t,i){var n;if(!arguments.length){if(this.$parent)for(t in this._events)n=this._events[t],n&&e(this,t,-n.length);return this._events={},this}if(n=this._events[t],!n)return this;if(1===arguments.length)return e(this,t,-n.length),this._events[t]=null,this;for(var r,s=n.length;s--;)if(r=n[s],r===i||r.fn===i){e(this,t,-1),n.splice(s,1);break}return this},t.prototype.$emit=function(t){var e="string"==typeof t;t=e?t:t.name;var i=this._events[t],n=e||!i;if(i){i=i.length>1?v(i):i;var r=e&&i.some(function(t){return t._fromParent});r&&(n=!1);for(var s=v(arguments,1),o=0,a=i.length;a>o;o++){var l=i[o],h=l.apply(this,s);h!==!0||r&&!l._fromParent||(n=!0)}}return n},t.prototype.$broadcast=function(t){var e="string"==typeof t;if(t=e?t:t.name,this._eventsCount[t]){var i=this.$children,n=v(arguments);e&&(n[0]={name:t,source:this});for(var r=0,s=i.length;s>r;r++){var o=i[r],a=o.$emit.apply(o,n);a&&o.$broadcast.apply(o,n)}return this}},t.prototype.$dispatch=function(t){var e=this.$emit.apply(this,arguments);if(e){var i=this.$parent,n=v(arguments);for(n[0]={name:t,source:this};i;)e=i.$emit.apply(i,n),i=e?i.$parent:null;return this}};var i=/^hook:/}function Ci(t){function e(){this._isAttached=!0,this._isReady=!0,this._callHook("ready")}t.prototype.$mount=function(t){return this._isCompiled?void An("$mount() should be called only once.",this):(t=U(t),t||(t=document.createElement("div")),this._compile(t),this._initDOMHooks(),I(this.$el)?(this._callHook("attached"),e.call(this)):this.$once("hook:attached",e),this)},t.prototype.$destroy=function(t,e){this._destroy(t,e)},t.prototype.$compile=function(t,e,i,n){return Pe(t,this.$options,!0)(this,t,e,i,n)}}function $i(t){this._init(t)}function ki(t,e,i){return i=i?parseInt(i,10):0,e=a(e),"number"==typeof e?t.slice(i,i+e):t}function xi(t,e,i){if(t=eo(t),null==e)return t;if("function"==typeof e)return t.filter(e);e=(""+e).toLowerCase();for(var n,r,s,o,a="in"===i?3:2,l=Array.prototype.concat.apply([],v(arguments,a)),h=[],u=0,c=t.length;c>u;u++)if(n=t[u],s=n&&n.$value||n,o=l.length){for(;o--;)if(r=l[o],"$key"===r&&Oi(n.$key,e)||Oi(jt(s,r),e)){h.push(n);break}}else Oi(n,e)&&h.push(n);return h}function Ai(t){function e(t,e,i){var r=n[i];return r&&("$key"!==r&&(g(t)&&"$value"in t&&(t=t.$value),g(e)&&"$value"in e&&(e=e.$value)),t=g(t)?jt(t,r):t,e=g(e)?jt(e,r):e),t===e?0:t>e?s:-s}var i=null,n=void 0;t=eo(t);var r=v(arguments,1),s=r[r.length-1];"number"==typeof s?(s=0>s?-1:1,r=r.length>1?r.slice(0,-1):r):s=1;var o=r[0];return o?("function"==typeof o?i=function(t,e){return o(t,e)*s}:(n=Array.prototype.concat.apply([],r),i=function(t,r,s){return s=s||0,s>=n.length-1?e(t,r,s):e(t,r,s)||i(t,r,s+1)}),t.slice().sort(i)):t}function Oi(t,e){var i;if(y(t)){var n=Object.keys(t);for(i=n.length;i--;)if(Oi(t[n[i]],e))return!0}else if(Pi(t)){for(i=t.length;i--;)if(Oi(t[i],e))return!0}else if(null!=t)return t.toString().toLowerCase().indexOf(e)>-1}function Ti(e){function n(t){return new Function("return function "+p(t)+" (options) { this._init(options) }")()}e.options={directives:ws,elementDirectives:to,filters:no,transitions:{},components:{},partials:{},replace:!0},e.util=Hn,e.config=xn,e.set=t,e["delete"]=i,e.nextTick=Ki,e.compiler=Js,e.FragmentFactory=se,e.internalDirectives=Hs,e.parsers={path:rr,text:Cn,template:Fr,directive:mn,expression:yr},e.cid=0;var r=1;e.extend=function(t){t=t||{};var e=this,i=0===e.cid;if(i&&t._Ctor)return t._Ctor;var s=t.name||e.options.name;/^[a-zA-Z][\w-]*$/.test(s)||(An('Invalid component name: "'+s+'". Component names can only contain alphanumeric characaters and the hyphen.'),s=null);var o=n(s||"VueComponent");return o.prototype=Object.create(e.prototype),o.prototype.constructor=o,o.cid=r++,o.options=gt(e.options,t),o["super"]=e,o.extend=e.extend,xn._assetTypes.forEach(function(t){o[t]=e[t]}),s&&(o.options.components[s]=o),i&&(t._Ctor=o),o},e.use=function(t){if(!t.installed){var e=v(arguments,1);return e.unshift(this),"function"==typeof t.install?t.install.apply(t,e):t.apply(null,e),t.installed=!0,this}},e.mixin=function(t){e.options=gt(e.options,t)},xn._assetTypes.forEach(function(t){e[t]=function(i,n){return n?("component"===t&&(Nn.test(i)||jn.test(i))&&An("Do not use built-in or reserved HTML elements as component id: "+i),"component"===t&&y(n)&&(n.name=i,n=e.extend(n)),this.options[t+"s"][i]=n,n):this.options[t+"s"][i]}}),m(e.transition,Tn)}var Ei=Object.prototype.hasOwnProperty,Ni=/^\s?(true|false|-?[\d\.]+|'[^']*'|"[^"]*")\s?$/,ji=/-(\w)/g,Si=/([a-z\d])([A-Z])/g,Di=/(?:^|[-_\/])(\w)/g,Fi=Object.prototype.toString,Ri="[object Object]",Pi=Array.isArray,Li="__proto__"in{},Ui="undefined"!=typeof window&&"[object Object]"!==Object.prototype.toString.call(window),Ii=Ui&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,Hi=Ui&&window.navigator.userAgent.toLowerCase(),zi=Hi&&Hi.indexOf("msie 9.0")>0,Wi=Hi&&Hi.indexOf("android")>0,Mi=Hi&&/(iphone|ipad|ipod|ios)/i.test(Hi),Vi=Hi&&Hi.indexOf("micromessenger")>0,Bi=void 0,qi=void 0,Yi=void 0,Zi=void 0;if(Ui&&!zi){var Ji=void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend,Gi=void 0===window.onanimationend&&void 0!==window.onwebkitanimationend;Bi=Ji?"WebkitTransition":"transition",qi=Ji?"webkitTransitionEnd":"transitionend",Yi=Gi?"WebkitAnimation":"animation",Zi=Gi?"webkitAnimationEnd":"animationend"}var Ki=function(){function t(){r=!1;var t=n.slice(0);n=[];for(var e=0;e<t.length;e++)t[e]()}var i,n=[],r=!1;if("undefined"==typeof MutationObserver||Vi&&Mi){var s=Ui?window:"undefined"!=typeof e?e:{};i=s.setImmediate||setTimeout}else{var o=1,a=new MutationObserver(t),l=document.createTextNode(o);a.observe(l,{characterData:!0}),i=function(){o=(o+1)%2,l.data=o}}return function(e,s){var o=s?function(){e.call(s)}:e;n.push(o),r||(r=!0,i(t,0))}}(),Qi=void 0;"undefined"!=typeof Set&&Set.toString().match(/native code/)?Qi=Set:(Qi=function(){this.set=Object.create(null)},Qi.prototype.has=function(t){return void 0!==this.set[t]},Qi.prototype.add=function(t){this.set[t]=1},Qi.prototype.clear=function(){this.set=Object.create(null)});var Xi=k.prototype;Xi.put=function(t,e){var i;this.size===this.limit&&(i=this.shift());var n=this.get(t,!0);return n||(n={key:t},this._keymap[t]=n,this.tail?(this.tail.newer=n,n.older=this.tail):this.head=n,this.tail=n,this.size++),n.value=e,i},Xi.shift=function(){var t=this.head;return t&&(this.head=this.head.newer,this.head.older=void 0,t.newer=t.older=void 0,this._keymap[t.key]=void 0,this.size--),t},Xi.get=function(t,e){var i=this._keymap[t];if(void 0!==i)return i===this.tail?e?i:i.value:(i.newer&&(i===this.head&&(this.head=i.newer),i.newer.older=i.older),i.older&&(i.older.newer=i.newer),i.newer=void 0,i.older=this.tail,this.tail&&(this.tail.newer=i),this.tail=i,e?i:i.value)};var tn,en,nn,rn,sn,on,an,ln,hn,un,cn,fn,pn=new k(1e3),dn=/[^\s'"]+|'[^']*'|"[^"]*"/g,vn=/^in$|^-?\d+/,mn=Object.freeze({parseDirective:O}),gn=/[-.*+?^${}()|[\]\/\\]/g,yn=void 0,bn=void 0,_n=void 0,wn=/[^|]\|[^|]/,Cn=Object.freeze({compileRegex:E,parseText:N,tokensToExp:j}),$n=["{{","}}"],kn=["{{{","}}}"],xn=Object.defineProperties({debug:!1,silent:!1,async:!0,warnExpressionErrors:!0,devtools:!0,_delimitersChanged:!0,_assetTypes:["component","directive","elementDirective","filter","transition","partial"],_propBindingModes:{ONE_WAY:0,TWO_WAY:1,ONE_TIME:2},_maxUpdateCount:100},{delimiters:{get:function(){return $n},set:function(t){$n=t,E()},configurable:!0,enumerable:!0},unsafeDelimiters:{get:function(){return kn},set:function(t){kn=t,E()},configurable:!0,enumerable:!0}}),An=void 0,On=void 0;!function(){var t="undefined"!=typeof console;An=function(e,i){t&&!xn.silent&&console.error("[Vue warn]: "+e+(i?On(i):""))},On=function(t){var e=t._isVue?t.$options.name:t.name;return e?" (found in component: <"+f(e)+">)":""}}();var Tn=Object.freeze({appendWithTransition:F,beforeWithTransition:R,removeWithTransition:P,applyTransition:L}),En=/^v-ref:/,Nn=/^(div|p|span|img|a|b|i|br|ul|ol|li|h1|h2|h3|h4|h5|h6|code|pre|table|th|td|tr|form|label|input|select|option|nav|article|section|header|footer)$/i,jn=/^(slot|partial|component)$/i,Sn=void 0;Sn=function(t,e){return e.indexOf("-")>-1?t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:/HTMLUnknownElement/.test(t.toString())&&!/^(data|time|rtc|rb)$/.test(e)};var Dn=xn.optionMergeStrategies=Object.create(null);Dn.data=function(t,e,i){return i?t||e?function(){var n="function"==typeof e?e.call(i):e,r="function"==typeof t?t.call(i):void 0;return n?ft(n,r):r}:void 0:e?"function"!=typeof e?(An('The "data" option should be a function that returns a per-instance value in component definitions.',i),t):t?function(){return ft(e.call(this),t.call(this))}:e:t},Dn.el=function(t,e,i){if(!i&&e&&"function"!=typeof e)return void An('The "el" option should be a function that returns a per-instance value in component definitions.',i);var n=e||t;return i&&"function"==typeof n?n.call(i):n},Dn.init=Dn.created=Dn.ready=Dn.attached=Dn.detached=Dn.beforeCompile=Dn.compiled=Dn.beforeDestroy=Dn.destroyed=Dn.activate=function(t,e){return e?t?t.concat(e):Pi(e)?e:[e]:t},xn._assetTypes.forEach(function(t){Dn[t+"s"]=pt}),Dn.watch=Dn.events=function(t,e){if(!e)return t;if(!t)return e;var i={};m(i,t);for(var n in e){var r=i[n],s=e[n];r&&!Pi(r)&&(r=[r]),i[n]=r?r.concat(s):[s]}return i},Dn.props=Dn.methods=Dn.computed=function(t,e){if(!e)return t;if(!t)return e;var i=Object.create(null);return m(i,t),m(i,e),i};var Fn=function(t,e){return void 0===e?t:e},Rn=0;bt.target=null,bt.prototype.addSub=function(t){this.subs.push(t)},bt.prototype.removeSub=function(t){this.subs.$remove(t)},bt.prototype.depend=function(){bt.target.addDep(this)},bt.prototype.notify=function(){for(var t=v(this.subs),e=0,i=t.length;i>e;e++)t[e].update()};var Pn=Array.prototype,Ln=Object.create(Pn);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(t){var e=Pn[t];b(Ln,t,function(){for(var i=arguments.length,n=new Array(i);i--;)n[i]=arguments[i];var r,s=e.apply(this,n),o=this.__ob__;switch(t){case"push":r=n;break;case"unshift":r=n;break;case"splice":r=n.slice(2)}return r&&o.observeArray(r),o.dep.notify(),s})}),b(Pn,"$set",function(t,e){return t>=this.length&&(this.length=Number(t)+1),this.splice(t,1,e)[0]}),b(Pn,"$remove",function(t){if(this.length){var e=w(this,t);return e>-1?this.splice(e,1):void 0}});var Un=Object.getOwnPropertyNames(Ln),In=!0;wt.prototype.walk=function(t){for(var e=Object.keys(t),i=0,n=e.length;n>i;i++)this.convert(e[i],t[e[i]])},wt.prototype.observeArray=function(t){for(var e=0,i=t.length;i>e;e++)kt(t[e])},wt.prototype.convert=function(t,e){xt(this.value,t,e)},wt.prototype.addVm=function(t){(this.vms||(this.vms=[])).push(t)},wt.prototype.removeVm=function(t){this.vms.$remove(t)};var Hn=Object.freeze({defineReactive:xt,set:t,del:i,hasOwn:n,isLiteral:r,isReserved:s,_toString:o,toNumber:a,toBoolean:l,stripQuotes:h,camelize:u,hyphenate:f,classify:p,bind:d,toArray:v,extend:m,isObject:g,isPlainObject:y,def:b,debounce:_,indexOf:w,cancellable:C,looseEqual:$,isArray:Pi,hasProto:Li,inBrowser:Ui,devtools:Ii,isIE9:zi,isAndroid:Wi,isIos:Mi,isWechat:Vi,get transitionProp(){return Bi},get transitionEndEvent(){return qi},get animationProp(){return Yi},get animationEndEvent(){return Zi},nextTick:Ki,get _Set(){return Qi},query:U,inDoc:I,getAttr:H,getBindAttr:z,hasBindAttr:W,before:M,after:V,remove:B,prepend:q,replace:Y,on:Z,off:J,setClass:K,addClass:Q,removeClass:X,extractContent:tt,trimNode:et,isTemplate:nt,createAnchor:rt,findRef:st,mapNodeRange:ot,removeNodeRange:at,isFragment:lt,getOuterHTML:ht,mergeOptions:gt,resolveAsset:yt,checkComponentAttr:ut,commonTagRE:Nn,reservedTagRE:jn,get warn(){return An}}),zn=0,Wn=new k(1e3),Mn=0,Vn=1,Bn=2,qn=3,Yn=0,Zn=1,Jn=2,Gn=3,Kn=4,Qn=5,Xn=6,tr=7,er=8,ir=[];ir[Yn]={ws:[Yn],ident:[Gn,Mn],"[":[Kn],eof:[tr]},ir[Zn]={ws:[Zn],".":[Jn],"[":[Kn],eof:[tr]},ir[Jn]={ws:[Jn],ident:[Gn,Mn]},ir[Gn]={ident:[Gn,Mn],0:[Gn,Mn],number:[Gn,Mn],ws:[Zn,Vn],".":[Jn,Vn],"[":[Kn,Vn],eof:[tr,Vn]},ir[Kn]={"'":[Qn,Mn],'"':[Xn,Mn],"[":[Kn,Bn],"]":[Zn,qn],eof:er,"else":[Kn,Mn]},ir[Qn]={"'":[Kn,Mn],eof:er,"else":[Qn,Mn]},ir[Xn]={'"':[Kn,Mn],eof:er,"else":[Xn,Mn]};var nr;nr=function(t,e){An('You are setting a non-existent path "'+t.raw+'" on a vm instance. Consider pre-initializing the property with the "data" option for more reliable reactivity and better performance.',e)};var rr=Object.freeze({parsePath:Nt,getPath:jt,setPath:St}),sr=new k(1e3),or="Math,Date,this,true,false,null,undefined,Infinity,NaN,isNaN,isFinite,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,parseInt,parseFloat",ar=new RegExp("^("+or.replace(/,/g,"\\b|")+"\\b)"),lr="break,case,class,catch,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,in,instanceof,let,return,super,switch,throw,try,var,while,with,yield,enum,await,implements,package,protected,static,interface,private,public",hr=new RegExp("^("+lr.replace(/,/g,"\\b|")+"\\b)"),ur=/\s/g,cr=/\n/g,fr=/[\{,]\s*[\w\$_]+\s*:|('(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`)|new |typeof |void /g,pr=/"(\d+)"/g,dr=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?'\]|\[".*?"\]|\[\d+\]|\[[A-Za-z_$][\w$]*\])*$/,vr=/[^\w$\.](?:[A-Za-z_$][\w$]*)/g,mr=/^(?:true|false)$/,gr=[],yr=Object.freeze({parseExpression:It,isSimplePath:Ht}),br=[],_r=[],wr={},Cr={},$r=!1,kr=0;Bt.prototype.get=function(){this.beforeGet();var t,e=this.scope||this.vm;try{t=this.getter.call(e,e)}catch(i){xn.warnExpressionErrors&&An('Error when evaluating expression "'+this.expression+'": '+i.toString(),this.vm)}return this.deep&&qt(t),this.preProcess&&(t=this.preProcess(t)),this.filters&&(t=e._applyFilters(t,null,this.filters,!1)),this.postProcess&&(t=this.postProcess(t)),this.afterGet(),t},Bt.prototype.set=function(t){var e=this.scope||this.vm;this.filters&&(t=e._applyFilters(t,this.value,this.filters,!0));try{this.setter.call(e,e,t)}catch(i){xn.warnExpressionErrors&&An('Error when evaluating setter "'+this.expression+'": '+i.toString(),this.vm)}var n=e.$forContext;if(n&&n.alias===this.expression){if(n.filters)return void An("It seems you are using two-way binding on a v-for alias ("+this.expression+"), and the v-for has filters. This will not work properly. Either remove the filters or use an array of objects and bind to object properties instead.",this.vm);n._withLock(function(){e.$key?n.rawValue[e.$key]=t:n.rawValue.$set(e.$index,t)})}},Bt.prototype.beforeGet=function(){bt.target=this},Bt.prototype.addDep=function(t){var e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))},Bt.prototype.afterGet=function(){bt.target=null;for(var t=this.deps.length;t--;){var e=this.deps[t];this.newDepIds.has(e.id)||e.removeSub(this)}var i=this.depIds;this.depIds=this.newDepIds,this.newDepIds=i,this.newDepIds.clear(),i=this.deps,this.deps=this.newDeps,this.newDeps=i,this.newDeps.length=0},Bt.prototype.update=function(t){this.lazy?this.dirty=!0:this.sync||!xn.async?this.run():(this.shallow=this.queued?t?this.shallow:!1:!!t,this.queued=!0,xn.debug&&(this.prevError=new Error("[vue] async stack trace")),Vt(this))},Bt.prototype.run=function(){if(this.active){var t=this.get();if(t!==this.value||(g(t)||this.deep)&&!this.shallow){var e=this.value;this.value=t;var i=this.prevError;if(xn.debug&&i){this.prevError=null;try{this.cb.call(this.vm,t,e)}catch(n){throw Ki(function(){throw i},0),n}}else this.cb.call(this.vm,t,e)}this.queued=this.shallow=!1}},Bt.prototype.evaluate=function(){var t=bt.target;this.value=this.get(),this.dirty=!1,bt.target=t},Bt.prototype.depend=function(){for(var t=this.deps.length;t--;)this.deps[t].depend()},Bt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||this.vm._vForRemoving||this.vm._watchers.$remove(this);for(var t=this.deps.length;t--;)this.deps[t].removeSub(this);this.active=!1,this.vm=this.cb=this.value=null}};var xr=new Qi,Ar={bind:function(){this.attr=3===this.el.nodeType?"data":"textContent"},update:function(t){this.el[this.attr]=o(t)}},Or=new k(1e3),Tr=new k(1e3),Er={efault:[0,"",""],legend:[1,"<fieldset>","</fieldset>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"]};Er.td=Er.th=[3,"<table><tbody><tr>","</tr></tbody></table>"],Er.option=Er.optgroup=[1,'<select multiple="multiple">',"</select>"],Er.thead=Er.tbody=Er.colgroup=Er.caption=Er.tfoot=[1,"<table>","</table>"],Er.g=Er.defs=Er.symbol=Er.use=Er.image=Er.text=Er.circle=Er.ellipse=Er.line=Er.path=Er.polygon=Er.polyline=Er.rect=[1,'<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ev="http://www.w3.org/2001/xml-events"version="1.1">',"</svg>"];var Nr=/<([\w:-]+)/,jr=/&#?\w+?;/,Sr=function(){if(Ui){var t=document.createElement("div");return t.innerHTML="<template>1</template>",!t.cloneNode(!0).firstChild.innerHTML}return!1}(),Dr=function(){if(Ui){var t=document.createElement("textarea");return t.placeholder="t","t"===t.cloneNode(!0).value}return!1}(),Fr=Object.freeze({cloneNode:Gt,parseTemplate:Kt}),Rr={bind:function(){8===this.el.nodeType&&(this.nodes=[],this.anchor=rt("v-html"),Y(this.el,this.anchor))},update:function(t){t=o(t),this.nodes?this.swap(t):this.el.innerHTML=t},swap:function(t){for(var e=this.nodes.length;e--;)B(this.nodes[e]);var i=Kt(t,!0,!0);this.nodes=v(i.childNodes),M(i,this.anchor)}};Qt.prototype.callHook=function(t){var e,i;for(e=0,i=this.childFrags.length;i>e;e++)this.childFrags[e].callHook(t);for(e=0,i=this.children.length;i>e;e++)t(this.children[e])},Qt.prototype.beforeRemove=function(){var t,e;for(t=0,e=this.childFrags.length;e>t;t++)this.childFrags[t].beforeRemove(!1);for(t=0,e=this.children.length;e>t;t++)this.children[t].$destroy(!1,!0);var i=this.unlink.dirs;for(t=0,e=i.length;e>t;t++)i[t]._watcher&&i[t]._watcher.teardown()},Qt.prototype.destroy=function(){this.parentFrag&&this.parentFrag.childFrags.$remove(this),this.node.__v_frag=null,this.unlink()};var Pr=new k(5e3);se.prototype.create=function(t,e,i){var n=Gt(this.template);return new Qt(this.linker,this.vm,n,t,e,i)};var Lr=700,Ur=800,Ir=850,Hr=1100,zr=1500,Wr=1500,Mr=1750,Vr=2100,Br=2200,qr=2300,Yr=0,Zr={priority:Br,terminal:!0,params:["track-by","stagger","enter-stagger","leave-stagger"],bind:function(){var t=this.expression.match(/(.*) (?:in|of) (.*)/);if(t){var e=t[1].match(/\((.*),(.*)\)/);e?(this.iterator=e[1].trim(),this.alias=e[2].trim()):this.alias=t[1].trim(),this.expression=t[2]}if(!this.alias)return void An('Invalid v-for expression "'+this.descriptor.raw+'": alias is required.',this.vm);this.id="__v-for__"+ ++Yr;var i=this.el.tagName;this.isOption=("OPTION"===i||"OPTGROUP"===i)&&"SELECT"===this.el.parentNode.tagName,this.start=rt("v-for-start"),this.end=rt("v-for-end"),Y(this.el,this.end),M(this.start,this.end),this.cache=Object.create(null),this.factory=new se(this.vm,this.el)},update:function(t){this.diff(t),this.updateRef(),this.updateModel()},diff:function(t){var e,i,r,s,o,a,l=t[0],h=this.fromObject=g(l)&&n(l,"$key")&&n(l,"$value"),u=this.params.trackBy,c=this.frags,f=this.frags=new Array(t.length),p=this.alias,d=this.iterator,v=this.start,m=this.end,y=I(v),b=!c;for(e=0,i=t.length;i>e;e++)l=t[e],s=h?l.$key:null,o=h?l.$value:l,a=!g(o),r=!b&&this.getCachedFrag(o,e,s),r?(r.reused=!0,r.scope.$index=e,s&&(r.scope.$key=s),d&&(r.scope[d]=null!==s?s:e),(u||h||a)&&_t(function(){r.scope[p]=o})):(r=this.create(o,p,e,s),r.fresh=!b),f[e]=r,b&&r.before(m);if(!b){var _=0,w=c.length-f.length;for(this.vm._vForRemoving=!0,e=0,i=c.length;i>e;e++)r=c[e],r.reused||(this.deleteCachedFrag(r),this.remove(r,_++,w,y));this.vm._vForRemoving=!1,_&&(this.vm._watchers=this.vm._watchers.filter(function(t){return t.active}));var C,$,k,x=0;for(e=0,i=f.length;i>e;e++)r=f[e],C=f[e-1],$=C?C.staggerCb?C.staggerAnchor:C.end||C.node:v,r.reused&&!r.staggerCb?(k=oe(r,v,this.id),k===C||k&&oe(k,v,this.id)===C||this.move(r,$)):this.insert(r,x++,$,y),r.reused=r.fresh=!1}},create:function(t,e,i,n){var r=this._host,s=this._scope||this.vm,o=Object.create(s);o.$refs=Object.create(s.$refs),o.$els=Object.create(s.$els),o.$parent=s,o.$forContext=this,_t(function(){xt(o,e,t)}),xt(o,"$index",i),n?xt(o,"$key",n):o.$key&&b(o,"$key",null),this.iterator&&xt(o,this.iterator,null!==n?n:i);var a=this.factory.create(r,o,this._frag);return a.forId=this.id,this.cacheFrag(t,a,i,n),a},updateRef:function(){var t=this.descriptor.ref;if(t){var e,i=(this._scope||this.vm).$refs;this.fromObject?(e={},this.frags.forEach(function(t){e[t.scope.$key]=ae(t)})):e=this.frags.map(ae),i[t]=e}},updateModel:function(){if(this.isOption){var t=this.start.parentNode,e=t&&t.__v_model;e&&e.forceUpdate()}},insert:function(t,e,i,n){t.staggerCb&&(t.staggerCb.cancel(),t.staggerCb=null);var r=this.getStagger(t,e,null,"enter");if(n&&r){var s=t.staggerAnchor;s||(s=t.staggerAnchor=rt("stagger-anchor"),s.__v_frag=t),V(s,i);var o=t.staggerCb=C(function(){t.staggerCb=null,t.before(s),B(s)});setTimeout(o,r)}else{var a=i.nextSibling;a||(V(this.end,i),a=this.end),t.before(a)}},remove:function(t,e,i,n){if(t.staggerCb)return t.staggerCb.cancel(),void(t.staggerCb=null);var r=this.getStagger(t,e,i,"leave");if(n&&r){var s=t.staggerCb=C(function(){t.staggerCb=null,t.remove()});setTimeout(s,r)}else t.remove()},move:function(t,e){e.nextSibling||this.end.parentNode.appendChild(this.end),t.before(e.nextSibling,!1)},cacheFrag:function(t,e,i,r){var s,o=this.params.trackBy,a=this.cache,l=!g(t);r||o||l?(s=he(i,r,t,o),a[s]?"$index"!==o&&this.warnDuplicate(t):a[s]=e):(s=this.id,n(t,s)?null===t[s]?t[s]=e:this.warnDuplicate(t):Object.isExtensible(t)?b(t,s,e):An("Frozen v-for objects cannot be automatically tracked, make sure to provide a track-by key.")),e.raw=t},getCachedFrag:function(t,e,i){var n,r=this.params.trackBy,s=!g(t);if(i||r||s){var o=he(e,i,t,r);n=this.cache[o]}else n=t[this.id];return n&&(n.reused||n.fresh)&&this.warnDuplicate(t),n},deleteCachedFrag:function(t){var e=t.raw,i=this.params.trackBy,r=t.scope,s=r.$index,o=n(r,"$key")&&r.$key,a=!g(e);if(i||o||a){var l=he(s,o,e,i);this.cache[l]=null}else e[this.id]=null,t.raw=null},getStagger:function(t,e,i,n){n+="Stagger";var r=t.node.__v_trans,s=r&&r.hooks,o=s&&(s[n]||s.stagger);return o?o.call(t,e,i):e*parseInt(this.params[n]||this.params.stagger,10)},_preProcess:function(t){return this.rawValue=t,t},_postProcess:function(t){if(Pi(t))return t;if(y(t)){for(var e,i=Object.keys(t),n=i.length,r=new Array(n);n--;)e=i[n],r[n]={$key:e,$value:t[e]};return r}return"number"!=typeof t||isNaN(t)||(t=le(t)),t||[]},unbind:function(){if(this.descriptor.ref&&((this._scope||this.vm).$refs[this.descriptor.ref]=null),this.frags)for(var t,e=this.frags.length;e--;)t=this.frags[e],this.deleteCachedFrag(t),t.destroy()}};Zr.warnDuplicate=function(t){An('Duplicate value found in v-for="'+this.descriptor.raw+'": '+JSON.stringify(t)+'. Use track-by="$index" if you are expecting duplicate values.',this.vm)};var Jr={priority:Vr,terminal:!0,bind:function(){var t=this.el;if(t.__vue__)An('v-if="'+this.expression+'" cannot be used on an instance root element.',this.vm),this.invalid=!0;else{var e=t.nextElementSibling;e&&null!==H(e,"v-else")&&(B(e),this.elseEl=e),this.anchor=rt("v-if"),Y(t,this.anchor)}},update:function(t){this.invalid||(t?this.frag||this.insert():this.remove())},insert:function(){this.elseFrag&&(this.elseFrag.remove(),this.elseFrag=null),this.factory||(this.factory=new se(this.vm,this.el)),this.frag=this.factory.create(this._host,this._scope,this._frag),this.frag.before(this.anchor)},remove:function(){this.frag&&(this.frag.remove(),this.frag=null),this.elseEl&&!this.elseFrag&&(this.elseFactory||(this.elseFactory=new se(this.elseEl._context||this.vm,this.elseEl)),this.elseFrag=this.elseFactory.create(this._host,this._scope,this._frag),this.elseFrag.before(this.anchor))},unbind:function(){this.frag&&this.frag.destroy(),this.elseFrag&&this.elseFrag.destroy()}},Gr={bind:function(){var t=this.el.nextElementSibling;t&&null!==H(t,"v-else")&&(this.elseEl=t)},update:function(t){this.apply(this.el,t),this.elseEl&&this.apply(this.elseEl,!t)},apply:function(t,e){function i(){t.style.display=e?"":"none";
+}I(t)?L(t,e?1:-1,i,this.vm):i()}},Kr={bind:function(){var t=this,e=this.el,i="range"===e.type,n=this.params.lazy,r=this.params.number,s=this.params.debounce,o=!1;if(Wi||i||(this.on("compositionstart",function(){o=!0}),this.on("compositionend",function(){o=!1,n||t.listener()})),this.focused=!1,i||n||(this.on("focus",function(){t.focused=!0}),this.on("blur",function(){t.focused=!1,t._frag&&!t._frag.inserted||t.rawListener()})),this.listener=this.rawListener=function(){if(!o&&t._bound){var n=r||i?a(e.value):e.value;t.set(n),Ki(function(){t._bound&&!t.focused&&t.update(t._watcher.value)})}},s&&(this.listener=_(this.listener,s)),this.hasjQuery="function"==typeof jQuery,this.hasjQuery){var l=jQuery.fn.on?"on":"bind";jQuery(e)[l]("change",this.rawListener),n||jQuery(e)[l]("input",this.listener)}else this.on("change",this.rawListener),n||this.on("input",this.listener);!n&&zi&&(this.on("cut",function(){Ki(t.listener)}),this.on("keyup",function(e){46!==e.keyCode&&8!==e.keyCode||t.listener()})),(e.hasAttribute("value")||"TEXTAREA"===e.tagName&&e.value.trim())&&(this.afterBind=this.listener)},update:function(t){this.el.value=o(t)},unbind:function(){var t=this.el;if(this.hasjQuery){var e=jQuery.fn.off?"off":"unbind";jQuery(t)[e]("change",this.listener),jQuery(t)[e]("input",this.listener)}}},Qr={bind:function(){var t=this,e=this.el;this.getValue=function(){if(e.hasOwnProperty("_value"))return e._value;var i=e.value;return t.params.number&&(i=a(i)),i},this.listener=function(){t.set(t.getValue())},this.on("change",this.listener),e.hasAttribute("checked")&&(this.afterBind=this.listener)},update:function(t){this.el.checked=$(t,this.getValue())}},Xr={bind:function(){var t=this,e=this.el;this.forceUpdate=function(){t._watcher&&t.update(t._watcher.get())};var i=this.multiple=e.hasAttribute("multiple");this.listener=function(){var n=ue(e,i);n=t.params.number?Pi(n)?n.map(a):a(n):n,t.set(n)},this.on("change",this.listener);var n=ue(e,i,!0);(i&&n.length||!i&&null!==n)&&(this.afterBind=this.listener),this.vm.$on("hook:attached",this.forceUpdate)},update:function(t){var e=this.el;e.selectedIndex=-1;for(var i,n,r=this.multiple&&Pi(t),s=e.options,o=s.length;o--;)i=s[o],n=i.hasOwnProperty("_value")?i._value:i.value,i.selected=r?ce(t,n)>-1:$(t,n)},unbind:function(){this.vm.$off("hook:attached",this.forceUpdate)}},ts={bind:function(){function t(){var t=i.checked;return t&&i.hasOwnProperty("_trueValue")?i._trueValue:!t&&i.hasOwnProperty("_falseValue")?i._falseValue:t}var e=this,i=this.el;this.getValue=function(){return i.hasOwnProperty("_value")?i._value:e.params.number?a(i.value):i.value},this.listener=function(){var n=e._watcher.value;if(Pi(n)){var r=e.getValue();i.checked?w(n,r)<0&&n.push(r):n.$remove(r)}else e.set(t())},this.on("change",this.listener),i.hasAttribute("checked")&&(this.afterBind=this.listener)},update:function(t){var e=this.el;Pi(t)?e.checked=w(t,this.getValue())>-1:e.hasOwnProperty("_trueValue")?e.checked=$(t,e._trueValue):e.checked=!!t}},es={text:Kr,radio:Qr,select:Xr,checkbox:ts},is={priority:Ur,twoWay:!0,handlers:es,params:["lazy","number","debounce"],bind:function(){this.checkFilters(),this.hasRead&&!this.hasWrite&&An('It seems you are using a read-only filter with v-model="'+this.descriptor.raw+'". You might want to use a two-way filter to ensure correct behavior.',this.vm);var t,e=this.el,i=e.tagName;if("INPUT"===i)t=es[e.type]||es.text;else if("SELECT"===i)t=es.select;else{if("TEXTAREA"!==i)return void An("v-model does not support element type: "+i,this.vm);t=es.text}e.__v_model=this,t.bind.call(this),this.update=t.update,this._unbind=t.unbind},checkFilters:function(){var t=this.filters;if(t)for(var e=t.length;e--;){var i=yt(this.vm.$options,"filters",t[e].name);("function"==typeof i||i.read)&&(this.hasRead=!0),i.write&&(this.hasWrite=!0)}},unbind:function(){this.el.__v_model=null,this._unbind&&this._unbind()}},ns={esc:27,tab:9,enter:13,space:32,"delete":[8,46],up:38,left:37,right:39,down:40},rs={priority:Lr,acceptStatement:!0,keyCodes:ns,bind:function(){if("IFRAME"===this.el.tagName&&"load"!==this.arg){var t=this;this.iframeBind=function(){Z(t.el.contentWindow,t.arg,t.handler,t.modifiers.capture)},this.on("load",this.iframeBind)}},update:function(t){if(this.descriptor.raw||(t=function(){}),"function"!=typeof t)return void An("v-on:"+this.arg+'="'+this.expression+'" expects a function value, got '+t,this.vm);this.modifiers.stop&&(t=pe(t)),this.modifiers.prevent&&(t=de(t)),this.modifiers.self&&(t=ve(t));var e=Object.keys(this.modifiers).filter(function(t){return"stop"!==t&&"prevent"!==t&&"self"!==t&&"capture"!==t});e.length&&(t=fe(t,e)),this.reset(),this.handler=t,this.iframeBind?this.iframeBind():Z(this.el,this.arg,this.handler,this.modifiers.capture)},reset:function(){var t=this.iframeBind?this.el.contentWindow:this.el;this.handler&&J(t,this.arg,this.handler)},unbind:function(){this.reset()}},ss=["-webkit-","-moz-","-ms-"],os=["Webkit","Moz","ms"],as=/!important;?$/,ls=Object.create(null),hs=null,us={deep:!0,update:function(t){"string"==typeof t?this.el.style.cssText=t:Pi(t)?this.handleObject(t.reduce(m,{})):this.handleObject(t||{})},handleObject:function(t){var e,i,n=this.cache||(this.cache={});for(e in n)e in t||(this.handleSingle(e,null),delete n[e]);for(e in t)i=t[e],i!==n[e]&&(n[e]=i,this.handleSingle(e,i))},handleSingle:function(t,e){if(t=me(t))if(null!=e&&(e+=""),e){var i=as.test(e)?"important":"";i?(An("It's probably a bad idea to use !important with inline rules. This feature will be deprecated in a future version of Vue."),e=e.replace(as,"").trim(),this.el.style.setProperty(t.kebab,e,i)):this.el.style[t.camel]=e}else this.el.style[t.camel]=""}},cs="http://www.w3.org/1999/xlink",fs=/^xlink:/,ps=/^v-|^:|^@|^(?:is|transition|transition-mode|debounce|track-by|stagger|enter-stagger|leave-stagger)$/,ds=/^(?:value|checked|selected|muted)$/,vs=/^(?:draggable|contenteditable|spellcheck)$/,ms={value:"_value","true-value":"_trueValue","false-value":"_falseValue"},gs={priority:Ir,bind:function(){var t=this.arg,e=this.el.tagName;t||(this.deep=!0);var i=this.descriptor,n=i.interp;if(n){i.hasOneTime&&(this.expression=j(n,this._scope||this.vm)),(ps.test(t)||"name"===t&&("PARTIAL"===e||"SLOT"===e))&&(An(t+'="'+i.raw+'": attribute interpolation is not allowed in Vue.js directives and special attributes.',this.vm),this.el.removeAttribute(t),this.invalid=!0);var r=t+'="'+i.raw+'": ';"src"===t&&An(r+'interpolation in "src" attribute will cause a 404 request. Use v-bind:src instead.',this.vm),"style"===t&&An(r+'interpolation in "style" attribute will cause the attribute to be discarded in Internet Explorer. Use v-bind:style instead.',this.vm)}},update:function(t){if(!this.invalid){var e=this.arg;this.arg?this.handleSingle(e,t):this.handleObject(t||{})}},handleObject:us.handleObject,handleSingle:function(t,e){var i=this.el,n=this.descriptor.interp;if(this.modifiers.camel&&(t=u(t)),!n&&ds.test(t)&&t in i){var r="value"===t&&null==e?"":e;i[t]!==r&&(i[t]=r)}var s=ms[t];if(!n&&s){i[s]=e;var o=i.__v_model;o&&o.listener()}return"value"===t&&"TEXTAREA"===i.tagName?void i.removeAttribute(t):void(vs.test(t)?i.setAttribute(t,e?"true":"false"):null!=e&&e!==!1?"class"===t?(i.__v_trans&&(e+=" "+i.__v_trans.id+"-transition"),K(i,e)):fs.test(t)?i.setAttributeNS(cs,t,e===!0?"":e):i.setAttribute(t,e===!0?"":e):i.removeAttribute(t))}},ys={priority:zr,bind:function(){if(this.arg){var t=this.id=u(this.arg),e=(this._scope||this.vm).$els;n(e,t)?e[t]=this.el:xt(e,t,this.el)}},unbind:function(){var t=(this._scope||this.vm).$els;t[this.id]===this.el&&(t[this.id]=null)}},bs={bind:function(){An("v-ref:"+this.arg+" must be used on a child component. Found on <"+this.el.tagName.toLowerCase()+">.",this.vm)}},_s={bind:function(){var t=this.el;this.vm.$once("pre-hook:compiled",function(){t.removeAttribute("v-cloak")})}},ws={text:Ar,html:Rr,"for":Zr,"if":Jr,show:Gr,model:is,on:rs,bind:gs,el:ys,ref:bs,cloak:_s},Cs={deep:!0,update:function(t){t?"string"==typeof t?this.setClass(t.trim().split(/\s+/)):this.setClass(ye(t)):this.cleanup()},setClass:function(t){this.cleanup(t);for(var e=0,i=t.length;i>e;e++){var n=t[e];n&&be(this.el,n,Q)}this.prevKeys=t},cleanup:function(t){var e=this.prevKeys;if(e)for(var i=e.length;i--;){var n=e[i];(!t||t.indexOf(n)<0)&&be(this.el,n,X)}}},$s={priority:Wr,params:["keep-alive","transition-mode","inline-template"],bind:function(){this.el.__vue__?An('cannot mount component "'+this.expression+'" on already mounted element: '+this.el):(this.keepAlive=this.params.keepAlive,this.keepAlive&&(this.cache={}),this.params.inlineTemplate&&(this.inlineTemplate=tt(this.el,!0)),this.pendingComponentCb=this.Component=null,this.pendingRemovals=0,this.pendingRemovalCb=null,this.anchor=rt("v-component"),Y(this.el,this.anchor),this.el.removeAttribute("is"),this.el.removeAttribute(":is"),this.descriptor.ref&&this.el.removeAttribute("v-ref:"+f(this.descriptor.ref)),this.literal&&this.setComponent(this.expression))},update:function(t){this.literal||this.setComponent(t)},setComponent:function(t,e){if(this.invalidatePending(),t){var i=this;this.resolveComponent(t,function(){i.mountComponent(e)})}else this.unbuild(!0),this.remove(this.childVM,e),this.childVM=null},resolveComponent:function(t,e){var i=this;this.pendingComponentCb=C(function(n){i.ComponentName=n.options.name||("string"==typeof t?t:null),i.Component=n,e()}),this.vm._resolveComponent(t,this.pendingComponentCb)},mountComponent:function(t){this.unbuild(!0);var e=this,i=this.Component.options.activate,n=this.getCached(),r=this.build();i&&!n?(this.waitingFor=r,_e(i,r,function(){e.waitingFor===r&&(e.waitingFor=null,e.transition(r,t))})):(n&&r._updateRef(),this.transition(r,t))},invalidatePending:function(){this.pendingComponentCb&&(this.pendingComponentCb.cancel(),this.pendingComponentCb=null)},build:function(t){var e=this.getCached();if(e)return e;if(this.Component){var i={name:this.ComponentName,el:Gt(this.el),template:this.inlineTemplate,parent:this._host||this.vm,_linkerCachable:!this.inlineTemplate,_ref:this.descriptor.ref,_asComponent:!0,_isRouterView:this._isRouterView,_context:this.vm,_scope:this._scope,_frag:this._frag};t&&m(i,t);var n=new this.Component(i);return this.keepAlive&&(this.cache[this.Component.cid]=n),this.el.hasAttribute("transition")&&n._isFragment&&An("Transitions will not work on a fragment instance. Template: "+n.$options.template,n),n}},getCached:function(){return this.keepAlive&&this.cache[this.Component.cid]},unbuild:function(t){this.waitingFor&&(this.keepAlive||this.waitingFor.$destroy(),this.waitingFor=null);var e=this.childVM;return!e||this.keepAlive?void(e&&(e._inactive=!0,e._updateRef(!0))):void e.$destroy(!1,t)},remove:function(t,e){var i=this.keepAlive;if(t){this.pendingRemovals++,this.pendingRemovalCb=e;var n=this;t.$remove(function(){n.pendingRemovals--,i||t._cleanup(),!n.pendingRemovals&&n.pendingRemovalCb&&(n.pendingRemovalCb(),n.pendingRemovalCb=null)})}else e&&e()},transition:function(t,e){var i=this,n=this.childVM;switch(n&&(n._inactive=!0),t._inactive=!1,this.childVM=t,i.params.transitionMode){case"in-out":t.$before(i.anchor,function(){i.remove(n,e)});break;case"out-in":i.remove(n,function(){t.$before(i.anchor,e)});break;default:i.remove(n),t.$before(i.anchor,e)}},unbind:function(){if(this.invalidatePending(),this.unbuild(),this.cache){for(var t in this.cache)this.cache[t].$destroy();this.cache=null}}},ks=xn._propBindingModes,xs={},As=/^[$_a-zA-Z]+[\w$]*$/,Os=/^[A-Za-z_$][\w$]*(\.[A-Za-z_$][\w$]*|\[[^\[\]]+\])*$/,Ts=xn._propBindingModes,Es={bind:function(){var t=this.vm,e=t._context,i=this.descriptor.prop,n=i.path,r=i.parentPath,s=i.mode===Ts.TWO_WAY,o=this.parentWatcher=new Bt(e,r,function(e){xe(t,i,e)},{twoWay:s,filters:i.filters,scope:this._scope});if(ke(t,i,o.value),s){var a=this;t.$once("pre-hook:created",function(){a.childWatcher=new Bt(t,n,function(t){o.set(t)},{sync:!0})})}},unbind:function(){this.parentWatcher.teardown(),this.childWatcher&&this.childWatcher.teardown()}},Ns=[],js=!1,Ss="transition",Ds="animation",Fs=Bi+"Duration",Rs=Yi+"Duration",Ps=Ui&&window.requestAnimationFrame,Ls=Ps?function(t){Ps(function(){Ps(t)})}:function(t){setTimeout(t,50)},Us=Fe.prototype;Us.enter=function(t,e){this.cancelPending(),this.callHook("beforeEnter"),this.cb=e,Q(this.el,this.enterClass),t(),this.entered=!1,this.callHookWithCb("enter"),this.entered||(this.cancel=this.hooks&&this.hooks.enterCancelled,Se(this.enterNextTick))},Us.enterNextTick=function(){var t=this;this.justEntered=!0,Ls(function(){t.justEntered=!1});var e=this.enterDone,i=this.getCssTransitionType(this.enterClass);this.pendingJsCb?i===Ss&&X(this.el,this.enterClass):i===Ss?(X(this.el,this.enterClass),this.setupCssCb(qi,e)):i===Ds?this.setupCssCb(Zi,e):e()},Us.enterDone=function(){this.entered=!0,this.cancel=this.pendingJsCb=null,X(this.el,this.enterClass),this.callHook("afterEnter"),this.cb&&this.cb()},Us.leave=function(t,e){this.cancelPending(),this.callHook("beforeLeave"),this.op=t,this.cb=e,Q(this.el,this.leaveClass),this.left=!1,this.callHookWithCb("leave"),this.left||(this.cancel=this.hooks&&this.hooks.leaveCancelled,this.op&&!this.pendingJsCb&&(this.justEntered?this.leaveDone():Se(this.leaveNextTick)))},Us.leaveNextTick=function(){var t=this.getCssTransitionType(this.leaveClass);if(t){var e=t===Ss?qi:Zi;this.setupCssCb(e,this.leaveDone)}else this.leaveDone()},Us.leaveDone=function(){this.left=!0,this.cancel=this.pendingJsCb=null,this.op(),X(this.el,this.leaveClass),this.callHook("afterLeave"),this.cb&&this.cb(),this.op=null},Us.cancelPending=function(){this.op=this.cb=null;var t=!1;this.pendingCssCb&&(t=!0,J(this.el,this.pendingCssEvent,this.pendingCssCb),this.pendingCssEvent=this.pendingCssCb=null),this.pendingJsCb&&(t=!0,this.pendingJsCb.cancel(),this.pendingJsCb=null),t&&(X(this.el,this.enterClass),X(this.el,this.leaveClass)),this.cancel&&(this.cancel.call(this.vm,this.el),this.cancel=null)},Us.callHook=function(t){this.hooks&&this.hooks[t]&&this.hooks[t].call(this.vm,this.el)},Us.callHookWithCb=function(t){var e=this.hooks&&this.hooks[t];e&&(e.length>1&&(this.pendingJsCb=C(this[t+"Done"])),e.call(this.vm,this.el,this.pendingJsCb))},Us.getCssTransitionType=function(t){if(!(!qi||document.hidden||this.hooks&&this.hooks.css===!1||Re(this.el))){var e=this.type||this.typeCache[t];if(e)return e;var i=this.el.style,n=window.getComputedStyle(this.el),r=i[Fs]||n[Fs];if(r&&"0s"!==r)e=Ss;else{var s=i[Rs]||n[Rs];s&&"0s"!==s&&(e=Ds)}return e&&(this.typeCache[t]=e),e}},Us.setupCssCb=function(t,e){this.pendingCssEvent=t;var i=this,n=this.el,r=this.pendingCssCb=function(s){s.target===n&&(J(n,t,r),i.pendingCssEvent=i.pendingCssCb=null,!i.pendingJsCb&&e&&e())};Z(n,t,r)};var Is={priority:Hr,update:function(t,e){var i=this.el,n=yt(this.vm.$options,"transitions",t);t=t||"v",i.__v_trans=new Fe(i,t,n,this.vm),e&&X(i,e+"-transition"),Q(i,t+"-transition")}},Hs={style:us,"class":Cs,component:$s,prop:Es,transition:Is},zs=/^v-bind:|^:/,Ws=/^v-on:|^@/,Ms=/^v-([^:]+)(?:$|:(.*)$)/,Vs=/\.[^\.]+/g,Bs=/^(v-bind:|:)?transition$/,qs=1e3,Ys=2e3;ti.terminal=!0;var Zs=/[^\w\-:\.]/,Js=Object.freeze({compile:Pe,compileAndLinkProps:ze,compileRoot:We,transclude:ai,resolveSlots:ci}),Gs=/^v-on:|^@/;mi.prototype._bind=function(){var t=this.name,e=this.descriptor;if(("cloak"!==t||this.vm._isCompiled)&&this.el&&this.el.removeAttribute){var i=e.attr||"v-"+t;this.el.removeAttribute(i)}var n=e.def;if("function"==typeof n?this.update=n:m(this,n),this._setupParams(),this.bind&&this.bind(),this._bound=!0,this.literal)this.update&&this.update(e.raw);else if((this.expression||this.modifiers)&&(this.update||this.twoWay)&&!this._checkStatement()){var r=this;this.update?this._update=function(t,e){r._locked||r.update(t,e)}:this._update=vi;var s=this._preProcess?d(this._preProcess,this):null,o=this._postProcess?d(this._postProcess,this):null,a=this._watcher=new Bt(this.vm,this.expression,this._update,{filters:this.filters,twoWay:this.twoWay,deep:this.deep,preProcess:s,postProcess:o,scope:this._scope});this.afterBind?this.afterBind():this.update&&this.update(a.value)}},mi.prototype._setupParams=function(){if(this.params){var t=this.params;this.params=Object.create(null);for(var e,i,n,r=t.length;r--;)e=f(t[r]),n=u(e),i=z(this.el,e),null!=i?this._setupParamWatcher(n,i):(i=H(this.el,e),null!=i&&(this.params[n]=""===i?!0:i))}},mi.prototype._setupParamWatcher=function(t,e){var i=this,n=!1,r=(this._scope||this.vm).$watch(e,function(e,r){if(i.params[t]=e,n){var s=i.paramWatchers&&i.paramWatchers[t];s&&s.call(i,e,r)}else n=!0},{immediate:!0,user:!1});(this._paramUnwatchFns||(this._paramUnwatchFns=[])).push(r)},mi.prototype._checkStatement=function(){var t=this.expression;if(t&&this.acceptStatement&&!Ht(t)){var e=It(t).get,i=this._scope||this.vm,n=function(t){i.$event=t,e.call(i,i),i.$event=null};return this.filters&&(n=i._applyFilters(n,null,this.filters)),this.update(n),!0}},mi.prototype.set=function(t){this.twoWay?this._withLock(function(){this._watcher.set(t)}):An("Directive.set() can only be used inside twoWaydirectives.")},mi.prototype._withLock=function(t){var e=this;e._locked=!0,t.call(e),Ki(function(){e._locked=!1})},mi.prototype.on=function(t,e,i){Z(this.el,t,e,i),(this._listeners||(this._listeners=[])).push([t,e])},mi.prototype._teardown=function(){if(this._bound){this._bound=!1,this.unbind&&this.unbind(),this._watcher&&this._watcher.teardown();var t,e=this._listeners;if(e)for(t=e.length;t--;)J(this.el,e[t][0],e[t][1]);var i=this._paramUnwatchFns;if(i)for(t=i.length;t--;)i[t]();this.el&&this.el._vue_directives.$remove(this),this.vm=this.el=this._watcher=this._listeners=null}};var Ks=/[^|]\|[^|]/;At($i),pi($i),di($i),gi($i),yi($i),bi($i),_i($i),wi($i),Ci($i);var Qs={priority:qr,params:["name"],bind:function(){var t=this.params.name||"default",e=this.vm._slotContents&&this.vm._slotContents[t];e&&e.hasChildNodes()?this.compile(e.cloneNode(!0),this.vm._context,this.vm):this.fallback()},compile:function(t,e,i){if(t&&e){if(this.el.hasChildNodes()&&1===t.childNodes.length&&1===t.childNodes[0].nodeType&&t.childNodes[0].hasAttribute("v-if")){var n=document.createElement("template");n.setAttribute("v-else",""),n.innerHTML=this.el.innerHTML,n._context=this.vm,t.appendChild(n)}var r=i?i._scope:this._scope;this.unlink=e.$compile(t,i,r,this._frag)}t?Y(this.el,t):B(this.el)},fallback:function(){this.compile(tt(this.el,!0),this.vm)},unbind:function(){this.unlink&&this.unlink()}},Xs={priority:Mr,params:["name"],paramWatchers:{name:function(t){Jr.remove.call(this),t&&this.insert(t)}},bind:function(){this.anchor=rt("v-partial"),Y(this.el,this.anchor),this.insert(this.params.name)},insert:function(t){var e=yt(this.vm.$options,"partials",t,!0);e&&(this.factory=new se(this.vm,e),Jr.insert.call(this))},unbind:function(){this.frag&&this.frag.destroy()}},to={slot:Qs,partial:Xs},eo=Zr._postProcess,io=/(\d{3})(?=\d)/g,no={orderBy:Ai,filterBy:xi,limitBy:ki,json:{read:function(t,e){return"string"==typeof t?t:JSON.stringify(t,null,Number(e)||2)},write:function(t){try{return JSON.parse(t)}catch(e){return t}}},capitalize:function(t){return t||0===t?(t=t.toString(),t.charAt(0).toUpperCase()+t.slice(1)):""},uppercase:function(t){return t||0===t?t.toString().toUpperCase():""},lowercase:function(t){return t||0===t?t.toString().toLowerCase():""},currency:function(t,e,i){if(t=parseFloat(t),!isFinite(t)||!t&&0!==t)return"";e=null!=e?e:"$",i=null!=i?i:2;var n=Math.abs(t).toFixed(i),r=i?n.slice(0,-1-i):n,s=r.length%3,o=s>0?r.slice(0,s)+(r.length>3?",":""):"",a=i?n.slice(-1-i):"",l=0>t?"-":"";return l+e+o+r.slice(s).replace(io,"$1,")+a},pluralize:function(t){var e=v(arguments,1);return e.length>1?e[t%10-1]||e[e.length-1]:e[0]+(1===t?"":"s")},debounce:function(t,e){return t?(e||(e=300),_(t,e)):void 0}};return Ti($i),$i.version="1.0.24",setTimeout(function(){xn.devtools&&(Ii?Ii.emit("init",$i):Ui&&/Chrome\/\d+/.test(window.navigator.userAgent)&&console.log("Download the Vue Devtools for a better development experience:\nhttps://github.com/vuejs/vue-devtools"))},0),$i})}).call(e,function(){return this}())},function(t,e,i){var n,r;n=i(4),r=i(7),t.exports=n||{},t.exports.__esModule&&(t.exports=t.exports["default"]),r&&(("function"==typeof t.exports?t.exports.options||(t.exports.options={}):t.exports).template=r)},function(t,e,i){"use strict";t.exports={components:{"vue-select":i(5)},data:function(){return{options1:["value1","value2","value3"],options2:[{text:"name1",value:"value1"},{text:"name2",value:"value2"},{text:"name3",value:"value3"}],options3:[{label:"group1",options:[{text:"name1",value:"value1"},{text:"name2",value:"value2"},{text:"name3",value:"value3"}]},{label:"group2",options:[{text:"name4",value:"value4"},{text:"name5",value:"value5"},{text:"name6",value:"value6"}]}]}},props:{result1:{required:!0,twoWay:!0},result2:{required:!0,twoWay:!0},result3:{required:!0,twoWay:!0}}}},function(t,e,i){var n="en-US";t.exports={replace:!0,inherit:!1,template:"<select class='form-control' v-model='model' style='width: 100%'><option v-if='optionsType === \"values\"' v-for='val in options' :value='val'>{{val}}</option><option v-if='optionsType === \"options\"' v-for='opt in options' :value='opt.value'>{{opt.text}}</option><optgroup v-if='optionsType === \"groups\"' v-for='group in options' :label='group.label'><option v-for='opt in group.options' :value='opt.value'>{{opt.text}}</option></optgroup></select>",props:{options:{type:Array,required:!0},model:{required:!0,twoWay:!0},searchable:{type:Boolean,required:!1,"default":!1},matchValue:{type:Boolean,required:!1,"default":!0},language:{type:String,required:!1,"default":""},theme:{type:String,required:!1,"default":"bootstrap"}},data:function(){return{optionsType:"unknown"}},beforeCompile:function(){this.isChanging=!1,this.control=null,this.optionsType=this.getOptionsType()},watch:{options:function(t,e){this.optionsType=this.getOptionsType();var i=this.inOptions(this.model),n=i?this.model:null;this.control.removeData("data"),this.control.val(n).trigger("change")},model:function(t,e){this.isChanging||(this.isChanging=!0,this.control.val(t).trigger("change"),this.isChanging=!1)}},ready:function(){var t=this.language;null!==t&&""!==t||(t=this.$language?this.$language:n);var e={theme:this.theme,language:this.getLanguageCode(t)};this.searchable?this.matchValue&&(e.matcher=i(6)):e.minimumResultsForSearch=1/0,this.control=$(this.$el),this.control.select2(e);var r=this;this.control.on("change",function(t){r.isChanging||(r.isChanging=!0,r.model=r.control.val(),r.$nextTick(function(){r.isChanging=!1}))})},methods:{getOptionsType:function(){if(0===this.options.length)return"values";var t=this.options[0];return"string"==typeof t||t instanceof String?"values":"undefined"!=typeof t.text?"options":"undefined"!=typeof t.label?"groups":"unknown"},inOptions:function(t){var e,i,n=this.getOptionsType(),r=this.options;switch(n){case"values":for(e=0;e<r.length;++e)if(t===r[e])return!0;break;case"options":for(e=0;e<r.length;++e)if(t===r[e].value)return!0;break;case"groups":for(e=0;e<r.length;++e){var s=r[e].options;for(i=0;i<s.length;++i)if(t===s[i].value)return!0}}return!1},getLanguageCode:function(t){if(null===t||0===t.length)return"en";if(t.length<=2)return t;switch(t){case"pt-BR":case"zh-CN":case"zh-TW":return t;default:return t.substr(0,2)}}}}},function(t,e){function i(t){function e(t){return n[t]||t}return t.replace(/[^\u0000-\u007E]/g,e)}var n={"":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"AA","":"AE","":"AE","":"AE","":"AO","":"AU","":"AV","":"AV","":"AY","":"B","":"B","":"B","":"B","":"B","":"B","":"B","":"B","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"DZ","":"DZ","":"Dz","":"Dz","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"F","":"F","":"F","":"F","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"J","":"J","":"J","":"J","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"LJ","":"Lj","":"M","":"M","":"M","":"M","":"M","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"NJ","":"Nj","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"OI","":"OO","":"OU","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"Q","":"Q","":"Q","":"Q","":"Q","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"TZ","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"V","":"V","":"V","":"V","":"V","":"V","":"VY","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"aa","":"ae","":"ae","":"ae","":"ao","":"au","":"av","":"av","":"ay","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"dz","":"dz","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"f","":"f","":"f","":"f","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"hv","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"j","":"j","":"j","":"j","":"j","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"lj","":"m","":"m","":"m","":"m","":"m","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"nj","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"oi","":"ou","":"oo","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"q","":"q","":"q","":"q","":"q","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"tz","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"v","":"v","":"v","":"v","":"v","":"v","":"v","":"vy","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":""};t.exports=matcher=function(t,e){if(""===$.trim(t.term))return e;if(e.children&&e.children.length>0){for(var n=$.extend(!0,{},e),r=e.children.length-1;r>=0;r--){var s=e.children[r],o=matcher(t,s);null==o&&n.children.splice(r,1)}return n.children.length>0?n:matcher(t,n)}var a=i(e.text).toUpperCase(),l=i(t.term).toUpperCase();if(a.indexOf(l)>-1)return e;if(e.id){var h=i(e.id).toUpperCase();if(h.indexOf(l)>-1)return e}return null}},function(t,e){t.exports='\n<div class="form-horizontal">\n  <div class="form-group">\n    <label for="select1" class="col-sm-3 control-label">\n      A simple select:\n    </label>\n    <div class="col-sm-5">\n      <vue-select class="vue-select1" name="select1"\n                  :options="options1" :model.sync="result1"\n                  language="">\n      </vue-select>\n    </div>\n    <div class="col-sm-4">\n      <p class="form-control-static">\n        Selected Result: <span class="vue-result1">{{result1}}</span>\n      </p>\n    </div>\n  </div>\n  <div class="form-group">\n    <label for="select2" class="col-sm-3 control-label">\n      A searchable select with names and localized in en-US:\n    </label>\n    <div class="col-sm-5">\n      <vue-select class="vue-select2" name="select2"\n              :options="options2" :model.sync="result2"\n              :searchable="true" language="en-US">\n      </vue-select>\n    </div>\n    <div class="col-sm-4">\n      <p class="form-control-static">\n        Selected Result: <span class="vue-result2">{{result2}}</span>\n      </p>\n    </div>\n  </div>\n  <div class="form-group">\n    <label for="select3" class="col-sm-3 control-label">\n      A searchable select with groups and localized in zh-CN:\n    </label>\n    <div class="col-sm-5">\n      <vue-select class="vue-select3" name="select3"\n                  :options="options3" :model.sync="result3"\n                  :searchable="true" language="zh-CN">\n      </vue-select>\n    </div>\n    <div class="col-sm-4">\n      <p class="form-control-static">\n        Selected Result: <span class="vue-result3">{{result3}}</span>\n      </p>\n    </div>\n  </div>\n</div>\n';
+}]);
\ No newline at end of file
Index: public/node_modules/vue-select2/webpack.config.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/webpack.config.js	(revision )
+++ public/node_modules/vue-select2/webpack.config.js	(revision )
@@ -0,0 +1,37 @@
+//  Configuration file of webpack
+var path = require("path");
+var webpack = require("webpack");
+var BowerWebpackPlugin = require("bower-webpack-plugin");
+var pkg = require(path.join(__dirname, "package.json"));
+var dirs = pkg.configs.directories;
+var version = process.env.VERSION || pkg.version;
+var banner = pkg.name + " v" + version + "\n" +
+  "(c) " + new Date().getFullYear() +
+  " " + pkg.author.name + "\n" +
+  "Released under the " + pkg.license + " License.";
+
+module.exports = {
+  entry: {
+    "vue-select": path.join(__dirname, dirs.src, "vue-select.js")
+  },
+  resolve: {
+    root: [__dirname],
+    modulesDirectories: [ "lib" ]
+  },
+  plugins: [
+    new webpack.optimize.DedupePlugin(),
+    new BowerWebpackPlugin({
+      modulesDirectories: [ "lib" ],
+      manifestFiles:      "bower.json",
+      includes:           /.*/,
+      excludes:           [],
+      searchResolveModulesDirectories: true
+    }),
+    new webpack.BannerPlugin(banner)
+  ],
+  output: {
+    path: path.join(__dirname, dirs.dist),
+    filename: "[name].js",
+    sourceMapFilename: "[file].map"
+  }
+};
Index: public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/index.js	(revision )
@@ -0,0 +1,36 @@
+'use strict';
+const PassThrough = require('stream').PassThrough;
+const zlib = require('zlib');
+
+module.exports = res => {
+	// TODO: use Array#includes when targeting Node.js 6
+	if (['gzip', 'deflate'].indexOf(res.headers['content-encoding']) === -1) {
+		return res;
+	}
+
+	const unzip = zlib.createUnzip();
+	const stream = new PassThrough();
+
+	stream.httpVersion = res.httpVersion;
+	stream.headers = res.headers;
+	stream.rawHeaders = res.rawHeaders;
+	stream.trailers = res.trailers;
+	stream.rawTrailers = res.rawTrailers;
+	stream.setTimeout = res.setTimeout.bind(res);
+	stream.statusCode = res.statusCode;
+	stream.statusMessage = res.statusMessage;
+	stream.socket = res.socket;
+
+	unzip.on('error', err => {
+		if (err.code === 'Z_BUF_ERROR') {
+			stream.end();
+			return;
+		}
+
+		stream.emit('error', err);
+	});
+
+	res.pipe(unzip).pipe(stream);
+
+	return stream;
+};
Index: public/node_modules/vue-resource/src/http/client/xdr.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/client/xdr.js	(revision )
+++ public/node_modules/vue-resource/src/http/client/xdr.js	(revision )
@@ -0,0 +1,38 @@
+/**
+ * XDomain client (Internet Explorer).
+ */
+
+import Promise from '../../promise';
+
+export default function (request) {
+    return new Promise(resolve => {
+
+        var xdr = new XDomainRequest(), handler = ({type}) => {
+
+            var status = 0;
+
+            if (type === 'load') {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            resolve(request.respondWith(xdr.responseText, {status}));
+        };
+
+        request.abort = () => xdr.abort();
+
+        xdr.open(request.method, request.getUrl());
+
+        if (request.timeout) {
+            xdr.timeout = request.timeout;
+        }
+
+        xdr.onload = handler;
+        xdr.onabort = handler;
+        xdr.onerror = handler;
+        xdr.ontimeout = handler;
+        xdr.onprogress = () => {};
+        xdr.send(request.getBody());
+    });
+}
Index: public/node_modules/vue/src/compiler/parser/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/parser/index.js	(revision )
+++ public/node_modules/vue/src/compiler/parser/index.js	(revision )
@@ -0,0 +1,563 @@
+/* @flow */
+
+import { decode } from 'he'
+import { parseHTML } from './html-parser'
+import { parseText } from './text-parser'
+import { parseFilters } from './filter-parser'
+import { cached, no, camelize } from 'shared/util'
+import { isIE, isServerRendering } from 'core/util/env'
+import {
+  pluckModuleFunction,
+  getAndRemoveAttr,
+  addProp,
+  addAttr,
+  addHandler,
+  addDirective,
+  getBindingAttr,
+  baseWarn
+} from '../helpers'
+
+export const dirRE = /^v-|^@|^:/
+export const onRE = /^@|^v-on:/
+export const forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/
+export const forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/
+const bindRE = /^:|^v-bind:/
+const argRE = /:(.*)$/
+const modifierRE = /\.[^.]+/g
+
+const decodeHTMLCached = cached(decode)
+
+// configurable state
+let warn
+let platformGetTagNamespace
+let platformMustUseProp
+let platformIsPreTag
+let preTransforms
+let transforms
+let postTransforms
+let delimiters
+
+/**
+ * Convert HTML string to AST.
+ */
+export function parse (
+  template: string,
+  options: CompilerOptions
+): ASTElement | void {
+  warn = options.warn || baseWarn
+  platformGetTagNamespace = options.getTagNamespace || no
+  platformMustUseProp = options.mustUseProp || no
+  platformIsPreTag = options.isPreTag || no
+  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode')
+  transforms = pluckModuleFunction(options.modules, 'transformNode')
+  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode')
+  delimiters = options.delimiters
+
+  const stack = []
+  const preserveWhitespace = options.preserveWhitespace !== false
+  let root
+  let currentParent
+  let inVPre = false
+  let inPre = false
+  let warned = false
+
+  function endPre (element) {
+    // check pre state
+    if (element.pre) {
+      inVPre = false
+    }
+    if (platformIsPreTag(element.tag)) {
+      inPre = false
+    }
+  }
+
+  parseHTML(template, {
+    warn,
+    expectHTML: options.expectHTML,
+    isUnaryTag: options.isUnaryTag,
+    shouldDecodeNewlines: options.shouldDecodeNewlines,
+    start (tag, attrs, unary) {
+      // check namespace.
+      // inherit parent ns if there is one
+      const ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag)
+
+      // handle IE svg bug
+      /* istanbul ignore if */
+      if (isIE && ns === 'svg') {
+        attrs = guardIESVGBug(attrs)
+      }
+
+      const element: ASTElement = {
+        type: 1,
+        tag,
+        attrsList: attrs,
+        attrsMap: makeAttrsMap(attrs),
+        parent: currentParent,
+        children: []
+      }
+      if (ns) {
+        element.ns = ns
+      }
+
+      if (isForbiddenTag(element) && !isServerRendering()) {
+        element.forbidden = true
+        process.env.NODE_ENV !== 'production' && warn(
+          'Templates should only be responsible for mapping the state to the ' +
+          'UI. Avoid placing tags with side-effects in your templates, such as ' +
+          `<${tag}>` + ', as they will not be parsed.'
+        )
+      }
+
+      // apply pre-transforms
+      for (let i = 0; i < preTransforms.length; i++) {
+        preTransforms[i](element, options)
+      }
+
+      if (!inVPre) {
+        processPre(element)
+        if (element.pre) {
+          inVPre = true
+        }
+      }
+      if (platformIsPreTag(element.tag)) {
+        inPre = true
+      }
+      if (inVPre) {
+        processRawAttrs(element)
+      } else {
+        processFor(element)
+        processIf(element)
+        processOnce(element)
+        processKey(element)
+
+        // determine whether this is a plain element after
+        // removing structural attributes
+        element.plain = !element.key && !attrs.length
+
+        processRef(element)
+        processSlot(element)
+        processComponent(element)
+        for (let i = 0; i < transforms.length; i++) {
+          transforms[i](element, options)
+        }
+        processAttrs(element)
+      }
+
+      function checkRootConstraints (el) {
+        if (process.env.NODE_ENV !== 'production' && !warned) {
+          if (el.tag === 'slot' || el.tag === 'template') {
+            warned = true
+            warn(
+              `Cannot use <${el.tag}> as component root element because it may ` +
+              'contain multiple nodes.'
+            )
+          }
+          if (el.attrsMap.hasOwnProperty('v-for')) {
+            warned = true
+            warn(
+              'Cannot use v-for on stateful component root element because ' +
+              'it renders multiple elements.'
+            )
+          }
+        }
+      }
+
+      // tree management
+      if (!root) {
+        root = element
+        checkRootConstraints(root)
+      } else if (!stack.length) {
+        // allow root elements with v-if, v-else-if and v-else
+        if (root.if && (element.elseif || element.else)) {
+          checkRootConstraints(element)
+          addIfCondition(root, {
+            exp: element.elseif,
+            block: element
+          })
+        } else if (process.env.NODE_ENV !== 'production' && !warned) {
+          warned = true
+          warn(
+            `Component template should contain exactly one root element. ` +
+            `If you are using v-if on multiple elements, ` +
+            `use v-else-if to chain them instead.`
+          )
+        }
+      }
+      if (currentParent && !element.forbidden) {
+        if (element.elseif || element.else) {
+          processIfConditions(element, currentParent)
+        } else if (element.slotScope) { // scoped slot
+          currentParent.plain = false
+          const name = element.slotTarget || '"default"'
+          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element
+        } else {
+          currentParent.children.push(element)
+          element.parent = currentParent
+        }
+      }
+      if (!unary) {
+        currentParent = element
+        stack.push(element)
+      } else {
+        endPre(element)
+      }
+      // apply post-transforms
+      for (let i = 0; i < postTransforms.length; i++) {
+        postTransforms[i](element, options)
+      }
+    },
+
+    end () {
+      // remove trailing whitespace
+      const element = stack[stack.length - 1]
+      const lastNode = element.children[element.children.length - 1]
+      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
+        element.children.pop()
+      }
+      // pop stack
+      stack.length -= 1
+      currentParent = stack[stack.length - 1]
+      endPre(element)
+    },
+
+    chars (text: string) {
+      if (!currentParent) {
+        if (process.env.NODE_ENV !== 'production' && !warned && text === template) {
+          warned = true
+          warn(
+            'Component template requires a root element, rather than just text.'
+          )
+        }
+        return
+      }
+      // IE textarea placeholder bug
+      /* istanbul ignore if */
+      if (isIE &&
+          currentParent.tag === 'textarea' &&
+          currentParent.attrsMap.placeholder === text) {
+        return
+      }
+      const children = currentParent.children
+      text = inPre || text.trim()
+        ? decodeHTMLCached(text)
+        // only preserve whitespace if its not right after a starting tag
+        : preserveWhitespace && children.length ? ' ' : ''
+      if (text) {
+        let expression
+        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
+          children.push({
+            type: 2,
+            expression,
+            text
+          })
+        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
+          children.push({
+            type: 3,
+            text
+          })
+        }
+      }
+    }
+  })
+  return root
+}
+
+function processPre (el) {
+  if (getAndRemoveAttr(el, 'v-pre') != null) {
+    el.pre = true
+  }
+}
+
+function processRawAttrs (el) {
+  const l = el.attrsList.length
+  if (l) {
+    const attrs = el.attrs = new Array(l)
+    for (let i = 0; i < l; i++) {
+      attrs[i] = {
+        name: el.attrsList[i].name,
+        value: JSON.stringify(el.attrsList[i].value)
+      }
+    }
+  } else if (!el.pre) {
+    // non root node in pre blocks with no attributes
+    el.plain = true
+  }
+}
+
+function processKey (el) {
+  const exp = getBindingAttr(el, 'key')
+  if (exp) {
+    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {
+      warn(`<template> cannot be keyed. Place the key on real elements instead.`)
+    }
+    el.key = exp
+  }
+}
+
+function processRef (el) {
+  const ref = getBindingAttr(el, 'ref')
+  if (ref) {
+    el.ref = ref
+    el.refInFor = checkInFor(el)
+  }
+}
+
+function processFor (el) {
+  let exp
+  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
+    const inMatch = exp.match(forAliasRE)
+    if (!inMatch) {
+      process.env.NODE_ENV !== 'production' && warn(
+        `Invalid v-for expression: ${exp}`
+      )
+      return
+    }
+    el.for = inMatch[2].trim()
+    const alias = inMatch[1].trim()
+    const iteratorMatch = alias.match(forIteratorRE)
+    if (iteratorMatch) {
+      el.alias = iteratorMatch[1].trim()
+      el.iterator1 = iteratorMatch[2].trim()
+      if (iteratorMatch[3]) {
+        el.iterator2 = iteratorMatch[3].trim()
+      }
+    } else {
+      el.alias = alias
+    }
+  }
+}
+
+function processIf (el) {
+  const exp = getAndRemoveAttr(el, 'v-if')
+  if (exp) {
+    el.if = exp
+    addIfCondition(el, {
+      exp: exp,
+      block: el
+    })
+  } else {
+    if (getAndRemoveAttr(el, 'v-else') != null) {
+      el.else = true
+    }
+    const elseif = getAndRemoveAttr(el, 'v-else-if')
+    if (elseif) {
+      el.elseif = elseif
+    }
+  }
+}
+
+function processIfConditions (el, parent) {
+  const prev = findPrevElement(parent.children)
+  if (prev && prev.if) {
+    addIfCondition(prev, {
+      exp: el.elseif,
+      block: el
+    })
+  } else if (process.env.NODE_ENV !== 'production') {
+    warn(
+      `v-${el.elseif ? ('else-if="' + el.elseif + '"') : 'else'} ` +
+      `used on element <${el.tag}> without corresponding v-if.`
+    )
+  }
+}
+
+function findPrevElement (children: Array<any>): ASTElement | void {
+  let i = children.length
+  while (i--) {
+    if (children[i].type === 1) {
+      return children[i]
+    } else {
+      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {
+        warn(
+          `text "${children[i].text.trim()}" between v-if and v-else(-if) ` +
+          `will be ignored.`
+        )
+      }
+      children.pop()
+    }
+  }
+}
+
+function addIfCondition (el, condition) {
+  if (!el.ifConditions) {
+    el.ifConditions = []
+  }
+  el.ifConditions.push(condition)
+}
+
+function processOnce (el) {
+  const once = getAndRemoveAttr(el, 'v-once')
+  if (once != null) {
+    el.once = true
+  }
+}
+
+function processSlot (el) {
+  if (el.tag === 'slot') {
+    el.slotName = getBindingAttr(el, 'name')
+    if (process.env.NODE_ENV !== 'production' && el.key) {
+      warn(
+        `\`key\` does not work on <slot> because slots are abstract outlets ` +
+        `and can possibly expand into multiple elements. ` +
+        `Use the key on a wrapping element instead.`
+      )
+    }
+  } else {
+    const slotTarget = getBindingAttr(el, 'slot')
+    if (slotTarget) {
+      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget
+    }
+    if (el.tag === 'template') {
+      el.slotScope = getAndRemoveAttr(el, 'scope')
+    }
+  }
+}
+
+function processComponent (el) {
+  let binding
+  if ((binding = getBindingAttr(el, 'is'))) {
+    el.component = binding
+  }
+  if (getAndRemoveAttr(el, 'inline-template') != null) {
+    el.inlineTemplate = true
+  }
+}
+
+function processAttrs (el) {
+  const list = el.attrsList
+  let i, l, name, rawName, value, arg, modifiers, isProp
+  for (i = 0, l = list.length; i < l; i++) {
+    name = rawName = list[i].name
+    value = list[i].value
+    if (dirRE.test(name)) {
+      // mark element as dynamic
+      el.hasBindings = true
+      // modifiers
+      modifiers = parseModifiers(name)
+      if (modifiers) {
+        name = name.replace(modifierRE, '')
+      }
+      if (bindRE.test(name)) { // v-bind
+        name = name.replace(bindRE, '')
+        value = parseFilters(value)
+        isProp = false
+        if (modifiers) {
+          if (modifiers.prop) {
+            isProp = true
+            name = camelize(name)
+            if (name === 'innerHtml') name = 'innerHTML'
+          }
+          if (modifiers.camel) {
+            name = camelize(name)
+          }
+        }
+        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
+          addProp(el, name, value)
+        } else {
+          addAttr(el, name, value)
+        }
+      } else if (onRE.test(name)) { // v-on
+        name = name.replace(onRE, '')
+        addHandler(el, name, value, modifiers)
+      } else { // normal directives
+        name = name.replace(dirRE, '')
+        // parse arg
+        const argMatch = name.match(argRE)
+        if (argMatch && (arg = argMatch[1])) {
+          name = name.slice(0, -(arg.length + 1))
+        }
+        addDirective(el, name, rawName, value, arg, modifiers)
+        if (process.env.NODE_ENV !== 'production' && name === 'model') {
+          checkForAliasModel(el, value)
+        }
+      }
+    } else {
+      // literal attribute
+      if (process.env.NODE_ENV !== 'production') {
+        const expression = parseText(value, delimiters)
+        if (expression) {
+          warn(
+            `${name}="${value}": ` +
+            'Interpolation inside attributes has been removed. ' +
+            'Use v-bind or the colon shorthand instead. For example, ' +
+            'instead of <div id="{{ val }}">, use <div :id="val">.'
+          )
+        }
+      }
+      addAttr(el, name, JSON.stringify(value))
+    }
+  }
+}
+
+function checkInFor (el: ASTElement): boolean {
+  let parent = el
+  while (parent) {
+    if (parent.for !== undefined) {
+      return true
+    }
+    parent = parent.parent
+  }
+  return false
+}
+
+function parseModifiers (name: string): Object | void {
+  const match = name.match(modifierRE)
+  if (match) {
+    const ret = {}
+    match.forEach(m => { ret[m.slice(1)] = true })
+    return ret
+  }
+}
+
+function makeAttrsMap (attrs: Array<Object>): Object {
+  const map = {}
+  for (let i = 0, l = attrs.length; i < l; i++) {
+    if (process.env.NODE_ENV !== 'production' && map[attrs[i].name] && !isIE) {
+      warn('duplicate attribute: ' + attrs[i].name)
+    }
+    map[attrs[i].name] = attrs[i].value
+  }
+  return map
+}
+
+function isForbiddenTag (el): boolean {
+  return (
+    el.tag === 'style' ||
+    (el.tag === 'script' && (
+      !el.attrsMap.type ||
+      el.attrsMap.type === 'text/javascript'
+    ))
+  )
+}
+
+const ieNSBug = /^xmlns:NS\d+/
+const ieNSPrefix = /^NS\d+:/
+
+/* istanbul ignore next */
+function guardIESVGBug (attrs) {
+  const res = []
+  for (let i = 0; i < attrs.length; i++) {
+    const attr = attrs[i]
+    if (!ieNSBug.test(attr.name)) {
+      attr.name = attr.name.replace(ieNSPrefix, '')
+      res.push(attr)
+    }
+  }
+  return res
+}
+
+function checkForAliasModel (el, value) {
+  let _el = el
+  while (_el) {
+    if (_el.for && _el.alias === value) {
+      warn(
+        `<${el.tag} v-model="${value}">: ` +
+        `You are binding v-model directly to a v-for iteration alias. ` +
+        `This will not be able to modify the v-for source array because ` +
+        `writing to the alias is like modifying a function local variable. ` +
+        `Consider using an array of objects and use v-model on an object property instead.`
+      )
+    }
+    _el = _el.parent
+  }
+}
Index: public/node_modules/vue/src/server/create-bundle-runner.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/create-bundle-runner.js	(revision )
+++ public/node_modules/vue/src/server/create-bundle-runner.js	(revision )
@@ -0,0 +1,80 @@
+const vm = require('vm')
+const path = require('path')
+const resolve = require('resolve')
+const NativeModule = require('module')
+
+function createContext (context) {
+  const sandbox = {
+    Buffer,
+    console,
+    process,
+    setTimeout,
+    setInterval,
+    setImmediate,
+    clearTimeout,
+    clearInterval,
+    clearImmediate,
+    __VUE_SSR_CONTEXT__: context
+  }
+  sandbox.global = sandbox
+  return sandbox
+}
+
+function compileModule (files, basedir) {
+  const compiledScripts = {}
+  const resolvedModules = {}
+
+  function getCompiledScript (filename) {
+    if (compiledScripts[filename]) {
+      return compiledScripts[filename]
+    }
+    const code = files[filename]
+    const wrapper = NativeModule.wrap(code)
+    const script = new vm.Script(wrapper, {
+      filename,
+      displayErrors: true
+    })
+    compiledScripts[filename] = script
+    return script
+  }
+
+  function evaluateModule (filename, context, evaluatedModules) {
+    if (evaluatedModules[filename]) {
+      return evaluatedModules[filename]
+    }
+
+    const script = getCompiledScript(filename)
+    const compiledWrapper = script.runInNewContext(context)
+    const m = { exports: {}}
+    const r = file => {
+      file = path.join('.', file)
+      if (files[file]) {
+        return evaluateModule(file, context, evaluatedModules)
+      } else if (basedir) {
+        return require(
+          resolvedModules[file] ||
+          (resolvedModules[file] = resolve.sync(file, { basedir }))
+        )
+      } else {
+        return require(file)
+      }
+    }
+    compiledWrapper.call(m.exports, m.exports, r, m)
+
+    const res = Object.prototype.hasOwnProperty.call(m.exports, 'default')
+      ? m.exports.default
+      : m.exports
+    evaluatedModules[filename] = res
+    return res
+  }
+  return evaluateModule
+}
+
+export function createBundleRunner (entry, files, basedir) {
+  const evaluate = compileModule(files, basedir)
+  return (_context = {}) => new Promise((resolve, reject) => {
+    const context = createContext(_context)
+    const res = evaluate(entry, context, {})
+    resolve(typeof res === 'function' ? res(_context) : res)
+  })
+}
Index: public/node_modules/vue/src/compiler/parser/filter-parser.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/parser/filter-parser.js	(revision )
+++ public/node_modules/vue/src/compiler/parser/filter-parser.js	(revision )
@@ -0,0 +1,97 @@
+/* @flow */
+
+const validDivisionCharRE = /[\w).+\-_$\]]/
+
+export function parseFilters (exp: string): string {
+  let inSingle = false
+  let inDouble = false
+  let inTemplateString = false
+  let inRegex = false
+  let curly = 0
+  let square = 0
+  let paren = 0
+  let lastFilterIndex = 0
+  let c, prev, i, expression, filters
+
+  for (i = 0; i < exp.length; i++) {
+    prev = c
+    c = exp.charCodeAt(i)
+    if (inSingle) {
+      if (c === 0x27 && prev !== 0x5C) inSingle = false
+    } else if (inDouble) {
+      if (c === 0x22 && prev !== 0x5C) inDouble = false
+    } else if (inTemplateString) {
+      if (c === 0x60 && prev !== 0x5C) inTemplateString = false
+    } else if (inRegex) {
+      if (c === 0x2f && prev !== 0x5C) inRegex = false
+    } else if (
+      c === 0x7C && // pipe
+      exp.charCodeAt(i + 1) !== 0x7C &&
+      exp.charCodeAt(i - 1) !== 0x7C &&
+      !curly && !square && !paren
+    ) {
+      if (expression === undefined) {
+        // first filter, end of expression
+        lastFilterIndex = i + 1
+        expression = exp.slice(0, i).trim()
+      } else {
+        pushFilter()
+      }
+    } else {
+      switch (c) {
+        case 0x22: inDouble = true; break         // "
+        case 0x27: inSingle = true; break         // '
+        case 0x60: inTemplateString = true; break // `
+        case 0x28: paren++; break                 // (
+        case 0x29: paren--; break                 // )
+        case 0x5B: square++; break                // [
+        case 0x5D: square--; break                // ]
+        case 0x7B: curly++; break                 // {
+        case 0x7D: curly--; break                 // }
+      }
+      if (c === 0x2f) { // /
+        let j = i - 1
+        let p
+        // find first non-whitespace prev char
+        for (; j >= 0; j--) {
+          p = exp.charAt(j)
+          if (p !== ' ') break
+        }
+        if (!p || !validDivisionCharRE.test(p)) {
+          inRegex = true
+        }
+      }
+    }
+  }
+
+  if (expression === undefined) {
+    expression = exp.slice(0, i).trim()
+  } else if (lastFilterIndex !== 0) {
+    pushFilter()
+  }
+
+  function pushFilter () {
+    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim())
+    lastFilterIndex = i + 1
+  }
+
+  if (filters) {
+    for (i = 0; i < filters.length; i++) {
+      expression = wrapFilter(expression, filters[i])
+    }
+  }
+
+  return expression
+}
+
+function wrapFilter (exp: string, filter: string): string {
+  const i = filter.indexOf('(')
+  if (i < 0) {
+    // _f: resolveFilter
+    return `_f("${filter}")(${exp})`
+  } else {
+    const name = filter.slice(0, i)
+    const args = filter.slice(i + 1)
+    return `_f("${name}")(${exp},${args}`
+  }
+}
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/workspace.xml	(revision 3d426e1c0d52d26cb969fee1b80a5af3508614bb)
+++ .idea/workspace.xml	(revision )
@@ -6,2244 +6,107 @@
     <bookmark url="file://$PROJECT_DIR$/app/Http/Controllers/Web/FormController.php" description="{" line="373" />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="d9e16f0e-8983-42e1-b8ec-02cd8c802c46" name="Default" comment="">
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/img/loading-sm.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/img/loading.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/apple-touch-icon.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/fonts/glyphicons-halflings-regular.eot" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/fonts/glyphicons-halflings-regular.ttf" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/fonts/glyphicons-halflings-regular.woff" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/flash/ZeroClipboard.swf" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/images/alipay.jpg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/images/alipayLogo.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/images/paypalLogo.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/images/weixin.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/images/weixinLogo.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/favicon.ico" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/tree-column/icon.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.zip" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.eot" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.ttf" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.woff" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.woff2" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/fonts/glyphicons-halflings-regular.eot" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/fonts/glyphicons-halflings-regular.ttf" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/fonts/glyphicons-halflings-regular.woff" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/fonts/glyphicons-halflings-regular.woff2" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_diagonals-thick_18_b81900_40x40.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_diagonals-thick_20_666666_40x40.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_flat_10_000000_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_glass_100_f6f6f6_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_glass_100_fdf5ce_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_glass_65_ffffff_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_gloss-wave_35_f6a828_500x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_highlight-soft_100_eeeeee_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-bg_highlight-soft_75_ffe45c_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-icons_222222_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-icons_228ef1_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-icons_ef8c08_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-icons_ffd27a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/images/ui-icons_ffffff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.4.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.4.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.4.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.5.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.2.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.2.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.2.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.3.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.3.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.0-rc1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.4.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.4.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.4.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.5.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.2.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.2.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.2.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.3.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.3.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.0-rc1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.4.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.4.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.4.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.5.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.2.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.2.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.2.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.3.0.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.3.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.0-rc1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.1.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.2.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.3.nupkg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/toastr-2.1.2.tgz" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/toastr-icon.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/toastr-2.1.2.tgz" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/toastr-icon.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/toastr-icon.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap-editable/img/clear.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap-editable/img/loading.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap3-editable/img/clear.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap3-editable/img/loading.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/img/clear.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/img/loading.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/animated-overlay.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_flat_0_aaaaaa_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_flat_55_fbec88_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_glass_75_d0e5f5_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_glass_85_dfeffc_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_glass_95_fef1ec_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_gloss-wave_55_5c9ccc_500x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_inset-hard_100_f5f8f9_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-bg_inset-hard_100_fcfdfd_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-icons_217bc0_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-icons_2e83ff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-icons_469bdd_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-icons_6da8d5_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-icons_cd0a0a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-icons_d8e7f3_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/images/ui-icons_f9bd01_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jqueryui-editable/img/clear.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jqueryui-editable/img/loading.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/img/clear.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/img/loading.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/animated-overlay.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_flat_0_aaaaaa_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_flat_55_fbec88_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_glass_75_d0e5f5_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_glass_85_dfeffc_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_glass_95_fef1ec_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_gloss-wave_55_5c9ccc_500x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_inset-hard_100_f5f8f9_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-bg_inset-hard_100_fcfdfd_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-icons_217bc0_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-icons_2e83ff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-icons_469bdd_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-icons_6da8d5_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-icons_cd0a0a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-icons_d8e7f3_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/images/ui-icons_f9bd01_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/lib/select2-spinner.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/lib/select2.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/lib/select2x2.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/img/glyphicons-halflings-white.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/img/glyphicons-halflings.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/img/glyphicons-halflings-white.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/img/glyphicons-halflings.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/img/glyphicons-halflings-white.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/img/glyphicons-halflings.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/img/glyphicons-halflings-white.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/img/glyphicons-halflings.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/fonts/glyphicons-halflings-regular.eot" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/fonts/glyphicons-halflings-regular.ttf" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/fonts/glyphicons-halflings-regular.woff" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/animated-overlay.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_flat_0_aaaaaa_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_flat_55_fbec88_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_glass_75_d0e5f5_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_glass_85_dfeffc_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_glass_95_fef1ec_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_gloss-wave_55_5c9ccc_500x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_inset-hard_100_f5f8f9_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-bg_inset-hard_100_fcfdfd_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-icons_217bc0_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-icons_2e83ff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-icons_469bdd_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-icons_6da8d5_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-icons_cd0a0a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-icons_d8e7f3_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/images/ui-icons_f9bd01_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/animated-overlay.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_flat_0_aaaaaa_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_flat_55_fbec88_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_glass_75_d0e5f5_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_glass_85_dfeffc_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_glass_95_fef1ec_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_gloss-wave_55_5c9ccc_500x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_inset-hard_100_f5f8f9_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-bg_inset-hard_100_fcfdfd_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-icons_217bc0_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-icons_2e83ff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-icons_469bdd_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-icons_6da8d5_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-icons_cd0a0a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-icons_d8e7f3_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/images/ui-icons_f9bd01_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/animated-overlay.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_diagonals-thick_18_b81900_40x40.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_diagonals-thick_20_666666_40x40.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_flat_10_000000_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_glass_100_f6f6f6_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_glass_100_fdf5ce_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_glass_65_ffffff_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_gloss-wave_35_f6a828_500x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_highlight-soft_100_eeeeee_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-bg_highlight-soft_75_ffe45c_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-icons_222222_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-icons_228ef1_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-icons_ef8c08_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-icons_ffd27a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/images/ui-icons_ffffff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_flat_0_aaaaaa_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_flat_55_fbec88_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_glass_75_d0e5f5_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_glass_85_dfeffc_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_glass_95_fef1ec_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_gloss-wave_55_5c9ccc_500x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_inset-hard_100_f5f8f9_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-bg_inset-hard_100_fcfdfd_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-icons_217bc0_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-icons_2e83ff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-icons_469bdd_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-icons_6da8d5_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-icons_cd0a0a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-icons_d8e7f3_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/images/ui-icons_f9bd01_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_flat_0_aaaaaa_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_flat_75_ffffff_40x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_glass_55_fbf9ee_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_glass_65_ffffff_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_glass_75_dadada_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_glass_75_e6e6e6_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_glass_95_fef1ec_1x400.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-bg_highlight-soft_75_cccccc_1x100.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-icons_222222_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-icons_2e83ff_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-icons_454545_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-icons_888888_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/images/ui-icons_cd0a0a_256x240.png" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/poshytip/tip-yellowsimple/tip-yellowsimple_arrows.gif" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/assets/js/tableExport.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/bootstrap-checkbox.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/bootstrap-checkbox.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/es.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/es.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/pt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/pt.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/ru.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/ru.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/tr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/dist/js/i18n/tr.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/js/bootstrap-checkbox.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/js/i18n/es.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/js/i18n/pt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/js/i18n/ru.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/js/i18n/tr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-checkbox/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/.github/CONTRIBUTING.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/.github/ISSUE_TEMPLATE.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/.github/PULL_REQUEST_TEMPLATE.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/CHANGE.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/LICENSE.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/composer.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/css/fileinput.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/css/fileinput.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/examples/index.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/fileinput.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/fileinput.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/LANG.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/ar.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/bg.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/ca.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/cr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/cz.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/da.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/de.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/el.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/es.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/fa.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/fi.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/fr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/hu.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/id.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/it.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/ja.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/kr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/kz.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/nl.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/pl.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/pt-BR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/pt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/ro.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/ru.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/sk.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/sl.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/th.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/tr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/uk.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/vi.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/zh-TW.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/locales/zh.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/plugins/canvas-to-blob.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/plugins/canvas-to-blob.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/plugins/purify.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/plugins/purify.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/plugins/sortable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/js/plugins/sortable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/nuget/Package.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/nuget/build.bat" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/sass/fileinput.scss" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/themes/explorer/theme.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/themes/explorer/theme.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/themes/fa/theme.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-fileinput/themes/gly/theme.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/.github/ISSUE_TEMPLATE.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/CHANGELOG.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/CONTRIBUTING.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/DONATORS.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/_config.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/bootstrap-table.jquery.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/composer.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/bootstrap-table-locale-all.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/bootstrap-table-locale-all.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/bootstrap-table.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/bootstrap-table.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/bootstrap-table.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/bootstrap-table.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/accent-neutralise/bootstrap-table-accent-neutralise.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/accent-neutralise/bootstrap-table-accent-neutralise.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/angular/bootstrap-table-angular.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/angular/bootstrap-table-angular.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/auto-refresh/bootstrap-table-auto-refresh.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/auto-refresh/bootstrap-table-auto-refresh.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/auto-refresh/bootstrap-table-auto-refresh.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/click-edit-row/bootstrap-table-click-edit-row.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/click-edit-row/bootstrap-table-click-edit-row.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/click-edit-row/bootstrap-table-click-edit-row.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/cookie/bootstrap-table-cookie.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/cookie/bootstrap-table-cookie.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/copy-rows/bootstrap-table-copy-rows.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/copy-rows/bootstrap-table-copy-rows.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/editable/bootstrap-table-editable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/editable/bootstrap-table-editable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/export/bootstrap-table-export.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/export/bootstrap-table-export.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/filter-control/bootstrap-table-filter-control.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/filter-control/bootstrap-table-filter-control.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/filter-control/bootstrap-table-filter-control.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/filter/bootstrap-table-filter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/filter/bootstrap-table-filter.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/flat-json/bootstrap-table-flat-json.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/flat-json/bootstrap-table-flat-json.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/group-by-v2/bootstrap-table-group-by.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/group-by-v2/bootstrap-table-group-by.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/group-by-v2/bootstrap-table-group-by.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/group-by/bootstrap-table-group-by.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/group-by/bootstrap-table-group-by.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/group-by/bootstrap-table-group-by.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/i18n-enhance/bootstrap-table-i18n-enhance.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/i18n-enhance/bootstrap-table-i18n-enhance.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/key-events/bootstrap-table-key-events.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/key-events/bootstrap-table-key-events.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/mobile/bootstrap-table-mobile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/mobile/bootstrap-table-mobile.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multi-column-toggle/bootstrap-table-multi-toggle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multi-column-toggle/bootstrap-table-multi-toggle.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multiple-search/bootstrap-table-multiple-search.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multiple-search/bootstrap-table-multiple-search.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multiple-sort/bootstrap-table-multiple-sort.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/multiple-sort/bootstrap-table-multiple-sort.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/natural-sorting/bootstrap-table-natural-sorting.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/natural-sorting/bootstrap-table-natural-sorting.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/print/bootstrap-table-print.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/print/bootstrap-table-print.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/reorder-columns/bootstrap-table-reorder-columns.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/reorder-columns/bootstrap-table-reorder-columns.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/reorder-rows/bootstrap-table-reorder-rows.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/reorder-rows/bootstrap-table-reorder-rows.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/reorder-rows/bootstrap-table-reorder-rows.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/resizable/bootstrap-table-resizable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/resizable/bootstrap-table-resizable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/select2-filter/bootstrap-table-select2-filter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/select2-filter/bootstrap-table-select2-filter.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/sticky-header/bootstrap-table-sticky-header.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/sticky-header/bootstrap-table-sticky-header.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/sticky-header/bootstrap-table-sticky-header.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/toolbar/bootstrap-table-toolbar.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/toolbar/bootstrap-table-toolbar.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/tree-column/bootstrap-table-tree-column.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/tree-column/bootstrap-table-tree-column.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/extensions/tree-column/bootstrap-table-tree-column.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-af-ZA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-af-ZA.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ar-SA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ar-SA.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ca-ES.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ca-ES.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-cs-CZ.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-cs-CZ.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-da-DK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-da-DK.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-de-DE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-de-DE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-el-GR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-el-GR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-en-US.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-en-US.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-AR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-AR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-CL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-CL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-CR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-CR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-ES.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-ES.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-MX.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-MX.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-NI.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-NI.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-SP.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-es-SP.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-et-EE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-et-EE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-fa-IR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-fa-IR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-fr-BE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-fr-BE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-fr-FR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-fr-FR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-he-IL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-he-IL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-hr-HR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-hr-HR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-hu-HU.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-hu-HU.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-id-ID.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-id-ID.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-it-IT.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-it-IT.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ja-JP.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ja-JP.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ka-GE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ka-GE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ko-KR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ko-KR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ms-MY.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ms-MY.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-nb-NO.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-nb-NO.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-nl-NL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-nl-NL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-pl-PL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-pl-PL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-pt-BR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-pt-BR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-pt-PT.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-pt-PT.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ro-RO.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ro-RO.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ru-RU.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ru-RU.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-sk-SK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-sk-SK.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-sv-SE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-sv-SE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-th-TH.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-th-TH.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-tr-TR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-tr-TR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-uk-UA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-uk-UA.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ur-PK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-ur-PK.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-uz-Latn-UZ.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-uz-Latn-UZ.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-vi-VN.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-vi-VN.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-zh-CN.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-zh-CN.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-zh-TW.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/dist/locale/bootstrap-table-zh-TW.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/documentation/column-options.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/documentation/events.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/documentation/localizations.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/documentation/methods.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/documentation/table-options.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/donate.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/faq/faq.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/footer.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/getting-started/download.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/getting-started/grunt.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/getting-started/usage.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/getting-started/whats-include.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/en/home/feature.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/documentation/column-options.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/documentation/events.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/documentation/localizations.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/documentation/methods.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/documentation/table-options.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/donate.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/faq/faq.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/footer.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/getting-started/download.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/getting-started/grunt.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/getting-started/usage.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/getting-started/whats-include.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/es/home/feature.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/documentation/column-options.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/documentation/events.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/documentation/localizations.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/documentation/methods.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/documentation/table-options.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/donate.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/faq/faq.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/footer.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/getting-started/download.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/getting-started/grunt.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/getting-started/usage.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/getting-started/whats-include.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_i18n/zh-cn/home/feature.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_includes/footer.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_includes/header.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_includes/latest-release.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_includes/nav.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_includes/social-buttons.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_layouts/default.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_layouts/home.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_plugins/markdown-tag.rb" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/_plugins/multiple-languages.rb" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/css/bootstrap-theme.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/css/bootstrap-theme.css.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/css/bootstrap-theme.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/css/bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/css/bootstrap.css.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/css/bootstrap.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/fonts/glyphicons-halflings-regular.svg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/js/bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/js/bootstrap.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/bootstrap/js/npm.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/css/docs.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/css/sidenav.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/css/style.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/common.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/customize.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/docs.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/ie-emulation-modes-warning.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/ie10-viewport-bug-workaround.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/ie8-responsive-file-warning.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/jquery.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/assets/js/sidenav.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/data/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/data/data1/demo.response.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/data/data2/demo.response.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/data/data3/demo.response.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/data/data4/demo.response.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/data/data5/demo.response.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/data/extensions.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/bootstrap-table-locale-all.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/bootstrap-table-locale-all.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/bootstrap-table.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/bootstrap-table.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/bootstrap-table.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/bootstrap-table.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/accent-neutralise/bootstrap-table-accent-neutralise.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/accent-neutralise/bootstrap-table-accent-neutralise.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/angular/bootstrap-table-angular.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/angular/bootstrap-table-angular.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/auto-refresh/bootstrap-table-auto-refresh.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/auto-refresh/bootstrap-table-auto-refresh.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/auto-refresh/bootstrap-table-auto-refresh.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/click-edit-row/bootstrap-table-click-edit-row.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/click-edit-row/bootstrap-table-click-edit-row.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/click-edit-row/bootstrap-table-click-edit-row.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/cookie/bootstrap-table-cookie.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/cookie/bootstrap-table-cookie.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/copy-rows/bootstrap-table-copy-rows.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/copy-rows/bootstrap-table-copy-rows.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/editable/bootstrap-table-editable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/editable/bootstrap-table-editable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/export/bootstrap-table-export.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/export/bootstrap-table-export.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/filter-control/bootstrap-table-filter-control.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/filter-control/bootstrap-table-filter-control.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/filter-control/bootstrap-table-filter-control.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/filter/bootstrap-table-filter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/filter/bootstrap-table-filter.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/flat-json/bootstrap-table-flat-json.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/flat-json/bootstrap-table-flat-json.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/group-by-v2/bootstrap-table-group-by.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/group-by-v2/bootstrap-table-group-by.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/group-by-v2/bootstrap-table-group-by.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/group-by/bootstrap-table-group-by.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/group-by/bootstrap-table-group-by.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/group-by/bootstrap-table-group-by.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/i18n-enhance/bootstrap-table-i18n-enhance.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/i18n-enhance/bootstrap-table-i18n-enhance.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/key-events/bootstrap-table-key-events.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/key-events/bootstrap-table-key-events.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/mobile/bootstrap-table-mobile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/mobile/bootstrap-table-mobile.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multi-column-toggle/bootstrap-table-multi-toggle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multi-column-toggle/bootstrap-table-multi-toggle.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multiple-search/bootstrap-table-multiple-search.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multiple-search/bootstrap-table-multiple-search.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multiple-sort/bootstrap-table-multiple-sort.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/multiple-sort/bootstrap-table-multiple-sort.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/natural-sorting/bootstrap-table-natural-sorting.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/natural-sorting/bootstrap-table-natural-sorting.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/print/bootstrap-table-print.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/print/bootstrap-table-print.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/reorder-columns/bootstrap-table-reorder-columns.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/reorder-columns/bootstrap-table-reorder-columns.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/reorder-rows/bootstrap-table-reorder-rows.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/reorder-rows/bootstrap-table-reorder-rows.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/reorder-rows/bootstrap-table-reorder-rows.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/resizable/bootstrap-table-resizable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/resizable/bootstrap-table-resizable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/select2-filter/bootstrap-table-select2-filter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/select2-filter/bootstrap-table-select2-filter.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/sticky-header/bootstrap-table-sticky-header.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/sticky-header/bootstrap-table-sticky-header.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/sticky-header/bootstrap-table-sticky-header.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/toolbar/bootstrap-table-toolbar.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/toolbar/bootstrap-table-toolbar.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/tree-column/bootstrap-table-tree-column.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/tree-column/bootstrap-table-tree-column.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/extensions/tree-column/bootstrap-table-tree-column.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-af-ZA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-af-ZA.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ar-SA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ar-SA.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ca-ES.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ca-ES.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-cs-CZ.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-cs-CZ.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-da-DK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-da-DK.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-de-DE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-de-DE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-el-GR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-el-GR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-en-US.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-en-US.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-AR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-AR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-CL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-CL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-CR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-CR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-ES.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-ES.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-MX.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-MX.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-NI.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-NI.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-SP.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-es-SP.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-et-EE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-et-EE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-fa-IR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-fa-IR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-fr-BE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-fr-BE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-fr-FR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-fr-FR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-he-IL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-he-IL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-hr-HR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-hr-HR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-hu-HU.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-hu-HU.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-id-ID.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-id-ID.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-it-IT.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-it-IT.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ja-JP.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ja-JP.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ka-GE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ka-GE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ko-KR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ko-KR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ms-MY.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ms-MY.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-nb-NO.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-nb-NO.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-nl-NL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-nl-NL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-pl-PL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-pl-PL.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-pt-BR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-pt-BR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-pt-PT.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-pt-PT.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ro-RO.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ro-RO.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ru-RU.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ru-RU.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-sk-SK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-sk-SK.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-sv-SE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-sv-SE.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-th-TH.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-th-TH.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-tr-TR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-tr-TR.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-uk-UA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-uk-UA.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ur-PK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-ur-PK.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-uz-Latn-UZ.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-uz-Latn-UZ.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-vi-VN.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-vi-VN.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-zh-CN.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-zh-CN.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-zh-TW.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/dist/locale/bootstrap-table-zh-TW.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/documentation.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/donate.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/examples.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/extensions.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/faq.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/getting-started.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/index.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/robots.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/docs/sitemap.xml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/bootstrap-table.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/bootstrap-table.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/accent-neutralise/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/accent-neutralise/bootstrap-table-accent-neutralise.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/accent-neutralise/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/angular/bootstrap-table-angular.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/auto-refresh/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/auto-refresh/bootstrap-table-auto-refresh.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/auto-refresh/bootstrap-table-auto-refresh.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/auto-refresh/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/click-edit-row/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/click-edit-row/bootstrap-table-click-edit-row.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/click-edit-row/bootstrap-table-click-edit-row.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/cookie/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/cookie/bootstrap-table-cookie.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/cookie/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/copy-rows/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/copy-rows/bootstrap-table-copy-rows.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/copy-rows/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/editable/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/editable/bootstrap-table-editable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/editable/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/export/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/export/bootstrap-table-export.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/export/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/filter-control/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/filter-control/bootstrap-table-filter-control.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/filter-control/bootstrap-table-filter-control.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/filter-control/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/filter/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/filter/bootstrap-table-filter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/filter/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/flat-json/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/flat-json/bootstrap-table-flat-json.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/flat-json/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by-v2/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by-v2/bootstrap-table-group-by.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by-v2/bootstrap-table-group-by.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by-v2/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by/bootstrap-table-group-by.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by/bootstrap-table-group-by.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/group-by/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/i18n-enhance/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/i18n-enhance/bootstrap-table-i18n-enhance.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/i18n-enhance/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/key-events/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/key-events/bootstrap-table-key-events.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/key-events/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/mobile/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/mobile/bootstrap-table-mobile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/mobile/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multi-column-toggle/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multi-column-toggle/bootstrap-table-multi-toggle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multi-column-toggle/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-search/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-search/bootstrap-table-multiple-search.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-search/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-selection-row/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-selection-row/bootstrap-table-multiple-selection-row.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-selection-row/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-sort/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-sort/bootstrap-table-multiple-sort.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/multiple-sort/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/natural-sorting/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/natural-sorting/bootstrap-table-natural-sorting.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/natural-sorting/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/print/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/print/bootstrap-table-print.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/reorder-columns/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/reorder-columns/bootstrap-table-reorder-columns.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/reorder-columns/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/reorder-rows/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/reorder-rows/bootstrap-table-reorder-rows.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/reorder-rows/bootstrap-table-reorder-rows.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/reorder-rows/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/resizable/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/resizable/bootstrap-table-resizable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/resizable/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/select2-filter/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/select2-filter/bootstrap-table-select2-filter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/select2-filter/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/sticky-header/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/sticky-header/bootstrap-table-sticky-header.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/sticky-header/bootstrap-table-sticky-header.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/sticky-header/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/toolbar/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/toolbar/bootstrap-table-toolbar.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/toolbar/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/tree-column/bootstrap-table-tree-column.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/tree-column/bootstrap-table-tree-column.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/tree-column/bootstrap-table-tree-column.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/extensions/tree-column/extension.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-af-ZA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ar-SA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ca-ES.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-cs-CZ.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-da-DK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-de-DE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-el-GR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-en-US.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-en-US.js.template" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-es-AR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-es-CL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-es-CR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-es-ES.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-es-MX.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-es-NI.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-es-SP.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-et-EE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-fa-IR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-fr-BE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-fr-FR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-he-IL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-hr-HR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-hu-HU.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-id-ID.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-it-IT.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ja-JP.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ka-GE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ko-KR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ms-MY.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-nb-NO.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-nl-NL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-pl-PL.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-pt-BR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-pt-PT.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ro-RO.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ru-RU.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-sk-SK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-sv-SE.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-th-TH.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-tr-TR.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-uk-UA.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-ur-PK.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-uz-Latn-UZ.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-vi-VN.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-zh-CN.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-table/src/locale/bootstrap-table-zh-TW.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/bootstrap-tagsinput.jquery.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput-angular.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput-angular.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput-angular.min.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput-typeahead.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/dist/bootstrap-tagsinput.min.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/assets/app.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/assets/app.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/assets/app_bs2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/assets/app_bs3.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/assets/cities.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/assets/citynames.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/bootstrap-2.3.2.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/examples/index.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/karma.conf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/src/bootstrap-tagsinput-angular.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/src/bootstrap-tagsinput-typeahead.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/src/bootstrap-tagsinput.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/src/bootstrap-tagsinput.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/bootstrap-tagsinput-angular.tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/bootstrap-tagsinput/events.tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/bootstrap-tagsinput/input_with_object_items.tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/bootstrap-tagsinput/input_with_string_items.tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/bootstrap-tagsinput/reproduced_bugs.tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/bootstrap-tagsinput/select_with_object_items.tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/bootstrap-tagsinput/select_with_string_items.tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/helpers.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap-tagsinput/test/index.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap-theme.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap-theme.css.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap-theme.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap-theme.min.css.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap.css.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/css/bootstrap.min.css.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/fonts/glyphicons-halflings-regular.svg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/js/bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/js/bootstrap.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/dist/js/npm.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/fonts/glyphicons-halflings-regular.svg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/bs-commonjs-generator.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/bs-glyphicons-data-generator.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/bs-lessdoc-parser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/bs-raw-files-generator.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/change-version.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/configBridge.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/npm-shrinkwrap.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/grunt/sauce_browsers.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/affix.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/alert.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/button.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/carousel.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/collapse.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/dropdown.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/modal.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/popover.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/scrollspy.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/tab.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/tooltip.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/js/transition.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/alerts.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/badges.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/bootstrap.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/breadcrumbs.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/button-groups.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/buttons.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/carousel.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/close.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/code.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/component-animations.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/dropdowns.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/forms.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/glyphicons.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/grid.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/input-groups.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/jumbotron.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/labels.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/list-group.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/media.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/alerts.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/background-variant.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/border-radius.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/buttons.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/center-block.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/clearfix.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/forms.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/gradients.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/grid-framework.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/grid.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/hide-text.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/image.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/labels.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/list-group.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/nav-divider.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/nav-vertical-align.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/opacity.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/pagination.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/panels.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/progress-bar.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/reset-filter.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/reset-text.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/resize.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/responsive-visibility.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/size.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/tab-focus.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/table-row.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/text-emphasis.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/text-overflow.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/mixins/vendor-prefixes.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/modals.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/navbar.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/navs.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/normalize.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/pager.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/pagination.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/panels.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/popovers.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/print.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/progress-bars.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/responsive-embed.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/responsive-utilities.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/scaffolding.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/tables.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/theme.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/thumbnails.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/tooltip.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/type.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/utilities.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/variables.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/less/wells.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/bootstrap/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/CONTRIBUTING.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/appveyor.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/internal-tasks/bump.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/internal-tasks/subgrunt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/cli.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/config.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/event.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/fail.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/file.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/help.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/option.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/task.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/grunt/template.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/lib/util/task.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/.bin/cake" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/.bin/coffee" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/.bin/js-yaml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/.bin/nopt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/.bin/rimraf" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/.bin/which" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/.gitmodules" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/Makefile" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/lib/async.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/async/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/CNAME" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/README" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/Rakefile" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/bin/cake" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/bin/coffee" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/extras/jsl.conf" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/browser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/cake.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/coffee-script.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/command.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/grammar.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/helpers.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/lexer.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/nodes.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/optparse.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/parser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/repl.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/rewriter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/lib/coffee-script/scope.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/coffee-script/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/MIT-LICENSE.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/ReadMe.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/colors.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/example.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/example.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/themes/winston-dark.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/colors/themes/winston-light.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/dateformat/Readme.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/dateformat/lib/dateformat.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/dateformat/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/dateformat/test/test_weekofyear.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/dateformat/test/test_weekofyear.sh" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/eventemitter2/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/eventemitter2/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/eventemitter2/lib/eventemitter2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/eventemitter2/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/lib/exit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/exit_test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/10-stderr.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/10-stdout-stderr.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/10-stdout.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/100-stderr.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/100-stdout-stderr.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/100-stdout.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/1000-stderr.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/1000-stdout-stderr.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/1000-stdout.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/create-files.sh" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/log-broken.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/exit/test/fixtures/log.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/lib/findup-sync.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/examples/g.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/examples/usr-local.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/glob.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/inherits/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/inherits/inherits.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/inherits/inherits_browser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/inherits/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/minimatch.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/CONTRIBUTORS" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/lib/lru-cache.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/test/basic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/test/foreach.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/test/memory-leak.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/lru-cache/test/serialize.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/sigmund/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/sigmund/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/sigmund/bench.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/sigmund/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/sigmund/sigmund.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/node_modules/sigmund/test/basic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/test/basic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/test/brace-expand.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/test/caching.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/test/defaults.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/node_modules/minimatch/test/extglob-ending-with-state-char.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/00-setup.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/bash-comparison.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/bash-results.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/cwd-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/globstar-match.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/mark.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/new-glob-optional-options.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/nocase-nomagic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/pause-resume.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/readme-issue.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/root-nomount.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/root.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/stat.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/glob/test/zz-cleanup.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/LICENSE.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/dist/lodash.compat.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/dist/lodash.compat.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/dist/lodash.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/dist/lodash.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/dist/lodash.underscore.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/dist/lodash.underscore.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/lodash.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/node_modules/lodash/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/test/findup-sync_test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/test/fixtures/a.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/test/fixtures/a/b/bar.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/test/fixtures/a/foo.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/findup-sync/test/fixtures/aaa.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/lib/getobject.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/getobject/test/namespace_test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/examples/g.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/examples/usr-local.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/glob.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/graceful-fs/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/graceful-fs/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/graceful-fs/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/graceful-fs/graceful-fs.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/graceful-fs/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/graceful-fs/test/open.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/graceful-fs/test/ulimit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/inherits/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/inherits/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/inherits/inherits.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/node_modules/inherits/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/00-setup.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/bash-comparison.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/bash-results.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/cwd-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/mark.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/nocase-nomagic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/pause-resume.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/root-nomount.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/root.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/glob/test/zz-cleanup.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/examples.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/grunt-legacy-log-utils/test/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/LICENSE.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.compat.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.compat.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.underscore.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/dist/lodash.underscore.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/lodash.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/lodash/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/Gemfile" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/Gemfile.lock" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/README.markdown" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/Rakefile" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/component.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/dist/underscore.string.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/lib/underscore.string.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/libpeerconnection.log" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/run-qunit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/speed.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/strings.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/strings_standalone.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_standalone.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/arrays.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/chaining.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/collections.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/functions.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/index.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/objects.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/speed.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/utility.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/jslitmus.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/qunit.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/test_underscore/vendor/qunit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/node_modules/underscore.string/test/underscore.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-log/test/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/fixtures/Gruntfile-execArgv-child.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/fixtures/Gruntfile-execArgv.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/fixtures/Gruntfile-print-text.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/fixtures/exec.cmd" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/fixtures/exec.sh" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/fixtures/spawn-multibyte.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/fixtures/spawn.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/grunt-legacy-util/test/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/child.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/dist/ba-hooker.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/dist/ba-hooker.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/grunt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/lib/hooker.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/parent.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/hooker/test/hooker_test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/encodings/big5.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/encodings/gbk.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/encodings/singlebyte.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/encodings/table/big5.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/encodings/table/gbk.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/generation/generate-big5-table.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/generation/generate-singlebyte.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/big5-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/big5File.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/cyrillic-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/gbk-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/gbkFile.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/greek-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/main-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/performance.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/iconv-lite/test/turkish-test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/HISTORY.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/bin/js-yaml.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/examples/custom_types.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/examples/custom_types.yaml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/examples/dumper.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/examples/dumper.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/examples/sample_document.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/examples/sample_document.yaml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/common.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/dumper.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/exception.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/loader.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/mark.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/require.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/schema.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/schema/default.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/schema/minimal.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/schema/safe.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/binary.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/bool.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/float.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/int.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/js/function.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/map.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/merge.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/null.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/omap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/pairs.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/seq.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/set.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/str.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/lib/js-yaml/type/timestamp.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/.bin/esparse" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/.bin/esvalidate" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/HISTORY.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/arguments.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/choice.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/constants.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/help.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/nargs.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/parents.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/prefix_chars.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/sub_commands.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/sum.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/examples/testformatters.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/append.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/append/constant.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/count.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/help.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/store.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/store/constant.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/store/false.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/store/true.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/subparsers.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action/version.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/action_container.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/argparse.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/argument/error.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/argument/exclusive.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/argument/group.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/argument_parser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/const.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/help/added_formatters.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/help/formatter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/lib/namespace.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/README.markdown" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/component.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/foo.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/gulpfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/lib/underscore.string.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/libpeerconnection.log" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore.string/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore/underscore-min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/node_modules/underscore/underscore.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/argparse/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/bin/esparse.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/bin/esvalidate.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/esprima.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/test/compat.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/test/reflect.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/test/run.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/test/runner.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/node_modules/esprima/test/test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/js-yaml/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/lodash/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/lodash/lodash.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/lodash/lodash.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/lodash/lodash.underscore.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/lodash/lodash.underscore.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/lodash/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/minimatch.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/CONTRIBUTORS" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/lib/lru-cache.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/test/basic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/test/foreach.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/test/memory-leak.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/lru-cache/test/serialize.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/sigmund/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/sigmund/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/sigmund/bench.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/sigmund/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/sigmund/sigmund.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/node_modules/sigmund/test/basic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/test/basic.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/test/brace-expand.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/test/caching.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/test/defaults.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/minimatch/test/extglob-ending-with-state-char.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/bin/nopt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/examples/my-program.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/lib/nopt.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/node_modules/abbrev/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/node_modules/abbrev/abbrev.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/node_modules/abbrev/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/nopt/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/AUTHORS" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/bin.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/rimraf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/test/run.sh" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/test/setup.sh" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/test/test-async.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/rimraf/test/test-sync.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/Gemfile" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/Gemfile.lock" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/README.markdown" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/Rakefile" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/dist/underscore.string.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/lib/underscore.string.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/run-qunit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/speed.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/strings.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/strings_standalone.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_standalone.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/arrays.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/chaining.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/collections.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/functions.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/objects.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/speed.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/temp.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/temp_tests.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/test.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/utility.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/vendor/jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/vendor/jslitmus.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/vendor/qunit.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/test_underscore/vendor/qunit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/underscore.string/test/underscore.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/which/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/which/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/which/bin/which" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/which/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/node_modules/which/which.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/grunt/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/AUTHORS.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/LICENSE.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/dist/core.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/dist/jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/dist/jquery.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/dist/jquery.min.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/dist/jquery.slim.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/dist/jquery.slim.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/dist/jquery.slim.min.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/external/sizzle/LICENSE.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/external/sizzle/dist/sizzle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/external/sizzle/dist/sizzle.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/external/sizzle/dist/sizzle.min.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/.eslintrc.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/jsonp.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/load.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/parseXML.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/script.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/var/location.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/var/nonce.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/var/rquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/ajax/xhr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/attributes.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/attributes/attr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/attributes/classes.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/attributes/prop.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/attributes/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/attributes/val.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/callbacks.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/DOMEval.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/access.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/init.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/parseHTML.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/ready-no-deferred.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/ready.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/readyException.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/stripAndCollapse.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/core/var/rsingleTag.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/addGetHookIf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/adjustCSS.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/curCSS.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/hiddenVisibleSelectors.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/showHide.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/var/cssExpand.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/var/getStyles.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/var/isHiddenWithinTree.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/var/rmargin.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/var/rnumnonpx.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/css/var/swap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/data.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/data/Data.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/data/var/acceptData.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/data/var/dataPriv.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/data/var/dataUser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/deferred.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/deferred/exceptionHook.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/deprecated.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/dimensions.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/effects.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/effects/Tween.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/effects/animatedSelector.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/event.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/event/ajax.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/event/alias.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/event/focusin.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/event/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/event/trigger.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/exports/amd.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/exports/global.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/_evalUrl.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/buildFragment.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/getAll.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/setGlobalEval.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/var/rcheckableType.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/var/rscriptType.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/var/rtagName.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/manipulation/wrapMap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/offset.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/queue.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/queue/delay.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/selector-native.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/selector-sizzle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/selector.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/serialize.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/traversing.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/traversing/findFilter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/traversing/var/dir.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/traversing/var/rneedsContext.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/traversing/var/siblings.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/ObjectFunctionString.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/arr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/class2type.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/concat.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/document.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/documentElement.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/fnToString.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/getProto.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/hasOwn.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/indexOf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/pnum.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/push.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/rcssNum.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/rnothtmlwhite.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/slice.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/var/toString.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jquery/src/wrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/external/jquery/jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/index.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.structure.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.structure.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.theme.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/jquery-ui.theme.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/jqueryui/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/.gitattributes" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/.jscsrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/CHANGELOG.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/build/toastr.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/build/toastr.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/build/toastr.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/build/toastr.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/demo.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/gulpfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/karma.conf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/content/content/toastr.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/content/content/toastr.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/content/content/toastr.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/content/content/toastr.scss" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/content/scripts/toastr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/content/scripts/toastr.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/content/scripts/toastr.min.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.0.3.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.4.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.4.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.4.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.1.5.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.2.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.2.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.2.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.3.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.1.3.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.0-rc1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/nuget/toastr.2.0.3.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/.gitattributes" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/.jscsrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/CHANGELOG.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/build/toastr.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/build/toastr.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/build/toastr.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/demo.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/gulpfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/karma.conf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/content/content/toastr.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/content/content/toastr.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/content/content/toastr.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/content/content/toastr.scss" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/content/scripts/toastr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/content/scripts/toastr.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/content/scripts/toastr.min.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.0.3.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.4.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.4.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.4.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.1.5.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.2.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.2.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.2.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.3.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.1.3.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.0-rc1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/nuget/toastr.2.0.3.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/.gitattributes" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/.jscsrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/CHANGELOG.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/build/toastr.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/build/toastr.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/build/toastr.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/demo.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/gulpfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/karma.conf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/content/content/toastr.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/content/content/toastr.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/content/content/toastr.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/content/content/toastr.scss" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/content/scripts/toastr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/content/scripts/toastr.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/content/scripts/toastr.min.js.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.0.3.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.4.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.4.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.4.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.1.5.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.2.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.2.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.2.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.3.0.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.1.3.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.0-rc1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.1.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.2.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/nuget/toastr.2.0.3.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/readme.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/release checklist.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/tests/qunit/qunit.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/tests/qunit/qunit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/tests/toastr-tests.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/tests/unit/qunit-helper.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/tests/unit/toastr-tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/tests/unit/x.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/toastr.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/toastr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/toastr.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/package/toastr.scss" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/readme.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/release checklist.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/tests/qunit/qunit.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/tests/qunit/qunit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/tests/toastr-tests.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/tests/unit/qunit-helper.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/tests/unit/toastr-tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/tests/unit/x.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/toastr.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/toastr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/toastr.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/package/toastr.scss" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/release checklist.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/tests/qunit/qunit.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/tests/qunit/qunit.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/tests/toastr-tests.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/tests/unit/qunit-helper.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/tests/unit/toastr-tests.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/tests/unit/x.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/toastr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/toastr.less" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/toastr/toastr.scss" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/.jshintrc" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/.travis.yml" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/CHANGELOG.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/CONTRIBUTING.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/LICENSE" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/composer.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/dist/bloodhound.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/dist/bloodhound.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/dist/typeahead.bundle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/dist/typeahead.bundle.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/dist/typeahead.jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/dist/typeahead.jquery.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/doc/bloodhound.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/doc/jquery_typeahead.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/doc/migration/0.10.0.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/karma.conf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/AUTHORS.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/LICENSE.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/dist/core.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/dist/jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/dist/jquery.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/dist/jquery.min.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/dist/jquery.slim.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/dist/jquery.slim.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/dist/jquery.slim.min.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/external/sizzle/LICENSE.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/external/sizzle/dist/sizzle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/external/sizzle/dist/sizzle.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/external/sizzle/dist/sizzle.min.map" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/.eslintrc.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/jsonp.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/load.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/parseXML.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/script.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/var/location.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/var/nonce.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/var/rquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/ajax/xhr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/attributes.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/attributes/attr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/attributes/classes.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/attributes/prop.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/attributes/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/attributes/val.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/callbacks.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/DOMEval.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/access.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/init.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/parseHTML.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/ready-no-deferred.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/ready.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/readyException.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/stripAndCollapse.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/core/var/rsingleTag.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/addGetHookIf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/adjustCSS.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/curCSS.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/hiddenVisibleSelectors.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/showHide.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/var/cssExpand.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/var/getStyles.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/var/isHiddenWithinTree.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/var/rmargin.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/var/rnumnonpx.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/css/var/swap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/data.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/data/Data.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/data/var/acceptData.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/data/var/dataPriv.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/data/var/dataUser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/deferred.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/deferred/exceptionHook.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/deprecated.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/dimensions.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/effects.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/effects/Tween.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/effects/animatedSelector.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/event.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/event/ajax.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/event/alias.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/event/focusin.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/event/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/event/trigger.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/exports/amd.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/exports/global.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/jquery.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/_evalUrl.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/buildFragment.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/getAll.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/setGlobalEval.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/var/rcheckableType.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/var/rscriptType.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/var/rtagName.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/manipulation/wrapMap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/offset.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/queue.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/queue/delay.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/selector-native.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/selector-sizzle.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/selector.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/serialize.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/traversing.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/traversing/findFilter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/traversing/var/dir.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/traversing/var/rneedsContext.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/traversing/var/siblings.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/ObjectFunctionString.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/arr.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/class2type.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/concat.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/document.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/documentElement.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/fnToString.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/getProto.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/hasOwn.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/indexOf.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/pnum.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/push.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/rcssNum.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/rnothtmlwhite.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/slice.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/support.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/var/toString.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/node_modules/jquery/src/wrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/bloodhound.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/lru_cache.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/options_parser.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/persistent_storage.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/prefetch.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/remote.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/search_index.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/tokenizers.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/transport.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/bloodhound/version.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/common/utils.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/dataset.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/default_menu.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/event_bus.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/event_emitter.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/highlight.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/input.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/menu.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/plugin.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/typeahead.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/src/typeahead/www.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/bloodhound_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/lru_cache_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/options_parser_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/persistent_storage_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/prefetch_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/remote_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/search_index_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/tokenizers_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/bloodhound/transport_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/ci" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/fixtures/ajax_responses.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/fixtures/data.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/fixtures/html.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/helpers/typeahead_mocks.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/integration/test.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/integration/test.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/playground.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/dataset_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/default_results_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/event_bus_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/event_emitter_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/highlight_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/input_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/plugin_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/results_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/test/typeahead/typeahead_spec.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/typeahead.js/typeahead.js.jquery.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/.npmignore" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/CHANGELOG.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/Gruntfile.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/Package.nuspec" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/bower.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/composer.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/CHANGELOG.txt" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/LICENSE-MIT" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/README.md" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap-editable/css/bootstrap-editable.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap-editable/js/bootstrap-editable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap-editable/js/bootstrap-editable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap3-editable/css/bootstrap-editable.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/bootstrap3-editable/js/bootstrap-editable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/address/address.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/address/address.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/typeaheadjs/lib/typeahead.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/typeaheadjs/lib/typeahead.js-bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/typeaheadjs/typeaheadjs.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysiwyg-color.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/inputs-ext/wysihtml5/wysihtml5.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/css/jquery-editable.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.3.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.3.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/js/jquery-ui-1.10.3.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/jquery-ui-datepicker/js/jquery-ui-1.10.3.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/js/jquery-editable-poshytip.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jquery-editable/js/jquery-editable-poshytip.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jqueryui-editable/css/jqueryui-editable.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jqueryui-editable/js/jqueryui-editable.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/dist/jqueryui-editable/js/jqueryui-editable.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/package.json" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/containers/editable-container.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/containers/editable-container.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/containers/editable-inline.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/containers/editable-popover.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/containers/editable-popover3.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/containers/editable-poshytip.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/containers/editable-tooltip.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/editable-form/editable-form-bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/editable-form/editable-form-bootstrap3.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/editable-form/editable-form-jqueryui.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/editable-form/editable-form-utils.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/editable-form/editable-form.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/editable-form/editable-form.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/element/editable-element.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/element/editable-element.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/address/address.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/address/address.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/typeaheadjs/lib/typeahead.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/typeaheadjs/lib/typeahead.js-bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/typeaheadjs/typeaheadjs.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysiwyg-color.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs-ext/wysihtml5/wysihtml5.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/abstract.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/checklist.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/combodate/combodate.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/combodate/lib/combodate.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/combodate/lib/moment.min.1.7.2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/combodate/lib/moment.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/date/bootstrap-datepicker/css/datepicker.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/date/bootstrap-datepicker/js/bootstrap-datepicker.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/date/date.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/date/datefield.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/datetime/bootstrap-datetimepicker/css/datetimepicker.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/datetime/bootstrap-datetimepicker/js/bootstrap-datetimepicker.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/datetime/datetime.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/datetime/datetimefield.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/dateui.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/dateuifield.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.1.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.1.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.2.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.2.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.3.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.10.3.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.9.1.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/css/redmond/jquery-ui-1.9.1.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.10.1.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.10.1.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.10.2.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.10.2.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.10.3.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.10.3.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.9.1.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/dateui/jquery-ui-datepicker/js/jquery-ui-1.9.1.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/html5types.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/list.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/lib/select2-bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/lib/select2.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/lib/select2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/lib/select2.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/select2/select2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/text.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/textarea.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/src/inputs/typeahead.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/coverage" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/index.html" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/css/bootstrap-responsive.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/css/bootstrap-responsive.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/css/bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/css/bootstrap.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/js/bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap221/js/bootstrap.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/css/bootstrap-responsive.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/css/bootstrap-responsive.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/css/bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/css/bootstrap.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/js/bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap222/js/bootstrap.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/css/bootstrap-responsive.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/css/bootstrap-responsive.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/css/bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/css/bootstrap.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/js/bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap231/js/bootstrap.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/css/bootstrap-responsive.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/css/bootstrap-responsive.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/css/bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/css/bootstrap.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/js/bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap232/js/bootstrap.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/css/bootstrap-theme.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/css/bootstrap-theme.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/css/bootstrap.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/css/bootstrap.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/fonts/glyphicons-halflings-regular.svg" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/js/bootstrap.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/bootstrap300/js/bootstrap.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/jquery-ui-1.10.1.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/css/redmond/jquery-ui-1.10.1.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/js/jquery-1.9.1.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/js/jquery-ui-1.10.1.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.1.custom/js/jquery-ui-1.10.1.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/jquery-ui-1.10.2.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/css/redmond/jquery-ui-1.10.2.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/js/jquery-1.9.1.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/js/jquery-ui-1.10.2.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.2.custom/js/jquery-ui-1.10.2.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/jquery-ui-1.10.3.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/css/redmond/jquery-ui-1.10.3.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/js/jquery-1.9.1.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/js/jquery-ui-1.10.3.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.10.3.custom/js/jquery-ui-1.10.3.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/jquery-ui-1.9.1.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/redmond/jquery-ui-1.9.1.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/jquery-ui-1.9.1.custom.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/css/smoothness/jquery-ui-1.9.1.custom.min.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/jquery.ui.datepicker-ru.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/js/jquery-1.8.2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/js/jquery-ui-1.9.1.custom.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery-ui-1.9.1.custom/js/jquery-ui-1.9.1.custom.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery/jquery-1.8.2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery/jquery-1.8.2.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery/jquery-1.9.0.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery/jquery-1.9.1.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/jquery/jquery-1.9.1.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/mockjax/jquery.mockjax.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/poshytip/jquery.poshytip.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/poshytip/jquery.poshytip.min.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/poshytip/tip-yellowsimple/tip-yellowsimple.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/qunit/qunit-1.10.0.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/qunit/qunit-1.10.0.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/qunit/qunit-1.12.0.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/libs/qunit/qunit-1.12.0.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/loader.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/main.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/mocks.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/require.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/style.css" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/api.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/checklist.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/combodate.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/common.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/date.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/datefield.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/datetime.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/datetimefield.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/dateui.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/dateuifield.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/select.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/select2.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/text.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/textarea.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/typeahead.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/typeaheadjs.js" />
-      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/x-editable/test/unit/wysihtml5.js" />
+    <list default="true" id="d9e16f0e-8983-42e1-b8ec-02cd8c802c46" name="Default" comment="">
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/.npmignore" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/LICENSE" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/README.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/dist/README.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/dist/vue-resource.common.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/dist/vue-resource.es2015.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/dist/vue-resource.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/dist/vue-resource.min.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/README.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/buffer-stream.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/get-stream/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/.travis.yml" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/LICENSE" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/README.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/browser.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/test.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/node_modules/prepend-http/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/node_modules/got/readme.md" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/package.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/client/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/client/jsonp.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/client/node.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/client/xdr.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/client/xhr.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/headers.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/interceptor/before.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/interceptor/body.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/interceptor/cors.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/interceptor/header.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/interceptor/jsonp.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/interceptor/method.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/request.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/http/response.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/lib/promise.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/lib/url-template.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/promise.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/resource.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/url/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/url/query.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/url/root.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/url/template.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/src/util.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/data/invalid.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/data/text.txt" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/data/valid.json" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/http.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/http.test.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/index.html" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/index.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/promise.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/resource.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/url.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/test/webpack.config.js" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/public/node_modules/vue-resource/yarn.lock" />
+      <change type="NEW" beforePath="" afterPath="$PROJECT_DIR$/resources/views/web/form/invite_vue.blade.php" />
       <change type="MODIFICATION" beforePath="$PROJECT_DIR$/.idea/deployment.xml" afterPath="$PROJECT_DIR$/.idea/deployment.xml" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/.idea/webServers.xml" afterPath="$PROJECT_DIR$/.idea/webServers.xml" />
       <change type="MODIFICATION" beforePath="$PROJECT_DIR$/.idea/workspace.xml" afterPath="$PROJECT_DIR$/.idea/workspace.xml" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/app/Helpers/functions.php" afterPath="$PROJECT_DIR$/app/Helpers/functions.php" />
       <change type="MODIFICATION" beforePath="$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php" afterPath="$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/app/Http/Controllers/Web/WechatController.php" afterPath="$PROJECT_DIR$/app/Http/Controllers/Web/WechatController.php" />
+      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/app/Http/Controllers/Web/FormAdminController.php" afterPath="$PROJECT_DIR$/app/Http/Controllers/Web/FormAdminController.php" />
       <change type="MODIFICATION" beforePath="$PROJECT_DIR$/app/Http/routes.php" afterPath="$PROJECT_DIR$/app/Http/routes.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/config/database.php" afterPath="$PROJECT_DIR$/config/database.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/public/assets/js/datalist.js" afterPath="$PROJECT_DIR$/public/assets/js/datalist.js" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/home.blade.php" afterPath="$PROJECT_DIR$/resources/views/home.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/layouts/app.blade.php" afterPath="$PROJECT_DIR$/resources/views/layouts/app.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/layouts/pub.blade.php" afterPath="$PROJECT_DIR$/resources/views/layouts/pub.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/notice.blade.php" afterPath="$PROJECT_DIR$/resources/views/notice.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/pub/info/info.blade.php" afterPath="$PROJECT_DIR$/resources/views/pub/info/info.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/form/admins.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/form/admins.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/form/create.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/form/create.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/form/custom.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/form/custom.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/form/datalist.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/form/datalist.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/form/noticeSetting.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/form/noticeSetting.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/form/publish.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/form/publish.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/form/summary.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/form/summary.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/web/wechat/platforms.blade.php" afterPath="$PROJECT_DIR$/resources/views/web/wechat/platforms.blade.php" />
-      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/resources/views/welcome.blade.php" afterPath="$PROJECT_DIR$/resources/views/welcome.blade.php" />
+      <change type="MODIFICATION" beforePath="$PROJECT_DIR$/app/User.php" afterPath="$PROJECT_DIR$/app/User.php" />
     </list>
     <ignored path="laravel-v5.2.15.iws" />
     <ignored path=".idea/workspace.xml" />
@@ -2257,6 +120,7 @@
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
     <option name="LAST_RESOLUTION" value="IGNORE" />
   </component>
+  <component name="ChangesViewManager" flattened_view="false" />
   <component name="CreatePatchCommitExecutor">
     <option name="PATCH_PATH" value="" />
   </component>
@@ -2284,85 +148,41 @@
   </component>
   <component name="FileEditorManager">
     <leaf SIDE_TABS_SIZE_LIMIT_KEY="300">
-      <file leaf-file-name="WechatController.php" pinned="false" current-in-tab="false">
-        <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Web/WechatController.php">
-          <provider selected="true" editor-type-id="text-editor">
-            <state relative-caret-position="208">
-              <caret line="302" column="34" lean-forward="false" selection-start-line="302" selection-start-column="34" selection-end-line="302" selection-end-column="34" />
-              <folding>
-                <element signature="e#20678#20852#0#PHP" expanded="false" />
-                <marker date="1489214474668" expanded="true" signature="7932:8171" ph="..." />
-                <marker date="1489214474668" expanded="true" signature="8470:8679" ph="..." />
-                <marker date="1489214474668" expanded="true" signature="8893:9170" ph="..." />
-              </folding>
-            </state>
-          </provider>
-        </entry>
-      </file>
-      <file leaf-file-name="TestController.php" pinned="false" current-in-tab="false">
-        <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php">
-          <provider selected="true" editor-type-id="text-editor">
-            <state relative-caret-position="369">
-              <caret line="19" column="21" lean-forward="false" selection-start-line="19" selection-start-column="21" selection-end-line="19" selection-end-column="21" />
-              <folding>
-                <element signature="e#44#74#0#PHP" expanded="true" />
-              </folding>
-            </state>
-          </provider>
-        </entry>
-      </file>
-      <file leaf-file-name="functions.php" pinned="false" current-in-tab="true">
-        <entry file="file://$PROJECT_DIR$/app/Helpers/functions.php">
+      <file leaf-file-name="routes.php" pinned="false" current-in-tab="true">
+        <entry file="file://$PROJECT_DIR$/app/Http/routes.php">
           <provider selected="true" editor-type-id="text-editor">
             <state relative-caret-position="330">
-              <caret line="21" column="28" lean-forward="false" selection-start-line="21" selection-start-column="28" selection-end-line="21" selection-end-column="28" />
+              <caret line="84" column="49" lean-forward="false" selection-start-line="84" selection-start-column="49" selection-end-line="84" selection-end-column="49" />
               <folding />
             </state>
           </provider>
         </entry>
       </file>
-      <file leaf-file-name="datalist.js" pinned="false" current-in-tab="false">
-        <entry file="file://$PROJECT_DIR$/public/assets/js/datalist.js">
+      <file leaf-file-name="FormAdminController.php" pinned="false" current-in-tab="false">
+        <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Web/FormAdminController.php">
           <provider selected="true" editor-type-id="text-editor">
-            <state relative-caret-position="199">
-              <caret line="70" column="28" lean-forward="false" selection-start-line="70" selection-start-column="28" selection-end-line="70" selection-end-column="29" />
-              <folding>
-                <marker date="1489216682400" expanded="true" signature="4074:4088" ph="..." />
-                <marker date="1489216682400" expanded="true" signature="4695:4709" ph="..." />
-                <marker date="1489216682400" expanded="true" signature="5459:5484" ph="..." />
-                <marker date="1489216682400" expanded="true" signature="5613:5637" ph="..." />
-                <marker date="1489216682400" expanded="true" signature="5758:5782" ph="..." />
-                <marker date="1489216682400" expanded="true" signature="6118:6162" ph="..." />
-              </folding>
-            </state>
-          </provider>
-        </entry>
-      </file>
-      <file leaf-file-name="home.blade.php" pinned="false" current-in-tab="false">
-        <entry file="file://$PROJECT_DIR$/resources/views/home.blade.php">
-          <provider selected="true" editor-type-id="text-editor">
-            <state relative-caret-position="158">
-              <caret line="229" column="12" lean-forward="true" selection-start-line="229" selection-start-column="12" selection-end-line="229" selection-end-column="12" />
+            <state relative-caret-position="308">
+              <caret line="138" column="31" lean-forward="false" selection-start-line="138" selection-start-column="20" selection-end-line="138" selection-end-column="31" />
               <folding />
             </state>
           </provider>
         </entry>
       </file>
-      <file leaf-file-name="routes.php" pinned="false" current-in-tab="false">
-        <entry file="file://$PROJECT_DIR$/app/Http/routes.php">
+      <file leaf-file-name="TestController.php" pinned="false" current-in-tab="false">
+        <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php">
           <provider selected="true" editor-type-id="text-editor">
-            <state relative-caret-position="149">
-              <caret line="64" column="29" lean-forward="true" selection-start-line="97" selection-start-column="16" selection-end-line="97" selection-end-column="42" />
+            <state relative-caret-position="220">
+              <caret line="19" column="47" lean-forward="false" selection-start-line="19" selection-start-column="25" selection-end-line="19" selection-end-column="47" />
               <folding />
             </state>
           </provider>
         </entry>
       </file>
-      <file leaf-file-name="app.blade.php" pinned="false" current-in-tab="false">
-        <entry file="file://$PROJECT_DIR$/resources/views/layouts/app.blade.php">
+      <file leaf-file-name="User.php" pinned="false" current-in-tab="false">
+        <entry file="file://$PROJECT_DIR$/app/User.php">
           <provider selected="true" editor-type-id="text-editor">
-            <state relative-caret-position="330">
-              <caret line="90" column="32" lean-forward="false" selection-start-line="90" selection-start-column="32" selection-end-line="90" selection-end-column="32" />
+            <state relative-caret-position="347">
+              <caret line="32" column="30" lean-forward="false" selection-start-line="32" selection-start-column="30" selection-end-line="32" selection-end-column="30" />
               <folding />
             </state>
           </provider>
@@ -2380,7 +200,6 @@
   </component>
   <component name="FindInProjectRecents">
     <findStrings>
-      <find>form-group</find>
       <find>Cache::.*('pre_auth_code')</find>
       <find>rendered-form</find>
       <find>accordion</find>
@@ -2410,6 +229,7 @@
       <find>cdn.bootcss.com</find>
       <find>asset(\(.*\))</find>
       <find>cURL::</find>
+      <find>v-model</find>
     </findStrings>
     <replaceStrings>
       <replace>form-group col-xs-12 col-md-12</replace>
@@ -2433,18 +253,12 @@
   <component name="IdeDocumentHistory">
     <option name="CHANGED_PATHS">
       <list>
-        <option value="$PROJECT_DIR$/public/assets/css/welcome.scss" />
-        <option value="$PROJECT_DIR$/resources/assets/sass/demo.scss.css" />
-        <option value="$PROJECT_DIR$/resources/assets/sass/demo.scss" />
-        <option value="$PROJECT_DIR$/public/assets/css/welcome.css" />
-        <option value="$PROJECT_DIR$/resources/assets/sass/welcome.scss" />
         <option value="$PROJECT_DIR$/public/assets/css/app.css" />
         <option value="$PROJECT_DIR$/resources/views/welcome.blade.php" />
         <option value="$PROJECT_DIR$/resources/views/web/form/message.blade.php" />
         <option value="$PROJECT_DIR$/app/Http/Controllers/Auth/AuthController.php" />
         <option value="$PROJECT_DIR$/resources/views/web/emails/invite_msg.blade.php" />
         <option value="$PROJECT_DIR$/public/assets/js/admins.js" />
-        <option value="$PROJECT_DIR$/app/Http/Controllers/Web/FormAdminController.php" />
         <option value="$PROJECT_DIR$/app/Notice.php" />
         <option value="$PROJECT_DIR$/app/Http/Controllers/Web/ReviewController.php" />
         <option value="$PROJECT_DIR$/resources/views/web/form/noticeSetting.blade.php" />
@@ -2463,10 +277,8 @@
         <option value="$PROJECT_DIR$/app/Http/Controllers/Pub/InfoController.php" />
         <option value="$PROJECT_DIR$/resources/views/web/form/customReviewList.blade.php" />
         <option value="$PROJECT_DIR$/app/Form.php" />
-        <option value="$PROJECT_DIR$/.env" />
         <option value="$PROJECT_DIR$/resources/views/web/emails/customreview.blade.php" />
         <option value="$PROJECT_DIR$/app/Http/Controllers/Web/FormController.php" />
-        <option value="$PROJECT_DIR$/resources/views/auth/register.blade.php" />
         <option value="$PROJECT_DIR$/resources/views/web/wechat/platforms.blade.php" />
         <option value="$PROJECT_DIR$/resources/views/layouts/pub.blade.php" />
         <option value="$PROJECT_DIR$/resources/views/web/form/admins.blade.php" />
@@ -2477,13 +289,21 @@
         <option value="$PROJECT_DIR$/config/database.php" />
         <option value="$PROJECT_DIR$/.env_meizu" />
         <option value="$PROJECT_DIR$/.env_qcloud" />
-        <option value="$PROJECT_DIR$/app/Http/routes.php" />
         <option value="$PROJECT_DIR$/app/Http/Controllers/Web/WechatController.php" />
-        <option value="$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php" />
         <option value="$PROJECT_DIR$/resources/views/home.blade.php" />
         <option value="$PROJECT_DIR$/public/assets/js/datalist.js" />
         <option value="$PROJECT_DIR$/resources/views/layouts/app.blade.php" />
         <option value="$PROJECT_DIR$/app/Helpers/functions.php" />
+        <option value="$PROJECT_DIR$/resources/views/test.blade.php" />
+        <option value="$PROJECT_DIR$/resources/views/auth/register.blade.php" />
+        <option value="$PROJECT_DIR$/.env" />
+        <option value="$PROJECT_DIR$/resources/views/auth/login.blade.php" />
+        <option value="$PROJECT_DIR$/resources/views/web/form/invite_uncomplete_increase_condition.blade.php" />
+        <option value="$PROJECT_DIR$/app/User.php" />
+        <option value="$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php" />
+        <option value="$PROJECT_DIR$/app/Http/Controllers/Web/FormAdminController.php" />
+        <option value="$PROJECT_DIR$/app/Http/routes.php" />
+        <option value="$PROJECT_DIR$/resources/views/web/form/invite_vue.blade.php" />
       </list>
     </option>
   </component>
@@ -2509,9 +329,10 @@
   </component>
   <component name="PhpWorkspaceProjectConfiguration" backward_compatibility_performed="true" interpreter_name="PHP 7" />
   <component name="ProjectFrameBounds">
+    <option name="x" value="1366" />
     <option name="y" value="24" />
-    <option name="width" value="1366" />
-    <option name="height" value="744" />
+    <option name="width" value="1440" />
+    <option name="height" value="876" />
   </component>
   <component name="ProjectInspectionProfilesVisibleTreeState">
     <entry key="Project Default">
@@ -2547,6 +368,8 @@
       <foldersAlwaysOnTop value="true" />
     </navigator>
     <panes>
+      <pane id="Scratches" />
+      <pane id="Scope" />
       <pane id="ProjectPane">
         <subPane>
           <PATH>
@@ -2569,6 +392,86 @@
               <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
             </PATH_ELEMENT>
             <PATH_ELEMENT>
+              <option name="myItemId" value="resources" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="views" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+          </PATH>
+          <PATH>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.intellij.ide.projectView.impl.nodes.ProjectViewProjectNode" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="resources" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="views" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="web" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+          </PATH>
+          <PATH>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.intellij.ide.projectView.impl.nodes.ProjectViewProjectNode" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="resources" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="views" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="web" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="form" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+          </PATH>
+          <PATH>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.intellij.ide.projectView.impl.nodes.ProjectViewProjectNode" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="resources" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+          </PATH>
+          <PATH>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.intellij.ide.projectView.impl.nodes.ProjectViewProjectNode" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
               <option name="myItemId" value="public" />
               <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
             </PATH_ELEMENT>
@@ -2587,7 +490,7 @@
               <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
             </PATH_ELEMENT>
             <PATH_ELEMENT>
-              <option name="myItemId" value="storage" />
+              <option name="myItemId" value="node_modules" />
               <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
             </PATH_ELEMENT>
           </PATH>
@@ -2601,21 +504,53 @@
               <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
             </PATH_ELEMENT>
             <PATH_ELEMENT>
-              <option name="myItemId" value="app" />
+              <option name="myItemId" value="public" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="node_modules" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="vue-select2" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+          </PATH>
+          <PATH>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.intellij.ide.projectView.impl.nodes.ProjectViewProjectNode" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="FormReview" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="public" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="node_modules" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="vue-select2" />
+              <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
+            </PATH_ELEMENT>
+            <PATH_ELEMENT>
+              <option name="myItemId" value="demo" />
               <option name="myItemType" value="com.jetbrains.php.projectView.PhpTreeStructureProvider$1" />
             </PATH_ELEMENT>
           </PATH>
         </subPane>
       </pane>
-      <pane id="Scratches" />
-      <pane id="Scope" />
     </panes>
   </component>
   <component name="PropertiesComponent">
-    <property name="settings.editor.selected.configurable" value="reference.settingsdialog.IDE.editor.colors.Font" />
+    <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
     <property name="last_opened_file_path" value="$PROJECT_DIR$/resources/views" />
     <property name="WebServerToolWindowFactoryState" value="false" />
-    <property name="SearchEverywhereHistoryKey" value="app&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/layouts/app.blade.php&#10;Test&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Pub/TestController.php&#10;route&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/routes.php&#10;Wechat&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/WechatController.php&#10;database.&#9;FILE&#9;file:///home/lyndon/work/FormReview/config/database.php&#10;home&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/home.blade.php&#10;regist&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/auth/register.blade.php&#10;cus&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/custom.blade.php&#10;summ&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/summary.blade.php&#10;TestCon&#9;null&#9;null&#10;crea&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/create.blade.php&#10;create&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/create.blade.php&#10;Form&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormController.php&#10;Info&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Pub/InfoController.php&#10;info&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/pub/info/info.blade.php&#10;rout&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/routes.php&#10;data&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/datalist.js&#10;sum&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/summary.blade.php&#10;creat&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/create.blade.php&#10;notice&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/noticeSetting.blade.php&#10;getopen&#9;null&#9;null&#10;admins&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/admins.js&#10;Auth&#9;null&#9;null&#10;Home&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/HomeController.php&#10;email&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/auth/passwords/email.blade.php&#10;FormA&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormAdminController.php&#10;mess&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/message.blade.php&#10;css&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/css/app.css&#10;getReviews&#9;null&#9;null&#10;User&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/User.php&#10;forml&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/formlist.blade.php&#10;FormController&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormController.php&#10;rou&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/routes.php&#10;nav&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/nav.blade.php&#10;message&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/message.blade.php&#10;pla&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/wechat/platforms.blade.php&#10;wechatplateforms.js&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/wechatplateforms.js&#10;InfoCon&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Pub/InfoController.php&#10;FormDa&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/FormData.php&#10;form&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Form.php&#10;create_tab&#9;FILE&#9;file:///home/lyndon/work/FormReview/database/migrations/2016_11_17_084614_create_form_table.php&#10;admin&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/admins.js&#10;FormPo&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Policies/FormPolicy.php&#10;Review&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Policies/ReviewPolicy.php&#10;app.js&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/app.js&#10;Admin&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormAdminController.php&#10;admins.js&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/admins.js&#10;invi&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/invite.blade.php&#10;datali&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/datalist.js&#10;FormAd&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormAdminController.php" />
+    <property name="SearchEverywhereHistoryKey" value="User&#9;null&#9;null&#10;Test&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Pub/TestController.php&#10;FormAD&#9;null&#9;null&#10;route&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/routes.php&#10;meizu&#9;FILE&#9;file:///home/lyndon/work/FormReview/.env_meizu&#10;env&#9;FILE&#9;file:///home/lyndon/work/FormReview/.env&#10;regis&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/auth/register.blade.php&#10;login&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/auth/login.blade.php&#10;app&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/layouts/app.blade.php&#10;Wechat&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/WechatController.php&#10;database.&#9;FILE&#9;file:///home/lyndon/work/FormReview/config/database.php&#10;home&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/home.blade.php&#10;regist&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/auth/register.blade.php&#10;cus&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/custom.blade.php&#10;summ&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/summary.blade.php&#10;TestCon&#9;null&#9;null&#10;crea&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/create.blade.php&#10;create&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/create.blade.php&#10;Form&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormController.php&#10;Info&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Pub/InfoController.php&#10;info&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/pub/info/info.blade.php&#10;rout&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/routes.php&#10;data&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/datalist.js&#10;sum&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/summary.blade.php&#10;creat&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/create.blade.php&#10;notice&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/noticeSetting.blade.php&#10;getopen&#9;null&#9;null&#10;admins&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/admins.js&#10;Auth&#9;null&#9;null&#10;Home&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/HomeController.php&#10;email&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/auth/passwords/email.blade.php&#10;FormA&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormAdminController.php&#10;mess&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/message.blade.php&#10;css&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/css/app.css&#10;getReviews&#9;null&#9;null&#10;forml&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/formlist.blade.php&#10;FormController&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Web/FormController.php&#10;rou&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/routes.php&#10;nav&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/nav.blade.php&#10;message&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/form/message.blade.php&#10;pla&#9;FILE&#9;file:///home/lyndon/work/FormReview/resources/views/web/wechat/platforms.blade.php&#10;wechatplateforms.js&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/wechatplateforms.js&#10;InfoCon&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Http/Controllers/Pub/InfoController.php&#10;FormDa&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/FormData.php&#10;form&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Form.php&#10;create_tab&#9;FILE&#9;file:///home/lyndon/work/FormReview/database/migrations/2016_11_17_084614_create_form_table.php&#10;admin&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/admins.js&#10;FormPo&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Policies/FormPolicy.php&#10;Review&#9;FILE&#9;file:///home/lyndon/work/FormReview/app/Policies/ReviewPolicy.php&#10;app.js&#9;FILE&#9;file:///home/lyndon/work/FormReview/public/assets/js/app.js" />
     <property name="js.buildTools.gulp.gulp_package_dir" value="" />
     <property name="js-jscs-nodeInterpreter" value="C:\Program Files\nodejs\node.exe" />
     <property name="nodejs_interpreter_path" value="C:/Program Files/nodejs/node" />
@@ -2626,17 +561,17 @@
   </component>
   <component name="RecentsManager">
     <key name="MoveFile.RECENT_KEYS">
-      <recent name="$PROJECT_DIR$/public" />
       <recent name="$PROJECT_DIR$/public/node_modules" />
+      <recent name="$PROJECT_DIR$/public" />
       <recent name="D:\work\laravel-v5.2.15\resources\views\web\form" />
       <recent name="D:\work\laravel-v5.2.15\resources\views\layouts" />
       <recent name="D:\work\laravel-v5.2.15\resources\views\pub\info" />
     </key>
     <key name="CopyFile.RECENT_KEYS">
+      <recent name="$PROJECT_DIR$/resources/views/web/form" />
       <recent name="$PROJECT_DIR$" />
       <recent name="$PROJECT_DIR$/public/assets/js" />
       <recent name="$PROJECT_DIR$/resources/views/web/emails" />
-      <recent name="$PROJECT_DIR$/resources/views/web/form" />
       <recent name="$PROJECT_DIR$/storage/app/public" />
     </key>
   </component>
@@ -2793,7 +728,12 @@
       <workItem from="1489193916171" duration="215000" />
       <workItem from="1489198152769" duration="12000" />
       <workItem from="1489201131529" duration="5813000" />
-      <workItem from="1489211726529" duration="4567000" />
+      <workItem from="1489211726529" duration="4809000" />
+      <workItem from="1489279816906" duration="204000" />
+      <workItem from="1489286900906" duration="3693000" />
+      <workItem from="1489303089922" duration="261000" />
+      <workItem from="1489372071662" duration="548000" />
+      <workItem from="1489373805896" duration="13507000" />
     </task>
     <task id="LOCAL-00001" summary="jQuery FromBuilder">
       <created>1483242040682</created>
@@ -2935,11 +875,25 @@
       <option name="project" value="LOCAL" />
       <updated>1489194080642</updated>
     </task>
-    <option name="localTasksCounter" value="21" />
+    <task id="LOCAL-00021" summary="cdn.bootcss.com">
+      <created>1489217175811</created>
+      <option name="number" value="00021" />
+      <option name="presentableId" value="LOCAL-00021" />
+      <option name="project" value="LOCAL" />
+      <updated>1489217175811</updated>
+    </task>
+    <task id="LOCAL-00022" summary="">
+      <created>1489290384416</created>
+      <option name="number" value="00022" />
+      <option name="presentableId" value="LOCAL-00022" />
+      <option name="project" value="LOCAL" />
+      <updated>1489290384416</updated>
+    </task>
+    <option name="localTasksCounter" value="23" />
     <servers />
   </component>
   <component name="TimeTrackingManager">
-    <option name="totallyTimeSpent" value="648226000" />
+    <option name="totallyTimeSpent" value="666681000" />
   </component>
   <component name="TodoView">
     <todo-panel id="selected-file">
@@ -2951,27 +905,27 @@
     </todo-panel>
   </component>
   <component name="ToolWindowManager">
-    <frame x="0" y="24" width="1366" height="744" extended-state="6" />
+    <frame x="1366" y="24" width="1440" height="876" extended-state="6" />
     <editor active="false" />
     <layout>
+      <window_info id="Gulp" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.24924012" sideWeight="0.5057283" order="3" side_tool="false" content_ui="tabs" />
+      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.21346705" sideWeight="0.4357367" order="0" side_tool="false" content_ui="combo" />
       <window_info id="TODO" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.27272728" sideWeight="0.5" order="6" side_tool="false" content_ui="tabs" />
       <window_info id="Event Log" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.58243454" sideWeight="0.5121029" order="7" side_tool="true" content_ui="tabs" />
-      <window_info id="File Transfer" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.2311248" sideWeight="0.5" order="10" side_tool="false" content_ui="tabs" />
-      <window_info id="Version Control" active="true" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.9414484" sideWeight="0.48789713" order="9" side_tool="false" content_ui="tabs" />
-      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
-      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.36671802" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
-      <window_info id="Gulp" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.24924012" sideWeight="0.5057283" order="3" side_tool="false" content_ui="tabs" />
-      <window_info id="Project" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.21104388" sideWeight="0.4357367" order="0" side_tool="false" content_ui="combo" />
       <window_info id="Database" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.21960486" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
-      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.3266564" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
+      <window_info id="Version Control" active="true" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="true" show_stripe_button="true" weight="0.2778489" sideWeight="0.48789713" order="9" side_tool="false" content_ui="tabs" />
+      <window_info id="Run" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="2" side_tool="false" content_ui="tabs" />
       <window_info id="Structure" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.19818456" sideWeight="0.47178683" order="1" side_tool="false" content_ui="tabs" />
+      <window_info id="Terminal" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.19462228" sideWeight="0.5" order="8" side_tool="false" content_ui="tabs" />
       <window_info id="Favorites" active="false" anchor="left" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25227964" sideWeight="0.56426334" order="2" side_tool="true" content_ui="tabs" />
       <window_info id="Debug" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.63009405" sideWeight="0.5" order="3" side_tool="false" content_ui="tabs" />
       <window_info id="Cvs" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="4" side_tool="false" content_ui="tabs" />
       <window_info id="Message" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.33" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
       <window_info id="Commander" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="0" side_tool="false" content_ui="tabs" />
       <window_info id="Inspection" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.4" sideWeight="0.5" order="5" side_tool="false" content_ui="tabs" />
+      <window_info id="File Transfer" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.2311248" sideWeight="0.5" order="10" side_tool="false" content_ui="tabs" />
       <window_info id="Hierarchy" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="2" side_tool="false" content_ui="combo" />
+      <window_info id="Find" active="false" anchor="bottom" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.3266564" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
       <window_info id="Ant Build" active="false" anchor="right" auto_hide="false" internal_type="DOCKED" type="DOCKED" visible="false" show_stripe_button="true" weight="0.25" sideWeight="0.5" order="1" side_tool="false" content_ui="tabs" />
     </layout>
     <layout-to-restore>
@@ -3051,7 +1005,9 @@
     <MESSAGE value="" />
     <MESSAGE value="" />
     <MESSAGE value="" />
-    <option name="LAST_COMMIT_MESSAGE" value="" />
+    <MESSAGE value="cdn.bootcss.com" />
+    <MESSAGE value="" />
+    <option name="LAST_COMMIT_MESSAGE" value="" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
@@ -3060,67 +1016,6 @@
     <watches-manager />
   </component>
   <component name="editorHistoryManager">
-    <entry file="file://$PROJECT_DIR$/resources/views/errors/503.blade.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="726">
-          <caret line="33" column="20" lean-forward="false" selection-start-line="33" selection-start-column="20" selection-end-line="33" selection-end-column="20" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/storage/app/public/logo.png">
-      <provider selected="true" editor-type-id="images">
-        <state />
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/tests/TestCase.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="0">
-          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/vendor/paquettg/php-html-parser/src/PHPHtmlParser/Dom.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="155">
-          <caret line="15" column="6" lean-forward="false" selection-start-line="15" selection-start-column="6" selection-end-line="15" selection-end-column="6" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/app/Http/Controllers/TestController.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="198">
-          <caret line="13" column="7" lean-forward="false" selection-start-line="13" selection-start-column="7" selection-end-line="13" selection-end-column="7" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/vendor/yangqi/htmldom/src/Yangqi/Htmldom/Htmldom.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="23">
-          <caret line="111" column="20" lean-forward="false" selection-start-line="111" selection-start-column="20" selection-end-line="111" selection-end-column="20" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/composer.json">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="198">
-          <caret line="17" column="31" lean-forward="false" selection-start-line="17" selection-start-column="31" selection-end-line="17" selection-end-column="31" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Pub/InfoController.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="1227">
-          <caret line="196" column="13" lean-forward="true" selection-start-line="196" selection-start-column="13" selection-end-line="196" selection-end-column="13" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/public/assets/js/customview.js">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="88">
-          <caret line="6" column="46" lean-forward="true" selection-start-line="6" selection-start-column="46" selection-end-line="6" selection-end-column="46" />
-        </state>
-      </provider>
-    </entry>
     <entry file="file://$PROJECT_DIR$/config/app.php">
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="110">
@@ -3160,25 +1055,10 @@
         </state>
       </provider>
     </entry>
-    <entry file="file://$PROJECT_DIR$/resources/views/auth/register.blade.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="44">
-          <caret line="131" column="12" lean-forward="true" selection-start-line="131" selection-start-column="12" selection-end-line="131" selection-end-column="12" />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/.env">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="312">
-          <caret line="16" column="0" lean-forward="false" selection-start-line="16" selection-start-column="0" selection-end-line="16" selection-end-column="0" />
-        </state>
-      </provider>
-    </entry>
     <entry file="file://$PROJECT_DIR$/public/assets/js/tableExport.js">
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="0">
           <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3193,7 +1073,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="4">
           <caret line="18" column="16" lean-forward="false" selection-start-line="18" selection-start-column="16" selection-end-line="18" selection-end-column="16" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3201,7 +1080,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="25">
           <caret line="15" column="116" lean-forward="false" selection-start-line="15" selection-start-column="116" selection-end-line="15" selection-end-column="116" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3209,15 +1087,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="-313">
           <caret line="88" column="14" lean-forward="false" selection-start-line="88" selection-start-column="14" selection-end-line="88" selection-end-column="14" />
-          <folding />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/resources/views/web/form/custom.blade.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="-485">
-          <caret line="44" column="72" lean-forward="true" selection-start-line="44" selection-start-column="72" selection-end-line="44" selection-end-column="72" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3225,7 +1094,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="439">
           <caret line="83" column="19" lean-forward="false" selection-start-line="83" selection-start-column="19" selection-end-line="83" selection-end-column="19" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3233,7 +1101,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="1232">
           <caret line="49" column="43" lean-forward="false" selection-start-line="49" selection-start-column="37" selection-end-line="49" selection-end-column="43" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3241,7 +1108,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="-331">
           <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3249,23 +1115,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="-397">
           <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/resources/views/web/form/invite.blade.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="-280">
-          <caret line="147" column="20" lean-forward="false" selection-start-line="147" selection-start-column="20" selection-end-line="147" selection-end-column="20" />
-          <folding />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/resources/views/web/form/invite_uncomplete_increase_condition.blade.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="0">
-          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3273,7 +1122,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="-2817">
           <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3288,9 +1136,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="-124">
           <caret line="64" column="76" lean-forward="false" selection-start-line="64" selection-start-column="76" selection-end-line="64" selection-end-column="76" />
-          <folding>
-            <marker date="1489215149836" expanded="true" signature="5241:5251" ph="..." />
-          </folding>
         </state>
       </provider>
     </entry>
@@ -3298,7 +1143,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="-462">
           <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3306,7 +1150,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="88">
           <caret line="4" column="32" lean-forward="false" selection-start-line="4" selection-start-column="32" selection-end-line="4" selection-end-column="32" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3314,7 +1157,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="2068">
           <caret line="94" column="107" lean-forward="false" selection-start-line="94" selection-start-column="107" selection-end-line="94" selection-end-column="107" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3322,7 +1164,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="0">
           <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3330,7 +1171,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="286">
           <caret line="13" column="50" lean-forward="false" selection-start-line="13" selection-start-column="26" selection-end-line="13" selection-end-column="50" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3338,15 +1178,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="154">
           <caret line="7" column="26" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="29" selection-end-column="0" />
-          <folding />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/resources/views/welcome.blade.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="0">
-          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3354,7 +1185,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="2134">
           <caret line="97" column="18" lean-forward="false" selection-start-line="97" selection-start-column="18" selection-end-line="97" selection-end-column="18" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3362,15 +1192,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="132">
           <caret line="6" column="19" lean-forward="true" selection-start-line="6" selection-start-column="19" selection-end-line="6" selection-end-column="19" />
-          <folding />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/.env_meizu">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="488">
-          <caret line="40" column="0" lean-forward="false" selection-start-line="40" selection-start-column="0" selection-end-line="40" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3378,7 +1199,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="0">
           <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3386,33 +1206,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="198">
           <caret line="51" column="22" lean-forward="false" selection-start-line="51" selection-start-column="22" selection-end-line="51" selection-end-column="22" />
-          <folding />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/app/Http/routes.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="149">
-          <caret line="64" column="29" lean-forward="true" selection-start-line="97" selection-start-column="16" selection-end-line="97" selection-end-column="42" />
-          <folding />
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="369">
-          <caret line="19" column="21" lean-forward="false" selection-start-line="19" selection-start-column="21" selection-end-line="19" selection-end-column="21" />
-          <folding>
-            <element signature="e#44#74#0#PHP" expanded="true" />
-          </folding>
-        </state>
-      </provider>
-    </entry>
-    <entry file="file://$PROJECT_DIR$/resources/views/home.blade.php">
-      <provider selected="true" editor-type-id="text-editor">
-        <state relative-caret-position="158">
-          <caret line="229" column="12" lean-forward="true" selection-start-line="229" selection-start-column="12" selection-end-line="229" selection-end-column="12" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3420,14 +1213,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="199">
           <caret line="70" column="28" lean-forward="false" selection-start-line="70" selection-start-column="28" selection-end-line="70" selection-end-column="29" />
-          <folding>
-            <marker date="1489216682400" expanded="true" signature="4074:4088" ph="..." />
-            <marker date="1489216682400" expanded="true" signature="4695:4709" ph="..." />
-            <marker date="1489216682400" expanded="true" signature="5459:5484" ph="..." />
-            <marker date="1489216682400" expanded="true" signature="5613:5637" ph="..." />
-            <marker date="1489216682400" expanded="true" signature="5758:5782" ph="..." />
-            <marker date="1489216682400" expanded="true" signature="6118:6162" ph="..." />
-          </folding>
         </state>
       </provider>
     </entry>
@@ -3435,7 +1220,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="330">
           <caret line="90" column="32" lean-forward="false" selection-start-line="90" selection-start-column="32" selection-end-line="90" selection-end-column="32" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3443,7 +1227,6 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="-80">
           <caret line="128" column="7" lean-forward="true" selection-start-line="128" selection-start-column="7" selection-end-line="128" selection-end-column="7" />
-          <folding />
         </state>
       </provider>
     </entry>
@@ -3464,6 +1247,141 @@
       <provider selected="true" editor-type-id="text-editor">
         <state relative-caret-position="330">
           <caret line="21" column="28" lean-forward="false" selection-start-line="21" selection-start-column="28" selection-end-line="21" selection-end-column="28" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/home.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="1808">
+          <caret line="229" column="12" lean-forward="true" selection-start-line="229" selection-start-column="12" selection-end-line="229" selection-end-column="12" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/test.blade.php" />
+    <entry file="file://$PROJECT_DIR$/resources/views/welcome.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="110">
+          <caret line="5" column="33" lean-forward="false" selection-start-line="5" selection-start-column="4" selection-end-line="5" selection-end-column="33" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/auth/register.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="110">
+          <caret line="5" column="32" lean-forward="false" selection-start-line="5" selection-start-column="32" selection-end-line="5" selection-end-column="32" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/.env_meizu">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="330">
+          <caret line="15" column="31" lean-forward="false" selection-start-line="6" selection-start-column="0" selection-end-line="15" selection-end-column="31" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/.env">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="330">
+          <caret line="15" column="31" lean-forward="false" selection-start-line="15" selection-start-column="31" selection-end-line="15" selection-end-column="31" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/auth/login.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="307">
+          <caret line="19" column="101" lean-forward="false" selection-start-line="19" selection-start-column="101" selection-end-line="19" selection-end-column="101" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/web/form/invite.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="22">
+          <caret line="147" column="20" lean-forward="false" selection-start-line="147" selection-start-column="20" selection-end-line="147" selection-end-column="20" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/web/form/invite_uncomplete_increase_condition.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="-1452">
+          <caret line="5" column="44" lean-forward="false" selection-start-line="5" selection-start-column="44" selection-end-line="5" selection-end-column="44" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/web/form/custom.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="132">
+          <caret line="43" column="0" lean-forward="false" selection-start-line="43" selection-start-column="0" selection-end-line="44" selection-end-column="0" />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/app/User.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="347">
+          <caret line="32" column="30" lean-forward="false" selection-start-line="32" selection-start-column="30" selection-end-line="32" selection-end-column="30" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Pub/TestController.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="220">
+          <caret line="19" column="47" lean-forward="false" selection-start-line="19" selection-start-column="25" selection-end-line="19" selection-end-column="47" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/app/Http/Controllers/Web/FormAdminController.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="308">
+          <caret line="138" column="31" lean-forward="false" selection-start-line="138" selection-start-column="20" selection-end-line="138" selection-end-column="31" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/public/node_modules/vue-select2/demo/demo.all.js">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="0">
+          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/public/node_modules/vue-select2/demo/demo.js">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="22">
+          <caret line="1" column="0" lean-forward="true" selection-start-line="1" selection-start-column="0" selection-end-line="1" selection-end-column="0" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/public/node_modules/vue-select2/demo/demo.vue">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="-330">
+          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/resources/views/web/form/invite_vue.blade.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="495">
+          <caret line="44" column="16" lean-forward="false" selection-start-line="44" selection-start-column="16" selection-end-line="44" selection-end-column="16" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/public/node_modules/vue-select2/demo/demo.html">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="-201">
+          <caret line="0" column="0" lean-forward="false" selection-start-line="0" selection-start-column="0" selection-end-line="0" selection-end-column="0" />
+          <folding />
+        </state>
+      </provider>
+    </entry>
+    <entry file="file://$PROJECT_DIR$/app/Http/routes.php">
+      <provider selected="true" editor-type-id="text-editor">
+        <state relative-caret-position="330">
+          <caret line="84" column="49" lean-forward="false" selection-start-line="84" selection-start-column="49" selection-end-line="84" selection-end-column="49" />
           <folding />
         </state>
       </provider>
Index: public/node_modules/vue-select2/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/README.md	(revision )
+++ public/node_modules/vue-select2/README.md	(revision )
@@ -0,0 +1,300 @@
+# vue-select
+
+[![Build Status](https://circleci.com/gh/Haixing-Hu/vue-select/tree/master.svg?style=shield)](https://circleci.com/gh/Haixing-Hu/vue-select/tree/master)
+[![Coverage Status](https://coveralls.io/repos/Haixing-Hu/vue-select/badge.svg?branch=master&service=github)](https://coveralls.io/github/Haixing-Hu/vue-select?branch=master)
+[![bitHound Score](https://www.bithound.io/github/Haixing-Hu/vue-select/badges/score.svg)](https://www.bithound.io/github/Haixing-Hu/vue-select)
+[![Dependency Status](https://david-dm.org/Haixing-Hu/vue-select.svg)](https://david-dm.org/Haixing-Hu/vue-select)
+[![devDependency Status](https://david-dm.org/Haixing-Hu/vue-select/dev-status.svg)](https://david-dm.org/Haixing-Hu/vue-select#info=devDependencies)
+
+A Vue.js component implementing the select control with the [jQuery select2 plugin](https://github.com/select2/select2).
+
+# Demo
+
+The demo page is [HERE](http://haixing-hu.github.io/vue-select/demo.html).
+
+![Screenshot](screenshot.png)
+
+# Requirements
+
+- [Vue.js](https://github.com/yyx990803/vue) `^1.0.24`
+- [JQuery](https://github.com/jquery/jquery) `^2.2.4`
+- [Select2](https://github.com/select2/select2) `^4.0.3`
+
+# Instllation
+
+## npm
+
+```shell
+$ npm install vue-select2
+```
+
+## bower
+
+```shell
+$ bower install vue-select
+```
+
+# Usage
+
+The HTML snippets are as follows:
+
+```html
+<div id="app">
+  <div class="form-horizontal">
+    <div class="form-group">
+      <label for="select1" class="col-sm-3 control-label">
+        A simple select:
+      </label>
+      <div class="col-sm-5">
+        <vue-select class="vue-select1" name="select1" :options="options1" :model.sync="result1">
+        </vue-select>
+      </div>
+      <div class="col-sm-4">
+        <p class="form-control-static">
+          Selected Result: <span class="vue-result1">{{result1}}</span>
+        </p>
+      </div>
+    </div>
+    <div class="form-group">
+      <label for="select2" class="col-sm-3 control-label">
+        A searchable select with names and localized in en-US:
+      </label>
+      <div class="col-sm-5">
+        <vue-select class="vue-select2" name="select2"
+                :options="options2" :model.sync="result2"
+                :searchable="true" language="en-US">
+        </vue-select>
+      </div>
+      <div class="col-sm-4">
+        <p class="form-control-static">
+          Selected Result: <span class="vue-result2">{{result2}}</span>
+        </p>
+      </div>
+    </div>
+    <div class="form-group">
+      <label for="select3" class="col-sm-3 control-label">
+        A searchable select with groups and localized in zh-CN:
+      </label>
+      <div class="col-sm-5">
+        <vue-select class="vue-select3" name="select3"
+                    :options="options3" :model.sync="result3"
+                    :searchable="true" language="zh-CN">
+        </vue-select>
+      </div>
+      <div class="col-sm-4">
+        <p class="form-control-static">
+          Selected Result: <span class="vue-result3">{{result3}}</span>
+        </p>
+      </div>
+    </div>
+  </div>
+</div>
+```
+
+The Javascript snippets are as follows:
+
+```javascript
+var vm = new Vue({
+  el: "#app",
+  components: {
+    "vue-select": require("vue-select")
+  },
+  data: {
+    options1: [
+      "value1",
+      "value2",
+      "value3"
+    ],
+    options2: [{
+      text: "name1",
+      value: "value1"
+    }, {
+      text: "name2",
+      value: "value2"
+    }, {
+      text: "name3",
+      value: "value3"
+    }],
+    options3: [{
+      label: "group1",
+      options: [{
+        text: "name1",
+        value: "value1"
+      }, {
+        text: "name2",
+        value: "value2"
+      }, {
+        text: "name3",
+        value: "value3"
+      }]
+    }, {
+      label: "group2",
+      options: [{
+        text: "name4",
+        value: "value4"
+      }, {
+        text: "name5",
+        value: "value5"
+      }, {
+        text: "name6",
+        value: "value6"
+      }]
+    }],
+    result1: "",
+    result2: "",
+    result3: ""
+  }
+});
+```
+
+# Component Properties
+
+## `options`
+
+The array of options of the selection control. It could be
+
+- an array of strings, e.g., `['opt1', 'opt2']`; or
+- an array of objects specifying the text and value of each option, e.g.,
+  `[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]`; or
+- an array of objects specifying the option group, e.g.
+  ```
+  [{
+    label: 'group1',
+    options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]
+  }, {
+    label: 'group2',
+    options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]
+  }]
+  ```
+
+## `model`
+
+The model bind to the control, which must be a two way binding variable.
+
+Note that the value of model could be set to `null`, and in that case the
+selection will be set to nothing. Also, if the selection is set to nothing
+(that is, the user delete the text in the input box of the selector), the
+value of the model will be set to `null` instead of an empty string.
+
+## `searchable`
+
+The optional flag indicates whether to show the search box.
+
+## `language`
+
+The optional code of language used by the
+[select2](https://github.com/select2/select2) plugin.
+
+The supported languages are exactly the same as the supported languages of the
+[select2](https://github.com/select2/select2) plugin. In order to use the
+supported language, you must also include the corresponding "i18n" js file of
+the [select2](https://github.com/select2/select2) plugin in your HTML file.
+
+Note that the language code passed to this property could be a locale code
+consists of a language code and a country code, e.g., `"en-US"`. The component
+will automatically convert the locale code to the language code supported by
+the [select2](https://github.com/select2/select2) plugin. Since some languages
+have different variants in different country or region, e.g., `"zh-CN"` for the
+simplified Chinese and `"zh-TW"` for the traditional Chinese, it's recommended
+to use the locale code in the form of `"[language]-[country]"`.
+
+If this property is not set, and the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n)
+plugin is used, the component will use the language code `$language` provided
+by the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin; otherwise, the
+component will use the default value `"en-US"`.
+
+## `theme`
+
+The optional name of the theme of the [select2](https://github.com/select2/select2)
+plugin. Default value is `'bootstrap'`.
+
+Note that in order to use the bootstrap theme, you must include the CSS file
+from the [select2-bootstrap-theme](https://github.com/select2/select2-bootstrap-theme/) project.
+And it's very important that the above CSS file must be included AFTER the
+CSS file of the bootstrap.
+
+The following is the correct order for including CSS files:
+
+```html
+<link rel="stylesheet" type="text/css" href="http://cdn.bootcss.com/select2/4.0.0/css/select2.css">
+<link rel="stylesheet" type="text/css" href="http://cdn.bootcss.com/bootstrap/3.3.5/css/bootstrap.css">
+<link rel="stylesheet" type="text/css" href="https://select2.github.io/select2-bootstrap-theme/css/select2-bootstrap.css">
+```
+
+Check the [demo page](http://haixing-hu.github.io/vue-select/demo.html) for details.
+
+## `name`
+
+The optional name of the selection control.
+
+# API
+
+## `control`
+
+This property is a reference to the JQuery selection of the base select
+control. It could be used to call the APIs of
+[select2](https://github.com/select2/select2) plugin. For example,
+`select.control.val(val)` will set the value of the select to the
+specified value, where `select` is the reference to the `vue-select`
+component.
+
+# Contributing
+
+- Fork it !
+- Create your top branch from `dev`: `git branch my-new-topic origin/dev`
+- Commit your changes: `git commit -am 'Add some topic'`
+- Push to the branch: `git push origin my-new-topic`
+- Submit a pull request to `dev` branch of `Haixing-Hu/vue-select` repository !
+
+# Building and Testing
+
+First you should install all depended NPM packages. The NPM packages are used
+for building and testing this package.
+
+```shell
+$ npm install
+```
+
+Then install all depended bower packages. The bower packages are depended by
+this packages.
+
+```shell
+$ bower install
+```
+
+Now you can build the project.
+```shell
+$ gulp build
+```
+
+The following command will test the project.
+```shell
+$ gulp test
+```
+
+The following command will perform the test and generate a coverage report.
+```shell
+$ gulp test:coverage
+```
+
+The following command will perform the test, generate a coverage report, and
+upload the coverage report to [coveralls.io](https://coveralls.io/).
+```shell
+$ gulp test:coveralls
+```
+
+You can also run `bower install` and `gulp build` together with the following
+command:
+```shell
+npm run build
+```
+
+Or run `bower install` and `gulp test:coveralls` together with the following
+command:
+```shell
+npm run test
+```
+
+# License
+
+[The MIT License](http://opensource.org/licenses/MIT)
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/index.js	(revision )
@@ -0,0 +1,21 @@
+'use strict';
+
+var isStream = module.exports = function (stream) {
+	return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
+};
+
+isStream.writable = function (stream) {
+	return isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
+};
+
+isStream.readable = function (stream) {
+	return isStream(stream) && stream.readable !== false && typeof stream._read === 'function' && typeof stream._readableState === 'object';
+};
+
+isStream.duplex = function (stream) {
+	return isStream.writable(stream) && isStream.readable(stream);
+};
+
+isStream.transform = function (stream) {
+	return isStream.duplex(stream) && typeof stream._transform === 'function' && typeof stream._transformState === 'object';
+};
Index: public/node_modules/vue/src/platforms/web/util/attrs.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/util/attrs.js	(revision )
+++ public/node_modules/vue/src/platforms/web/util/attrs.js	(revision )
@@ -0,0 +1,39 @@
+/* @flow */
+
+import { makeMap } from 'shared/util'
+
+// attributes that should be using props for binding
+const acceptValue = makeMap('input,textarea,option,select')
+export const mustUseProp = (tag: string, type: ?string, attr: string): boolean => {
+  return (
+    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
+    (attr === 'selected' && tag === 'option') ||
+    (attr === 'checked' && tag === 'input') ||
+    (attr === 'muted' && tag === 'video')
+  )
+}
+
+export const isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck')
+
+export const isBooleanAttr = makeMap(
+  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
+  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
+  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
+  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
+  'required,reversed,scoped,seamless,selected,sortable,translate,' +
+  'truespeed,typemustmatch,visible'
+)
+
+export const xlinkNS = 'http://www.w3.org/1999/xlink'
+
+export const isXlink = (name: string): boolean => {
+  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
+}
+
+export const getXlinkProp = (name: string): string => {
+  return isXlink(name) ? name.slice(6, name.length) : ''
+}
+
+export const isFalsyAttrValue = (val: any): boolean => {
+  return val == null || val === false
+}
Index: public/node_modules/vue-resource/src/http/headers.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/headers.js	(revision )
+++ public/node_modules/vue-resource/src/http/headers.js	(revision )
@@ -0,0 +1,75 @@
+/**
+ * HTTP Headers.
+ */
+
+import { each, trim, toLower } from '../util';
+
+export default class Headers {
+
+    constructor(headers) {
+
+        this.map = {};
+
+        each(headers, (value, name) => this.append(name, value));
+    }
+
+    has(name) {
+        return getName(this.map, name) !== null;
+    }
+
+    get(name) {
+
+        var list = this.map[getName(this.map, name)];
+
+        return list ? list.join() : null;
+    }
+
+    getAll(name) {
+        return this.map[getName(this.map, name)] || [];
+    }
+
+    set(name, value) {
+        this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
+    }
+
+    append(name, value){
+
+        var list = this.map[getName(this.map, name)];
+
+        if (list) {
+            list.push(trim(value));
+        } else {
+            this.set(name, value);
+        }
+    }
+
+    delete(name){
+        delete this.map[getName(this.map, name)];
+    }
+
+    deleteAll(){
+        this.map = {};
+    }
+
+    forEach(callback, thisArg) {
+        each(this.map, (list, name) => {
+            each(list, value => callback.call(thisArg, value, name, this));
+        });
+    }
+
+}
+
+function getName(map, name) {
+    return Object.keys(map).reduce((prev, curr) => {
+        return toLower(name) === toLower(curr) ? curr : prev;
+    }, null);
+}
+
+function normalizeName(name) {
+
+    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
+        throw new TypeError('Invalid character in header field name');
+    }
+
+    return trim(name);
+}
Index: public/node_modules/vue/src/platforms/web/runtime/modules/dom-props.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/modules/dom-props.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/modules/dom-props.js	(revision )
@@ -0,0 +1,83 @@
+/* @flow */
+
+import { extend, toNumber } from 'shared/util'
+
+function updateDOMProps (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (!oldVnode.data.domProps && !vnode.data.domProps) {
+    return
+  }
+  let key, cur
+  const elm: any = vnode.elm
+  const oldProps = oldVnode.data.domProps || {}
+  let props = vnode.data.domProps || {}
+  // clone observed objects, as the user probably wants to mutate it
+  if (props.__ob__) {
+    props = vnode.data.domProps = extend({}, props)
+  }
+
+  for (key in oldProps) {
+    if (props[key] == null) {
+      elm[key] = ''
+    }
+  }
+  for (key in props) {
+    cur = props[key]
+    // ignore children if the node has textContent or innerHTML,
+    // as these will throw away existing DOM nodes and cause removal errors
+    // on subsequent patches (#3360)
+    if (key === 'textContent' || key === 'innerHTML') {
+      if (vnode.children) vnode.children.length = 0
+      if (cur === oldProps[key]) continue
+    }
+
+    if (key === 'value') {
+      // store value as _value as well since
+      // non-string values will be stringified
+      elm._value = cur
+      // avoid resetting cursor position when value is the same
+      const strCur = cur == null ? '' : String(cur)
+      if (shouldUpdateValue(elm, vnode, strCur)) {
+        elm.value = strCur
+      }
+    } else {
+      elm[key] = cur
+    }
+  }
+}
+
+// check platforms/web/util/attrs.js acceptValue
+type acceptValueElm = HTMLInputElement | HTMLSelectElement | HTMLOptionElement;
+
+function shouldUpdateValue (
+  elm: acceptValueElm,
+  vnode: VNodeWithData,
+  checkVal: string
+): boolean {
+  return (!elm.composing && (
+    vnode.tag === 'option' ||
+    isDirty(elm, checkVal) ||
+    isInputChanged(elm, checkVal)
+  ))
+}
+
+function isDirty (elm: acceptValueElm, checkVal: string): boolean {
+  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
+  return document.activeElement !== elm && elm.value !== checkVal
+}
+
+function isInputChanged (elm: any, newVal: string): boolean {
+  const value = elm.value
+  const modifiers = elm._vModifiers // injected by v-model runtime
+  if ((modifiers && modifiers.number) || elm.type === 'number') {
+    return toNumber(value) !== toNumber(newVal)
+  }
+  if (modifiers && modifiers.trim) {
+    return value.trim() !== newVal.trim()
+  }
+  return value !== newVal
+}
+
+export default {
+  create: updateDOMProps,
+  update: updateDOMProps
+}
Index: public/node_modules/vue-resource/dist/vue-resource.es2015.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/dist/vue-resource.es2015.js	(revision )
+++ public/node_modules/vue-resource/dist/vue-resource.es2015.js	(revision )
@@ -0,0 +1,1527 @@
+/*!
+ * vue-resource v1.2.1
+ * https://github.com/pagekit/vue-resource
+ * Released under the MIT License.
+ */
+
+/**
+ * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
+ */
+
+var RESOLVED = 0;
+var REJECTED = 1;
+var PENDING  = 2;
+
+function Promise$1(executor) {
+
+    this.state = PENDING;
+    this.value = undefined;
+    this.deferred = [];
+
+    var promise = this;
+
+    try {
+        executor(function (x) {
+            promise.resolve(x);
+        }, function (r) {
+            promise.reject(r);
+        });
+    } catch (e) {
+        promise.reject(e);
+    }
+}
+
+Promise$1.reject = function (r) {
+    return new Promise$1(function (resolve, reject) {
+        reject(r);
+    });
+};
+
+Promise$1.resolve = function (x) {
+    return new Promise$1(function (resolve, reject) {
+        resolve(x);
+    });
+};
+
+Promise$1.all = function all(iterable) {
+    return new Promise$1(function (resolve, reject) {
+        var count = 0, result = [];
+
+        if (iterable.length === 0) {
+            resolve(result);
+        }
+
+        function resolver(i) {
+            return function (x) {
+                result[i] = x;
+                count += 1;
+
+                if (count === iterable.length) {
+                    resolve(result);
+                }
+            };
+        }
+
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise$1.resolve(iterable[i]).then(resolver(i), reject);
+        }
+    });
+};
+
+Promise$1.race = function race(iterable) {
+    return new Promise$1(function (resolve, reject) {
+        for (var i = 0; i < iterable.length; i += 1) {
+            Promise$1.resolve(iterable[i]).then(resolve, reject);
+        }
+    });
+};
+
+var p$1 = Promise$1.prototype;
+
+p$1.resolve = function resolve(x) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (x === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        var called = false;
+
+        try {
+            var then = x && x['then'];
+
+            if (x !== null && typeof x === 'object' && typeof then === 'function') {
+                then.call(x, function (x) {
+                    if (!called) {
+                        promise.resolve(x);
+                    }
+                    called = true;
+
+                }, function (r) {
+                    if (!called) {
+                        promise.reject(r);
+                    }
+                    called = true;
+                });
+                return;
+            }
+        } catch (e) {
+            if (!called) {
+                promise.reject(e);
+            }
+            return;
+        }
+
+        promise.state = RESOLVED;
+        promise.value = x;
+        promise.notify();
+    }
+};
+
+p$1.reject = function reject(reason) {
+    var promise = this;
+
+    if (promise.state === PENDING) {
+        if (reason === promise) {
+            throw new TypeError('Promise settled with itself.');
+        }
+
+        promise.state = REJECTED;
+        promise.value = reason;
+        promise.notify();
+    }
+};
+
+p$1.notify = function notify() {
+    var promise = this;
+
+    nextTick(function () {
+        if (promise.state !== PENDING) {
+            while (promise.deferred.length) {
+                var deferred = promise.deferred.shift(),
+                    onResolved = deferred[0],
+                    onRejected = deferred[1],
+                    resolve = deferred[2],
+                    reject = deferred[3];
+
+                try {
+                    if (promise.state === RESOLVED) {
+                        if (typeof onResolved === 'function') {
+                            resolve(onResolved.call(undefined, promise.value));
+                        } else {
+                            resolve(promise.value);
+                        }
+                    } else if (promise.state === REJECTED) {
+                        if (typeof onRejected === 'function') {
+                            resolve(onRejected.call(undefined, promise.value));
+                        } else {
+                            reject(promise.value);
+                        }
+                    }
+                } catch (e) {
+                    reject(e);
+                }
+            }
+        }
+    });
+};
+
+p$1.then = function then(onResolved, onRejected) {
+    var promise = this;
+
+    return new Promise$1(function (resolve, reject) {
+        promise.deferred.push([onResolved, onRejected, resolve, reject]);
+        promise.notify();
+    });
+};
+
+p$1.catch = function (onRejected) {
+    return this.then(undefined, onRejected);
+};
+
+/**
+ * Promise adapter.
+ */
+
+if (typeof Promise === 'undefined') {
+    window.Promise = Promise$1;
+}
+
+function PromiseObj(executor, context) {
+
+    if (executor instanceof Promise) {
+        this.promise = executor;
+    } else {
+        this.promise = new Promise(executor.bind(context));
+    }
+
+    this.context = context;
+}
+
+PromiseObj.all = function (iterable, context) {
+    return new PromiseObj(Promise.all(iterable), context);
+};
+
+PromiseObj.resolve = function (value, context) {
+    return new PromiseObj(Promise.resolve(value), context);
+};
+
+PromiseObj.reject = function (reason, context) {
+    return new PromiseObj(Promise.reject(reason), context);
+};
+
+PromiseObj.race = function (iterable, context) {
+    return new PromiseObj(Promise.race(iterable), context);
+};
+
+var p = PromiseObj.prototype;
+
+p.bind = function (context) {
+    this.context = context;
+    return this;
+};
+
+p.then = function (fulfilled, rejected) {
+
+    if (fulfilled && fulfilled.bind && this.context) {
+        fulfilled = fulfilled.bind(this.context);
+    }
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
+};
+
+p.catch = function (rejected) {
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.catch(rejected), this.context);
+};
+
+p.finally = function (callback) {
+
+    return this.then(function (value) {
+            callback.call(this);
+            return value;
+        }, function (reason) {
+            callback.call(this);
+            return Promise.reject(reason);
+        }
+    );
+};
+
+/**
+ * Utility functions.
+ */
+
+var ref = {};
+var hasOwnProperty = ref.hasOwnProperty;
+
+var ref$1 = [];
+var slice = ref$1.slice;
+var debug = false;
+var ntick;
+
+var inBrowser = typeof window !== 'undefined';
+
+var Util = function (ref) {
+    var config = ref.config;
+    var nextTick = ref.nextTick;
+
+    ntick = nextTick;
+    debug = config.debug || !config.silent;
+};
+
+function warn(msg) {
+    if (typeof console !== 'undefined' && debug) {
+        console.warn('[VueResource warn]: ' + msg);
+    }
+}
+
+function error(msg) {
+    if (typeof console !== 'undefined') {
+        console.error(msg);
+    }
+}
+
+function nextTick(cb, ctx) {
+    return ntick(cb, ctx);
+}
+
+function trim(str) {
+    return str ? str.replace(/^\s*|\s*$/g, '') : '';
+}
+
+function toLower(str) {
+    return str ? str.toLowerCase() : '';
+}
+
+function toUpper(str) {
+    return str ? str.toUpperCase() : '';
+}
+
+var isArray = Array.isArray;
+
+function isString(val) {
+    return typeof val === 'string';
+}
+
+
+
+function isFunction(val) {
+    return typeof val === 'function';
+}
+
+function isObject(obj) {
+    return obj !== null && typeof obj === 'object';
+}
+
+function isPlainObject(obj) {
+    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
+}
+
+function isBlob(obj) {
+    return typeof Blob !== 'undefined' && obj instanceof Blob;
+}
+
+function isFormData(obj) {
+    return typeof FormData !== 'undefined' && obj instanceof FormData;
+}
+
+function when(value, fulfilled, rejected) {
+
+    var promise = PromiseObj.resolve(value);
+
+    if (arguments.length < 2) {
+        return promise;
+    }
+
+    return promise.then(fulfilled, rejected);
+}
+
+function options(fn, obj, opts) {
+
+    opts = opts || {};
+
+    if (isFunction(opts)) {
+        opts = opts.call(obj);
+    }
+
+    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
+}
+
+function each(obj, iterator) {
+
+    var i, key;
+
+    if (isArray(obj)) {
+        for (i = 0; i < obj.length; i++) {
+            iterator.call(obj[i], obj[i], i);
+        }
+    } else if (isObject(obj)) {
+        for (key in obj) {
+            if (hasOwnProperty.call(obj, key)) {
+                iterator.call(obj[key], obj[key], key);
+            }
+        }
+    }
+
+    return obj;
+}
+
+var assign = Object.assign || _assign;
+
+function merge(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+        _merge(target, source, true);
+    });
+
+    return target;
+}
+
+function defaults(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+
+        for (var key in source) {
+            if (target[key] === undefined) {
+                target[key] = source[key];
+            }
+        }
+
+    });
+
+    return target;
+}
+
+function _assign(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(function (source) {
+        _merge(target, source);
+    });
+
+    return target;
+}
+
+function _merge(target, source, deep) {
+    for (var key in source) {
+        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
+            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
+                target[key] = {};
+            }
+            if (isArray(source[key]) && !isArray(target[key])) {
+                target[key] = [];
+            }
+            _merge(target[key], source[key], deep);
+        } else if (source[key] !== undefined) {
+            target[key] = source[key];
+        }
+    }
+}
+
+/**
+ * Root Prefix Transform.
+ */
+
+var root = function (options$$1, next) {
+
+    var url = next(options$$1);
+
+    if (isString(options$$1.root) && !url.match(/^(https?:)?\//)) {
+        url = options$$1.root + '/' + url;
+    }
+
+    return url;
+};
+
+/**
+ * Query Parameter Transform.
+ */
+
+var query = function (options$$1, next) {
+
+    var urlParams = Object.keys(Url.options.params), query = {}, url = next(options$$1);
+
+    each(options$$1.params, function (value, key) {
+        if (urlParams.indexOf(key) === -1) {
+            query[key] = value;
+        }
+    });
+
+    query = Url.params(query);
+
+    if (query) {
+        url += (url.indexOf('?') == -1 ? '?' : '&') + query;
+    }
+
+    return url;
+};
+
+/**
+ * URL Template v2.0.6 (https://github.com/bramstein/url-template)
+ */
+
+function expand(url, params, variables) {
+
+    var tmpl = parse(url), expanded = tmpl.expand(params);
+
+    if (variables) {
+        variables.push.apply(variables, tmpl.vars);
+    }
+
+    return expanded;
+}
+
+function parse(template) {
+
+    var operators = ['+', '#', '.', '/', ';', '?', '&'], variables = [];
+
+    return {
+        vars: variables,
+        expand: function expand(context) {
+            return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
+                if (expression) {
+
+                    var operator = null, values = [];
+
+                    if (operators.indexOf(expression.charAt(0)) !== -1) {
+                        operator = expression.charAt(0);
+                        expression = expression.substr(1);
+                    }
+
+                    expression.split(/,/g).forEach(function (variable) {
+                        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
+                        values.push.apply(values, getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
+                        variables.push(tmp[1]);
+                    });
+
+                    if (operator && operator !== '+') {
+
+                        var separator = ',';
+
+                        if (operator === '?') {
+                            separator = '&';
+                        } else if (operator !== '#') {
+                            separator = operator;
+                        }
+
+                        return (values.length !== 0 ? operator : '') + values.join(separator);
+                    } else {
+                        return values.join(',');
+                    }
+
+                } else {
+                    return encodeReserved(literal);
+                }
+            });
+        }
+    };
+}
+
+function getValues(context, operator, key, modifier) {
+
+    var value = context[key], result = [];
+
+    if (isDefined(value) && value !== '') {
+        if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
+            value = value.toString();
+
+            if (modifier && modifier !== '*') {
+                value = value.substring(0, parseInt(modifier, 10));
+            }
+
+            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+        } else {
+            if (modifier === '*') {
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach(function (value) {
+                        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : null));
+                    });
+                } else {
+                    Object.keys(value).forEach(function (k) {
+                        if (isDefined(value[k])) {
+                            result.push(encodeValue(operator, value[k], k));
+                        }
+                    });
+                }
+            } else {
+                var tmp = [];
+
+                if (Array.isArray(value)) {
+                    value.filter(isDefined).forEach(function (value) {
+                        tmp.push(encodeValue(operator, value));
+                    });
+                } else {
+                    Object.keys(value).forEach(function (k) {
+                        if (isDefined(value[k])) {
+                            tmp.push(encodeURIComponent(k));
+                            tmp.push(encodeValue(operator, value[k].toString()));
+                        }
+                    });
+                }
+
+                if (isKeyOperator(operator)) {
+                    result.push(encodeURIComponent(key) + '=' + tmp.join(','));
+                } else if (tmp.length !== 0) {
+                    result.push(tmp.join(','));
+                }
+            }
+        }
+    } else {
+        if (operator === ';') {
+            result.push(encodeURIComponent(key));
+        } else if (value === '' && (operator === '&' || operator === '?')) {
+            result.push(encodeURIComponent(key) + '=');
+        } else if (value === '') {
+            result.push('');
+        }
+    }
+
+    return result;
+}
+
+function isDefined(value) {
+    return value !== undefined && value !== null;
+}
+
+function isKeyOperator(operator) {
+    return operator === ';' || operator === '&' || operator === '?';
+}
+
+function encodeValue(operator, value, key) {
+
+    value = (operator === '+' || operator === '#') ? encodeReserved(value) : encodeURIComponent(value);
+
+    if (key) {
+        return encodeURIComponent(key) + '=' + value;
+    } else {
+        return value;
+    }
+}
+
+function encodeReserved(str) {
+    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
+        if (!/%[0-9A-Fa-f]/.test(part)) {
+            part = encodeURI(part);
+        }
+        return part;
+    }).join('');
+}
+
+/**
+ * URL Template (RFC 6570) Transform.
+ */
+
+var template = function (options) {
+
+    var variables = [], url = expand(options.url, options.params, variables);
+
+    variables.forEach(function (key) {
+        delete options.params[key];
+    });
+
+    return url;
+};
+
+/**
+ * Service for URL templating.
+ */
+
+function Url(url, params) {
+
+    var self = this || {}, options$$1 = url, transform;
+
+    if (isString(url)) {
+        options$$1 = {url: url, params: params};
+    }
+
+    options$$1 = merge({}, Url.options, self.$options, options$$1);
+
+    Url.transforms.forEach(function (handler) {
+        transform = factory(handler, transform, self.$vm);
+    });
+
+    return transform(options$$1);
+}
+
+/**
+ * Url options.
+ */
+
+Url.options = {
+    url: '',
+    root: null,
+    params: {}
+};
+
+/**
+ * Url transforms.
+ */
+
+Url.transforms = [template, query, root];
+
+/**
+ * Encodes a Url parameter string.
+ *
+ * @param {Object} obj
+ */
+
+Url.params = function (obj) {
+
+    var params = [], escape = encodeURIComponent;
+
+    params.add = function (key, value) {
+
+        if (isFunction(value)) {
+            value = value();
+        }
+
+        if (value === null) {
+            value = '';
+        }
+
+        this.push(escape(key) + '=' + escape(value));
+    };
+
+    serialize(params, obj);
+
+    return params.join('&').replace(/%20/g, '+');
+};
+
+/**
+ * Parse a URL and return its components.
+ *
+ * @param {String} url
+ */
+
+Url.parse = function (url) {
+
+    var el = document.createElement('a');
+
+    if (document.documentMode) {
+        el.href = url;
+        url = el.href;
+    }
+
+    el.href = url;
+
+    return {
+        href: el.href,
+        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
+        port: el.port,
+        host: el.host,
+        hostname: el.hostname,
+        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
+        search: el.search ? el.search.replace(/^\?/, '') : '',
+        hash: el.hash ? el.hash.replace(/^#/, '') : ''
+    };
+};
+
+function factory(handler, next, vm) {
+    return function (options$$1) {
+        return handler.call(vm, options$$1, next);
+    };
+}
+
+function serialize(params, obj, scope) {
+
+    var array = isArray(obj), plain = isPlainObject(obj), hash;
+
+    each(obj, function (value, key) {
+
+        hash = isObject(value) || isArray(value);
+
+        if (scope) {
+            key = scope + '[' + (plain || hash ? key : '') + ']';
+        }
+
+        if (!scope && array) {
+            params.add(value.name, value.value);
+        } else if (hash) {
+            serialize(params, value, key);
+        } else {
+            params.add(key, value);
+        }
+    });
+}
+
+/**
+ * XDomain client (Internet Explorer).
+ */
+
+var xdrClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var xdr = new XDomainRequest(), handler = function (ref) {
+            var type = ref.type;
+
+
+            var status = 0;
+
+            if (type === 'load') {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            resolve(request.respondWith(xdr.responseText, {status: status}));
+        };
+
+        request.abort = function () { return xdr.abort(); };
+
+        xdr.open(request.method, request.getUrl());
+
+        if (request.timeout) {
+            xdr.timeout = request.timeout;
+        }
+
+        xdr.onload = handler;
+        xdr.onabort = handler;
+        xdr.onerror = handler;
+        xdr.ontimeout = handler;
+        xdr.onprogress = function () {};
+        xdr.send(request.getBody());
+    });
+};
+
+/**
+ * CORS Interceptor.
+ */
+
+var SUPPORTS_CORS = inBrowser && 'withCredentials' in new XMLHttpRequest();
+
+var cors = function (request, next) {
+
+    if (inBrowser) {
+
+        var orgUrl = Url.parse(location.href);
+        var reqUrl = Url.parse(request.getUrl());
+
+        if (reqUrl.protocol !== orgUrl.protocol || reqUrl.host !== orgUrl.host) {
+
+            request.crossOrigin = true;
+            request.emulateHTTP = false;
+
+            if (!SUPPORTS_CORS) {
+                request.client = xdrClient;
+            }
+        }
+    }
+
+    next();
+};
+
+/**
+ * Body Interceptor.
+ */
+
+var body = function (request, next) {
+
+    if (isFormData(request.body)) {
+
+        request.headers.delete('Content-Type');
+
+    } else if (isObject(request.body) || isArray(request.body)) {
+
+        if (request.emulateJSON) {
+            request.body = Url.params(request.body);
+            request.headers.set('Content-Type', 'application/x-www-form-urlencoded');
+        } else {
+            request.body = JSON.stringify(request.body);
+        }
+    }
+
+    next(function (response) {
+
+        Object.defineProperty(response, 'data', {
+
+            get: function get() {
+                return this.body;
+            },
+
+            set: function set(body) {
+                this.body = body;
+            }
+
+        });
+
+        return response.bodyText ? when(response.text(), function (text) {
+
+            var type = response.headers.get('Content-Type') || '';
+
+            if (type.indexOf('application/json') === 0 || isJson(text)) {
+
+                try {
+                    response.body = JSON.parse(text);
+                } catch (e) {
+                    response.body = null;
+                }
+
+            } else {
+                response.body = text;
+            }
+
+            return response;
+
+        }) : response;
+
+    });
+};
+
+function isJson(str) {
+
+    var start = str.match(/^\[|^\{(?!\{)/), end = {'[': /]$/, '{': /}$/};
+
+    return start && end[start[0]].test(str);
+}
+
+/**
+ * JSONP client (Browser).
+ */
+
+var jsonpClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var name = request.jsonp || 'callback', callback = request.jsonpCallback || '_jsonp' + Math.random().toString(36).substr(2), body = null, handler, script;
+
+        handler = function (ref) {
+            var type = ref.type;
+
+
+            var status = 0;
+
+            if (type === 'load' && body !== null) {
+                status = 200;
+            } else if (type === 'error') {
+                status = 500;
+            }
+
+            if (status && window[callback]) {
+                delete window[callback];
+                document.body.removeChild(script);
+            }
+
+            resolve(request.respondWith(body, {status: status}));
+        };
+
+        window[callback] = function (result) {
+            body = JSON.stringify(result);
+        };
+
+        request.abort = function () {
+            handler({type: 'abort'});
+        };
+
+        request.params[name] = callback;
+
+        if (request.timeout) {
+            setTimeout(request.abort, request.timeout);
+        }
+
+        script = document.createElement('script');
+        script.src = request.getUrl();
+        script.type = 'text/javascript';
+        script.async = true;
+        script.onload = handler;
+        script.onerror = handler;
+
+        document.body.appendChild(script);
+    });
+};
+
+/**
+ * JSONP Interceptor.
+ */
+
+var jsonp = function (request, next) {
+
+    if (request.method == 'JSONP') {
+        request.client = jsonpClient;
+    }
+
+    next();
+};
+
+/**
+ * Before Interceptor.
+ */
+
+var before = function (request, next) {
+
+    if (isFunction(request.before)) {
+        request.before.call(this, request);
+    }
+
+    next();
+};
+
+/**
+ * HTTP method override Interceptor.
+ */
+
+var method = function (request, next) {
+
+    if (request.emulateHTTP && /^(PUT|PATCH|DELETE)$/i.test(request.method)) {
+        request.headers.set('X-HTTP-Method-Override', request.method);
+        request.method = 'POST';
+    }
+
+    next();
+};
+
+/**
+ * Header Interceptor.
+ */
+
+var header = function (request, next) {
+
+    var headers = assign({}, Http.headers.common,
+        !request.crossOrigin ? Http.headers.custom : {},
+        Http.headers[toLower(request.method)]
+    );
+
+    each(headers, function (value, name) {
+        if (!request.headers.has(name)) {
+            request.headers.set(name, value);
+        }
+    });
+
+    next();
+};
+
+/**
+ * XMLHttp client (Browser).
+ */
+
+var SUPPORTS_BLOB = typeof Blob !== 'undefined' && typeof FileReader !== 'undefined';
+
+var xhrClient = function (request) {
+    return new PromiseObj(function (resolve) {
+
+        var xhr = new XMLHttpRequest(), handler = function (event) {
+
+            var response = request.respondWith(
+                'response' in xhr ? xhr.response : xhr.responseText, {
+                    status: xhr.status === 1223 ? 204 : xhr.status, // IE9 status bug
+                    statusText: xhr.status === 1223 ? 'No Content' : trim(xhr.statusText)
+                }
+            );
+
+            each(trim(xhr.getAllResponseHeaders()).split('\n'), function (row) {
+                response.headers.append(row.slice(0, row.indexOf(':')), row.slice(row.indexOf(':') + 1));
+            });
+
+            resolve(response);
+        };
+
+        request.abort = function () { return xhr.abort(); };
+
+        if (request.progress) {
+            if (request.method === 'GET') {
+                xhr.addEventListener('progress', request.progress);
+            } else if (/^(POST|PUT)$/i.test(request.method)) {
+                xhr.upload.addEventListener('progress', request.progress);
+            }
+        }
+
+        xhr.open(request.method, request.getUrl(), true);
+
+        if (request.timeout) {
+            xhr.timeout = request.timeout;
+        }
+
+        if (request.credentials === true) {
+            xhr.withCredentials = true;
+        }
+
+        if (!request.crossOrigin) {
+            request.headers.set('X-Requested-With', 'XMLHttpRequest');
+        }
+
+        if ('responseType' in xhr && SUPPORTS_BLOB) {
+            xhr.responseType = 'blob';
+        }
+
+        request.headers.forEach(function (value, name) {
+            xhr.setRequestHeader(name, value);
+        });
+
+        xhr.onload = handler;
+        xhr.onabort = handler;
+        xhr.onerror = handler;
+        xhr.ontimeout = handler;
+        xhr.send(request.getBody());
+    });
+};
+
+/**
+ * Http client (Node).
+ */
+
+var nodeClient = function (request) {
+
+    var client = require('got');
+
+    return new PromiseObj(function (resolve) {
+
+        var url = request.getUrl();
+        var body = request.getBody();
+        var method = request.method;
+        var headers = {}, handler;
+
+        request.headers.forEach(function (value, name) {
+            headers[name] = value;
+        });
+
+        client(url, {body: body, method: method, headers: headers}).then(handler = function (resp) {
+
+            var response = request.respondWith(resp.body, {
+                    status: resp.statusCode,
+                    statusText: trim(resp.statusMessage)
+                }
+            );
+
+            each(resp.headers, function (value, name) {
+                response.headers.set(name, value);
+            });
+
+            resolve(response);
+
+        }, function (error$$1) { return handler(error$$1.response); });
+    });
+};
+
+/**
+ * Base client.
+ */
+
+var Client = function (context) {
+
+    var reqHandlers = [sendRequest], resHandlers = [], handler;
+
+    if (!isObject(context)) {
+        context = null;
+    }
+
+    function Client(request) {
+        return new PromiseObj(function (resolve) {
+
+            function exec() {
+
+                handler = reqHandlers.pop();
+
+                if (isFunction(handler)) {
+                    handler.call(context, request, next);
+                } else {
+                    warn(("Invalid interceptor of type " + (typeof handler) + ", must be a function"));
+                    next();
+                }
+            }
+
+            function next(response) {
+
+                if (isFunction(response)) {
+
+                    resHandlers.unshift(response);
+
+                } else if (isObject(response)) {
+
+                    resHandlers.forEach(function (handler) {
+                        response = when(response, function (response) {
+                            return handler.call(context, response) || response;
+                        });
+                    });
+
+                    when(response, resolve);
+
+                    return;
+                }
+
+                exec();
+            }
+
+            exec();
+
+        }, context);
+    }
+
+    Client.use = function (handler) {
+        reqHandlers.push(handler);
+    };
+
+    return Client;
+};
+
+function sendRequest(request, resolve) {
+
+    var client = request.client || (inBrowser ? xhrClient : nodeClient);
+
+    resolve(client(request));
+}
+
+/**
+ * HTTP Headers.
+ */
+
+var Headers = function Headers(headers) {
+    var this$1 = this;
+
+
+    this.map = {};
+
+    each(headers, function (value, name) { return this$1.append(name, value); });
+};
+
+Headers.prototype.has = function has (name) {
+    return getName(this.map, name) !== null;
+};
+
+Headers.prototype.get = function get (name) {
+
+    var list = this.map[getName(this.map, name)];
+
+    return list ? list.join() : null;
+};
+
+Headers.prototype.getAll = function getAll (name) {
+    return this.map[getName(this.map, name)] || [];
+};
+
+Headers.prototype.set = function set (name, value) {
+    this.map[normalizeName(getName(this.map, name) || name)] = [trim(value)];
+};
+
+Headers.prototype.append = function append (name, value){
+
+    var list = this.map[getName(this.map, name)];
+
+    if (list) {
+        list.push(trim(value));
+    } else {
+        this.set(name, value);
+    }
+};
+
+Headers.prototype.delete = function delete$1 (name){
+    delete this.map[getName(this.map, name)];
+};
+
+Headers.prototype.deleteAll = function deleteAll (){
+    this.map = {};
+};
+
+Headers.prototype.forEach = function forEach (callback, thisArg) {
+        var this$1 = this;
+
+    each(this.map, function (list, name) {
+        each(list, function (value) { return callback.call(thisArg, value, name, this$1); });
+    });
+};
+
+function getName(map, name) {
+    return Object.keys(map).reduce(function (prev, curr) {
+        return toLower(name) === toLower(curr) ? curr : prev;
+    }, null);
+}
+
+function normalizeName(name) {
+
+    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
+        throw new TypeError('Invalid character in header field name');
+    }
+
+    return trim(name);
+}
+
+/**
+ * HTTP Response.
+ */
+
+var Response = function Response(body, ref) {
+    var url = ref.url;
+    var headers = ref.headers;
+    var status = ref.status;
+    var statusText = ref.statusText;
+
+
+    this.url = url;
+    this.ok = status >= 200 && status < 300;
+    this.status = status || 0;
+    this.statusText = statusText || '';
+    this.headers = new Headers(headers);
+    this.body = body;
+
+    if (isString(body)) {
+
+        this.bodyText = body;
+
+    } else if (isBlob(body)) {
+
+        this.bodyBlob = body;
+
+        if (isBlobText(body)) {
+            this.bodyText = blobText(body);
+        }
+    }
+};
+
+Response.prototype.blob = function blob () {
+    return when(this.bodyBlob);
+};
+
+Response.prototype.text = function text () {
+    return when(this.bodyText);
+};
+
+Response.prototype.json = function json () {
+    return when(this.text(), function (text) { return JSON.parse(text); });
+};
+
+function blobText(body) {
+    return new PromiseObj(function (resolve) {
+
+        var reader = new FileReader();
+
+        reader.readAsText(body);
+        reader.onload = function () {
+            resolve(reader.result);
+        };
+
+    });
+}
+
+function isBlobText(body) {
+    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
+}
+
+/**
+ * HTTP Request.
+ */
+
+var Request = function Request(options$$1) {
+
+    this.body = null;
+    this.params = {};
+
+    assign(this, options$$1, {
+        method: toUpper(options$$1.method || 'GET')
+    });
+
+    if (!(this.headers instanceof Headers)) {
+        this.headers = new Headers(this.headers);
+    }
+};
+
+Request.prototype.getUrl = function getUrl (){
+    return Url(this);
+};
+
+Request.prototype.getBody = function getBody (){
+    return this.body;
+};
+
+Request.prototype.respondWith = function respondWith (body, options$$1) {
+    return new Response(body, assign(options$$1 || {}, {url: this.getUrl()}));
+};
+
+/**
+ * Service for sending network requests.
+ */
+
+var COMMON_HEADERS = {'Accept': 'application/json, text/plain, */*'};
+var JSON_CONTENT_TYPE = {'Content-Type': 'application/json;charset=utf-8'};
+
+function Http(options$$1) {
+
+    var self = this || {}, client = Client(self.$vm);
+
+    defaults(options$$1 || {}, self.$options, Http.options);
+
+    Http.interceptors.forEach(function (handler) {
+        client.use(handler);
+    });
+
+    return client(new Request(options$$1)).then(function (response) {
+
+        return response.ok ? response : PromiseObj.reject(response);
+
+    }, function (response) {
+
+        if (response instanceof Error) {
+            error(response);
+        }
+
+        return PromiseObj.reject(response);
+    });
+}
+
+Http.options = {};
+
+Http.headers = {
+    put: JSON_CONTENT_TYPE,
+    post: JSON_CONTENT_TYPE,
+    patch: JSON_CONTENT_TYPE,
+    delete: JSON_CONTENT_TYPE,
+    common: COMMON_HEADERS,
+    custom: {}
+};
+
+Http.interceptors = [before, method, body, jsonp, header, cors];
+
+['get', 'delete', 'head', 'jsonp'].forEach(function (method$$1) {
+
+    Http[method$$1] = function (url, options$$1) {
+        return this(assign(options$$1 || {}, {url: url, method: method$$1}));
+    };
+
+});
+
+['post', 'put', 'patch'].forEach(function (method$$1) {
+
+    Http[method$$1] = function (url, body$$1, options$$1) {
+        return this(assign(options$$1 || {}, {url: url, method: method$$1, body: body$$1}));
+    };
+
+});
+
+/**
+ * Service for interacting with RESTful services.
+ */
+
+function Resource(url, params, actions, options$$1) {
+
+    var self = this || {}, resource = {};
+
+    actions = assign({},
+        Resource.actions,
+        actions
+    );
+
+    each(actions, function (action, name) {
+
+        action = merge({url: url, params: assign({}, params)}, options$$1, action);
+
+        resource[name] = function () {
+            return (self.$http || Http)(opts(action, arguments));
+        };
+    });
+
+    return resource;
+}
+
+function opts(action, args) {
+
+    var options$$1 = assign({}, action), params = {}, body;
+
+    switch (args.length) {
+
+        case 2:
+
+            params = args[0];
+            body = args[1];
+
+            break;
+
+        case 1:
+
+            if (/^(POST|PUT|PATCH)$/i.test(options$$1.method)) {
+                body = args[0];
+            } else {
+                params = args[0];
+            }
+
+            break;
+
+        case 0:
+
+            break;
+
+        default:
+
+            throw 'Expected up to 2 arguments [params, body], got ' + args.length + ' arguments';
+    }
+
+    options$$1.body = body;
+    options$$1.params = assign({}, options$$1.params, params);
+
+    return options$$1;
+}
+
+Resource.actions = {
+
+    get: {method: 'GET'},
+    save: {method: 'POST'},
+    query: {method: 'GET'},
+    update: {method: 'PUT'},
+    remove: {method: 'DELETE'},
+    delete: {method: 'DELETE'}
+
+};
+
+/**
+ * Install plugin.
+ */
+
+function plugin(Vue) {
+
+    if (plugin.installed) {
+        return;
+    }
+
+    Util(Vue);
+
+    Vue.url = Url;
+    Vue.http = Http;
+    Vue.resource = Resource;
+    Vue.Promise = PromiseObj;
+
+    Object.defineProperties(Vue.prototype, {
+
+        $url: {
+            get: function get() {
+                return options(Vue.url, this, this.$options.url);
+            }
+        },
+
+        $http: {
+            get: function get() {
+                return options(Vue.http, this, this.$options.http);
+            }
+        },
+
+        $resource: {
+            get: function get() {
+                return Vue.resource.bind(this);
+            }
+        },
+
+        $promise: {
+            get: function get() {
+                var this$1 = this;
+
+                return function (executor) { return new Vue.Promise(executor, this$1); };
+            }
+        }
+
+    });
+}
+
+if (typeof window !== 'undefined' && window.Vue) {
+    window.Vue.use(plugin);
+}
+
+export default plugin;
+export { Url, Http, Resource };
Index: public/node_modules/vue-select2/bower.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/bower.json	(revision )
+++ public/node_modules/vue-select2/bower.json	(revision )
@@ -0,0 +1,38 @@
+{
+  "name": "vue-select",
+  "description": "A Vue.js component implementing the select control with the jQuery select2 plugin.",
+  "version": "0.2.6",
+  "keywords": [
+    "Vue.js",
+    "component",
+    "select",
+    "jquery.select2"
+  ],
+  "authors": [
+    "Haixing Hu"
+  ],
+  "homepage": "https://github.com/Haixing-Hu/vue-select",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git@github.com:Haixing-Hu/vue-select.git"
+  },
+  "main": [
+    "src/vue-select.js"
+  ],
+  "ignore": [
+    "lib",
+    "coverage",
+    "node_modules"
+  ],
+  "dependencies": {
+    "vue": "^1.0.24",
+    "select2": "^4.0.3"
+  },
+  "devDependencies": {
+    "bootstrap": "^3.3.6",
+    "jquery": "^2.2.4",
+    "select2-bootstrap-theme": "^0.1.0-beta.7",
+    "vue-i18n-plugin": "^0.2.2"
+  }
+}
Index: public/node_modules/vue/src/platforms/web/server/modules/style.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/modules/style.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/modules/style.js	(revision )
@@ -0,0 +1,19 @@
+/* @flow */
+import { hyphenate } from 'shared/util'
+import { getStyle } from 'web/util/style'
+
+function genStyleText (vnode: VNode): string {
+  let styleText = ''
+  const style = getStyle(vnode, false)
+  for (const key in style) {
+    styleText += `${hyphenate(key)}:${style[key]};`
+  }
+  return styleText
+}
+
+export default function renderStyle (vnode: VNodeWithData): ?string {
+  const styleText = genStyleText(vnode)
+  if (styleText) {
+    return ` style=${JSON.stringify(styleText)}`
+  }
+}
Index: public/node_modules/vue-resource/src/promise.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/promise.js	(revision )
+++ public/node_modules/vue-resource/src/promise.js	(revision )
@@ -0,0 +1,77 @@
+/**
+ * Promise adapter.
+ */
+
+import PromiseLib from './lib/promise';
+
+if (typeof Promise === 'undefined') {
+    window.Promise = PromiseLib;
+}
+
+export default function PromiseObj(executor, context) {
+
+    if (executor instanceof Promise) {
+        this.promise = executor;
+    } else {
+        this.promise = new Promise(executor.bind(context));
+    }
+
+    this.context = context;
+}
+
+PromiseObj.all = function (iterable, context) {
+    return new PromiseObj(Promise.all(iterable), context);
+};
+
+PromiseObj.resolve = function (value, context) {
+    return new PromiseObj(Promise.resolve(value), context);
+};
+
+PromiseObj.reject = function (reason, context) {
+    return new PromiseObj(Promise.reject(reason), context);
+};
+
+PromiseObj.race = function (iterable, context) {
+    return new PromiseObj(Promise.race(iterable), context);
+};
+
+var p = PromiseObj.prototype;
+
+p.bind = function (context) {
+    this.context = context;
+    return this;
+};
+
+p.then = function (fulfilled, rejected) {
+
+    if (fulfilled && fulfilled.bind && this.context) {
+        fulfilled = fulfilled.bind(this.context);
+    }
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.then(fulfilled, rejected), this.context);
+};
+
+p.catch = function (rejected) {
+
+    if (rejected && rejected.bind && this.context) {
+        rejected = rejected.bind(this.context);
+    }
+
+    return new PromiseObj(this.promise.catch(rejected), this.context);
+};
+
+p.finally = function (callback) {
+
+    return this.then(function (value) {
+            callback.call(this);
+            return value;
+        }, function (reason) {
+            callback.call(this);
+            return Promise.reject(reason);
+        }
+    );
+};
Index: public/node_modules/vue/src/platforms/weex/framework.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/framework.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/framework.js	(revision )
@@ -0,0 +1,417 @@
+import TextNode from 'weex/runtime/text-node'
+
+// this will be preserved during build
+const VueFactory = require('./factory')
+
+const instances = {}
+const modules = {}
+const components = {}
+
+const renderer = {
+  TextNode,
+  instances,
+  modules,
+  components
+}
+
+/**
+ * Prepare framework config, basically about the virtual-DOM and JS bridge.
+ * @param {object} cfg
+ */
+export function init (cfg) {
+  renderer.Document = cfg.Document
+  renderer.Element = cfg.Element
+  renderer.Comment = cfg.Comment
+  renderer.sendTasks = cfg.sendTasks
+}
+
+/**
+ * Reset framework config and clear all registrations.
+ */
+export function reset () {
+  clear(instances)
+  clear(modules)
+  clear(components)
+  delete renderer.Document
+  delete renderer.Element
+  delete renderer.Comment
+  delete renderer.sendTasks
+}
+
+/**
+ * Delete all keys of an object.
+ * @param {object} obj
+ */
+function clear (obj) {
+  for (const key in obj) {
+    delete obj[key]
+  }
+}
+
+/**
+ * Create an instance with id, code, config and external data.
+ * @param {string} instanceId
+ * @param {string} appCode
+ * @param {object} config
+ * @param {object} data
+ * @param {object} env { info, config, services }
+ */
+export function createInstance (
+  instanceId,
+  appCode = '',
+  config = {},
+  data,
+  env = {}
+) {
+  // Virtual-DOM object.
+  const document = new renderer.Document(instanceId, config.bundleUrl)
+
+  // All function/callback of parameters before sent to native
+  // will be converted as an id. So `callbacks` is used to store
+  // these real functions. When a callback invoked and won't be
+  // called again, it should be removed from here automatically.
+  const callbacks = []
+
+  // The latest callback id, incremental.
+  const callbackId = 1
+
+  const instance = instances[instanceId] = {
+    instanceId, config, data,
+    document, callbacks, callbackId
+  }
+
+  // Prepare native module getter and HTML5 Timer APIs.
+  const moduleGetter = genModuleGetter(instanceId)
+  const timerAPIs = getInstanceTimer(instanceId, moduleGetter)
+
+  // Prepare `weex` instance variable.
+  const weexInstanceVar = {
+    config,
+    document,
+    requireModule: moduleGetter
+  }
+  Object.freeze(weexInstanceVar)
+
+  // Each instance has a independent `Vue` module instance
+  const Vue = instance.Vue = createVueModuleInstance(instanceId, moduleGetter)
+
+  // The function which create a closure the JS Bundle will run in.
+  // It will declare some instance variables like `Vue`, HTML5 Timer APIs etc.
+  const instanceVars = Object.assign({
+    Vue,
+    weex: weexInstanceVar,
+    // deprecated
+    __weex_require_module__: weexInstanceVar.requireModule // eslint-disable-line
+  }, timerAPIs)
+  callFunction(instanceVars, appCode)
+
+  // Send `createFinish` signal to native.
+  renderer.sendTasks(instanceId + '', [{ module: 'dom', method: 'createFinish', args: [] }], -1)
+}
+
+/**
+ * Destroy an instance with id. It will make sure all memory of
+ * this instance released and no more leaks.
+ * @param {string} instanceId
+ */
+export function destroyInstance (instanceId) {
+  const instance = instances[instanceId]
+  if (instance && instance.app instanceof instance.Vue) {
+    instance.app.$destroy()
+  }
+  delete instances[instanceId]
+}
+
+/**
+ * Refresh an instance with id and new top-level component data.
+ * It will use `Vue.set` on all keys of the new data. So it's better
+ * define all possible meaningful keys when instance created.
+ * @param {string} instanceId
+ * @param {object} data
+ */
+export function refreshInstance (instanceId, data) {
+  const instance = instances[instanceId]
+  if (!instance || !(instance.app instanceof instance.Vue)) {
+    return new Error(`refreshInstance: instance ${instanceId} not found!`)
+  }
+  for (const key in data) {
+    instance.Vue.set(instance.app, key, data[key])
+  }
+  // Finally `refreshFinish` signal needed.
+  renderer.sendTasks(instanceId + '', [{ module: 'dom', method: 'refreshFinish', args: [] }], -1)
+}
+
+/**
+ * Get the JSON object of the root element.
+ * @param {string} instanceId
+ */
+export function getRoot (instanceId) {
+  const instance = instances[instanceId]
+  if (!instance || !(instance.app instanceof instance.Vue)) {
+    return new Error(`getRoot: instance ${instanceId} not found!`)
+  }
+  return instance.app.$el.toJSON()
+}
+
+/**
+ * Receive tasks from native. Generally there are two types of tasks:
+ * 1. `fireEvent`: an device actions or user actions from native.
+ * 2. `callback`: invoke function which sent to native as a parameter before.
+ * @param {string} instanceId
+ * @param {array}  tasks
+ */
+export function receiveTasks (instanceId, tasks) {
+  const instance = instances[instanceId]
+  if (!instance || !(instance.app instanceof instance.Vue)) {
+    return new Error(`receiveTasks: instance ${instanceId} not found!`)
+  }
+  const { callbacks, document } = instance
+  tasks.forEach(task => {
+    // `fireEvent` case: find the event target and fire.
+    if (task.method === 'fireEvent') {
+      const [nodeId, type, e, domChanges] = task.args
+      const el = document.getRef(nodeId)
+      document.fireEvent(el, type, e, domChanges)
+    }
+    // `callback` case: find the callback by id and call it.
+    if (task.method === 'callback') {
+      const [callbackId, data, ifKeepAlive] = task.args
+      const callback = callbacks[callbackId]
+      if (typeof callback === 'function') {
+        callback(data)
+        // Remove the callback from `callbacks` if it won't called again.
+        if (typeof ifKeepAlive === 'undefined' || ifKeepAlive === false) {
+          callbacks[callbackId] = undefined
+        }
+      }
+    }
+  })
+  // Finally `updateFinish` signal needed.
+  renderer.sendTasks(instanceId + '', [{ module: 'dom', method: 'updateFinish', args: [] }], -1)
+}
+
+/**
+ * Register native modules information.
+ * @param {object} newModules
+ */
+export function registerModules (newModules) {
+  for (const name in newModules) {
+    if (!modules[name]) {
+      modules[name] = {}
+    }
+    newModules[name].forEach(method => {
+      if (typeof method === 'string') {
+        modules[name][method] = true
+      } else {
+        modules[name][method.name] = method.args
+      }
+    })
+  }
+}
+
+/**
+ * Register native components information.
+ * @param {array} newComponents
+ */
+export function registerComponents (newComponents) {
+  if (Array.isArray(newComponents)) {
+    newComponents.forEach(component => {
+      if (!component) {
+        return
+      }
+      if (typeof component === 'string') {
+        components[component] = true
+      } else if (typeof component === 'object' && typeof component.type === 'string') {
+        components[component.type] = component
+      }
+    })
+  }
+}
+
+/**
+ * Create a fresh instance of Vue for each Weex instance.
+ */
+function createVueModuleInstance (instanceId, moduleGetter) {
+  const exports = {}
+  VueFactory(exports, renderer)
+  const Vue = exports.Vue
+
+  const instance = instances[instanceId]
+
+  // patch reserved tag detection to account for dynamically registered
+  // components
+  const isReservedTag = Vue.config.isReservedTag || (() => false)
+  Vue.config.isReservedTag = name => {
+    return components[name] || isReservedTag(name)
+  }
+
+  // expose weex-specific info
+  Vue.prototype.$instanceId = instanceId
+  Vue.prototype.$document = instance.document
+
+  // expose weex native module getter on subVue prototype so that
+  // vdom runtime modules can access native modules via vnode.context
+  Vue.prototype.$requireWeexModule = moduleGetter
+
+  // Hack `Vue` behavior to handle instance information and data
+  // before root component created.
+  Vue.mixin({
+    beforeCreate () {
+      const options = this.$options
+      // root component (vm)
+      if (options.el) {
+        // set external data of instance
+        const dataOption = options.data
+        const internalData = (typeof dataOption === 'function' ? dataOption() : dataOption) || {}
+        options.data = Object.assign(internalData, instance.data)
+        // record instance by id
+        instance.app = this
+      }
+    }
+  })
+
+  /**
+   * @deprecated Just instance variable `weex.config`
+   * Get instance config.
+   * @return {object}
+   */
+  Vue.prototype.$getConfig = function () {
+    if (instance.app instanceof Vue) {
+      return instance.config
+    }
+  }
+
+  return Vue
+}
+
+/**
+ * Generate native module getter. Each native module has several
+ * methods to call. And all the behaviors is instance-related. So
+ * this getter will return a set of methods which additionally
+ * send current instance id to native when called. Also the args
+ * will be normalized into "safe" value. For example function arg
+ * will be converted into a callback id.
+ * @param  {string}  instanceId
+ * @return {function}
+ */
+function genModuleGetter (instanceId) {
+  const instance = instances[instanceId]
+  return function (name) {
+    const nativeModule = modules[name] || []
+    const output = {}
+    for (const methodName in nativeModule) {
+      output[methodName] = (...args) => {
+        const finalArgs = args.map(value => {
+          return normalize(value, instance)
+        })
+        renderer.sendTasks(instanceId + '', [{ module: name, method: methodName, args: finalArgs }], -1)
+      }
+    }
+    return output
+  }
+}
+
+/**
+ * Generate HTML5 Timer APIs. An important point is that the callback
+ * will be converted into callback id when sent to native. So the
+ * framework can make sure no side effect of the callback happened after
+ * an instance destroyed.
+ * @param  {[type]} instanceId   [description]
+ * @param  {[type]} moduleGetter [description]
+ * @return {[type]}              [description]
+ */
+function getInstanceTimer (instanceId, moduleGetter) {
+  const instance = instances[instanceId]
+  const timer = moduleGetter('timer')
+  const timerAPIs = {
+    setTimeout: (...args) => {
+      const handler = function () {
+        args[0](...args.slice(2))
+      }
+      timer.setTimeout(handler, args[1])
+      return instance.callbackId.toString()
+    },
+    setInterval: (...args) => {
+      const handler = function () {
+        args[0](...args.slice(2))
+      }
+      timer.setInterval(handler, args[1])
+      return instance.callbackId.toString()
+    },
+    clearTimeout: (n) => {
+      timer.clearTimeout(n)
+    },
+    clearInterval: (n) => {
+      timer.clearInterval(n)
+    }
+  }
+  return timerAPIs
+}
+
+/**
+ * Call a new function body with some global objects.
+ * @param  {object} globalObjects
+ * @param  {string} code
+ * @return {any}
+ */
+function callFunction (globalObjects, body) {
+  const globalKeys = []
+  const globalValues = []
+  for (const key in globalObjects) {
+    globalKeys.push(key)
+    globalValues.push(globalObjects[key])
+  }
+  globalKeys.push(body)
+
+  const result = new Function(...globalKeys)
+  return result(...globalValues)
+}
+
+/**
+ * Convert all type of values into "safe" format to send to native.
+ * 1. A `function` will be converted into callback id.
+ * 2. An `Element` object will be converted into `ref`.
+ * The `instance` param is used to generate callback id and store
+ * function if necessary.
+ * @param  {any}    v
+ * @param  {object} instance
+ * @return {any}
+ */
+function normalize (v, instance) {
+  const type = typof(v)
+
+  switch (type) {
+    case 'undefined':
+    case 'null':
+      return ''
+    case 'regexp':
+      return v.toString()
+    case 'date':
+      return v.toISOString()
+    case 'number':
+    case 'string':
+    case 'boolean':
+    case 'array':
+    case 'object':
+      if (v instanceof renderer.Element) {
+        return v.ref
+      }
+      return v
+    case 'function':
+      instance.callbacks[++instance.callbackId] = v
+      return instance.callbackId.toString()
+    default:
+      return JSON.stringify(v)
+  }
+}
+
+/**
+ * Get the exact type of an object by `toString()`. For example call
+ * `toString()` on an array will be returned `[object Array]`.
+ * @param  {any}    v
+ * @return {string}
+ */
+function typof (v) {
+  const s = Object.prototype.toString.call(v)
+  return s.substring(8, s.length - 1).toLowerCase()
+}
Index: public/node_modules/vue-resource/src/url/template.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/url/template.js	(revision )
+++ public/node_modules/vue-resource/src/url/template.js	(revision )
@@ -0,0 +1,16 @@
+/**
+ * URL Template (RFC 6570) Transform.
+ */
+
+import { expand } from '../lib/url-template';
+
+export default function (options) {
+
+    var variables = [], url = expand(options.url, options.params, variables);
+
+    variables.forEach((key) => {
+        delete options.params[key];
+    });
+
+    return url;
+}
Index: public/node_modules/vue/dist/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/README.md	(revision )
+++ public/node_modules/vue/dist/README.md	(revision )
@@ -0,0 +1,124 @@
+## Explanation of Build Files
+
+| | UMD | CommonJS | ES Module |
+| --- | --- | --- | --- |
+| **Full** | vue.js | vue.common.js | vue.esm.js |
+| **Runtime-only** | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js |
+| **Full (production)** | vue.min.js | | |
+| **Runtime-only (production)** | vue.runtime.min.js | | |
+
+### Terms
+
+- **Full**: builds that contains both the compiler and the runtime.
+
+- **Compiler**: code that is responsible for compiling template strings into JavaScript render functions.
+
+- **Runtime**: code that is responsible for creating Vue instances, rendering and patching virtual DOM, etc. Basically everything minus the compiler.
+
+- **[UMD](https://github.com/umdjs/umd)**: UMD builds can be used directly in the browser via a `<script>` tag. The default file from Unpkg CDN at [https://unpkg.com/vue](https://unpkg.com/vue) is the Runtime + Compiler UMD build (`vue.js`).
+
+- **[CommonJS](http://wiki.commonjs.org/wiki/Modules/1.1)**: CommonJS builds are intended for use with older bundlers like [browserify](http://browserify.org/) or [webpack 1](https://webpack.github.io). The default file for these bundlers (`pkg.main`) is the Runtime only CommonJS build (`vue.runtime.common.js`).
+
+- **[ES Module](http://exploringjs.com/es6/ch_modules.html)**: ES module builds are intended for use with modern bundlers like [webpack 2](https://webpack.js.org) or [rollup](http://rollupjs.org/). The default file for these bundlers (`pkg.module`) is the Runtime only ES Module build (`vue.runtime.esm.js`).
+
+### Runtime + Compiler vs. Runtime-only
+
+If you need to compile templates on the fly (e.g. passing a string to the `template` option, or mounting to an element using its in-DOM HTML as the template), you will need the compiler and thus the full build.
+
+When using `vue-loader` or `vueify`, templates inside `*.vue` files are compiled into JavaScript at build time. You don't really need the compiler in the final bundle, and can therefore use the runtime-only build.
+
+Since the runtime-only builds are roughly 30% lighter-weight than their full-build counterparts, you should use it whenever you can. If you wish to use the full build instead, you need to configure an alias in your bundler.
+
+#### Webpack
+
+``` js
+module.exports = {
+  // ...
+  resolve: {
+    alias: {
+      'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1
+    }
+  }
+}
+````
+
+#### Rollup
+
+``` js
+const alias = require('rollup-plugin-alias')
+
+rollup({
+  // ...
+  plugins: [
+    alias({
+      'vue': 'vue/dist/vue.esm.js'
+    })
+  ]
+})
+```
+
+#### Browserify
+
+Add to your project's `package.json`:
+
+``` js
+{
+  // ...
+  "browser": {
+    "vue": "vue/dist/vue.common.js"
+  }
+}
+```
+
+### Development vs. Production Mode
+
+Development/production modes are hard-coded for the UMD builds: the un-minified files are for development, and the minified files are for production.
+
+CommonJS and ES Module builds are intended for bundlers, therefore we don't provide minified versions for them. You will be responsible for minifying the final bundle yourself.
+
+CommonJS and ES Module builds also preserve raw checks for `process.env.NODE_ENV` to determine the mode they should run in. You should use appropriate bundler configurations to replace these environment variables in order to control which mode Vue will run in. Replacing `process.env.NODE_ENV` with string literals also allows minifiers like UglifyJS to completely drop the development-only code blocks, reducing final file size.
+
+#### Webpack
+
+Use Webpack's [DefinePlugin](https://webpack.js.org/plugins/define-plugin/):
+
+``` js
+var webpack = require('webpack')
+
+module.exports = {
+  // ...
+  plugins: [
+    // ...
+    new webpack.DefinePlugin({
+      'process.env': {
+        NODE_ENV: JSON.stringify('production')
+      }
+    })
+  ]
+}
+```
+
+#### Rollup
+
+Use [rollup-plugin-replace](https://github.com/rollup/rollup-plugin-replace):
+
+``` js
+const replace = require('rollup-plugin-replace')
+
+rollup({
+  // ...
+  plugins: [
+    replace({
+      'process.env.NODE_ENV': JSON.stringify('production')
+    })
+  ]
+}).then(...)
+```
+
+#### Browserify
+
+Apply a global [envify](https://github.com/hughsk/envify) transform to your bundle.
+
+``` bash
+NODE_ENV=production browserify -g envify -e main.js | uglifyjs -c -m > build.js
+```
Index: public/node_modules/vue/src/platforms/weex/runtime/node-ops.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/node-ops.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/node-ops.js	(revision )
@@ -0,0 +1,79 @@
+/* globals renderer */
+// renderer is injected by weex factory wrapper
+
+export const namespaceMap = {}
+
+export function createElement (tagName) {
+  return new renderer.Element(tagName)
+}
+
+export function createElementNS (namespace, tagName) {
+  return new renderer.Element(namespace + ':' + tagName)
+}
+
+export function createTextNode (text) {
+  return new renderer.TextNode(text)
+}
+
+export function createComment (text) {
+  return new renderer.Comment(text)
+}
+
+export function insertBefore (node, target, before) {
+  if (target.nodeType === 3) {
+    if (node.type === 'text') {
+      node.setAttr('value', target.text)
+      target.parentNode = node
+    } else {
+      const text = createElement('text')
+      text.setAttr('value', target.text)
+      node.insertBefore(text, before)
+    }
+    return
+  }
+  node.insertBefore(target, before)
+}
+
+export function removeChild (node, child) {
+  if (child.nodeType === 3) {
+    node.setAttr('value', '')
+    return
+  }
+  node.removeChild(child)
+}
+
+export function appendChild (node, child) {
+  if (child.nodeType === 3) {
+    if (node.type === 'text') {
+      node.setAttr('value', child.text)
+      child.parentNode = node
+    } else {
+      const text = createElement('text')
+      text.setAttr('value', child.text)
+      node.appendChild(text)
+    }
+    return
+  }
+
+  node.appendChild(child)
+}
+
+export function parentNode (node) {
+  return node.parentNode
+}
+
+export function nextSibling (node) {
+  return node.nextSibling
+}
+
+export function tagName (node) {
+  return node.type
+}
+
+export function setTextContent (node, text) {
+  node.parentNode.setAttr('value', text)
+}
+
+export function setAttribute (node, key, val) {
+  node.setAttr(key, val)
+}
Index: public/node_modules/vue/dist/vue.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.js	(revision )
+++ public/node_modules/vue/dist/vue.js	(revision )
@@ -0,0 +1,9191 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+(function (global, factory) {
+	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
+	typeof define === 'function' && define.amd ? define(factory) :
+	(global.Vue = factory());
+}(this, (function () { 'use strict';
+
+/*  */
+
+/**
+ * Convert a value to a string that is actually rendered.
+ */
+function _toString (val) {
+  return val == null
+    ? ''
+    : typeof val === 'object'
+      ? JSON.stringify(val, null, 2)
+      : String(val)
+}
+
+/**
+ * Convert a input value to a number for persistence.
+ * If the conversion fails, return original string.
+ */
+function toNumber (val) {
+  var n = parseFloat(val);
+  return isNaN(n) ? val : n
+}
+
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ */
+function makeMap (
+  str,
+  expectsLowerCase
+) {
+  var map = Object.create(null);
+  var list = str.split(',');
+  for (var i = 0; i < list.length; i++) {
+    map[list[i]] = true;
+  }
+  return expectsLowerCase
+    ? function (val) { return map[val.toLowerCase()]; }
+    : function (val) { return map[val]; }
+}
+
+/**
+ * Check if a tag is a built-in tag.
+ */
+var isBuiltInTag = makeMap('slot,component', true);
+
+/**
+ * Remove an item from an array
+ */
+function remove (arr, item) {
+  if (arr.length) {
+    var index = arr.indexOf(item);
+    if (index > -1) {
+      return arr.splice(index, 1)
+    }
+  }
+}
+
+/**
+ * Check whether the object has the property.
+ */
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+function hasOwn (obj, key) {
+  return hasOwnProperty.call(obj, key)
+}
+
+/**
+ * Check if value is primitive
+ */
+function isPrimitive (value) {
+  return typeof value === 'string' || typeof value === 'number'
+}
+
+/**
+ * Create a cached version of a pure function.
+ */
+function cached (fn) {
+  var cache = Object.create(null);
+  return (function cachedFn (str) {
+    var hit = cache[str];
+    return hit || (cache[str] = fn(str))
+  })
+}
+
+/**
+ * Camelize a hyphen-delimited string.
+ */
+var camelizeRE = /-(\w)/g;
+var camelize = cached(function (str) {
+  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
+});
+
+/**
+ * Capitalize a string.
+ */
+var capitalize = cached(function (str) {
+  return str.charAt(0).toUpperCase() + str.slice(1)
+});
+
+/**
+ * Hyphenate a camelCase string.
+ */
+var hyphenateRE = /([^-])([A-Z])/g;
+var hyphenate = cached(function (str) {
+  return str
+    .replace(hyphenateRE, '$1-$2')
+    .replace(hyphenateRE, '$1-$2')
+    .toLowerCase()
+});
+
+/**
+ * Simple bind, faster than native
+ */
+function bind (fn, ctx) {
+  function boundFn (a) {
+    var l = arguments.length;
+    return l
+      ? l > 1
+        ? fn.apply(ctx, arguments)
+        : fn.call(ctx, a)
+      : fn.call(ctx)
+  }
+  // record original fn length
+  boundFn._length = fn.length;
+  return boundFn
+}
+
+/**
+ * Convert an Array-like object to a real Array.
+ */
+function toArray (list, start) {
+  start = start || 0;
+  var i = list.length - start;
+  var ret = new Array(i);
+  while (i--) {
+    ret[i] = list[i + start];
+  }
+  return ret
+}
+
+/**
+ * Mix properties into target object.
+ */
+function extend (to, _from) {
+  for (var key in _from) {
+    to[key] = _from[key];
+  }
+  return to
+}
+
+/**
+ * Quick object check - this is primarily used to tell
+ * Objects from primitive values when we know the value
+ * is a JSON-compliant type.
+ */
+function isObject (obj) {
+  return obj !== null && typeof obj === 'object'
+}
+
+/**
+ * Strict object type check. Only returns true
+ * for plain JavaScript objects.
+ */
+var toString = Object.prototype.toString;
+var OBJECT_STRING = '[object Object]';
+function isPlainObject (obj) {
+  return toString.call(obj) === OBJECT_STRING
+}
+
+/**
+ * Merge an Array of Objects into a single Object.
+ */
+function toObject (arr) {
+  var res = {};
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i]);
+    }
+  }
+  return res
+}
+
+/**
+ * Perform no operation.
+ */
+function noop () {}
+
+/**
+ * Always return false.
+ */
+var no = function () { return false; };
+
+/**
+ * Return same value
+ */
+var identity = function (_) { return _; };
+
+/**
+ * Generate a static keys string from compiler modules.
+ */
+function genStaticKeys (modules) {
+  return modules.reduce(function (keys, m) {
+    return keys.concat(m.staticKeys || [])
+  }, []).join(',')
+}
+
+/**
+ * Check if two values are loosely equal - that is,
+ * if they are plain objects, do they have the same shape?
+ */
+function looseEqual (a, b) {
+  var isObjectA = isObject(a);
+  var isObjectB = isObject(b);
+  if (isObjectA && isObjectB) {
+    try {
+      return JSON.stringify(a) === JSON.stringify(b)
+    } catch (e) {
+      // possible circular reference
+      return a === b
+    }
+  } else if (!isObjectA && !isObjectB) {
+    return String(a) === String(b)
+  } else {
+    return false
+  }
+}
+
+function looseIndexOf (arr, val) {
+  for (var i = 0; i < arr.length; i++) {
+    if (looseEqual(arr[i], val)) { return i }
+  }
+  return -1
+}
+
+/**
+ * Ensure a function is called only once.
+ */
+function once (fn) {
+  var called = false;
+  return function () {
+    if (!called) {
+      called = true;
+      fn();
+    }
+  }
+}
+
+/*  */
+
+var config = {
+  /**
+   * Option merge strategies (used in core/util/options)
+   */
+  optionMergeStrategies: Object.create(null),
+
+  /**
+   * Whether to suppress warnings.
+   */
+  silent: false,
+
+  /**
+   * Show production mode tip message on boot?
+   */
+  productionTip: "development" !== 'production',
+
+  /**
+   * Whether to enable devtools
+   */
+  devtools: "development" !== 'production',
+
+  /**
+   * Whether to record perf
+   */
+  performance: "development" !== 'production',
+
+  /**
+   * Error handler for watcher errors
+   */
+  errorHandler: null,
+
+  /**
+   * Ignore certain custom elements
+   */
+  ignoredElements: [],
+
+  /**
+   * Custom user key aliases for v-on
+   */
+  keyCodes: Object.create(null),
+
+  /**
+   * Check if a tag is reserved so that it cannot be registered as a
+   * component. This is platform-dependent and may be overwritten.
+   */
+  isReservedTag: no,
+
+  /**
+   * Check if a tag is an unknown element.
+   * Platform-dependent.
+   */
+  isUnknownElement: no,
+
+  /**
+   * Get the namespace of an element
+   */
+  getTagNamespace: noop,
+
+  /**
+   * Parse the real tag name for the specific platform.
+   */
+  parsePlatformTagName: identity,
+
+  /**
+   * Check if an attribute must be bound using property, e.g. value
+   * Platform-dependent.
+   */
+  mustUseProp: no,
+
+  /**
+   * List of asset types that a component can own.
+   */
+  _assetTypes: [
+    'component',
+    'directive',
+    'filter'
+  ],
+
+  /**
+   * List of lifecycle hooks.
+   */
+  _lifecycleHooks: [
+    'beforeCreate',
+    'created',
+    'beforeMount',
+    'mounted',
+    'beforeUpdate',
+    'updated',
+    'beforeDestroy',
+    'destroyed',
+    'activated',
+    'deactivated'
+  ],
+
+  /**
+   * Max circular updates allowed in a scheduler flush cycle.
+   */
+  _maxUpdateCount: 100
+};
+
+/*  */
+/* globals MutationObserver */
+
+// can we use __proto__?
+var hasProto = '__proto__' in {};
+
+// Browser environment sniffing
+var inBrowser = typeof window !== 'undefined';
+var UA = inBrowser && window.navigator.userAgent.toLowerCase();
+var isIE = UA && /msie|trident/.test(UA);
+var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
+var isEdge = UA && UA.indexOf('edge/') > 0;
+var isAndroid = UA && UA.indexOf('android') > 0;
+var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
+var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
+
+// this needs to be lazy-evaled because vue may be required before
+// vue-server-renderer can set VUE_ENV
+var _isServer;
+var isServerRendering = function () {
+  if (_isServer === undefined) {
+    /* istanbul ignore if */
+    if (!inBrowser && typeof global !== 'undefined') {
+      // detect presence of vue-server-renderer and avoid
+      // Webpack shimming the process
+      _isServer = global['process'].env.VUE_ENV === 'server';
+    } else {
+      _isServer = false;
+    }
+  }
+  return _isServer
+};
+
+// detect devtools
+var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
+
+/* istanbul ignore next */
+function isNative (Ctor) {
+  return /native code/.test(Ctor.toString())
+}
+
+var hasSymbol =
+  typeof Symbol !== 'undefined' && isNative(Symbol) &&
+  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
+
+/**
+ * Defer a task to execute it asynchronously.
+ */
+var nextTick = (function () {
+  var callbacks = [];
+  var pending = false;
+  var timerFunc;
+
+  function nextTickHandler () {
+    pending = false;
+    var copies = callbacks.slice(0);
+    callbacks.length = 0;
+    for (var i = 0; i < copies.length; i++) {
+      copies[i]();
+    }
+  }
+
+  // the nextTick behavior leverages the microtask queue, which can be accessed
+  // via either native Promise.then or MutationObserver.
+  // MutationObserver has wider support, however it is seriously bugged in
+  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
+  // completely stops working after triggering a few times... so, if native
+  // Promise is available, we will use it:
+  /* istanbul ignore if */
+  if (typeof Promise !== 'undefined' && isNative(Promise)) {
+    var p = Promise.resolve();
+    var logError = function (err) { console.error(err); };
+    timerFunc = function () {
+      p.then(nextTickHandler).catch(logError);
+      // in problematic UIWebViews, Promise.then doesn't completely break, but
+      // it can get stuck in a weird state where callbacks are pushed into the
+      // microtask queue but the queue isn't being flushed, until the browser
+      // needs to do some other work, e.g. handle a timer. Therefore we can
+      // "force" the microtask queue to be flushed by adding an empty timer.
+      if (isIOS) { setTimeout(noop); }
+    };
+  } else if (typeof MutationObserver !== 'undefined' && (
+    isNative(MutationObserver) ||
+    // PhantomJS and iOS 7.x
+    MutationObserver.toString() === '[object MutationObserverConstructor]'
+  )) {
+    // use MutationObserver where native Promise is not available,
+    // e.g. PhantomJS IE11, iOS7, Android 4.4
+    var counter = 1;
+    var observer = new MutationObserver(nextTickHandler);
+    var textNode = document.createTextNode(String(counter));
+    observer.observe(textNode, {
+      characterData: true
+    });
+    timerFunc = function () {
+      counter = (counter + 1) % 2;
+      textNode.data = String(counter);
+    };
+  } else {
+    // fallback to setTimeout
+    /* istanbul ignore next */
+    timerFunc = function () {
+      setTimeout(nextTickHandler, 0);
+    };
+  }
+
+  return function queueNextTick (cb, ctx) {
+    var _resolve;
+    callbacks.push(function () {
+      if (cb) { cb.call(ctx); }
+      if (_resolve) { _resolve(ctx); }
+    });
+    if (!pending) {
+      pending = true;
+      timerFunc();
+    }
+    if (!cb && typeof Promise !== 'undefined') {
+      return new Promise(function (resolve) {
+        _resolve = resolve;
+      })
+    }
+  }
+})();
+
+var _Set;
+/* istanbul ignore if */
+if (typeof Set !== 'undefined' && isNative(Set)) {
+  // use native Set when available.
+  _Set = Set;
+} else {
+  // a non-standard Set polyfill that only works with primitive keys.
+  _Set = (function () {
+    function Set () {
+      this.set = Object.create(null);
+    }
+    Set.prototype.has = function has (key) {
+      return this.set[key] === true
+    };
+    Set.prototype.add = function add (key) {
+      this.set[key] = true;
+    };
+    Set.prototype.clear = function clear () {
+      this.set = Object.create(null);
+    };
+
+    return Set;
+  }());
+}
+
+var perf;
+
+{
+  perf = inBrowser && window.performance;
+  if (perf && (!perf.mark || !perf.measure)) {
+    perf = undefined;
+  }
+}
+
+/*  */
+
+var emptyObject = Object.freeze({});
+
+/**
+ * Check if a string starts with $ or _
+ */
+function isReserved (str) {
+  var c = (str + '').charCodeAt(0);
+  return c === 0x24 || c === 0x5F
+}
+
+/**
+ * Define a property.
+ */
+function def (obj, key, val, enumerable) {
+  Object.defineProperty(obj, key, {
+    value: val,
+    enumerable: !!enumerable,
+    writable: true,
+    configurable: true
+  });
+}
+
+/**
+ * Parse simple path.
+ */
+var bailRE = /[^\w.$]/;
+function parsePath (path) {
+  if (bailRE.test(path)) {
+    return
+  }
+  var segments = path.split('.');
+  return function (obj) {
+    for (var i = 0; i < segments.length; i++) {
+      if (!obj) { return }
+      obj = obj[segments[i]];
+    }
+    return obj
+  }
+}
+
+var warn = noop;
+var tip = noop;
+var formatComponentName;
+
+{
+  var hasConsole = typeof console !== 'undefined';
+  var classifyRE = /(?:^|[-_])(\w)/g;
+  var classify = function (str) { return str
+    .replace(classifyRE, function (c) { return c.toUpperCase(); })
+    .replace(/[-_]/g, ''); };
+
+  warn = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.error("[Vue warn]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  tip = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.warn("[Vue tip]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  formatComponentName = function (vm, includeFile) {
+    if (vm.$root === vm) {
+      return '<Root>'
+    }
+    var name = vm._isVue
+      ? vm.$options.name || vm.$options._componentTag
+      : vm.name;
+
+    var file = vm._isVue && vm.$options.__file;
+    if (!name && file) {
+      var match = file.match(/([^/\\]+)\.vue$/);
+      name = match && match[1];
+    }
+
+    return (
+      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
+      (file && includeFile !== false ? (" at " + file) : '')
+    )
+  };
+
+  var formatLocation = function (str) {
+    if (str === "<Anonymous>") {
+      str += " - use the \"name\" option for better debugging messages.";
+    }
+    return ("\n(found in " + str + ")")
+  };
+}
+
+/*  */
+
+
+var uid$1 = 0;
+
+/**
+ * A dep is an observable that can have multiple
+ * directives subscribing to it.
+ */
+var Dep = function Dep () {
+  this.id = uid$1++;
+  this.subs = [];
+};
+
+Dep.prototype.addSub = function addSub (sub) {
+  this.subs.push(sub);
+};
+
+Dep.prototype.removeSub = function removeSub (sub) {
+  remove(this.subs, sub);
+};
+
+Dep.prototype.depend = function depend () {
+  if (Dep.target) {
+    Dep.target.addDep(this);
+  }
+};
+
+Dep.prototype.notify = function notify () {
+  // stabilize the subscriber list first
+  var subs = this.subs.slice();
+  for (var i = 0, l = subs.length; i < l; i++) {
+    subs[i].update();
+  }
+};
+
+// the current target watcher being evaluated.
+// this is globally unique because there could be only one
+// watcher being evaluated at any time.
+Dep.target = null;
+var targetStack = [];
+
+function pushTarget (_target) {
+  if (Dep.target) { targetStack.push(Dep.target); }
+  Dep.target = _target;
+}
+
+function popTarget () {
+  Dep.target = targetStack.pop();
+}
+
+/*
+ * not type checking this file because flow doesn't play well with
+ * dynamically accessing methods on Array prototype
+ */
+
+var arrayProto = Array.prototype;
+var arrayMethods = Object.create(arrayProto);[
+  'push',
+  'pop',
+  'shift',
+  'unshift',
+  'splice',
+  'sort',
+  'reverse'
+]
+.forEach(function (method) {
+  // cache original method
+  var original = arrayProto[method];
+  def(arrayMethods, method, function mutator () {
+    var arguments$1 = arguments;
+
+    // avoid leaking arguments:
+    // http://jsperf.com/closure-with-arguments
+    var i = arguments.length;
+    var args = new Array(i);
+    while (i--) {
+      args[i] = arguments$1[i];
+    }
+    var result = original.apply(this, args);
+    var ob = this.__ob__;
+    var inserted;
+    switch (method) {
+      case 'push':
+        inserted = args;
+        break
+      case 'unshift':
+        inserted = args;
+        break
+      case 'splice':
+        inserted = args.slice(2);
+        break
+    }
+    if (inserted) { ob.observeArray(inserted); }
+    // notify change
+    ob.dep.notify();
+    return result
+  });
+});
+
+/*  */
+
+var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
+
+/**
+ * By default, when a reactive property is set, the new value is
+ * also converted to become reactive. However when passing down props,
+ * we don't want to force conversion because the value may be a nested value
+ * under a frozen data structure. Converting it would defeat the optimization.
+ */
+var observerState = {
+  shouldConvert: true,
+  isSettingProps: false
+};
+
+/**
+ * Observer class that are attached to each observed
+ * object. Once attached, the observer converts target
+ * object's property keys into getter/setters that
+ * collect dependencies and dispatches updates.
+ */
+var Observer = function Observer (value) {
+  this.value = value;
+  this.dep = new Dep();
+  this.vmCount = 0;
+  def(value, '__ob__', this);
+  if (Array.isArray(value)) {
+    var augment = hasProto
+      ? protoAugment
+      : copyAugment;
+    augment(value, arrayMethods, arrayKeys);
+    this.observeArray(value);
+  } else {
+    this.walk(value);
+  }
+};
+
+/**
+ * Walk through each property and convert them into
+ * getter/setters. This method should only be called when
+ * value type is Object.
+ */
+Observer.prototype.walk = function walk (obj) {
+  var keys = Object.keys(obj);
+  for (var i = 0; i < keys.length; i++) {
+    defineReactive$$1(obj, keys[i], obj[keys[i]]);
+  }
+};
+
+/**
+ * Observe a list of Array items.
+ */
+Observer.prototype.observeArray = function observeArray (items) {
+  for (var i = 0, l = items.length; i < l; i++) {
+    observe(items[i]);
+  }
+};
+
+// helpers
+
+/**
+ * Augment an target Object or Array by intercepting
+ * the prototype chain using __proto__
+ */
+function protoAugment (target, src) {
+  /* eslint-disable no-proto */
+  target.__proto__ = src;
+  /* eslint-enable no-proto */
+}
+
+/**
+ * Augment an target Object or Array by defining
+ * hidden properties.
+ */
+/* istanbul ignore next */
+function copyAugment (target, src, keys) {
+  for (var i = 0, l = keys.length; i < l; i++) {
+    var key = keys[i];
+    def(target, key, src[key]);
+  }
+}
+
+/**
+ * Attempt to create an observer instance for a value,
+ * returns the new observer if successfully observed,
+ * or the existing observer if the value already has one.
+ */
+function observe (value, asRootData) {
+  if (!isObject(value)) {
+    return
+  }
+  var ob;
+  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+    ob = value.__ob__;
+  } else if (
+    observerState.shouldConvert &&
+    !isServerRendering() &&
+    (Array.isArray(value) || isPlainObject(value)) &&
+    Object.isExtensible(value) &&
+    !value._isVue
+  ) {
+    ob = new Observer(value);
+  }
+  if (asRootData && ob) {
+    ob.vmCount++;
+  }
+  return ob
+}
+
+/**
+ * Define a reactive property on an Object.
+ */
+function defineReactive$$1 (
+  obj,
+  key,
+  val,
+  customSetter
+) {
+  var dep = new Dep();
+
+  var property = Object.getOwnPropertyDescriptor(obj, key);
+  if (property && property.configurable === false) {
+    return
+  }
+
+  // cater for pre-defined getter/setters
+  var getter = property && property.get;
+  var setter = property && property.set;
+
+  var childOb = observe(val);
+  Object.defineProperty(obj, key, {
+    enumerable: true,
+    configurable: true,
+    get: function reactiveGetter () {
+      var value = getter ? getter.call(obj) : val;
+      if (Dep.target) {
+        dep.depend();
+        if (childOb) {
+          childOb.dep.depend();
+        }
+        if (Array.isArray(value)) {
+          dependArray(value);
+        }
+      }
+      return value
+    },
+    set: function reactiveSetter (newVal) {
+      var value = getter ? getter.call(obj) : val;
+      /* eslint-disable no-self-compare */
+      if (newVal === value || (newVal !== newVal && value !== value)) {
+        return
+      }
+      /* eslint-enable no-self-compare */
+      if ("development" !== 'production' && customSetter) {
+        customSetter();
+      }
+      if (setter) {
+        setter.call(obj, newVal);
+      } else {
+        val = newVal;
+      }
+      childOb = observe(newVal);
+      dep.notify();
+    }
+  });
+}
+
+/**
+ * Set a property on an object. Adds the new property and
+ * triggers change notification if the property doesn't
+ * already exist.
+ */
+function set (target, key, val) {
+  if (Array.isArray(target)) {
+    target.length = Math.max(target.length, key);
+    target.splice(key, 1, val);
+    return val
+  }
+  if (hasOwn(target, key)) {
+    target[key] = val;
+    return val
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    "development" !== 'production' && warn(
+      'Avoid adding reactive properties to a Vue instance or its root $data ' +
+      'at runtime - declare it upfront in the data option.'
+    );
+    return val
+  }
+  if (!ob) {
+    target[key] = val;
+    return val
+  }
+  defineReactive$$1(ob.value, key, val);
+  ob.dep.notify();
+  return val
+}
+
+/**
+ * Delete a property and trigger change if necessary.
+ */
+function del (target, key) {
+  if (Array.isArray(target)) {
+    target.splice(key, 1);
+    return
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    "development" !== 'production' && warn(
+      'Avoid deleting properties on a Vue instance or its root $data ' +
+      '- just set it to null.'
+    );
+    return
+  }
+  if (!hasOwn(target, key)) {
+    return
+  }
+  delete target[key];
+  if (!ob) {
+    return
+  }
+  ob.dep.notify();
+}
+
+/**
+ * Collect dependencies on array elements when the array is touched, since
+ * we cannot intercept array element access like property getters.
+ */
+function dependArray (value) {
+  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
+    e = value[i];
+    e && e.__ob__ && e.__ob__.dep.depend();
+    if (Array.isArray(e)) {
+      dependArray(e);
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Option overwriting strategies are functions that handle
+ * how to merge a parent option value and a child option
+ * value into the final value.
+ */
+var strats = config.optionMergeStrategies;
+
+/**
+ * Options with restrictions
+ */
+{
+  strats.el = strats.propsData = function (parent, child, vm, key) {
+    if (!vm) {
+      warn(
+        "option \"" + key + "\" can only be used during instance " +
+        'creation with the `new` keyword.'
+      );
+    }
+    return defaultStrat(parent, child)
+  };
+}
+
+/**
+ * Helper that recursively merges two data objects together.
+ */
+function mergeData (to, from) {
+  if (!from) { return to }
+  var key, toVal, fromVal;
+  var keys = Object.keys(from);
+  for (var i = 0; i < keys.length; i++) {
+    key = keys[i];
+    toVal = to[key];
+    fromVal = from[key];
+    if (!hasOwn(to, key)) {
+      set(to, key, fromVal);
+    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
+      mergeData(toVal, fromVal);
+    }
+  }
+  return to
+}
+
+/**
+ * Data
+ */
+strats.data = function (
+  parentVal,
+  childVal,
+  vm
+) {
+  if (!vm) {
+    // in a Vue.extend merge, both should be functions
+    if (!childVal) {
+      return parentVal
+    }
+    if (typeof childVal !== 'function') {
+      "development" !== 'production' && warn(
+        'The "data" option should be a function ' +
+        'that returns a per-instance value in component ' +
+        'definitions.',
+        vm
+      );
+      return parentVal
+    }
+    if (!parentVal) {
+      return childVal
+    }
+    // when parentVal & childVal are both present,
+    // we need to return a function that returns the
+    // merged result of both functions... no need to
+    // check if parentVal is a function here because
+    // it has to be a function to pass previous merges.
+    return function mergedDataFn () {
+      return mergeData(
+        childVal.call(this),
+        parentVal.call(this)
+      )
+    }
+  } else if (parentVal || childVal) {
+    return function mergedInstanceDataFn () {
+      // instance merge
+      var instanceData = typeof childVal === 'function'
+        ? childVal.call(vm)
+        : childVal;
+      var defaultData = typeof parentVal === 'function'
+        ? parentVal.call(vm)
+        : undefined;
+      if (instanceData) {
+        return mergeData(instanceData, defaultData)
+      } else {
+        return defaultData
+      }
+    }
+  }
+};
+
+/**
+ * Hooks and props are merged as arrays.
+ */
+function mergeHook (
+  parentVal,
+  childVal
+) {
+  return childVal
+    ? parentVal
+      ? parentVal.concat(childVal)
+      : Array.isArray(childVal)
+        ? childVal
+        : [childVal]
+    : parentVal
+}
+
+config._lifecycleHooks.forEach(function (hook) {
+  strats[hook] = mergeHook;
+});
+
+/**
+ * Assets
+ *
+ * When a vm is present (instance creation), we need to do
+ * a three-way merge between constructor options, instance
+ * options and parent options.
+ */
+function mergeAssets (parentVal, childVal) {
+  var res = Object.create(parentVal || null);
+  return childVal
+    ? extend(res, childVal)
+    : res
+}
+
+config._assetTypes.forEach(function (type) {
+  strats[type + 's'] = mergeAssets;
+});
+
+/**
+ * Watchers.
+ *
+ * Watchers hashes should not overwrite one
+ * another, so we merge them as arrays.
+ */
+strats.watch = function (parentVal, childVal) {
+  /* istanbul ignore if */
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = {};
+  extend(ret, parentVal);
+  for (var key in childVal) {
+    var parent = ret[key];
+    var child = childVal[key];
+    if (parent && !Array.isArray(parent)) {
+      parent = [parent];
+    }
+    ret[key] = parent
+      ? parent.concat(child)
+      : [child];
+  }
+  return ret
+};
+
+/**
+ * Other object hashes.
+ */
+strats.props =
+strats.methods =
+strats.computed = function (parentVal, childVal) {
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = Object.create(null);
+  extend(ret, parentVal);
+  extend(ret, childVal);
+  return ret
+};
+
+/**
+ * Default strategy.
+ */
+var defaultStrat = function (parentVal, childVal) {
+  return childVal === undefined
+    ? parentVal
+    : childVal
+};
+
+/**
+ * Validate component names
+ */
+function checkComponents (options) {
+  for (var key in options.components) {
+    var lower = key.toLowerCase();
+    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
+      warn(
+        'Do not use built-in or reserved HTML elements as component ' +
+        'id: ' + key
+      );
+    }
+  }
+}
+
+/**
+ * Ensure all props option syntax are normalized into the
+ * Object-based format.
+ */
+function normalizeProps (options) {
+  var props = options.props;
+  if (!props) { return }
+  var res = {};
+  var i, val, name;
+  if (Array.isArray(props)) {
+    i = props.length;
+    while (i--) {
+      val = props[i];
+      if (typeof val === 'string') {
+        name = camelize(val);
+        res[name] = { type: null };
+      } else {
+        warn('props must be strings when using array syntax.');
+      }
+    }
+  } else if (isPlainObject(props)) {
+    for (var key in props) {
+      val = props[key];
+      name = camelize(key);
+      res[name] = isPlainObject(val)
+        ? val
+        : { type: val };
+    }
+  }
+  options.props = res;
+}
+
+/**
+ * Normalize raw function directives into object format.
+ */
+function normalizeDirectives (options) {
+  var dirs = options.directives;
+  if (dirs) {
+    for (var key in dirs) {
+      var def = dirs[key];
+      if (typeof def === 'function') {
+        dirs[key] = { bind: def, update: def };
+      }
+    }
+  }
+}
+
+/**
+ * Merge two option objects into a new one.
+ * Core utility used in both instantiation and inheritance.
+ */
+function mergeOptions (
+  parent,
+  child,
+  vm
+) {
+  {
+    checkComponents(child);
+  }
+  normalizeProps(child);
+  normalizeDirectives(child);
+  var extendsFrom = child.extends;
+  if (extendsFrom) {
+    parent = typeof extendsFrom === 'function'
+      ? mergeOptions(parent, extendsFrom.options, vm)
+      : mergeOptions(parent, extendsFrom, vm);
+  }
+  if (child.mixins) {
+    for (var i = 0, l = child.mixins.length; i < l; i++) {
+      var mixin = child.mixins[i];
+      if (mixin.prototype instanceof Vue$3) {
+        mixin = mixin.options;
+      }
+      parent = mergeOptions(parent, mixin, vm);
+    }
+  }
+  var options = {};
+  var key;
+  for (key in parent) {
+    mergeField(key);
+  }
+  for (key in child) {
+    if (!hasOwn(parent, key)) {
+      mergeField(key);
+    }
+  }
+  function mergeField (key) {
+    var strat = strats[key] || defaultStrat;
+    options[key] = strat(parent[key], child[key], vm, key);
+  }
+  return options
+}
+
+/**
+ * Resolve an asset.
+ * This function is used because child instances need access
+ * to assets defined in its ancestor chain.
+ */
+function resolveAsset (
+  options,
+  type,
+  id,
+  warnMissing
+) {
+  /* istanbul ignore if */
+  if (typeof id !== 'string') {
+    return
+  }
+  var assets = options[type];
+  // check local registration variations first
+  if (hasOwn(assets, id)) { return assets[id] }
+  var camelizedId = camelize(id);
+  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
+  var PascalCaseId = capitalize(camelizedId);
+  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
+  // fallback to prototype chain
+  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
+  if ("development" !== 'production' && warnMissing && !res) {
+    warn(
+      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
+      options
+    );
+  }
+  return res
+}
+
+/*  */
+
+function validateProp (
+  key,
+  propOptions,
+  propsData,
+  vm
+) {
+  var prop = propOptions[key];
+  var absent = !hasOwn(propsData, key);
+  var value = propsData[key];
+  // handle boolean props
+  if (isType(Boolean, prop.type)) {
+    if (absent && !hasOwn(prop, 'default')) {
+      value = false;
+    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
+      value = true;
+    }
+  }
+  // check default value
+  if (value === undefined) {
+    value = getPropDefaultValue(vm, prop, key);
+    // since the default value is a fresh copy,
+    // make sure to observe it.
+    var prevShouldConvert = observerState.shouldConvert;
+    observerState.shouldConvert = true;
+    observe(value);
+    observerState.shouldConvert = prevShouldConvert;
+  }
+  {
+    assertProp(prop, key, value, vm, absent);
+  }
+  return value
+}
+
+/**
+ * Get the default value of a prop.
+ */
+function getPropDefaultValue (vm, prop, key) {
+  // no default, return undefined
+  if (!hasOwn(prop, 'default')) {
+    return undefined
+  }
+  var def = prop.default;
+  // warn against non-factory defaults for Object & Array
+  if ("development" !== 'production' && isObject(def)) {
+    warn(
+      'Invalid default value for prop "' + key + '": ' +
+      'Props with type Object/Array must use a factory function ' +
+      'to return the default value.',
+      vm
+    );
+  }
+  // the raw prop value was also undefined from previous render,
+  // return previous default value to avoid unnecessary watcher trigger
+  if (vm && vm.$options.propsData &&
+    vm.$options.propsData[key] === undefined &&
+    vm._props[key] !== undefined) {
+    return vm._props[key]
+  }
+  // call factory function for non-Function types
+  // a value is Function if its prototype is function even across different execution context
+  return typeof def === 'function' && getType(prop.type) !== 'Function'
+    ? def.call(vm)
+    : def
+}
+
+/**
+ * Assert whether a prop is valid.
+ */
+function assertProp (
+  prop,
+  name,
+  value,
+  vm,
+  absent
+) {
+  if (prop.required && absent) {
+    warn(
+      'Missing required prop: "' + name + '"',
+      vm
+    );
+    return
+  }
+  if (value == null && !prop.required) {
+    return
+  }
+  var type = prop.type;
+  var valid = !type || type === true;
+  var expectedTypes = [];
+  if (type) {
+    if (!Array.isArray(type)) {
+      type = [type];
+    }
+    for (var i = 0; i < type.length && !valid; i++) {
+      var assertedType = assertType(value, type[i]);
+      expectedTypes.push(assertedType.expectedType || '');
+      valid = assertedType.valid;
+    }
+  }
+  if (!valid) {
+    warn(
+      'Invalid prop: type check failed for prop "' + name + '".' +
+      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
+      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
+      vm
+    );
+    return
+  }
+  var validator = prop.validator;
+  if (validator) {
+    if (!validator(value)) {
+      warn(
+        'Invalid prop: custom validator check failed for prop "' + name + '".',
+        vm
+      );
+    }
+  }
+}
+
+/**
+ * Assert the type of a value
+ */
+function assertType (value, type) {
+  var valid;
+  var expectedType = getType(type);
+  if (expectedType === 'String') {
+    valid = typeof value === (expectedType = 'string');
+  } else if (expectedType === 'Number') {
+    valid = typeof value === (expectedType = 'number');
+  } else if (expectedType === 'Boolean') {
+    valid = typeof value === (expectedType = 'boolean');
+  } else if (expectedType === 'Function') {
+    valid = typeof value === (expectedType = 'function');
+  } else if (expectedType === 'Object') {
+    valid = isPlainObject(value);
+  } else if (expectedType === 'Array') {
+    valid = Array.isArray(value);
+  } else {
+    valid = value instanceof type;
+  }
+  return {
+    valid: valid,
+    expectedType: expectedType
+  }
+}
+
+/**
+ * Use function string name to check built-in types,
+ * because a simple equality check will fail when running
+ * across different vms / iframes.
+ */
+function getType (fn) {
+  var match = fn && fn.toString().match(/^\s*function (\w+)/);
+  return match && match[1]
+}
+
+function isType (type, fn) {
+  if (!Array.isArray(fn)) {
+    return getType(fn) === getType(type)
+  }
+  for (var i = 0, len = fn.length; i < len; i++) {
+    if (getType(fn[i]) === getType(type)) {
+      return true
+    }
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function handleError (err, vm, info) {
+  if (config.errorHandler) {
+    config.errorHandler.call(null, err, vm, info);
+  } else {
+    {
+      warn(("Error in " + info + ":"), vm);
+    }
+    /* istanbul ignore else */
+    if (inBrowser && typeof console !== 'undefined') {
+      console.error(err);
+    } else {
+      throw err
+    }
+  }
+}
+
+/* not type checking this file because flow doesn't play well with Proxy */
+
+var initProxy;
+
+{
+  var allowedGlobals = makeMap(
+    'Infinity,undefined,NaN,isFinite,isNaN,' +
+    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
+    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
+    'require' // for Webpack/Browserify
+  );
+
+  var warnNonPresent = function (target, key) {
+    warn(
+      "Property or method \"" + key + "\" is not defined on the instance but " +
+      "referenced during render. Make sure to declare reactive data " +
+      "properties in the data option.",
+      target
+    );
+  };
+
+  var hasProxy =
+    typeof Proxy !== 'undefined' &&
+    Proxy.toString().match(/native code/);
+
+  if (hasProxy) {
+    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
+    config.keyCodes = new Proxy(config.keyCodes, {
+      set: function set (target, key, value) {
+        if (isBuiltInModifier(key)) {
+          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
+          return false
+        } else {
+          target[key] = value;
+          return true
+        }
+      }
+    });
+  }
+
+  var hasHandler = {
+    has: function has (target, key) {
+      var has = key in target;
+      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
+      if (!has && !isAllowed) {
+        warnNonPresent(target, key);
+      }
+      return has || !isAllowed
+    }
+  };
+
+  var getHandler = {
+    get: function get (target, key) {
+      if (typeof key === 'string' && !(key in target)) {
+        warnNonPresent(target, key);
+      }
+      return target[key]
+    }
+  };
+
+  initProxy = function initProxy (vm) {
+    if (hasProxy) {
+      // determine which proxy handler to use
+      var options = vm.$options;
+      var handlers = options.render && options.render._withStripped
+        ? getHandler
+        : hasHandler;
+      vm._renderProxy = new Proxy(vm, handlers);
+    } else {
+      vm._renderProxy = vm;
+    }
+  };
+}
+
+/*  */
+
+var VNode = function VNode (
+  tag,
+  data,
+  children,
+  text,
+  elm,
+  context,
+  componentOptions
+) {
+  this.tag = tag;
+  this.data = data;
+  this.children = children;
+  this.text = text;
+  this.elm = elm;
+  this.ns = undefined;
+  this.context = context;
+  this.functionalContext = undefined;
+  this.key = data && data.key;
+  this.componentOptions = componentOptions;
+  this.componentInstance = undefined;
+  this.parent = undefined;
+  this.raw = false;
+  this.isStatic = false;
+  this.isRootInsert = true;
+  this.isComment = false;
+  this.isCloned = false;
+  this.isOnce = false;
+};
+
+var prototypeAccessors = { child: {} };
+
+// DEPRECATED: alias for componentInstance for backwards compat.
+/* istanbul ignore next */
+prototypeAccessors.child.get = function () {
+  return this.componentInstance
+};
+
+Object.defineProperties( VNode.prototype, prototypeAccessors );
+
+var createEmptyVNode = function () {
+  var node = new VNode();
+  node.text = '';
+  node.isComment = true;
+  return node
+};
+
+function createTextVNode (val) {
+  return new VNode(undefined, undefined, undefined, String(val))
+}
+
+// optimized shallow clone
+// used for static nodes and slot nodes because they may be reused across
+// multiple renders, cloning them avoids errors when DOM manipulations rely
+// on their elm reference.
+function cloneVNode (vnode) {
+  var cloned = new VNode(
+    vnode.tag,
+    vnode.data,
+    vnode.children,
+    vnode.text,
+    vnode.elm,
+    vnode.context,
+    vnode.componentOptions
+  );
+  cloned.ns = vnode.ns;
+  cloned.isStatic = vnode.isStatic;
+  cloned.key = vnode.key;
+  cloned.isCloned = true;
+  return cloned
+}
+
+function cloneVNodes (vnodes) {
+  var len = vnodes.length;
+  var res = new Array(len);
+  for (var i = 0; i < len; i++) {
+    res[i] = cloneVNode(vnodes[i]);
+  }
+  return res
+}
+
+/*  */
+
+var normalizeEvent = cached(function (name) {
+  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
+  name = once$$1 ? name.slice(1) : name;
+  var capture = name.charAt(0) === '!';
+  name = capture ? name.slice(1) : name;
+  return {
+    name: name,
+    once: once$$1,
+    capture: capture
+  }
+});
+
+function createFnInvoker (fns) {
+  function invoker () {
+    var arguments$1 = arguments;
+
+    var fns = invoker.fns;
+    if (Array.isArray(fns)) {
+      for (var i = 0; i < fns.length; i++) {
+        fns[i].apply(null, arguments$1);
+      }
+    } else {
+      // return handler return value for single handlers
+      return fns.apply(null, arguments)
+    }
+  }
+  invoker.fns = fns;
+  return invoker
+}
+
+function updateListeners (
+  on,
+  oldOn,
+  add,
+  remove$$1,
+  vm
+) {
+  var name, cur, old, event;
+  for (name in on) {
+    cur = on[name];
+    old = oldOn[name];
+    event = normalizeEvent(name);
+    if (!cur) {
+      "development" !== 'production' && warn(
+        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
+        vm
+      );
+    } else if (!old) {
+      if (!cur.fns) {
+        cur = on[name] = createFnInvoker(cur);
+      }
+      add(event.name, cur, event.once, event.capture);
+    } else if (cur !== old) {
+      old.fns = cur;
+      on[name] = old;
+    }
+  }
+  for (name in oldOn) {
+    if (!on[name]) {
+      event = normalizeEvent(name);
+      remove$$1(event.name, oldOn[name], event.capture);
+    }
+  }
+}
+
+/*  */
+
+function mergeVNodeHook (def, hookKey, hook) {
+  var invoker;
+  var oldHook = def[hookKey];
+
+  function wrappedHook () {
+    hook.apply(this, arguments);
+    // important: remove merged hook to ensure it's called only once
+    // and prevent memory leak
+    remove(invoker.fns, wrappedHook);
+  }
+
+  if (!oldHook) {
+    // no existing hook
+    invoker = createFnInvoker([wrappedHook]);
+  } else {
+    /* istanbul ignore if */
+    if (oldHook.fns && oldHook.merged) {
+      // already a merged invoker
+      invoker = oldHook;
+      invoker.fns.push(wrappedHook);
+    } else {
+      // existing plain hook
+      invoker = createFnInvoker([oldHook, wrappedHook]);
+    }
+  }
+
+  invoker.merged = true;
+  def[hookKey] = invoker;
+}
+
+/*  */
+
+// The template compiler attempts to minimize the need for normalization by
+// statically analyzing the template at compile time.
+//
+// For plain HTML markup, normalization can be completely skipped because the
+// generated render function is guaranteed to return Array<VNode>. There are
+// two cases where extra normalization is needed:
+
+// 1. When the children contains components - because a functional component
+// may return an Array instead of a single root. In this case, just a simple
+// normalization is needed - if any child is an Array, we flatten the whole
+// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
+// because functional components already normalize their own children.
+function simpleNormalizeChildren (children) {
+  for (var i = 0; i < children.length; i++) {
+    if (Array.isArray(children[i])) {
+      return Array.prototype.concat.apply([], children)
+    }
+  }
+  return children
+}
+
+// 2. When the children contains constructs that always generated nested Arrays,
+// e.g. <template>, <slot>, v-for, or when the children is provided by user
+// with hand-written render functions / JSX. In such cases a full normalization
+// is needed to cater to all possible types of children values.
+function normalizeChildren (children) {
+  return isPrimitive(children)
+    ? [createTextVNode(children)]
+    : Array.isArray(children)
+      ? normalizeArrayChildren(children)
+      : undefined
+}
+
+function normalizeArrayChildren (children, nestedIndex) {
+  var res = [];
+  var i, c, last;
+  for (i = 0; i < children.length; i++) {
+    c = children[i];
+    if (c == null || typeof c === 'boolean') { continue }
+    last = res[res.length - 1];
+    //  nested
+    if (Array.isArray(c)) {
+      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
+    } else if (isPrimitive(c)) {
+      if (last && last.text) {
+        last.text += String(c);
+      } else if (c !== '') {
+        // convert primitive to vnode
+        res.push(createTextVNode(c));
+      }
+    } else {
+      if (c.text && last && last.text) {
+        res[res.length - 1] = createTextVNode(last.text + c.text);
+      } else {
+        // default key for nested array children (likely generated by v-for)
+        if (c.tag && c.key == null && nestedIndex != null) {
+          c.key = "__vlist" + nestedIndex + "_" + i + "__";
+        }
+        res.push(c);
+      }
+    }
+  }
+  return res
+}
+
+/*  */
+
+function getFirstComponentChild (children) {
+  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
+}
+
+/*  */
+
+function initEvents (vm) {
+  vm._events = Object.create(null);
+  vm._hasHookEvent = false;
+  // init parent attached events
+  var listeners = vm.$options._parentListeners;
+  if (listeners) {
+    updateComponentListeners(vm, listeners);
+  }
+}
+
+var target;
+
+function add (event, fn, once$$1) {
+  if (once$$1) {
+    target.$once(event, fn);
+  } else {
+    target.$on(event, fn);
+  }
+}
+
+function remove$1 (event, fn) {
+  target.$off(event, fn);
+}
+
+function updateComponentListeners (
+  vm,
+  listeners,
+  oldListeners
+) {
+  target = vm;
+  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
+}
+
+function eventsMixin (Vue) {
+  var hookRE = /^hook:/;
+  Vue.prototype.$on = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    if (Array.isArray(event)) {
+      for (var i = 0, l = event.length; i < l; i++) {
+        this$1.$on(event[i], fn);
+      }
+    } else {
+      (vm._events[event] || (vm._events[event] = [])).push(fn);
+      // optimize hook:event cost by using a boolean flag marked at registration
+      // instead of a hash lookup
+      if (hookRE.test(event)) {
+        vm._hasHookEvent = true;
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$once = function (event, fn) {
+    var vm = this;
+    function on () {
+      vm.$off(event, on);
+      fn.apply(vm, arguments);
+    }
+    on.fn = fn;
+    vm.$on(event, on);
+    return vm
+  };
+
+  Vue.prototype.$off = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    // all
+    if (!arguments.length) {
+      vm._events = Object.create(null);
+      return vm
+    }
+    // array of events
+    if (Array.isArray(event)) {
+      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
+        this$1.$off(event[i$1], fn);
+      }
+      return vm
+    }
+    // specific event
+    var cbs = vm._events[event];
+    if (!cbs) {
+      return vm
+    }
+    if (arguments.length === 1) {
+      vm._events[event] = null;
+      return vm
+    }
+    // specific handler
+    var cb;
+    var i = cbs.length;
+    while (i--) {
+      cb = cbs[i];
+      if (cb === fn || cb.fn === fn) {
+        cbs.splice(i, 1);
+        break
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$emit = function (event) {
+    var vm = this;
+    var cbs = vm._events[event];
+    if (cbs) {
+      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
+      var args = toArray(arguments, 1);
+      for (var i = 0, l = cbs.length; i < l; i++) {
+        cbs[i].apply(vm, args);
+      }
+    }
+    return vm
+  };
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving raw children VNodes into a slot object.
+ */
+function resolveSlots (
+  children,
+  context
+) {
+  var slots = {};
+  if (!children) {
+    return slots
+  }
+  var defaultSlot = [];
+  var name, child;
+  for (var i = 0, l = children.length; i < l; i++) {
+    child = children[i];
+    // named slots should only be respected if the vnode was rendered in the
+    // same context.
+    if ((child.context === context || child.functionalContext === context) &&
+        child.data && (name = child.data.slot)) {
+      var slot = (slots[name] || (slots[name] = []));
+      if (child.tag === 'template') {
+        slot.push.apply(slot, child.children);
+      } else {
+        slot.push(child);
+      }
+    } else {
+      defaultSlot.push(child);
+    }
+  }
+  // ignore whitespace
+  if (!defaultSlot.every(isWhitespace)) {
+    slots.default = defaultSlot;
+  }
+  return slots
+}
+
+function isWhitespace (node) {
+  return node.isComment || node.text === ' '
+}
+
+function resolveScopedSlots (
+  fns
+) {
+  var res = {};
+  for (var i = 0; i < fns.length; i++) {
+    res[fns[i][0]] = fns[i][1];
+  }
+  return res
+}
+
+/*  */
+
+var activeInstance = null;
+
+function initLifecycle (vm) {
+  var options = vm.$options;
+
+  // locate first non-abstract parent
+  var parent = options.parent;
+  if (parent && !options.abstract) {
+    while (parent.$options.abstract && parent.$parent) {
+      parent = parent.$parent;
+    }
+    parent.$children.push(vm);
+  }
+
+  vm.$parent = parent;
+  vm.$root = parent ? parent.$root : vm;
+
+  vm.$children = [];
+  vm.$refs = {};
+
+  vm._watcher = null;
+  vm._inactive = null;
+  vm._directInactive = false;
+  vm._isMounted = false;
+  vm._isDestroyed = false;
+  vm._isBeingDestroyed = false;
+}
+
+function lifecycleMixin (Vue) {
+  Vue.prototype._update = function (vnode, hydrating) {
+    var vm = this;
+    if (vm._isMounted) {
+      callHook(vm, 'beforeUpdate');
+    }
+    var prevEl = vm.$el;
+    var prevVnode = vm._vnode;
+    var prevActiveInstance = activeInstance;
+    activeInstance = vm;
+    vm._vnode = vnode;
+    // Vue.prototype.__patch__ is injected in entry points
+    // based on the rendering backend used.
+    if (!prevVnode) {
+      // initial render
+      vm.$el = vm.__patch__(
+        vm.$el, vnode, hydrating, false /* removeOnly */,
+        vm.$options._parentElm,
+        vm.$options._refElm
+      );
+    } else {
+      // updates
+      vm.$el = vm.__patch__(prevVnode, vnode);
+    }
+    activeInstance = prevActiveInstance;
+    // update __vue__ reference
+    if (prevEl) {
+      prevEl.__vue__ = null;
+    }
+    if (vm.$el) {
+      vm.$el.__vue__ = vm;
+    }
+    // if parent is an HOC, update its $el as well
+    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
+      vm.$parent.$el = vm.$el;
+    }
+    // updated hook is called by the scheduler to ensure that children are
+    // updated in a parent's updated hook.
+  };
+
+  Vue.prototype.$forceUpdate = function () {
+    var vm = this;
+    if (vm._watcher) {
+      vm._watcher.update();
+    }
+  };
+
+  Vue.prototype.$destroy = function () {
+    var vm = this;
+    if (vm._isBeingDestroyed) {
+      return
+    }
+    callHook(vm, 'beforeDestroy');
+    vm._isBeingDestroyed = true;
+    // remove self from parent
+    var parent = vm.$parent;
+    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
+      remove(parent.$children, vm);
+    }
+    // teardown watchers
+    if (vm._watcher) {
+      vm._watcher.teardown();
+    }
+    var i = vm._watchers.length;
+    while (i--) {
+      vm._watchers[i].teardown();
+    }
+    // remove reference from data ob
+    // frozen object may not have observer.
+    if (vm._data.__ob__) {
+      vm._data.__ob__.vmCount--;
+    }
+    // call the last hook...
+    vm._isDestroyed = true;
+    callHook(vm, 'destroyed');
+    // turn off all instance listeners.
+    vm.$off();
+    // remove __vue__ reference
+    if (vm.$el) {
+      vm.$el.__vue__ = null;
+    }
+    // invoke destroy hooks on current rendered tree
+    vm.__patch__(vm._vnode, null);
+  };
+}
+
+function mountComponent (
+  vm,
+  el,
+  hydrating
+) {
+  vm.$el = el;
+  if (!vm.$options.render) {
+    vm.$options.render = createEmptyVNode;
+    {
+      /* istanbul ignore if */
+      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
+        vm.$options.el || el) {
+        warn(
+          'You are using the runtime-only build of Vue where the template ' +
+          'compiler is not available. Either pre-compile the templates into ' +
+          'render functions, or use the compiler-included build.',
+          vm
+        );
+      } else {
+        warn(
+          'Failed to mount component: template or render function not defined.',
+          vm
+        );
+      }
+    }
+  }
+  callHook(vm, 'beforeMount');
+
+  var updateComponent;
+  /* istanbul ignore if */
+  if ("development" !== 'production' && config.performance && perf) {
+    updateComponent = function () {
+      var name = vm._name;
+      var startTag = "start " + name;
+      var endTag = "end " + name;
+      perf.mark(startTag);
+      var vnode = vm._render();
+      perf.mark(endTag);
+      perf.measure((name + " render"), startTag, endTag);
+      perf.mark(startTag);
+      vm._update(vnode, hydrating);
+      perf.mark(endTag);
+      perf.measure((name + " patch"), startTag, endTag);
+    };
+  } else {
+    updateComponent = function () {
+      vm._update(vm._render(), hydrating);
+    };
+  }
+
+  vm._watcher = new Watcher(vm, updateComponent, noop);
+  hydrating = false;
+
+  // manually mounted instance, call mounted on self
+  // mounted is called for render-created child components in its inserted hook
+  if (vm.$vnode == null) {
+    vm._isMounted = true;
+    callHook(vm, 'mounted');
+  }
+  return vm
+}
+
+function updateChildComponent (
+  vm,
+  propsData,
+  listeners,
+  parentVnode,
+  renderChildren
+) {
+  // determine whether component has slot children
+  // we need to do this before overwriting $options._renderChildren
+  var hasChildren = !!(
+    renderChildren ||               // has new static slots
+    vm.$options._renderChildren ||  // has old static slots
+    parentVnode.data.scopedSlots || // has new scoped slots
+    vm.$scopedSlots !== emptyObject // has old scoped slots
+  );
+
+  vm.$options._parentVnode = parentVnode;
+  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
+  if (vm._vnode) { // update child tree's parent
+    vm._vnode.parent = parentVnode;
+  }
+  vm.$options._renderChildren = renderChildren;
+
+  // update props
+  if (propsData && vm.$options.props) {
+    observerState.shouldConvert = false;
+    {
+      observerState.isSettingProps = true;
+    }
+    var props = vm._props;
+    var propKeys = vm.$options._propKeys || [];
+    for (var i = 0; i < propKeys.length; i++) {
+      var key = propKeys[i];
+      props[key] = validateProp(key, vm.$options.props, propsData, vm);
+    }
+    observerState.shouldConvert = true;
+    {
+      observerState.isSettingProps = false;
+    }
+    // keep a copy of raw propsData
+    vm.$options.propsData = propsData;
+  }
+  // update listeners
+  if (listeners) {
+    var oldListeners = vm.$options._parentListeners;
+    vm.$options._parentListeners = listeners;
+    updateComponentListeners(vm, listeners, oldListeners);
+  }
+  // resolve slots + force update if has children
+  if (hasChildren) {
+    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
+    vm.$forceUpdate();
+  }
+}
+
+function isInInactiveTree (vm) {
+  while (vm && (vm = vm.$parent)) {
+    if (vm._inactive) { return true }
+  }
+  return false
+}
+
+function activateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = false;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  } else if (vm._directInactive) {
+    return
+  }
+  if (vm._inactive || vm._inactive == null) {
+    vm._inactive = false;
+    for (var i = 0; i < vm.$children.length; i++) {
+      activateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'activated');
+  }
+}
+
+function deactivateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = true;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  }
+  if (!vm._inactive) {
+    vm._inactive = true;
+    for (var i = 0; i < vm.$children.length; i++) {
+      deactivateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'deactivated');
+  }
+}
+
+function callHook (vm, hook) {
+  var handlers = vm.$options[hook];
+  if (handlers) {
+    for (var i = 0, j = handlers.length; i < j; i++) {
+      try {
+        handlers[i].call(vm);
+      } catch (e) {
+        handleError(e, vm, (hook + " hook"));
+      }
+    }
+  }
+  if (vm._hasHookEvent) {
+    vm.$emit('hook:' + hook);
+  }
+}
+
+/*  */
+
+
+var queue = [];
+var has = {};
+var circular = {};
+var waiting = false;
+var flushing = false;
+var index = 0;
+
+/**
+ * Reset the scheduler's state.
+ */
+function resetSchedulerState () {
+  queue.length = 0;
+  has = {};
+  {
+    circular = {};
+  }
+  waiting = flushing = false;
+}
+
+/**
+ * Flush both queues and run the watchers.
+ */
+function flushSchedulerQueue () {
+  flushing = true;
+  var watcher, id, vm;
+
+  // Sort queue before flush.
+  // This ensures that:
+  // 1. Components are updated from parent to child. (because parent is always
+  //    created before the child)
+  // 2. A component's user watchers are run before its render watcher (because
+  //    user watchers are created before the render watcher)
+  // 3. If a component is destroyed during a parent component's watcher run,
+  //    its watchers can be skipped.
+  queue.sort(function (a, b) { return a.id - b.id; });
+
+  // do not cache length because more watchers might be pushed
+  // as we run existing watchers
+  for (index = 0; index < queue.length; index++) {
+    watcher = queue[index];
+    id = watcher.id;
+    has[id] = null;
+    watcher.run();
+    // in dev build, check and stop circular updates.
+    if ("development" !== 'production' && has[id] != null) {
+      circular[id] = (circular[id] || 0) + 1;
+      if (circular[id] > config._maxUpdateCount) {
+        warn(
+          'You may have an infinite update loop ' + (
+            watcher.user
+              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
+              : "in a component render function."
+          ),
+          watcher.vm
+        );
+        break
+      }
+    }
+  }
+
+  // call updated hooks
+  index = queue.length;
+  while (index--) {
+    watcher = queue[index];
+    vm = watcher.vm;
+    if (vm._watcher === watcher && vm._isMounted) {
+      callHook(vm, 'updated');
+    }
+  }
+
+  // devtool hook
+  /* istanbul ignore if */
+  if (devtools && config.devtools) {
+    devtools.emit('flush');
+  }
+
+  resetSchedulerState();
+}
+
+/**
+ * Push a watcher into the watcher queue.
+ * Jobs with duplicate IDs will be skipped unless it's
+ * pushed when the queue is being flushed.
+ */
+function queueWatcher (watcher) {
+  var id = watcher.id;
+  if (has[id] == null) {
+    has[id] = true;
+    if (!flushing) {
+      queue.push(watcher);
+    } else {
+      // if already flushing, splice the watcher based on its id
+      // if already past its id, it will be run next immediately.
+      var i = queue.length - 1;
+      while (i >= 0 && queue[i].id > watcher.id) {
+        i--;
+      }
+      queue.splice(Math.max(i, index) + 1, 0, watcher);
+    }
+    // queue the flush
+    if (!waiting) {
+      waiting = true;
+      nextTick(flushSchedulerQueue);
+    }
+  }
+}
+
+/*  */
+
+var uid$2 = 0;
+
+/**
+ * A watcher parses an expression, collects dependencies,
+ * and fires callback when the expression value changes.
+ * This is used for both the $watch() api and directives.
+ */
+var Watcher = function Watcher (
+  vm,
+  expOrFn,
+  cb,
+  options
+) {
+  this.vm = vm;
+  vm._watchers.push(this);
+  // options
+  if (options) {
+    this.deep = !!options.deep;
+    this.user = !!options.user;
+    this.lazy = !!options.lazy;
+    this.sync = !!options.sync;
+  } else {
+    this.deep = this.user = this.lazy = this.sync = false;
+  }
+  this.cb = cb;
+  this.id = ++uid$2; // uid for batching
+  this.active = true;
+  this.dirty = this.lazy; // for lazy watchers
+  this.deps = [];
+  this.newDeps = [];
+  this.depIds = new _Set();
+  this.newDepIds = new _Set();
+  this.expression = expOrFn.toString();
+  // parse expression for getter
+  if (typeof expOrFn === 'function') {
+    this.getter = expOrFn;
+  } else {
+    this.getter = parsePath(expOrFn);
+    if (!this.getter) {
+      this.getter = function () {};
+      "development" !== 'production' && warn(
+        "Failed watching path: \"" + expOrFn + "\" " +
+        'Watcher only accepts simple dot-delimited paths. ' +
+        'For full control, use a function instead.',
+        vm
+      );
+    }
+  }
+  this.value = this.lazy
+    ? undefined
+    : this.get();
+};
+
+/**
+ * Evaluate the getter, and re-collect dependencies.
+ */
+Watcher.prototype.get = function get () {
+  pushTarget(this);
+  var value;
+  var vm = this.vm;
+  if (this.user) {
+    try {
+      value = this.getter.call(vm, vm);
+    } catch (e) {
+      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
+    }
+  } else {
+    value = this.getter.call(vm, vm);
+  }
+  // "touch" every property so they are all tracked as
+  // dependencies for deep watching
+  if (this.deep) {
+    traverse(value);
+  }
+  popTarget();
+  this.cleanupDeps();
+  return value
+};
+
+/**
+ * Add a dependency to this directive.
+ */
+Watcher.prototype.addDep = function addDep (dep) {
+  var id = dep.id;
+  if (!this.newDepIds.has(id)) {
+    this.newDepIds.add(id);
+    this.newDeps.push(dep);
+    if (!this.depIds.has(id)) {
+      dep.addSub(this);
+    }
+  }
+};
+
+/**
+ * Clean up for dependency collection.
+ */
+Watcher.prototype.cleanupDeps = function cleanupDeps () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    var dep = this$1.deps[i];
+    if (!this$1.newDepIds.has(dep.id)) {
+      dep.removeSub(this$1);
+    }
+  }
+  var tmp = this.depIds;
+  this.depIds = this.newDepIds;
+  this.newDepIds = tmp;
+  this.newDepIds.clear();
+  tmp = this.deps;
+  this.deps = this.newDeps;
+  this.newDeps = tmp;
+  this.newDeps.length = 0;
+};
+
+/**
+ * Subscriber interface.
+ * Will be called when a dependency changes.
+ */
+Watcher.prototype.update = function update () {
+  /* istanbul ignore else */
+  if (this.lazy) {
+    this.dirty = true;
+  } else if (this.sync) {
+    this.run();
+  } else {
+    queueWatcher(this);
+  }
+};
+
+/**
+ * Scheduler job interface.
+ * Will be called by the scheduler.
+ */
+Watcher.prototype.run = function run () {
+  if (this.active) {
+    var value = this.get();
+    if (
+      value !== this.value ||
+      // Deep watchers and watchers on Object/Arrays should fire even
+      // when the value is the same, because the value may
+      // have mutated.
+      isObject(value) ||
+      this.deep
+    ) {
+      // set new value
+      var oldValue = this.value;
+      this.value = value;
+      if (this.user) {
+        try {
+          this.cb.call(this.vm, value, oldValue);
+        } catch (e) {
+          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
+        }
+      } else {
+        this.cb.call(this.vm, value, oldValue);
+      }
+    }
+  }
+};
+
+/**
+ * Evaluate the value of the watcher.
+ * This only gets called for lazy watchers.
+ */
+Watcher.prototype.evaluate = function evaluate () {
+  this.value = this.get();
+  this.dirty = false;
+};
+
+/**
+ * Depend on all deps collected by this watcher.
+ */
+Watcher.prototype.depend = function depend () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    this$1.deps[i].depend();
+  }
+};
+
+/**
+ * Remove self from all dependencies' subscriber list.
+ */
+Watcher.prototype.teardown = function teardown () {
+    var this$1 = this;
+
+  if (this.active) {
+    // remove self from vm's watcher list
+    // this is a somewhat expensive operation so we skip it
+    // if the vm is being destroyed.
+    if (!this.vm._isBeingDestroyed) {
+      remove(this.vm._watchers, this);
+    }
+    var i = this.deps.length;
+    while (i--) {
+      this$1.deps[i].removeSub(this$1);
+    }
+    this.active = false;
+  }
+};
+
+/**
+ * Recursively traverse an object to evoke all converted
+ * getters, so that every nested property inside the object
+ * is collected as a "deep" dependency.
+ */
+var seenObjects = new _Set();
+function traverse (val) {
+  seenObjects.clear();
+  _traverse(val, seenObjects);
+}
+
+function _traverse (val, seen) {
+  var i, keys;
+  var isA = Array.isArray(val);
+  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
+    return
+  }
+  if (val.__ob__) {
+    var depId = val.__ob__.dep.id;
+    if (seen.has(depId)) {
+      return
+    }
+    seen.add(depId);
+  }
+  if (isA) {
+    i = val.length;
+    while (i--) { _traverse(val[i], seen); }
+  } else {
+    keys = Object.keys(val);
+    i = keys.length;
+    while (i--) { _traverse(val[keys[i]], seen); }
+  }
+}
+
+/*  */
+
+var sharedPropertyDefinition = {
+  enumerable: true,
+  configurable: true,
+  get: noop,
+  set: noop
+};
+
+function proxy (target, sourceKey, key) {
+  sharedPropertyDefinition.get = function proxyGetter () {
+    return this[sourceKey][key]
+  };
+  sharedPropertyDefinition.set = function proxySetter (val) {
+    this[sourceKey][key] = val;
+  };
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function initState (vm) {
+  vm._watchers = [];
+  var opts = vm.$options;
+  if (opts.props) { initProps(vm, opts.props); }
+  if (opts.methods) { initMethods(vm, opts.methods); }
+  if (opts.data) {
+    initData(vm);
+  } else {
+    observe(vm._data = {}, true /* asRootData */);
+  }
+  if (opts.computed) { initComputed(vm, opts.computed); }
+  if (opts.watch) { initWatch(vm, opts.watch); }
+}
+
+var isReservedProp = { key: 1, ref: 1, slot: 1 };
+
+function initProps (vm, propsOptions) {
+  var propsData = vm.$options.propsData || {};
+  var props = vm._props = {};
+  // cache prop keys so that future props updates can iterate using Array
+  // instead of dynamic object key enumeration.
+  var keys = vm.$options._propKeys = [];
+  var isRoot = !vm.$parent;
+  // root instance props should be converted
+  observerState.shouldConvert = isRoot;
+  var loop = function ( key ) {
+    keys.push(key);
+    var value = validateProp(key, propsOptions, propsData, vm);
+    /* istanbul ignore else */
+    {
+      if (isReservedProp[key]) {
+        warn(
+          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
+          vm
+        );
+      }
+      defineReactive$$1(props, key, value, function () {
+        if (vm.$parent && !observerState.isSettingProps) {
+          warn(
+            "Avoid mutating a prop directly since the value will be " +
+            "overwritten whenever the parent component re-renders. " +
+            "Instead, use a data or computed property based on the prop's " +
+            "value. Prop being mutated: \"" + key + "\"",
+            vm
+          );
+        }
+      });
+    }
+    // static props are already proxied on the component's prototype
+    // during Vue.extend(). We only need to proxy props defined at
+    // instantiation here.
+    if (!(key in vm)) {
+      proxy(vm, "_props", key);
+    }
+  };
+
+  for (var key in propsOptions) loop( key );
+  observerState.shouldConvert = true;
+}
+
+function initData (vm) {
+  var data = vm.$options.data;
+  data = vm._data = typeof data === 'function'
+    ? data.call(vm)
+    : data || {};
+  if (!isPlainObject(data)) {
+    data = {};
+    "development" !== 'production' && warn(
+      'data functions should return an object:\n' +
+      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
+      vm
+    );
+  }
+  // proxy data on instance
+  var keys = Object.keys(data);
+  var props = vm.$options.props;
+  var i = keys.length;
+  while (i--) {
+    if (props && hasOwn(props, keys[i])) {
+      "development" !== 'production' && warn(
+        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
+        "Use prop default value instead.",
+        vm
+      );
+    } else if (!isReserved(keys[i])) {
+      proxy(vm, "_data", keys[i]);
+    }
+  }
+  // observe data
+  observe(data, true /* asRootData */);
+}
+
+var computedWatcherOptions = { lazy: true };
+
+function initComputed (vm, computed) {
+  var watchers = vm._computedWatchers = Object.create(null);
+
+  for (var key in computed) {
+    var userDef = computed[key];
+    var getter = typeof userDef === 'function' ? userDef : userDef.get;
+    // create internal watcher for the computed property.
+    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);
+
+    // component-defined computed properties are already defined on the
+    // component prototype. We only need to define computed properties defined
+    // at instantiation here.
+    if (!(key in vm)) {
+      defineComputed(vm, key, userDef);
+    }
+  }
+}
+
+function defineComputed (target, key, userDef) {
+  if (typeof userDef === 'function') {
+    sharedPropertyDefinition.get = createComputedGetter(key);
+    sharedPropertyDefinition.set = noop;
+  } else {
+    sharedPropertyDefinition.get = userDef.get
+      ? userDef.cache !== false
+        ? createComputedGetter(key)
+        : userDef.get
+      : noop;
+    sharedPropertyDefinition.set = userDef.set
+      ? userDef.set
+      : noop;
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function createComputedGetter (key) {
+  return function computedGetter () {
+    var watcher = this._computedWatchers && this._computedWatchers[key];
+    if (watcher) {
+      if (watcher.dirty) {
+        watcher.evaluate();
+      }
+      if (Dep.target) {
+        watcher.depend();
+      }
+      return watcher.value
+    }
+  }
+}
+
+function initMethods (vm, methods) {
+  var props = vm.$options.props;
+  for (var key in methods) {
+    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
+    {
+      if (methods[key] == null) {
+        warn(
+          "method \"" + key + "\" has an undefined value in the component definition. " +
+          "Did you reference the function correctly?",
+          vm
+        );
+      }
+      if (props && hasOwn(props, key)) {
+        warn(
+          ("method \"" + key + "\" has already been defined as a prop."),
+          vm
+        );
+      }
+    }
+  }
+}
+
+function initWatch (vm, watch) {
+  for (var key in watch) {
+    var handler = watch[key];
+    if (Array.isArray(handler)) {
+      for (var i = 0; i < handler.length; i++) {
+        createWatcher(vm, key, handler[i]);
+      }
+    } else {
+      createWatcher(vm, key, handler);
+    }
+  }
+}
+
+function createWatcher (vm, key, handler) {
+  var options;
+  if (isPlainObject(handler)) {
+    options = handler;
+    handler = handler.handler;
+  }
+  if (typeof handler === 'string') {
+    handler = vm[handler];
+  }
+  vm.$watch(key, handler, options);
+}
+
+function stateMixin (Vue) {
+  // flow somehow has problems with directly declared definition object
+  // when using Object.defineProperty, so we have to procedurally build up
+  // the object here.
+  var dataDef = {};
+  dataDef.get = function () { return this._data };
+  var propsDef = {};
+  propsDef.get = function () { return this._props };
+  {
+    dataDef.set = function (newData) {
+      warn(
+        'Avoid replacing instance root $data. ' +
+        'Use nested data properties instead.',
+        this
+      );
+    };
+    propsDef.set = function () {
+      warn("$props is readonly.", this);
+    };
+  }
+  Object.defineProperty(Vue.prototype, '$data', dataDef);
+  Object.defineProperty(Vue.prototype, '$props', propsDef);
+
+  Vue.prototype.$set = set;
+  Vue.prototype.$delete = del;
+
+  Vue.prototype.$watch = function (
+    expOrFn,
+    cb,
+    options
+  ) {
+    var vm = this;
+    options = options || {};
+    options.user = true;
+    var watcher = new Watcher(vm, expOrFn, cb, options);
+    if (options.immediate) {
+      cb.call(vm, watcher.value);
+    }
+    return function unwatchFn () {
+      watcher.teardown();
+    }
+  };
+}
+
+/*  */
+
+var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy };
+var hooksToMerge = Object.keys(hooks);
+
+function createComponent (
+  Ctor,
+  data,
+  context,
+  children,
+  tag
+) {
+  if (!Ctor) {
+    return
+  }
+
+  var baseCtor = context.$options._base;
+  if (isObject(Ctor)) {
+    Ctor = baseCtor.extend(Ctor);
+  }
+
+  if (typeof Ctor !== 'function') {
+    {
+      warn(("Invalid Component definition: " + (String(Ctor))), context);
+    }
+    return
+  }
+
+  // async component
+  if (!Ctor.cid) {
+    if (Ctor.resolved) {
+      Ctor = Ctor.resolved;
+    } else {
+      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
+        // it's ok to queue this on every render because
+        // $forceUpdate is buffered by the scheduler.
+        context.$forceUpdate();
+      });
+      if (!Ctor) {
+        // return nothing if this is indeed an async component
+        // wait for the callback to trigger parent update.
+        return
+      }
+    }
+  }
+
+  // resolve constructor options in case global mixins are applied after
+  // component constructor creation
+  resolveConstructorOptions(Ctor);
+
+  data = data || {};
+
+  // transform component v-model data into props & events
+  if (data.model) {
+    transformModel(Ctor.options, data);
+  }
+
+  // extract props
+  var propsData = extractProps(data, Ctor);
+
+  // functional component
+  if (Ctor.options.functional) {
+    return createFunctionalComponent(Ctor, propsData, data, context, children)
+  }
+
+  // extract listeners, since these needs to be treated as
+  // child component listeners instead of DOM listeners
+  var listeners = data.on;
+  // replace with listeners with .native modifier
+  data.on = data.nativeOn;
+
+  if (Ctor.options.abstract) {
+    // abstract components do not keep anything
+    // other than props & listeners
+    data = {};
+  }
+
+  // merge component management hooks onto the placeholder node
+  mergeHooks(data);
+
+  // return a placeholder vnode
+  var name = Ctor.options.name || tag;
+  var vnode = new VNode(
+    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
+    data, undefined, undefined, undefined, context,
+    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
+  );
+  return vnode
+}
+
+function createFunctionalComponent (
+  Ctor,
+  propsData,
+  data,
+  context,
+  children
+) {
+  var props = {};
+  var propOptions = Ctor.options.props;
+  if (propOptions) {
+    for (var key in propOptions) {
+      props[key] = validateProp(key, propOptions, propsData);
+    }
+  }
+  // ensure the createElement function in functional components
+  // gets a unique context - this is necessary for correct named slot check
+  var _context = Object.create(context);
+  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
+  var vnode = Ctor.options.render.call(null, h, {
+    props: props,
+    data: data,
+    parent: context,
+    children: children,
+    slots: function () { return resolveSlots(children, context); }
+  });
+  if (vnode instanceof VNode) {
+    vnode.functionalContext = context;
+    if (data.slot) {
+      (vnode.data || (vnode.data = {})).slot = data.slot;
+    }
+  }
+  return vnode
+}
+
+function createComponentInstanceForVnode (
+  vnode, // we know it's MountedComponentVNode but flow doesn't
+  parent, // activeInstance in lifecycle state
+  parentElm,
+  refElm
+) {
+  var vnodeComponentOptions = vnode.componentOptions;
+  var options = {
+    _isComponent: true,
+    parent: parent,
+    propsData: vnodeComponentOptions.propsData,
+    _componentTag: vnodeComponentOptions.tag,
+    _parentVnode: vnode,
+    _parentListeners: vnodeComponentOptions.listeners,
+    _renderChildren: vnodeComponentOptions.children,
+    _parentElm: parentElm || null,
+    _refElm: refElm || null
+  };
+  // check inline-template render functions
+  var inlineTemplate = vnode.data.inlineTemplate;
+  if (inlineTemplate) {
+    options.render = inlineTemplate.render;
+    options.staticRenderFns = inlineTemplate.staticRenderFns;
+  }
+  return new vnodeComponentOptions.Ctor(options)
+}
+
+function init (
+  vnode,
+  hydrating,
+  parentElm,
+  refElm
+) {
+  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
+    var child = vnode.componentInstance = createComponentInstanceForVnode(
+      vnode,
+      activeInstance,
+      parentElm,
+      refElm
+    );
+    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
+  } else if (vnode.data.keepAlive) {
+    // kept-alive components, treat as a patch
+    var mountedNode = vnode; // work around flow
+    prepatch(mountedNode, mountedNode);
+  }
+}
+
+function prepatch (
+  oldVnode,
+  vnode
+) {
+  var options = vnode.componentOptions;
+  var child = vnode.componentInstance = oldVnode.componentInstance;
+  updateChildComponent(
+    child,
+    options.propsData, // updated props
+    options.listeners, // updated listeners
+    vnode, // new parent vnode
+    options.children // new children
+  );
+}
+
+function insert (vnode) {
+  if (!vnode.componentInstance._isMounted) {
+    vnode.componentInstance._isMounted = true;
+    callHook(vnode.componentInstance, 'mounted');
+  }
+  if (vnode.data.keepAlive) {
+    activateChildComponent(vnode.componentInstance, true /* direct */);
+  }
+}
+
+function destroy (vnode) {
+  if (!vnode.componentInstance._isDestroyed) {
+    if (!vnode.data.keepAlive) {
+      vnode.componentInstance.$destroy();
+    } else {
+      deactivateChildComponent(vnode.componentInstance, true /* direct */);
+    }
+  }
+}
+
+function resolveAsyncComponent (
+  factory,
+  baseCtor,
+  cb
+) {
+  if (factory.requested) {
+    // pool callbacks
+    factory.pendingCallbacks.push(cb);
+  } else {
+    factory.requested = true;
+    var cbs = factory.pendingCallbacks = [cb];
+    var sync = true;
+
+    var resolve = function (res) {
+      if (isObject(res)) {
+        res = baseCtor.extend(res);
+      }
+      // cache resolved
+      factory.resolved = res;
+      // invoke callbacks only if this is not a synchronous resolve
+      // (async resolves are shimmed as synchronous during SSR)
+      if (!sync) {
+        for (var i = 0, l = cbs.length; i < l; i++) {
+          cbs[i](res);
+        }
+      }
+    };
+
+    var reject = function (reason) {
+      "development" !== 'production' && warn(
+        "Failed to resolve async component: " + (String(factory)) +
+        (reason ? ("\nReason: " + reason) : '')
+      );
+    };
+
+    var res = factory(resolve, reject);
+
+    // handle promise
+    if (res && typeof res.then === 'function' && !factory.resolved) {
+      res.then(resolve, reject);
+    }
+
+    sync = false;
+    // return in case resolved synchronously
+    return factory.resolved
+  }
+}
+
+function extractProps (data, Ctor) {
+  // we are only extracting raw values here.
+  // validation and default values are handled in the child
+  // component itself.
+  var propOptions = Ctor.options.props;
+  if (!propOptions) {
+    return
+  }
+  var res = {};
+  var attrs = data.attrs;
+  var props = data.props;
+  var domProps = data.domProps;
+  if (attrs || props || domProps) {
+    for (var key in propOptions) {
+      var altKey = hyphenate(key);
+      checkProp(res, props, key, altKey, true) ||
+      checkProp(res, attrs, key, altKey) ||
+      checkProp(res, domProps, key, altKey);
+    }
+  }
+  return res
+}
+
+function checkProp (
+  res,
+  hash,
+  key,
+  altKey,
+  preserve
+) {
+  if (hash) {
+    if (hasOwn(hash, key)) {
+      res[key] = hash[key];
+      if (!preserve) {
+        delete hash[key];
+      }
+      return true
+    } else if (hasOwn(hash, altKey)) {
+      res[key] = hash[altKey];
+      if (!preserve) {
+        delete hash[altKey];
+      }
+      return true
+    }
+  }
+  return false
+}
+
+function mergeHooks (data) {
+  if (!data.hook) {
+    data.hook = {};
+  }
+  for (var i = 0; i < hooksToMerge.length; i++) {
+    var key = hooksToMerge[i];
+    var fromParent = data.hook[key];
+    var ours = hooks[key];
+    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
+  }
+}
+
+function mergeHook$1 (one, two) {
+  return function (a, b, c, d) {
+    one(a, b, c, d);
+    two(a, b, c, d);
+  }
+}
+
+// transform component v-model info (value and callback) into
+// prop and event handler respectively.
+function transformModel (options, data) {
+  var prop = (options.model && options.model.prop) || 'value';
+  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
+  var on = data.on || (data.on = {});
+  if (on[event]) {
+    on[event] = [data.model.callback].concat(on[event]);
+  } else {
+    on[event] = data.model.callback;
+  }
+}
+
+/*  */
+
+var SIMPLE_NORMALIZE = 1;
+var ALWAYS_NORMALIZE = 2;
+
+// wrapper function for providing a more flexible interface
+// without getting yelled at by flow
+function createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType,
+  alwaysNormalize
+) {
+  if (Array.isArray(data) || isPrimitive(data)) {
+    normalizationType = children;
+    children = data;
+    data = undefined;
+  }
+  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
+  return _createElement(context, tag, data, children, normalizationType)
+}
+
+function _createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType
+) {
+  if (data && data.__ob__) {
+    "development" !== 'production' && warn(
+      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
+      'Always create fresh vnode data objects in each render!',
+      context
+    );
+    return createEmptyVNode()
+  }
+  if (!tag) {
+    // in case of component :is set to falsy value
+    return createEmptyVNode()
+  }
+  // support single function children as default scoped slot
+  if (Array.isArray(children) &&
+      typeof children[0] === 'function') {
+    data = data || {};
+    data.scopedSlots = { default: children[0] };
+    children.length = 0;
+  }
+  if (normalizationType === ALWAYS_NORMALIZE) {
+    children = normalizeChildren(children);
+  } else if (normalizationType === SIMPLE_NORMALIZE) {
+    children = simpleNormalizeChildren(children);
+  }
+  var vnode, ns;
+  if (typeof tag === 'string') {
+    var Ctor;
+    ns = config.getTagNamespace(tag);
+    if (config.isReservedTag(tag)) {
+      // platform built-in elements
+      vnode = new VNode(
+        config.parsePlatformTagName(tag), data, children,
+        undefined, undefined, context
+      );
+    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
+      // component
+      vnode = createComponent(Ctor, data, context, children, tag);
+    } else {
+      // unknown or unlisted namespaced elements
+      // check at runtime because it may get assigned a namespace when its
+      // parent normalizes children
+      vnode = new VNode(
+        tag, data, children,
+        undefined, undefined, context
+      );
+    }
+  } else {
+    // direct component options / constructor
+    vnode = createComponent(tag, data, context, children);
+  }
+  if (vnode) {
+    if (ns) { applyNS(vnode, ns); }
+    return vnode
+  } else {
+    return createEmptyVNode()
+  }
+}
+
+function applyNS (vnode, ns) {
+  vnode.ns = ns;
+  if (vnode.tag === 'foreignObject') {
+    // use default namespace inside foreignObject
+    return
+  }
+  if (vnode.children) {
+    for (var i = 0, l = vnode.children.length; i < l; i++) {
+      var child = vnode.children[i];
+      if (child.tag && !child.ns) {
+        applyNS(child, ns);
+      }
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering v-for lists.
+ */
+function renderList (
+  val,
+  render
+) {
+  var ret, i, l, keys, key;
+  if (Array.isArray(val) || typeof val === 'string') {
+    ret = new Array(val.length);
+    for (i = 0, l = val.length; i < l; i++) {
+      ret[i] = render(val[i], i);
+    }
+  } else if (typeof val === 'number') {
+    ret = new Array(val);
+    for (i = 0; i < val; i++) {
+      ret[i] = render(i + 1, i);
+    }
+  } else if (isObject(val)) {
+    keys = Object.keys(val);
+    ret = new Array(keys.length);
+    for (i = 0, l = keys.length; i < l; i++) {
+      key = keys[i];
+      ret[i] = render(val[key], key, i);
+    }
+  }
+  return ret
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering <slot>
+ */
+function renderSlot (
+  name,
+  fallback,
+  props,
+  bindObject
+) {
+  var scopedSlotFn = this.$scopedSlots[name];
+  if (scopedSlotFn) { // scoped slot
+    props = props || {};
+    if (bindObject) {
+      extend(props, bindObject);
+    }
+    return scopedSlotFn(props) || fallback
+  } else {
+    var slotNodes = this.$slots[name];
+    // warn duplicate slot usage
+    if (slotNodes && "development" !== 'production') {
+      slotNodes._rendered && warn(
+        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
+        "- this will likely cause render errors.",
+        this
+      );
+      slotNodes._rendered = true;
+    }
+    return slotNodes || fallback
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving filters
+ */
+function resolveFilter (id) {
+  return resolveAsset(this.$options, 'filters', id, true) || identity
+}
+
+/*  */
+
+/**
+ * Runtime helper for checking keyCodes from config.
+ */
+function checkKeyCodes (
+  eventKeyCode,
+  key,
+  builtInAlias
+) {
+  var keyCodes = config.keyCodes[key] || builtInAlias;
+  if (Array.isArray(keyCodes)) {
+    return keyCodes.indexOf(eventKeyCode) === -1
+  } else {
+    return keyCodes !== eventKeyCode
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for merging v-bind="object" into a VNode's data.
+ */
+function bindObjectProps (
+  data,
+  tag,
+  value,
+  asProp
+) {
+  if (value) {
+    if (!isObject(value)) {
+      "development" !== 'production' && warn(
+        'v-bind without argument expects an Object or Array value',
+        this
+      );
+    } else {
+      if (Array.isArray(value)) {
+        value = toObject(value);
+      }
+      for (var key in value) {
+        if (key === 'class' || key === 'style') {
+          data[key] = value[key];
+        } else {
+          var type = data.attrs && data.attrs.type;
+          var hash = asProp || config.mustUseProp(tag, type, key)
+            ? data.domProps || (data.domProps = {})
+            : data.attrs || (data.attrs = {});
+          hash[key] = value[key];
+        }
+      }
+    }
+  }
+  return data
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering static trees.
+ */
+function renderStatic (
+  index,
+  isInFor
+) {
+  var tree = this._staticTrees[index];
+  // if has already-rendered static tree and not inside v-for,
+  // we can reuse the same tree by doing a shallow clone.
+  if (tree && !isInFor) {
+    return Array.isArray(tree)
+      ? cloneVNodes(tree)
+      : cloneVNode(tree)
+  }
+  // otherwise, render a fresh tree.
+  tree = this._staticTrees[index] =
+    this.$options.staticRenderFns[index].call(this._renderProxy);
+  markStatic(tree, ("__static__" + index), false);
+  return tree
+}
+
+/**
+ * Runtime helper for v-once.
+ * Effectively it means marking the node as static with a unique key.
+ */
+function markOnce (
+  tree,
+  index,
+  key
+) {
+  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
+  return tree
+}
+
+function markStatic (
+  tree,
+  key,
+  isOnce
+) {
+  if (Array.isArray(tree)) {
+    for (var i = 0; i < tree.length; i++) {
+      if (tree[i] && typeof tree[i] !== 'string') {
+        markStaticNode(tree[i], (key + "_" + i), isOnce);
+      }
+    }
+  } else {
+    markStaticNode(tree, key, isOnce);
+  }
+}
+
+function markStaticNode (node, key, isOnce) {
+  node.isStatic = true;
+  node.key = key;
+  node.isOnce = isOnce;
+}
+
+/*  */
+
+function initRender (vm) {
+  vm.$vnode = null; // the placeholder node in parent tree
+  vm._vnode = null; // the root of the child tree
+  vm._staticTrees = null;
+  var parentVnode = vm.$options._parentVnode;
+  var renderContext = parentVnode && parentVnode.context;
+  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
+  vm.$scopedSlots = emptyObject;
+  // bind the createElement fn to this instance
+  // so that we get proper render context inside it.
+  // args order: tag, data, children, normalizationType, alwaysNormalize
+  // internal version is used by render functions compiled from templates
+  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
+  // normalization is always applied for the public version, used in
+  // user-written render functions.
+  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
+}
+
+function renderMixin (Vue) {
+  Vue.prototype.$nextTick = function (fn) {
+    return nextTick(fn, this)
+  };
+
+  Vue.prototype._render = function () {
+    var vm = this;
+    var ref = vm.$options;
+    var render = ref.render;
+    var staticRenderFns = ref.staticRenderFns;
+    var _parentVnode = ref._parentVnode;
+
+    if (vm._isMounted) {
+      // clone slot nodes on re-renders
+      for (var key in vm.$slots) {
+        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
+      }
+    }
+
+    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;
+
+    if (staticRenderFns && !vm._staticTrees) {
+      vm._staticTrees = [];
+    }
+    // set parent vnode. this allows render functions to have access
+    // to the data on the placeholder node.
+    vm.$vnode = _parentVnode;
+    // render self
+    var vnode;
+    try {
+      vnode = render.call(vm._renderProxy, vm.$createElement);
+    } catch (e) {
+      handleError(e, vm, "render function");
+      // return error render result,
+      // or previous vnode to prevent render error causing blank component
+      /* istanbul ignore else */
+      {
+        vnode = vm.$options.renderError
+          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
+          : vm._vnode;
+      }
+    }
+    // return empty vnode in case the render function errored out
+    if (!(vnode instanceof VNode)) {
+      if ("development" !== 'production' && Array.isArray(vnode)) {
+        warn(
+          'Multiple root nodes returned from render function. Render function ' +
+          'should return a single root node.',
+          vm
+        );
+      }
+      vnode = createEmptyVNode();
+    }
+    // set parent
+    vnode.parent = _parentVnode;
+    return vnode
+  };
+
+  // internal render helpers.
+  // these are exposed on the instance prototype to reduce generated render
+  // code size.
+  Vue.prototype._o = markOnce;
+  Vue.prototype._n = toNumber;
+  Vue.prototype._s = _toString;
+  Vue.prototype._l = renderList;
+  Vue.prototype._t = renderSlot;
+  Vue.prototype._q = looseEqual;
+  Vue.prototype._i = looseIndexOf;
+  Vue.prototype._m = renderStatic;
+  Vue.prototype._f = resolveFilter;
+  Vue.prototype._k = checkKeyCodes;
+  Vue.prototype._b = bindObjectProps;
+  Vue.prototype._v = createTextVNode;
+  Vue.prototype._e = createEmptyVNode;
+  Vue.prototype._u = resolveScopedSlots;
+}
+
+/*  */
+
+function initProvide (vm) {
+  var provide = vm.$options.provide;
+  if (provide) {
+    vm._provided = typeof provide === 'function'
+      ? provide.call(vm)
+      : provide;
+  }
+}
+
+function initInjections (vm) {
+  var inject = vm.$options.inject;
+  if (inject) {
+    // inject is :any because flow is not smart enough to figure out cached
+    // isArray here
+    var isArray = Array.isArray(inject);
+    var keys = isArray
+      ? inject
+      : hasSymbol
+        ? Reflect.ownKeys(inject)
+        : Object.keys(inject);
+
+    for (var i = 0; i < keys.length; i++) {
+      var key = keys[i];
+      var provideKey = isArray ? key : inject[key];
+      var source = vm;
+      while (source) {
+        if (source._provided && provideKey in source._provided) {
+          vm[key] = source._provided[provideKey];
+          break
+        }
+        source = source.$parent;
+      }
+    }
+  }
+}
+
+/*  */
+
+var uid = 0;
+
+function initMixin (Vue) {
+  Vue.prototype._init = function (options) {
+    /* istanbul ignore if */
+    if ("development" !== 'production' && config.performance && perf) {
+      perf.mark('init');
+    }
+
+    var vm = this;
+    // a uid
+    vm._uid = uid++;
+    // a flag to avoid this being observed
+    vm._isVue = true;
+    // merge options
+    if (options && options._isComponent) {
+      // optimize internal component instantiation
+      // since dynamic options merging is pretty slow, and none of the
+      // internal component options needs special treatment.
+      initInternalComponent(vm, options);
+    } else {
+      vm.$options = mergeOptions(
+        resolveConstructorOptions(vm.constructor),
+        options || {},
+        vm
+      );
+    }
+    /* istanbul ignore else */
+    {
+      initProxy(vm);
+    }
+    // expose real self
+    vm._self = vm;
+    initLifecycle(vm);
+    initEvents(vm);
+    initRender(vm);
+    callHook(vm, 'beforeCreate');
+    initInjections(vm); // resolve injections before data/props
+    initState(vm);
+    initProvide(vm); // resolve provide after data/props
+    callHook(vm, 'created');
+
+    /* istanbul ignore if */
+    if ("development" !== 'production' && config.performance && perf) {
+      vm._name = formatComponentName(vm, false);
+      perf.mark('init end');
+      perf.measure(((vm._name) + " init"), 'init', 'init end');
+    }
+
+    if (vm.$options.el) {
+      vm.$mount(vm.$options.el);
+    }
+  };
+}
+
+function initInternalComponent (vm, options) {
+  var opts = vm.$options = Object.create(vm.constructor.options);
+  // doing this because it's faster than dynamic enumeration.
+  opts.parent = options.parent;
+  opts.propsData = options.propsData;
+  opts._parentVnode = options._parentVnode;
+  opts._parentListeners = options._parentListeners;
+  opts._renderChildren = options._renderChildren;
+  opts._componentTag = options._componentTag;
+  opts._parentElm = options._parentElm;
+  opts._refElm = options._refElm;
+  if (options.render) {
+    opts.render = options.render;
+    opts.staticRenderFns = options.staticRenderFns;
+  }
+}
+
+function resolveConstructorOptions (Ctor) {
+  var options = Ctor.options;
+  if (Ctor.super) {
+    var superOptions = resolveConstructorOptions(Ctor.super);
+    var cachedSuperOptions = Ctor.superOptions;
+    if (superOptions !== cachedSuperOptions) {
+      // super option changed,
+      // need to resolve new options.
+      Ctor.superOptions = superOptions;
+      // check if there are any late-modified/attached options (#4976)
+      var modifiedOptions = resolveModifiedOptions(Ctor);
+      // update base extend options
+      if (modifiedOptions) {
+        extend(Ctor.extendOptions, modifiedOptions);
+      }
+      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
+      if (options.name) {
+        options.components[options.name] = Ctor;
+      }
+    }
+  }
+  return options
+}
+
+function resolveModifiedOptions (Ctor) {
+  var modified;
+  var latest = Ctor.options;
+  var sealed = Ctor.sealedOptions;
+  for (var key in latest) {
+    if (latest[key] !== sealed[key]) {
+      if (!modified) { modified = {}; }
+      modified[key] = dedupe(latest[key], sealed[key]);
+    }
+  }
+  return modified
+}
+
+function dedupe (latest, sealed) {
+  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
+  // between merges
+  if (Array.isArray(latest)) {
+    var res = [];
+    sealed = Array.isArray(sealed) ? sealed : [sealed];
+    for (var i = 0; i < latest.length; i++) {
+      if (sealed.indexOf(latest[i]) < 0) {
+        res.push(latest[i]);
+      }
+    }
+    return res
+  } else {
+    return latest
+  }
+}
+
+function Vue$3 (options) {
+  if ("development" !== 'production' &&
+    !(this instanceof Vue$3)) {
+    warn('Vue is a constructor and should be called with the `new` keyword');
+  }
+  this._init(options);
+}
+
+initMixin(Vue$3);
+stateMixin(Vue$3);
+eventsMixin(Vue$3);
+lifecycleMixin(Vue$3);
+renderMixin(Vue$3);
+
+/*  */
+
+function initUse (Vue) {
+  Vue.use = function (plugin) {
+    /* istanbul ignore if */
+    if (plugin.installed) {
+      return
+    }
+    // additional parameters
+    var args = toArray(arguments, 1);
+    args.unshift(this);
+    if (typeof plugin.install === 'function') {
+      plugin.install.apply(plugin, args);
+    } else if (typeof plugin === 'function') {
+      plugin.apply(null, args);
+    }
+    plugin.installed = true;
+    return this
+  };
+}
+
+/*  */
+
+function initMixin$1 (Vue) {
+  Vue.mixin = function (mixin) {
+    this.options = mergeOptions(this.options, mixin);
+  };
+}
+
+/*  */
+
+function initExtend (Vue) {
+  /**
+   * Each instance constructor, including Vue, has a unique
+   * cid. This enables us to create wrapped "child
+   * constructors" for prototypal inheritance and cache them.
+   */
+  Vue.cid = 0;
+  var cid = 1;
+
+  /**
+   * Class inheritance
+   */
+  Vue.extend = function (extendOptions) {
+    extendOptions = extendOptions || {};
+    var Super = this;
+    var SuperId = Super.cid;
+    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
+    if (cachedCtors[SuperId]) {
+      return cachedCtors[SuperId]
+    }
+
+    var name = extendOptions.name || Super.options.name;
+    {
+      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+        warn(
+          'Invalid component name: "' + name + '". Component names ' +
+          'can only contain alphanumeric characters and the hyphen, ' +
+          'and must start with a letter.'
+        );
+      }
+    }
+
+    var Sub = function VueComponent (options) {
+      this._init(options);
+    };
+    Sub.prototype = Object.create(Super.prototype);
+    Sub.prototype.constructor = Sub;
+    Sub.cid = cid++;
+    Sub.options = mergeOptions(
+      Super.options,
+      extendOptions
+    );
+    Sub['super'] = Super;
+
+    // For props and computed properties, we define the proxy getters on
+    // the Vue instances at extension time, on the extended prototype. This
+    // avoids Object.defineProperty calls for each instance created.
+    if (Sub.options.props) {
+      initProps$1(Sub);
+    }
+    if (Sub.options.computed) {
+      initComputed$1(Sub);
+    }
+
+    // allow further extension/mixin/plugin usage
+    Sub.extend = Super.extend;
+    Sub.mixin = Super.mixin;
+    Sub.use = Super.use;
+
+    // create asset registers, so extended classes
+    // can have their private assets too.
+    config._assetTypes.forEach(function (type) {
+      Sub[type] = Super[type];
+    });
+    // enable recursive self-lookup
+    if (name) {
+      Sub.options.components[name] = Sub;
+    }
+
+    // keep a reference to the super options at extension time.
+    // later at instantiation we can check if Super's options have
+    // been updated.
+    Sub.superOptions = Super.options;
+    Sub.extendOptions = extendOptions;
+    Sub.sealedOptions = extend({}, Sub.options);
+
+    // cache constructor
+    cachedCtors[SuperId] = Sub;
+    return Sub
+  };
+}
+
+function initProps$1 (Comp) {
+  var props = Comp.options.props;
+  for (var key in props) {
+    proxy(Comp.prototype, "_props", key);
+  }
+}
+
+function initComputed$1 (Comp) {
+  var computed = Comp.options.computed;
+  for (var key in computed) {
+    defineComputed(Comp.prototype, key, computed[key]);
+  }
+}
+
+/*  */
+
+function initAssetRegisters (Vue) {
+  /**
+   * Create asset registration methods.
+   */
+  config._assetTypes.forEach(function (type) {
+    Vue[type] = function (
+      id,
+      definition
+    ) {
+      if (!definition) {
+        return this.options[type + 's'][id]
+      } else {
+        /* istanbul ignore if */
+        {
+          if (type === 'component' && config.isReservedTag(id)) {
+            warn(
+              'Do not use built-in or reserved HTML elements as component ' +
+              'id: ' + id
+            );
+          }
+        }
+        if (type === 'component' && isPlainObject(definition)) {
+          definition.name = definition.name || id;
+          definition = this.options._base.extend(definition);
+        }
+        if (type === 'directive' && typeof definition === 'function') {
+          definition = { bind: definition, update: definition };
+        }
+        this.options[type + 's'][id] = definition;
+        return definition
+      }
+    };
+  });
+}
+
+/*  */
+
+var patternTypes = [String, RegExp];
+
+function getComponentName (opts) {
+  return opts && (opts.Ctor.options.name || opts.tag)
+}
+
+function matches (pattern, name) {
+  if (typeof pattern === 'string') {
+    return pattern.split(',').indexOf(name) > -1
+  } else if (pattern instanceof RegExp) {
+    return pattern.test(name)
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function pruneCache (cache, filter) {
+  for (var key in cache) {
+    var cachedNode = cache[key];
+    if (cachedNode) {
+      var name = getComponentName(cachedNode.componentOptions);
+      if (name && !filter(name)) {
+        pruneCacheEntry(cachedNode);
+        cache[key] = null;
+      }
+    }
+  }
+}
+
+function pruneCacheEntry (vnode) {
+  if (vnode) {
+    if (!vnode.componentInstance._inactive) {
+      callHook(vnode.componentInstance, 'deactivated');
+    }
+    vnode.componentInstance.$destroy();
+  }
+}
+
+var KeepAlive = {
+  name: 'keep-alive',
+  abstract: true,
+
+  props: {
+    include: patternTypes,
+    exclude: patternTypes
+  },
+
+  created: function created () {
+    this.cache = Object.create(null);
+  },
+
+  destroyed: function destroyed () {
+    var this$1 = this;
+
+    for (var key in this$1.cache) {
+      pruneCacheEntry(this$1.cache[key]);
+    }
+  },
+
+  watch: {
+    include: function include (val) {
+      pruneCache(this.cache, function (name) { return matches(val, name); });
+    },
+    exclude: function exclude (val) {
+      pruneCache(this.cache, function (name) { return !matches(val, name); });
+    }
+  },
+
+  render: function render () {
+    var vnode = getFirstComponentChild(this.$slots.default);
+    var componentOptions = vnode && vnode.componentOptions;
+    if (componentOptions) {
+      // check pattern
+      var name = getComponentName(componentOptions);
+      if (name && (
+        (this.include && !matches(this.include, name)) ||
+        (this.exclude && matches(this.exclude, name))
+      )) {
+        return vnode
+      }
+      var key = vnode.key == null
+        // same constructor may get registered as different local components
+        // so cid alone is not enough (#3269)
+        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
+        : vnode.key;
+      if (this.cache[key]) {
+        vnode.componentInstance = this.cache[key].componentInstance;
+      } else {
+        this.cache[key] = vnode;
+      }
+      vnode.data.keepAlive = true;
+    }
+    return vnode
+  }
+};
+
+var builtInComponents = {
+  KeepAlive: KeepAlive
+};
+
+/*  */
+
+function initGlobalAPI (Vue) {
+  // config
+  var configDef = {};
+  configDef.get = function () { return config; };
+  {
+    configDef.set = function () {
+      warn(
+        'Do not replace the Vue.config object, set individual fields instead.'
+      );
+    };
+  }
+  Object.defineProperty(Vue, 'config', configDef);
+
+  // exposed util methods.
+  // NOTE: these are not considered part of the public API - avoid relying on
+  // them unless you are aware of the risk.
+  Vue.util = {
+    warn: warn,
+    extend: extend,
+    mergeOptions: mergeOptions,
+    defineReactive: defineReactive$$1
+  };
+
+  Vue.set = set;
+  Vue.delete = del;
+  Vue.nextTick = nextTick;
+
+  Vue.options = Object.create(null);
+  config._assetTypes.forEach(function (type) {
+    Vue.options[type + 's'] = Object.create(null);
+  });
+
+  // this is used to identify the "base" constructor to extend all plain-object
+  // components with in Weex's multi-instance scenarios.
+  Vue.options._base = Vue;
+
+  extend(Vue.options.components, builtInComponents);
+
+  initUse(Vue);
+  initMixin$1(Vue);
+  initExtend(Vue);
+  initAssetRegisters(Vue);
+}
+
+initGlobalAPI(Vue$3);
+
+Object.defineProperty(Vue$3.prototype, '$isServer', {
+  get: isServerRendering
+});
+
+Vue$3.version = '2.2.2';
+
+/*  */
+
+// attributes that should be using props for binding
+var acceptValue = makeMap('input,textarea,option,select');
+var mustUseProp = function (tag, type, attr) {
+  return (
+    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
+    (attr === 'selected' && tag === 'option') ||
+    (attr === 'checked' && tag === 'input') ||
+    (attr === 'muted' && tag === 'video')
+  )
+};
+
+var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
+
+var isBooleanAttr = makeMap(
+  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
+  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
+  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
+  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
+  'required,reversed,scoped,seamless,selected,sortable,translate,' +
+  'truespeed,typemustmatch,visible'
+);
+
+var xlinkNS = 'http://www.w3.org/1999/xlink';
+
+var isXlink = function (name) {
+  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
+};
+
+var getXlinkProp = function (name) {
+  return isXlink(name) ? name.slice(6, name.length) : ''
+};
+
+var isFalsyAttrValue = function (val) {
+  return val == null || val === false
+};
+
+/*  */
+
+function genClassForVnode (vnode) {
+  var data = vnode.data;
+  var parentNode = vnode;
+  var childNode = vnode;
+  while (childNode.componentInstance) {
+    childNode = childNode.componentInstance._vnode;
+    if (childNode.data) {
+      data = mergeClassData(childNode.data, data);
+    }
+  }
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data) {
+      data = mergeClassData(data, parentNode.data);
+    }
+  }
+  return genClassFromData(data)
+}
+
+function mergeClassData (child, parent) {
+  return {
+    staticClass: concat(child.staticClass, parent.staticClass),
+    class: child.class
+      ? [child.class, parent.class]
+      : parent.class
+  }
+}
+
+function genClassFromData (data) {
+  var dynamicClass = data.class;
+  var staticClass = data.staticClass;
+  if (staticClass || dynamicClass) {
+    return concat(staticClass, stringifyClass(dynamicClass))
+  }
+  /* istanbul ignore next */
+  return ''
+}
+
+function concat (a, b) {
+  return a ? b ? (a + ' ' + b) : a : (b || '')
+}
+
+function stringifyClass (value) {
+  var res = '';
+  if (!value) {
+    return res
+  }
+  if (typeof value === 'string') {
+    return value
+  }
+  if (Array.isArray(value)) {
+    var stringified;
+    for (var i = 0, l = value.length; i < l; i++) {
+      if (value[i]) {
+        if ((stringified = stringifyClass(value[i]))) {
+          res += stringified + ' ';
+        }
+      }
+    }
+    return res.slice(0, -1)
+  }
+  if (isObject(value)) {
+    for (var key in value) {
+      if (value[key]) { res += key + ' '; }
+    }
+    return res.slice(0, -1)
+  }
+  /* istanbul ignore next */
+  return res
+}
+
+/*  */
+
+var namespaceMap = {
+  svg: 'http://www.w3.org/2000/svg',
+  math: 'http://www.w3.org/1998/Math/MathML'
+};
+
+var isHTMLTag = makeMap(
+  'html,body,base,head,link,meta,style,title,' +
+  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
+  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
+  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
+  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
+  'embed,object,param,source,canvas,script,noscript,del,ins,' +
+  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
+  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
+  'output,progress,select,textarea,' +
+  'details,dialog,menu,menuitem,summary,' +
+  'content,element,shadow,template'
+);
+
+// this map is intentionally selective, only covering SVG elements that may
+// contain child elements.
+var isSVG = makeMap(
+  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
+  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
+  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
+  true
+);
+
+var isPreTag = function (tag) { return tag === 'pre'; };
+
+var isReservedTag = function (tag) {
+  return isHTMLTag(tag) || isSVG(tag)
+};
+
+function getTagNamespace (tag) {
+  if (isSVG(tag)) {
+    return 'svg'
+  }
+  // basic support for MathML
+  // note it doesn't support other MathML elements being component roots
+  if (tag === 'math') {
+    return 'math'
+  }
+}
+
+var unknownElementCache = Object.create(null);
+function isUnknownElement (tag) {
+  /* istanbul ignore if */
+  if (!inBrowser) {
+    return true
+  }
+  if (isReservedTag(tag)) {
+    return false
+  }
+  tag = tag.toLowerCase();
+  /* istanbul ignore if */
+  if (unknownElementCache[tag] != null) {
+    return unknownElementCache[tag]
+  }
+  var el = document.createElement(tag);
+  if (tag.indexOf('-') > -1) {
+    // http://stackoverflow.com/a/28210364/1070244
+    return (unknownElementCache[tag] = (
+      el.constructor === window.HTMLUnknownElement ||
+      el.constructor === window.HTMLElement
+    ))
+  } else {
+    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
+  }
+}
+
+/*  */
+
+/**
+ * Query an element selector if it's not an element already.
+ */
+function query (el) {
+  if (typeof el === 'string') {
+    var selected = document.querySelector(el);
+    if (!selected) {
+      "development" !== 'production' && warn(
+        'Cannot find element: ' + el
+      );
+      return document.createElement('div')
+    }
+    return selected
+  } else {
+    return el
+  }
+}
+
+/*  */
+
+function createElement$1 (tagName, vnode) {
+  var elm = document.createElement(tagName);
+  if (tagName !== 'select') {
+    return elm
+  }
+  // false or null will remove the attribute but undefined will not
+  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
+    elm.setAttribute('multiple', 'multiple');
+  }
+  return elm
+}
+
+function createElementNS (namespace, tagName) {
+  return document.createElementNS(namespaceMap[namespace], tagName)
+}
+
+function createTextNode (text) {
+  return document.createTextNode(text)
+}
+
+function createComment (text) {
+  return document.createComment(text)
+}
+
+function insertBefore (parentNode, newNode, referenceNode) {
+  parentNode.insertBefore(newNode, referenceNode);
+}
+
+function removeChild (node, child) {
+  node.removeChild(child);
+}
+
+function appendChild (node, child) {
+  node.appendChild(child);
+}
+
+function parentNode (node) {
+  return node.parentNode
+}
+
+function nextSibling (node) {
+  return node.nextSibling
+}
+
+function tagName (node) {
+  return node.tagName
+}
+
+function setTextContent (node, text) {
+  node.textContent = text;
+}
+
+function setAttribute (node, key, val) {
+  node.setAttribute(key, val);
+}
+
+
+var nodeOps = Object.freeze({
+	createElement: createElement$1,
+	createElementNS: createElementNS,
+	createTextNode: createTextNode,
+	createComment: createComment,
+	insertBefore: insertBefore,
+	removeChild: removeChild,
+	appendChild: appendChild,
+	parentNode: parentNode,
+	nextSibling: nextSibling,
+	tagName: tagName,
+	setTextContent: setTextContent,
+	setAttribute: setAttribute
+});
+
+/*  */
+
+var ref = {
+  create: function create (_, vnode) {
+    registerRef(vnode);
+  },
+  update: function update (oldVnode, vnode) {
+    if (oldVnode.data.ref !== vnode.data.ref) {
+      registerRef(oldVnode, true);
+      registerRef(vnode);
+    }
+  },
+  destroy: function destroy (vnode) {
+    registerRef(vnode, true);
+  }
+};
+
+function registerRef (vnode, isRemoval) {
+  var key = vnode.data.ref;
+  if (!key) { return }
+
+  var vm = vnode.context;
+  var ref = vnode.componentInstance || vnode.elm;
+  var refs = vm.$refs;
+  if (isRemoval) {
+    if (Array.isArray(refs[key])) {
+      remove(refs[key], ref);
+    } else if (refs[key] === ref) {
+      refs[key] = undefined;
+    }
+  } else {
+    if (vnode.data.refInFor) {
+      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
+        refs[key].push(ref);
+      } else {
+        refs[key] = [ref];
+      }
+    } else {
+      refs[key] = ref;
+    }
+  }
+}
+
+/**
+ * Virtual DOM patching algorithm based on Snabbdom by
+ * Simon Friis Vindum (@paldepind)
+ * Licensed under the MIT License
+ * https://github.com/paldepind/snabbdom/blob/master/LICENSE
+ *
+ * modified by Evan You (@yyx990803)
+ *
+
+/*
+ * Not type-checking this because this file is perf-critical and the cost
+ * of making flow understand it is not worth it.
+ */
+
+var emptyNode = new VNode('', {}, []);
+
+var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];
+
+function isUndef (s) {
+  return s == null
+}
+
+function isDef (s) {
+  return s != null
+}
+
+function sameVnode (vnode1, vnode2) {
+  return (
+    vnode1.key === vnode2.key &&
+    vnode1.tag === vnode2.tag &&
+    vnode1.isComment === vnode2.isComment &&
+    !vnode1.data === !vnode2.data
+  )
+}
+
+function createKeyToOldIdx (children, beginIdx, endIdx) {
+  var i, key;
+  var map = {};
+  for (i = beginIdx; i <= endIdx; ++i) {
+    key = children[i].key;
+    if (isDef(key)) { map[key] = i; }
+  }
+  return map
+}
+
+function createPatchFunction (backend) {
+  var i, j;
+  var cbs = {};
+
+  var modules = backend.modules;
+  var nodeOps = backend.nodeOps;
+
+  for (i = 0; i < hooks$1.length; ++i) {
+    cbs[hooks$1[i]] = [];
+    for (j = 0; j < modules.length; ++j) {
+      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
+    }
+  }
+
+  function emptyNodeAt (elm) {
+    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
+  }
+
+  function createRmCb (childElm, listeners) {
+    function remove$$1 () {
+      if (--remove$$1.listeners === 0) {
+        removeNode(childElm);
+      }
+    }
+    remove$$1.listeners = listeners;
+    return remove$$1
+  }
+
+  function removeNode (el) {
+    var parent = nodeOps.parentNode(el);
+    // element may have already been removed due to v-html / v-text
+    if (parent) {
+      nodeOps.removeChild(parent, el);
+    }
+  }
+
+  var inPre = 0;
+  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
+    vnode.isRootInsert = !nested; // for transition enter check
+    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
+      return
+    }
+
+    var data = vnode.data;
+    var children = vnode.children;
+    var tag = vnode.tag;
+    if (isDef(tag)) {
+      {
+        if (data && data.pre) {
+          inPre++;
+        }
+        if (
+          !inPre &&
+          !vnode.ns &&
+          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
+          config.isUnknownElement(tag)
+        ) {
+          warn(
+            'Unknown custom element: <' + tag + '> - did you ' +
+            'register the component correctly? For recursive components, ' +
+            'make sure to provide the "name" option.',
+            vnode.context
+          );
+        }
+      }
+      vnode.elm = vnode.ns
+        ? nodeOps.createElementNS(vnode.ns, tag)
+        : nodeOps.createElement(tag, vnode);
+      setScope(vnode);
+
+      /* istanbul ignore if */
+      {
+        createChildren(vnode, children, insertedVnodeQueue);
+        if (isDef(data)) {
+          invokeCreateHooks(vnode, insertedVnodeQueue);
+        }
+        insert(parentElm, vnode.elm, refElm);
+      }
+
+      if ("development" !== 'production' && data && data.pre) {
+        inPre--;
+      }
+    } else if (vnode.isComment) {
+      vnode.elm = nodeOps.createComment(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    } else {
+      vnode.elm = nodeOps.createTextNode(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    }
+  }
+
+  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i = vnode.data;
+    if (isDef(i)) {
+      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
+      if (isDef(i = i.hook) && isDef(i = i.init)) {
+        i(vnode, false /* hydrating */, parentElm, refElm);
+      }
+      // after calling the init hook, if the vnode is a child component
+      // it should've created a child instance and mounted it. the child
+      // component also has set the placeholder vnode's elm.
+      // in that case we can just return the element and be done.
+      if (isDef(vnode.componentInstance)) {
+        initComponent(vnode, insertedVnodeQueue);
+        if (isReactivated) {
+          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
+        }
+        return true
+      }
+    }
+  }
+
+  function initComponent (vnode, insertedVnodeQueue) {
+    if (vnode.data.pendingInsert) {
+      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
+    }
+    vnode.elm = vnode.componentInstance.$el;
+    if (isPatchable(vnode)) {
+      invokeCreateHooks(vnode, insertedVnodeQueue);
+      setScope(vnode);
+    } else {
+      // empty component root.
+      // skip all element-related modules except for ref (#3455)
+      registerRef(vnode);
+      // make sure to invoke the insert hook
+      insertedVnodeQueue.push(vnode);
+    }
+  }
+
+  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i;
+    // hack for #4339: a reactivated component with inner transition
+    // does not trigger because the inner node's created hooks are not called
+    // again. It's not ideal to involve module-specific logic in here but
+    // there doesn't seem to be a better way to do it.
+    var innerNode = vnode;
+    while (innerNode.componentInstance) {
+      innerNode = innerNode.componentInstance._vnode;
+      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
+        for (i = 0; i < cbs.activate.length; ++i) {
+          cbs.activate[i](emptyNode, innerNode);
+        }
+        insertedVnodeQueue.push(innerNode);
+        break
+      }
+    }
+    // unlike a newly created component,
+    // a reactivated keep-alive component doesn't insert itself
+    insert(parentElm, vnode.elm, refElm);
+  }
+
+  function insert (parent, elm, ref) {
+    if (parent) {
+      if (ref) {
+        nodeOps.insertBefore(parent, elm, ref);
+      } else {
+        nodeOps.appendChild(parent, elm);
+      }
+    }
+  }
+
+  function createChildren (vnode, children, insertedVnodeQueue) {
+    if (Array.isArray(children)) {
+      for (var i = 0; i < children.length; ++i) {
+        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
+      }
+    } else if (isPrimitive(vnode.text)) {
+      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
+    }
+  }
+
+  function isPatchable (vnode) {
+    while (vnode.componentInstance) {
+      vnode = vnode.componentInstance._vnode;
+    }
+    return isDef(vnode.tag)
+  }
+
+  function invokeCreateHooks (vnode, insertedVnodeQueue) {
+    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
+      cbs.create[i$1](emptyNode, vnode);
+    }
+    i = vnode.data.hook; // Reuse variable
+    if (isDef(i)) {
+      if (i.create) { i.create(emptyNode, vnode); }
+      if (i.insert) { insertedVnodeQueue.push(vnode); }
+    }
+  }
+
+  // set scope id attribute for scoped CSS.
+  // this is implemented as a special case to avoid the overhead
+  // of going through the normal attribute patching process.
+  function setScope (vnode) {
+    var i;
+    var ancestor = vnode;
+    while (ancestor) {
+      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
+        nodeOps.setAttribute(vnode.elm, i, '');
+      }
+      ancestor = ancestor.parent;
+    }
+    // for slot content they should also get the scopeId from the host instance.
+    if (isDef(i = activeInstance) &&
+        i !== vnode.context &&
+        isDef(i = i.$options._scopeId)) {
+      nodeOps.setAttribute(vnode.elm, i, '');
+    }
+  }
+
+  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
+    }
+  }
+
+  function invokeDestroyHook (vnode) {
+    var i, j;
+    var data = vnode.data;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
+      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
+    }
+    if (isDef(i = vnode.children)) {
+      for (j = 0; j < vnode.children.length; ++j) {
+        invokeDestroyHook(vnode.children[j]);
+      }
+    }
+  }
+
+  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      var ch = vnodes[startIdx];
+      if (isDef(ch)) {
+        if (isDef(ch.tag)) {
+          removeAndInvokeRemoveHook(ch);
+          invokeDestroyHook(ch);
+        } else { // Text node
+          removeNode(ch.elm);
+        }
+      }
+    }
+  }
+
+  function removeAndInvokeRemoveHook (vnode, rm) {
+    if (rm || isDef(vnode.data)) {
+      var listeners = cbs.remove.length + 1;
+      if (!rm) {
+        // directly removing
+        rm = createRmCb(vnode.elm, listeners);
+      } else {
+        // we have a recursively passed down rm callback
+        // increase the listeners count
+        rm.listeners += listeners;
+      }
+      // recursively invoke hooks on child component root node
+      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
+        removeAndInvokeRemoveHook(i, rm);
+      }
+      for (i = 0; i < cbs.remove.length; ++i) {
+        cbs.remove[i](vnode, rm);
+      }
+      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
+        i(vnode, rm);
+      } else {
+        rm();
+      }
+    } else {
+      removeNode(vnode.elm);
+    }
+  }
+
+  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
+    var oldStartIdx = 0;
+    var newStartIdx = 0;
+    var oldEndIdx = oldCh.length - 1;
+    var oldStartVnode = oldCh[0];
+    var oldEndVnode = oldCh[oldEndIdx];
+    var newEndIdx = newCh.length - 1;
+    var newStartVnode = newCh[0];
+    var newEndVnode = newCh[newEndIdx];
+    var oldKeyToIdx, idxInOld, elmToMove, refElm;
+
+    // removeOnly is a special flag used only by <transition-group>
+    // to ensure removed elements stay in correct relative positions
+    // during leaving transitions
+    var canMove = !removeOnly;
+
+    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
+      if (isUndef(oldStartVnode)) {
+        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
+      } else if (isUndef(oldEndVnode)) {
+        oldEndVnode = oldCh[--oldEndIdx];
+      } else if (sameVnode(oldStartVnode, newStartVnode)) {
+        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
+        oldStartVnode = oldCh[++oldStartIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else if (sameVnode(oldEndVnode, newEndVnode)) {
+        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
+        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
+        oldStartVnode = oldCh[++oldStartIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
+        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else {
+        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
+        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
+        if (isUndef(idxInOld)) { // New element
+          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+          newStartVnode = newCh[++newStartIdx];
+        } else {
+          elmToMove = oldCh[idxInOld];
+          /* istanbul ignore if */
+          if ("development" !== 'production' && !elmToMove) {
+            warn(
+              'It seems there are duplicate keys that is causing an update error. ' +
+              'Make sure each v-for item has a unique key.'
+            );
+          }
+          if (sameVnode(elmToMove, newStartVnode)) {
+            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
+            oldCh[idxInOld] = undefined;
+            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          } else {
+            // same key but different element. treat as new element
+            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          }
+        }
+      }
+    }
+    if (oldStartIdx > oldEndIdx) {
+      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
+      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
+    } else if (newStartIdx > newEndIdx) {
+      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
+    }
+  }
+
+  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
+    if (oldVnode === vnode) {
+      return
+    }
+    // reuse element for static trees.
+    // note we only do this if the vnode is cloned -
+    // if the new node is not cloned it means the render functions have been
+    // reset by the hot-reload-api and we need to do a proper re-render.
+    if (vnode.isStatic &&
+        oldVnode.isStatic &&
+        vnode.key === oldVnode.key &&
+        (vnode.isCloned || vnode.isOnce)) {
+      vnode.elm = oldVnode.elm;
+      vnode.componentInstance = oldVnode.componentInstance;
+      return
+    }
+    var i;
+    var data = vnode.data;
+    var hasData = isDef(data);
+    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
+      i(oldVnode, vnode);
+    }
+    var elm = vnode.elm = oldVnode.elm;
+    var oldCh = oldVnode.children;
+    var ch = vnode.children;
+    if (hasData && isPatchable(vnode)) {
+      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
+      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
+    }
+    if (isUndef(vnode.text)) {
+      if (isDef(oldCh) && isDef(ch)) {
+        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
+      } else if (isDef(ch)) {
+        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
+        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
+      } else if (isDef(oldCh)) {
+        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
+      } else if (isDef(oldVnode.text)) {
+        nodeOps.setTextContent(elm, '');
+      }
+    } else if (oldVnode.text !== vnode.text) {
+      nodeOps.setTextContent(elm, vnode.text);
+    }
+    if (hasData) {
+      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
+    }
+  }
+
+  function invokeInsertHook (vnode, queue, initial) {
+    // delay insert hooks for component root nodes, invoke them after the
+    // element is really inserted
+    if (initial && vnode.parent) {
+      vnode.parent.data.pendingInsert = queue;
+    } else {
+      for (var i = 0; i < queue.length; ++i) {
+        queue[i].data.hook.insert(queue[i]);
+      }
+    }
+  }
+
+  var bailed = false;
+  // list of modules that can skip create hook during hydration because they
+  // are already rendered on the client or has no need for initialization
+  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
+
+  // Note: this is a browser-only function so we can assume elms are DOM nodes.
+  function hydrate (elm, vnode, insertedVnodeQueue) {
+    {
+      if (!assertNodeMatch(elm, vnode)) {
+        return false
+      }
+    }
+    vnode.elm = elm;
+    var tag = vnode.tag;
+    var data = vnode.data;
+    var children = vnode.children;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
+      if (isDef(i = vnode.componentInstance)) {
+        // child component. it should have hydrated its own tree.
+        initComponent(vnode, insertedVnodeQueue);
+        return true
+      }
+    }
+    if (isDef(tag)) {
+      if (isDef(children)) {
+        // empty element, allow client to pick up and populate children
+        if (!elm.hasChildNodes()) {
+          createChildren(vnode, children, insertedVnodeQueue);
+        } else {
+          var childrenMatch = true;
+          var childNode = elm.firstChild;
+          for (var i$1 = 0; i$1 < children.length; i$1++) {
+            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
+              childrenMatch = false;
+              break
+            }
+            childNode = childNode.nextSibling;
+          }
+          // if childNode is not null, it means the actual childNodes list is
+          // longer than the virtual children list.
+          if (!childrenMatch || childNode) {
+            if ("development" !== 'production' &&
+                typeof console !== 'undefined' &&
+                !bailed) {
+              bailed = true;
+              console.warn('Parent: ', elm);
+              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
+            }
+            return false
+          }
+        }
+      }
+      if (isDef(data)) {
+        for (var key in data) {
+          if (!isRenderedModule(key)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue);
+            break
+          }
+        }
+      }
+    } else if (elm.data !== vnode.text) {
+      elm.data = vnode.text;
+    }
+    return true
+  }
+
+  function assertNodeMatch (node, vnode) {
+    if (vnode.tag) {
+      return (
+        vnode.tag.indexOf('vue-component') === 0 ||
+        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
+      )
+    } else {
+      return node.nodeType === (vnode.isComment ? 8 : 3)
+    }
+  }
+
+  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
+    if (!vnode) {
+      if (oldVnode) { invokeDestroyHook(oldVnode); }
+      return
+    }
+
+    var isInitialPatch = false;
+    var insertedVnodeQueue = [];
+
+    if (!oldVnode) {
+      // empty mount (likely as component), create new root element
+      isInitialPatch = true;
+      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
+    } else {
+      var isRealElement = isDef(oldVnode.nodeType);
+      if (!isRealElement && sameVnode(oldVnode, vnode)) {
+        // patch existing root node
+        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
+      } else {
+        if (isRealElement) {
+          // mounting to a real element
+          // check if this is server-rendered content and if we can perform
+          // a successful hydration.
+          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
+            oldVnode.removeAttribute('server-rendered');
+            hydrating = true;
+          }
+          if (hydrating) {
+            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
+              invokeInsertHook(vnode, insertedVnodeQueue, true);
+              return oldVnode
+            } else {
+              warn(
+                'The client-side rendered virtual DOM tree is not matching ' +
+                'server-rendered content. This is likely caused by incorrect ' +
+                'HTML markup, for example nesting block-level elements inside ' +
+                '<p>, or missing <tbody>. Bailing hydration and performing ' +
+                'full client-side render.'
+              );
+            }
+          }
+          // either not server-rendered, or hydration failed.
+          // create an empty node and replace it
+          oldVnode = emptyNodeAt(oldVnode);
+        }
+        // replacing existing element
+        var oldElm = oldVnode.elm;
+        var parentElm$1 = nodeOps.parentNode(oldElm);
+        createElm(
+          vnode,
+          insertedVnodeQueue,
+          // extremely rare edge case: do not insert if old element is in a
+          // leaving transition. Only happens when combining transition +
+          // keep-alive + HOCs. (#4590)
+          oldElm._leaveCb ? null : parentElm$1,
+          nodeOps.nextSibling(oldElm)
+        );
+
+        if (vnode.parent) {
+          // component root element replaced.
+          // update parent placeholder node element, recursively
+          var ancestor = vnode.parent;
+          while (ancestor) {
+            ancestor.elm = vnode.elm;
+            ancestor = ancestor.parent;
+          }
+          if (isPatchable(vnode)) {
+            for (var i = 0; i < cbs.create.length; ++i) {
+              cbs.create[i](emptyNode, vnode.parent);
+            }
+          }
+        }
+
+        if (parentElm$1 !== null) {
+          removeVnodes(parentElm$1, [oldVnode], 0, 0);
+        } else if (isDef(oldVnode.tag)) {
+          invokeDestroyHook(oldVnode);
+        }
+      }
+    }
+
+    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
+    return vnode.elm
+  }
+}
+
+/*  */
+
+var directives = {
+  create: updateDirectives,
+  update: updateDirectives,
+  destroy: function unbindDirectives (vnode) {
+    updateDirectives(vnode, emptyNode);
+  }
+};
+
+function updateDirectives (oldVnode, vnode) {
+  if (oldVnode.data.directives || vnode.data.directives) {
+    _update(oldVnode, vnode);
+  }
+}
+
+function _update (oldVnode, vnode) {
+  var isCreate = oldVnode === emptyNode;
+  var isDestroy = vnode === emptyNode;
+  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
+  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
+
+  var dirsWithInsert = [];
+  var dirsWithPostpatch = [];
+
+  var key, oldDir, dir;
+  for (key in newDirs) {
+    oldDir = oldDirs[key];
+    dir = newDirs[key];
+    if (!oldDir) {
+      // new directive, bind
+      callHook$1(dir, 'bind', vnode, oldVnode);
+      if (dir.def && dir.def.inserted) {
+        dirsWithInsert.push(dir);
+      }
+    } else {
+      // existing directive, update
+      dir.oldValue = oldDir.value;
+      callHook$1(dir, 'update', vnode, oldVnode);
+      if (dir.def && dir.def.componentUpdated) {
+        dirsWithPostpatch.push(dir);
+      }
+    }
+  }
+
+  if (dirsWithInsert.length) {
+    var callInsert = function () {
+      for (var i = 0; i < dirsWithInsert.length; i++) {
+        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
+      }
+    };
+    if (isCreate) {
+      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
+    } else {
+      callInsert();
+    }
+  }
+
+  if (dirsWithPostpatch.length) {
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
+      for (var i = 0; i < dirsWithPostpatch.length; i++) {
+        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
+      }
+    });
+  }
+
+  if (!isCreate) {
+    for (key in oldDirs) {
+      if (!newDirs[key]) {
+        // no longer present, unbind
+        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
+      }
+    }
+  }
+}
+
+var emptyModifiers = Object.create(null);
+
+function normalizeDirectives$1 (
+  dirs,
+  vm
+) {
+  var res = Object.create(null);
+  if (!dirs) {
+    return res
+  }
+  var i, dir;
+  for (i = 0; i < dirs.length; i++) {
+    dir = dirs[i];
+    if (!dir.modifiers) {
+      dir.modifiers = emptyModifiers;
+    }
+    res[getRawDirName(dir)] = dir;
+    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
+  }
+  return res
+}
+
+function getRawDirName (dir) {
+  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
+}
+
+function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
+  var fn = dir.def && dir.def[hook];
+  if (fn) {
+    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
+  }
+}
+
+var baseModules = [
+  ref,
+  directives
+];
+
+/*  */
+
+function updateAttrs (oldVnode, vnode) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  var key, cur, old;
+  var elm = vnode.elm;
+  var oldAttrs = oldVnode.data.attrs || {};
+  var attrs = vnode.data.attrs || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs);
+  }
+
+  for (key in attrs) {
+    cur = attrs[key];
+    old = oldAttrs[key];
+    if (old !== cur) {
+      setAttr(elm, key, cur);
+    }
+  }
+  // #4391: in IE9, setting type can reset value for input[type=radio]
+  /* istanbul ignore if */
+  if (isIE9 && attrs.value !== oldAttrs.value) {
+    setAttr(elm, 'value', attrs.value);
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      if (isXlink(key)) {
+        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
+      } else if (!isEnumeratedAttr(key)) {
+        elm.removeAttribute(key);
+      }
+    }
+  }
+}
+
+function setAttr (el, key, value) {
+  if (isBooleanAttr(key)) {
+    // set attribute for blank value
+    // e.g. <option disabled>Select one</option>
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, key);
+    }
+  } else if (isEnumeratedAttr(key)) {
+    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
+  } else if (isXlink(key)) {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
+    } else {
+      el.setAttributeNS(xlinkNS, key, value);
+    }
+  } else {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, value);
+    }
+  }
+}
+
+var attrs = {
+  create: updateAttrs,
+  update: updateAttrs
+};
+
+/*  */
+
+function updateClass (oldVnode, vnode) {
+  var el = vnode.elm;
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  var cls = genClassForVnode(vnode);
+
+  // handle transition classes
+  var transitionClass = el._transitionClasses;
+  if (transitionClass) {
+    cls = concat(cls, stringifyClass(transitionClass));
+  }
+
+  // set the class
+  if (cls !== el._prevClass) {
+    el.setAttribute('class', cls);
+    el._prevClass = cls;
+  }
+}
+
+var klass = {
+  create: updateClass,
+  update: updateClass
+};
+
+/*  */
+
+var validDivisionCharRE = /[\w).+\-_$\]]/;
+
+function parseFilters (exp) {
+  var inSingle = false;
+  var inDouble = false;
+  var inTemplateString = false;
+  var inRegex = false;
+  var curly = 0;
+  var square = 0;
+  var paren = 0;
+  var lastFilterIndex = 0;
+  var c, prev, i, expression, filters;
+
+  for (i = 0; i < exp.length; i++) {
+    prev = c;
+    c = exp.charCodeAt(i);
+    if (inSingle) {
+      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }
+    } else if (inDouble) {
+      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }
+    } else if (inTemplateString) {
+      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }
+    } else if (inRegex) {
+      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }
+    } else if (
+      c === 0x7C && // pipe
+      exp.charCodeAt(i + 1) !== 0x7C &&
+      exp.charCodeAt(i - 1) !== 0x7C &&
+      !curly && !square && !paren
+    ) {
+      if (expression === undefined) {
+        // first filter, end of expression
+        lastFilterIndex = i + 1;
+        expression = exp.slice(0, i).trim();
+      } else {
+        pushFilter();
+      }
+    } else {
+      switch (c) {
+        case 0x22: inDouble = true; break         // "
+        case 0x27: inSingle = true; break         // '
+        case 0x60: inTemplateString = true; break // `
+        case 0x28: paren++; break                 // (
+        case 0x29: paren--; break                 // )
+        case 0x5B: square++; break                // [
+        case 0x5D: square--; break                // ]
+        case 0x7B: curly++; break                 // {
+        case 0x7D: curly--; break                 // }
+      }
+      if (c === 0x2f) { // /
+        var j = i - 1;
+        var p = (void 0);
+        // find first non-whitespace prev char
+        for (; j >= 0; j--) {
+          p = exp.charAt(j);
+          if (p !== ' ') { break }
+        }
+        if (!p || !validDivisionCharRE.test(p)) {
+          inRegex = true;
+        }
+      }
+    }
+  }
+
+  if (expression === undefined) {
+    expression = exp.slice(0, i).trim();
+  } else if (lastFilterIndex !== 0) {
+    pushFilter();
+  }
+
+  function pushFilter () {
+    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
+    lastFilterIndex = i + 1;
+  }
+
+  if (filters) {
+    for (i = 0; i < filters.length; i++) {
+      expression = wrapFilter(expression, filters[i]);
+    }
+  }
+
+  return expression
+}
+
+function wrapFilter (exp, filter) {
+  var i = filter.indexOf('(');
+  if (i < 0) {
+    // _f: resolveFilter
+    return ("_f(\"" + filter + "\")(" + exp + ")")
+  } else {
+    var name = filter.slice(0, i);
+    var args = filter.slice(i + 1);
+    return ("_f(\"" + name + "\")(" + exp + "," + args)
+  }
+}
+
+/*  */
+
+function baseWarn (msg) {
+  console.error(("[Vue compiler]: " + msg));
+}
+
+function pluckModuleFunction (
+  modules,
+  key
+) {
+  return modules
+    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })
+    : []
+}
+
+function addProp (el, name, value) {
+  (el.props || (el.props = [])).push({ name: name, value: value });
+}
+
+function addAttr (el, name, value) {
+  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
+}
+
+function addDirective (
+  el,
+  name,
+  rawName,
+  value,
+  arg,
+  modifiers
+) {
+  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
+}
+
+function addHandler (
+  el,
+  name,
+  value,
+  modifiers,
+  important
+) {
+  // check capture modifier
+  if (modifiers && modifiers.capture) {
+    delete modifiers.capture;
+    name = '!' + name; // mark the event as captured
+  }
+  if (modifiers && modifiers.once) {
+    delete modifiers.once;
+    name = '~' + name; // mark the event as once
+  }
+  var events;
+  if (modifiers && modifiers.native) {
+    delete modifiers.native;
+    events = el.nativeEvents || (el.nativeEvents = {});
+  } else {
+    events = el.events || (el.events = {});
+  }
+  var newHandler = { value: value, modifiers: modifiers };
+  var handlers = events[name];
+  /* istanbul ignore if */
+  if (Array.isArray(handlers)) {
+    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
+  } else if (handlers) {
+    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
+  } else {
+    events[name] = newHandler;
+  }
+}
+
+function getBindingAttr (
+  el,
+  name,
+  getStatic
+) {
+  var dynamicValue =
+    getAndRemoveAttr(el, ':' + name) ||
+    getAndRemoveAttr(el, 'v-bind:' + name);
+  if (dynamicValue != null) {
+    return parseFilters(dynamicValue)
+  } else if (getStatic !== false) {
+    var staticValue = getAndRemoveAttr(el, name);
+    if (staticValue != null) {
+      return JSON.stringify(staticValue)
+    }
+  }
+}
+
+function getAndRemoveAttr (el, name) {
+  var val;
+  if ((val = el.attrsMap[name]) != null) {
+    var list = el.attrsList;
+    for (var i = 0, l = list.length; i < l; i++) {
+      if (list[i].name === name) {
+        list.splice(i, 1);
+        break
+      }
+    }
+  }
+  return val
+}
+
+/*  */
+
+/**
+ * Cross-platform code generation for component v-model
+ */
+function genComponentModel (
+  el,
+  value,
+  modifiers
+) {
+  var ref = modifiers || {};
+  var number = ref.number;
+  var trim = ref.trim;
+
+  var baseValueExpression = '$$v';
+  var valueExpression = baseValueExpression;
+  if (trim) {
+    valueExpression =
+      "(typeof " + baseValueExpression + " === 'string'" +
+        "? " + baseValueExpression + ".trim()" +
+        ": " + baseValueExpression + ")";
+  }
+  if (number) {
+    valueExpression = "_n(" + valueExpression + ")";
+  }
+  var assignment = genAssignmentCode(value, valueExpression);
+
+  el.model = {
+    value: ("(" + value + ")"),
+    expression: ("\"" + value + "\""),
+    callback: ("function (" + baseValueExpression + ") {" + assignment + "}")
+  };
+}
+
+/**
+ * Cross-platform codegen helper for generating v-model value assignment code.
+ */
+function genAssignmentCode (
+  value,
+  assignment
+) {
+  var modelRs = parseModel(value);
+  if (modelRs.idx === null) {
+    return (value + "=" + assignment)
+  } else {
+    return "var $$exp = " + (modelRs.exp) + ", $$idx = " + (modelRs.idx) + ";" +
+      "if (!Array.isArray($$exp)){" +
+        value + "=" + assignment + "}" +
+      "else{$$exp.splice($$idx, 1, " + assignment + ")}"
+  }
+}
+
+/**
+ * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
+ *
+ * for loop possible cases:
+ *
+ * - test
+ * - test[idx]
+ * - test[test1[idx]]
+ * - test["a"][idx]
+ * - xxx.test[a[a].test1[idx]]
+ * - test.xxx.a["asa"][test1[idx]]
+ *
+ */
+
+var len;
+var str;
+var chr;
+var index$1;
+var expressionPos;
+var expressionEndPos;
+
+function parseModel (val) {
+  str = val;
+  len = str.length;
+  index$1 = expressionPos = expressionEndPos = 0;
+
+  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
+    return {
+      exp: val,
+      idx: null
+    }
+  }
+
+  while (!eof()) {
+    chr = next();
+    /* istanbul ignore if */
+    if (isStringStart(chr)) {
+      parseString(chr);
+    } else if (chr === 0x5B) {
+      parseBracket(chr);
+    }
+  }
+
+  return {
+    exp: val.substring(0, expressionPos),
+    idx: val.substring(expressionPos + 1, expressionEndPos)
+  }
+}
+
+function next () {
+  return str.charCodeAt(++index$1)
+}
+
+function eof () {
+  return index$1 >= len
+}
+
+function isStringStart (chr) {
+  return chr === 0x22 || chr === 0x27
+}
+
+function parseBracket (chr) {
+  var inBracket = 1;
+  expressionPos = index$1;
+  while (!eof()) {
+    chr = next();
+    if (isStringStart(chr)) {
+      parseString(chr);
+      continue
+    }
+    if (chr === 0x5B) { inBracket++; }
+    if (chr === 0x5D) { inBracket--; }
+    if (inBracket === 0) {
+      expressionEndPos = index$1;
+      break
+    }
+  }
+}
+
+function parseString (chr) {
+  var stringQuote = chr;
+  while (!eof()) {
+    chr = next();
+    if (chr === stringQuote) {
+      break
+    }
+  }
+}
+
+/*  */
+
+var warn$1;
+
+// in some cases, the event used has to be determined at runtime
+// so we used some reserved tokens during compile.
+var RANGE_TOKEN = '__r';
+var CHECKBOX_RADIO_TOKEN = '__c';
+
+function model (
+  el,
+  dir,
+  _warn
+) {
+  warn$1 = _warn;
+  var value = dir.value;
+  var modifiers = dir.modifiers;
+  var tag = el.tag;
+  var type = el.attrsMap.type;
+
+  {
+    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];
+    if (tag === 'input' && dynamicType) {
+      warn$1(
+        "<input :type=\"" + dynamicType + "\" v-model=\"" + value + "\">:\n" +
+        "v-model does not support dynamic input types. Use v-if branches instead."
+      );
+    }
+    // inputs with type="file" are read only and setting the input's
+    // value will throw an error.
+    if (tag === 'input' && type === 'file') {
+      warn$1(
+        "<" + (el.tag) + " v-model=\"" + value + "\" type=\"file\">:\n" +
+        "File inputs are read only. Use a v-on:change listener instead."
+      );
+    }
+  }
+
+  if (tag === 'select') {
+    genSelect(el, value, modifiers);
+  } else if (tag === 'input' && type === 'checkbox') {
+    genCheckboxModel(el, value, modifiers);
+  } else if (tag === 'input' && type === 'radio') {
+    genRadioModel(el, value, modifiers);
+  } else if (tag === 'input' || tag === 'textarea') {
+    genDefaultModel(el, value, modifiers);
+  } else if (!config.isReservedTag(tag)) {
+    genComponentModel(el, value, modifiers);
+    // component v-model doesn't need extra runtime
+    return false
+  } else {
+    warn$1(
+      "<" + (el.tag) + " v-model=\"" + value + "\">: " +
+      "v-model is not supported on this element type. " +
+      'If you are working with contenteditable, it\'s recommended to ' +
+      'wrap a library dedicated for that purpose inside a custom component.'
+    );
+  }
+
+  // ensure runtime directive metadata
+  return true
+}
+
+function genCheckboxModel (
+  el,
+  value,
+  modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var valueBinding = getBindingAttr(el, 'value') || 'null';
+  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
+  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
+  addProp(el, 'checked',
+    "Array.isArray(" + value + ")" +
+      "?_i(" + value + "," + valueBinding + ")>-1" + (
+        trueValueBinding === 'true'
+          ? (":(" + value + ")")
+          : (":_q(" + value + "," + trueValueBinding + ")")
+      )
+  );
+  addHandler(el, CHECKBOX_RADIO_TOKEN,
+    "var $$a=" + value + "," +
+        '$$el=$event.target,' +
+        "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" +
+    'if(Array.isArray($$a)){' +
+      "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," +
+          '$$i=_i($$a,$$v);' +
+      "if($$c){$$i<0&&(" + value + "=$$a.concat($$v))}" +
+      "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" +
+    "}else{" + value + "=$$c}",
+    null, true
+  );
+}
+
+function genRadioModel (
+    el,
+    value,
+    modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var valueBinding = getBindingAttr(el, 'value') || 'null';
+  valueBinding = number ? ("_n(" + valueBinding + ")") : valueBinding;
+  addProp(el, 'checked', ("_q(" + value + "," + valueBinding + ")"));
+  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);
+}
+
+function genSelect (
+    el,
+    value,
+    modifiers
+) {
+  var number = modifiers && modifiers.number;
+  var selectedVal = "Array.prototype.filter" +
+    ".call($event.target.options,function(o){return o.selected})" +
+    ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" +
+    "return " + (number ? '_n(val)' : 'val') + "})";
+
+  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
+  var code = "var $$selectedVal = " + selectedVal + ";";
+  code = code + " " + (genAssignmentCode(value, assignment));
+  addHandler(el, 'change', code, null, true);
+}
+
+function genDefaultModel (
+  el,
+  value,
+  modifiers
+) {
+  var type = el.attrsMap.type;
+  var ref = modifiers || {};
+  var lazy = ref.lazy;
+  var number = ref.number;
+  var trim = ref.trim;
+  var needCompositionGuard = !lazy && type !== 'range';
+  var event = lazy
+    ? 'change'
+    : type === 'range'
+      ? RANGE_TOKEN
+      : 'input';
+
+  var valueExpression = '$event.target.value';
+  if (trim) {
+    valueExpression = "$event.target.value.trim()";
+  }
+  if (number) {
+    valueExpression = "_n(" + valueExpression + ")";
+  }
+
+  var code = genAssignmentCode(value, valueExpression);
+  if (needCompositionGuard) {
+    code = "if($event.target.composing)return;" + code;
+  }
+
+  addProp(el, 'value', ("(" + value + ")"));
+  addHandler(el, event, code, null, true);
+  if (trim || number || type === 'number') {
+    addHandler(el, 'blur', '$forceUpdate()');
+  }
+}
+
+/*  */
+
+// normalize v-model event tokens that can only be determined at runtime.
+// it's important to place the event as the first in the array because
+// the whole point is ensuring the v-model callback gets called before
+// user-attached handlers.
+function normalizeEvents (on) {
+  var event;
+  /* istanbul ignore if */
+  if (on[RANGE_TOKEN]) {
+    // IE input[type=range] only supports `change` event
+    event = isIE ? 'change' : 'input';
+    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
+    delete on[RANGE_TOKEN];
+  }
+  if (on[CHECKBOX_RADIO_TOKEN]) {
+    // Chrome fires microtasks in between click/change, leads to #4521
+    event = isChrome ? 'click' : 'change';
+    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
+    delete on[CHECKBOX_RADIO_TOKEN];
+  }
+}
+
+var target$1;
+
+function add$1 (
+  event,
+  handler,
+  once,
+  capture
+) {
+  if (once) {
+    var oldHandler = handler;
+    var _target = target$1; // save current target element in closure
+    handler = function (ev) {
+      var res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments);
+      if (res !== null) {
+        remove$2(event, handler, capture, _target);
+      }
+    };
+  }
+  target$1.addEventListener(event, handler, capture);
+}
+
+function remove$2 (
+  event,
+  handler,
+  capture,
+  _target
+) {
+  (_target || target$1).removeEventListener(event, handler, capture);
+}
+
+function updateDOMListeners (oldVnode, vnode) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  var on = vnode.data.on || {};
+  var oldOn = oldVnode.data.on || {};
+  target$1 = vnode.elm;
+  normalizeEvents(on);
+  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
+}
+
+var events = {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+};
+
+/*  */
+
+function updateDOMProps (oldVnode, vnode) {
+  if (!oldVnode.data.domProps && !vnode.data.domProps) {
+    return
+  }
+  var key, cur;
+  var elm = vnode.elm;
+  var oldProps = oldVnode.data.domProps || {};
+  var props = vnode.data.domProps || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (props.__ob__) {
+    props = vnode.data.domProps = extend({}, props);
+  }
+
+  for (key in oldProps) {
+    if (props[key] == null) {
+      elm[key] = '';
+    }
+  }
+  for (key in props) {
+    cur = props[key];
+    // ignore children if the node has textContent or innerHTML,
+    // as these will throw away existing DOM nodes and cause removal errors
+    // on subsequent patches (#3360)
+    if (key === 'textContent' || key === 'innerHTML') {
+      if (vnode.children) { vnode.children.length = 0; }
+      if (cur === oldProps[key]) { continue }
+    }
+
+    if (key === 'value') {
+      // store value as _value as well since
+      // non-string values will be stringified
+      elm._value = cur;
+      // avoid resetting cursor position when value is the same
+      var strCur = cur == null ? '' : String(cur);
+      if (shouldUpdateValue(elm, vnode, strCur)) {
+        elm.value = strCur;
+      }
+    } else {
+      elm[key] = cur;
+    }
+  }
+}
+
+// check platforms/web/util/attrs.js acceptValue
+
+
+function shouldUpdateValue (
+  elm,
+  vnode,
+  checkVal
+) {
+  return (!elm.composing && (
+    vnode.tag === 'option' ||
+    isDirty(elm, checkVal) ||
+    isInputChanged(elm, checkVal)
+  ))
+}
+
+function isDirty (elm, checkVal) {
+  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
+  return document.activeElement !== elm && elm.value !== checkVal
+}
+
+function isInputChanged (elm, newVal) {
+  var value = elm.value;
+  var modifiers = elm._vModifiers; // injected by v-model runtime
+  if ((modifiers && modifiers.number) || elm.type === 'number') {
+    return toNumber(value) !== toNumber(newVal)
+  }
+  if (modifiers && modifiers.trim) {
+    return value.trim() !== newVal.trim()
+  }
+  return value !== newVal
+}
+
+var domProps = {
+  create: updateDOMProps,
+  update: updateDOMProps
+};
+
+/*  */
+
+var parseStyleText = cached(function (cssText) {
+  var res = {};
+  var listDelimiter = /;(?![^(]*\))/g;
+  var propertyDelimiter = /:(.+)/;
+  cssText.split(listDelimiter).forEach(function (item) {
+    if (item) {
+      var tmp = item.split(propertyDelimiter);
+      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
+    }
+  });
+  return res
+});
+
+// merge static and dynamic style data on the same vnode
+function normalizeStyleData (data) {
+  var style = normalizeStyleBinding(data.style);
+  // static style is pre-processed into an object during compilation
+  // and is always a fresh object, so it's safe to merge into it
+  return data.staticStyle
+    ? extend(data.staticStyle, style)
+    : style
+}
+
+// normalize possible array / string values into Object
+function normalizeStyleBinding (bindingStyle) {
+  if (Array.isArray(bindingStyle)) {
+    return toObject(bindingStyle)
+  }
+  if (typeof bindingStyle === 'string') {
+    return parseStyleText(bindingStyle)
+  }
+  return bindingStyle
+}
+
+/**
+ * parent component style should be after child's
+ * so that parent component's style could override it
+ */
+function getStyle (vnode, checkChild) {
+  var res = {};
+  var styleData;
+
+  if (checkChild) {
+    var childNode = vnode;
+    while (childNode.componentInstance) {
+      childNode = childNode.componentInstance._vnode;
+      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
+        extend(res, styleData);
+      }
+    }
+  }
+
+  if ((styleData = normalizeStyleData(vnode.data))) {
+    extend(res, styleData);
+  }
+
+  var parentNode = vnode;
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
+      extend(res, styleData);
+    }
+  }
+  return res
+}
+
+/*  */
+
+var cssVarRE = /^--/;
+var importantRE = /\s*!important$/;
+var setProp = function (el, name, val) {
+  /* istanbul ignore if */
+  if (cssVarRE.test(name)) {
+    el.style.setProperty(name, val);
+  } else if (importantRE.test(val)) {
+    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
+  } else {
+    el.style[normalize(name)] = val;
+  }
+};
+
+var prefixes = ['Webkit', 'Moz', 'ms'];
+
+var testEl;
+var normalize = cached(function (prop) {
+  testEl = testEl || document.createElement('div');
+  prop = camelize(prop);
+  if (prop !== 'filter' && (prop in testEl.style)) {
+    return prop
+  }
+  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
+  for (var i = 0; i < prefixes.length; i++) {
+    var prefixed = prefixes[i] + upper;
+    if (prefixed in testEl.style) {
+      return prefixed
+    }
+  }
+});
+
+function updateStyle (oldVnode, vnode) {
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+
+  if (!data.staticStyle && !data.style &&
+      !oldData.staticStyle && !oldData.style) {
+    return
+  }
+
+  var cur, name;
+  var el = vnode.elm;
+  var oldStaticStyle = oldVnode.data.staticStyle;
+  var oldStyleBinding = oldVnode.data.style || {};
+
+  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
+  var oldStyle = oldStaticStyle || oldStyleBinding;
+
+  var style = normalizeStyleBinding(vnode.data.style) || {};
+
+  vnode.data.style = style.__ob__ ? extend({}, style) : style;
+
+  var newStyle = getStyle(vnode, true);
+
+  for (name in oldStyle) {
+    if (newStyle[name] == null) {
+      setProp(el, name, '');
+    }
+  }
+  for (name in newStyle) {
+    cur = newStyle[name];
+    if (cur !== oldStyle[name]) {
+      // ie9 setting to null has no effect, must use empty string
+      setProp(el, name, cur == null ? '' : cur);
+    }
+  }
+}
+
+var style = {
+  create: updateStyle,
+  update: updateStyle
+};
+
+/*  */
+
+/**
+ * Add class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function addClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
+    } else {
+      el.classList.add(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    if (cur.indexOf(' ' + cls + ' ') < 0) {
+      el.setAttribute('class', (cur + cls).trim());
+    }
+  }
+}
+
+/**
+ * Remove class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function removeClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
+    } else {
+      el.classList.remove(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    var tar = ' ' + cls + ' ';
+    while (cur.indexOf(tar) >= 0) {
+      cur = cur.replace(tar, ' ');
+    }
+    el.setAttribute('class', cur.trim());
+  }
+}
+
+/*  */
+
+function resolveTransition (def$$1) {
+  if (!def$$1) {
+    return
+  }
+  /* istanbul ignore else */
+  if (typeof def$$1 === 'object') {
+    var res = {};
+    if (def$$1.css !== false) {
+      extend(res, autoCssTransition(def$$1.name || 'v'));
+    }
+    extend(res, def$$1);
+    return res
+  } else if (typeof def$$1 === 'string') {
+    return autoCssTransition(def$$1)
+  }
+}
+
+var autoCssTransition = cached(function (name) {
+  return {
+    enterClass: (name + "-enter"),
+    enterToClass: (name + "-enter-to"),
+    enterActiveClass: (name + "-enter-active"),
+    leaveClass: (name + "-leave"),
+    leaveToClass: (name + "-leave-to"),
+    leaveActiveClass: (name + "-leave-active")
+  }
+});
+
+var hasTransition = inBrowser && !isIE9;
+var TRANSITION = 'transition';
+var ANIMATION = 'animation';
+
+// Transition property/event sniffing
+var transitionProp = 'transition';
+var transitionEndEvent = 'transitionend';
+var animationProp = 'animation';
+var animationEndEvent = 'animationend';
+if (hasTransition) {
+  /* istanbul ignore if */
+  if (window.ontransitionend === undefined &&
+    window.onwebkittransitionend !== undefined) {
+    transitionProp = 'WebkitTransition';
+    transitionEndEvent = 'webkitTransitionEnd';
+  }
+  if (window.onanimationend === undefined &&
+    window.onwebkitanimationend !== undefined) {
+    animationProp = 'WebkitAnimation';
+    animationEndEvent = 'webkitAnimationEnd';
+  }
+}
+
+// binding to window is necessary to make hot reload work in IE in strict mode
+var raf = inBrowser && window.requestAnimationFrame
+  ? window.requestAnimationFrame.bind(window)
+  : setTimeout;
+
+function nextFrame (fn) {
+  raf(function () {
+    raf(fn);
+  });
+}
+
+function addTransitionClass (el, cls) {
+  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
+  addClass(el, cls);
+}
+
+function removeTransitionClass (el, cls) {
+  if (el._transitionClasses) {
+    remove(el._transitionClasses, cls);
+  }
+  removeClass(el, cls);
+}
+
+function whenTransitionEnds (
+  el,
+  expectedType,
+  cb
+) {
+  var ref = getTransitionInfo(el, expectedType);
+  var type = ref.type;
+  var timeout = ref.timeout;
+  var propCount = ref.propCount;
+  if (!type) { return cb() }
+  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
+  var ended = 0;
+  var end = function () {
+    el.removeEventListener(event, onEnd);
+    cb();
+  };
+  var onEnd = function (e) {
+    if (e.target === el) {
+      if (++ended >= propCount) {
+        end();
+      }
+    }
+  };
+  setTimeout(function () {
+    if (ended < propCount) {
+      end();
+    }
+  }, timeout + 1);
+  el.addEventListener(event, onEnd);
+}
+
+var transformRE = /\b(transform|all)(,|$)/;
+
+function getTransitionInfo (el, expectedType) {
+  var styles = window.getComputedStyle(el);
+  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
+  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
+  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
+  var animationDelays = styles[animationProp + 'Delay'].split(', ');
+  var animationDurations = styles[animationProp + 'Duration'].split(', ');
+  var animationTimeout = getTimeout(animationDelays, animationDurations);
+
+  var type;
+  var timeout = 0;
+  var propCount = 0;
+  /* istanbul ignore if */
+  if (expectedType === TRANSITION) {
+    if (transitionTimeout > 0) {
+      type = TRANSITION;
+      timeout = transitionTimeout;
+      propCount = transitionDurations.length;
+    }
+  } else if (expectedType === ANIMATION) {
+    if (animationTimeout > 0) {
+      type = ANIMATION;
+      timeout = animationTimeout;
+      propCount = animationDurations.length;
+    }
+  } else {
+    timeout = Math.max(transitionTimeout, animationTimeout);
+    type = timeout > 0
+      ? transitionTimeout > animationTimeout
+        ? TRANSITION
+        : ANIMATION
+      : null;
+    propCount = type
+      ? type === TRANSITION
+        ? transitionDurations.length
+        : animationDurations.length
+      : 0;
+  }
+  var hasTransform =
+    type === TRANSITION &&
+    transformRE.test(styles[transitionProp + 'Property']);
+  return {
+    type: type,
+    timeout: timeout,
+    propCount: propCount,
+    hasTransform: hasTransform
+  }
+}
+
+function getTimeout (delays, durations) {
+  /* istanbul ignore next */
+  while (delays.length < durations.length) {
+    delays = delays.concat(delays);
+  }
+
+  return Math.max.apply(null, durations.map(function (d, i) {
+    return toMs(d) + toMs(delays[i])
+  }))
+}
+
+function toMs (s) {
+  return Number(s.slice(0, -1)) * 1000
+}
+
+/*  */
+
+function enter (vnode, toggleDisplay) {
+  var el = vnode.elm;
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true;
+    el._leaveCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var enterClass = data.enterClass;
+  var enterToClass = data.enterToClass;
+  var enterActiveClass = data.enterActiveClass;
+  var appearClass = data.appearClass;
+  var appearToClass = data.appearToClass;
+  var appearActiveClass = data.appearActiveClass;
+  var beforeEnter = data.beforeEnter;
+  var enter = data.enter;
+  var afterEnter = data.afterEnter;
+  var enterCancelled = data.enterCancelled;
+  var beforeAppear = data.beforeAppear;
+  var appear = data.appear;
+  var afterAppear = data.afterAppear;
+  var appearCancelled = data.appearCancelled;
+  var duration = data.duration;
+
+  // activeInstance will always be the <transition> component managing this
+  // transition. One edge case to check is when the <transition> is placed
+  // as the root node of a child component. In that case we need to check
+  // <transition>'s parent for appear check.
+  var context = activeInstance;
+  var transitionNode = activeInstance.$vnode;
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent;
+    context = transitionNode.context;
+  }
+
+  var isAppear = !context._isMounted || !vnode.isRootInsert;
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  var startClass = isAppear && appearClass
+    ? appearClass
+    : enterClass;
+  var activeClass = isAppear && appearActiveClass
+    ? appearActiveClass
+    : enterActiveClass;
+  var toClass = isAppear && appearToClass
+    ? appearToClass
+    : enterToClass;
+
+  var beforeEnterHook = isAppear
+    ? (beforeAppear || beforeEnter)
+    : beforeEnter;
+  var enterHook = isAppear
+    ? (typeof appear === 'function' ? appear : enter)
+    : enter;
+  var afterEnterHook = isAppear
+    ? (afterAppear || afterEnter)
+    : afterEnter;
+  var enterCancelledHook = isAppear
+    ? (appearCancelled || enterCancelled)
+    : enterCancelled;
+
+  var explicitEnterDuration = toNumber(
+    isObject(duration)
+      ? duration.enter
+      : duration
+  );
+
+  if ("development" !== 'production' && explicitEnterDuration != null) {
+    checkDuration(explicitEnterDuration, 'enter', vnode);
+  }
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(enterHook);
+
+  var cb = el._enterCb = once(function () {
+    if (expectsCSS) {
+      removeTransitionClass(el, toClass);
+      removeTransitionClass(el, activeClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, startClass);
+      }
+      enterCancelledHook && enterCancelledHook(el);
+    } else {
+      afterEnterHook && afterEnterHook(el);
+    }
+    el._enterCb = null;
+  });
+
+  if (!vnode.data.show) {
+    // remove pending leave element on enter by injecting an insert hook
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
+      var parent = el.parentNode;
+      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
+      if (pendingNode &&
+          pendingNode.tag === vnode.tag &&
+          pendingNode.elm._leaveCb) {
+        pendingNode.elm._leaveCb();
+      }
+      enterHook && enterHook(el, cb);
+    });
+  }
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el);
+  if (expectsCSS) {
+    addTransitionClass(el, startClass);
+    addTransitionClass(el, activeClass);
+    nextFrame(function () {
+      addTransitionClass(el, toClass);
+      removeTransitionClass(el, startClass);
+      if (!cb.cancelled && !userWantsControl) {
+        if (isValidDuration(explicitEnterDuration)) {
+          setTimeout(cb, explicitEnterDuration);
+        } else {
+          whenTransitionEnds(el, type, cb);
+        }
+      }
+    });
+  }
+
+  if (vnode.data.show) {
+    toggleDisplay && toggleDisplay();
+    enterHook && enterHook(el, cb);
+  }
+
+  if (!expectsCSS && !userWantsControl) {
+    cb();
+  }
+}
+
+function leave (vnode, rm) {
+  var el = vnode.elm;
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true;
+    el._enterCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return rm()
+  }
+
+  /* istanbul ignore if */
+  if (el._leaveCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var leaveClass = data.leaveClass;
+  var leaveToClass = data.leaveToClass;
+  var leaveActiveClass = data.leaveActiveClass;
+  var beforeLeave = data.beforeLeave;
+  var leave = data.leave;
+  var afterLeave = data.afterLeave;
+  var leaveCancelled = data.leaveCancelled;
+  var delayLeave = data.delayLeave;
+  var duration = data.duration;
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(leave);
+
+  var explicitLeaveDuration = toNumber(
+    isObject(duration)
+      ? duration.leave
+      : duration
+  );
+
+  if ("development" !== 'production' && explicitLeaveDuration != null) {
+    checkDuration(explicitLeaveDuration, 'leave', vnode);
+  }
+
+  var cb = el._leaveCb = once(function () {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null;
+    }
+    if (expectsCSS) {
+      removeTransitionClass(el, leaveToClass);
+      removeTransitionClass(el, leaveActiveClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, leaveClass);
+      }
+      leaveCancelled && leaveCancelled(el);
+    } else {
+      rm();
+      afterLeave && afterLeave(el);
+    }
+    el._leaveCb = null;
+  });
+
+  if (delayLeave) {
+    delayLeave(performLeave);
+  } else {
+    performLeave();
+  }
+
+  function performLeave () {
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
+    }
+    beforeLeave && beforeLeave(el);
+    if (expectsCSS) {
+      addTransitionClass(el, leaveClass);
+      addTransitionClass(el, leaveActiveClass);
+      nextFrame(function () {
+        addTransitionClass(el, leaveToClass);
+        removeTransitionClass(el, leaveClass);
+        if (!cb.cancelled && !userWantsControl) {
+          if (isValidDuration(explicitLeaveDuration)) {
+            setTimeout(cb, explicitLeaveDuration);
+          } else {
+            whenTransitionEnds(el, type, cb);
+          }
+        }
+      });
+    }
+    leave && leave(el, cb);
+    if (!expectsCSS && !userWantsControl) {
+      cb();
+    }
+  }
+}
+
+// only used in dev mode
+function checkDuration (val, name, vnode) {
+  if (typeof val !== 'number') {
+    warn(
+      "<transition> explicit " + name + " duration is not a valid number - " +
+      "got " + (JSON.stringify(val)) + ".",
+      vnode.context
+    );
+  } else if (isNaN(val)) {
+    warn(
+      "<transition> explicit " + name + " duration is NaN - " +
+      'the duration expression might be incorrect.',
+      vnode.context
+    );
+  }
+}
+
+function isValidDuration (val) {
+  return typeof val === 'number' && !isNaN(val)
+}
+
+/**
+ * Normalize a transition hook's argument length. The hook may be:
+ * - a merged hook (invoker) with the original in .fns
+ * - a wrapped component method (check ._length)
+ * - a plain function (.length)
+ */
+function getHookArgumentsLength (fn) {
+  if (!fn) { return false }
+  var invokerFns = fn.fns;
+  if (invokerFns) {
+    // invoker
+    return getHookArgumentsLength(
+      Array.isArray(invokerFns)
+        ? invokerFns[0]
+        : invokerFns
+    )
+  } else {
+    return (fn._length || fn.length) > 1
+  }
+}
+
+function _enter (_, vnode) {
+  if (!vnode.data.show) {
+    enter(vnode);
+  }
+}
+
+var transition = inBrowser ? {
+  create: _enter,
+  activate: _enter,
+  remove: function remove$$1 (vnode, rm) {
+    /* istanbul ignore else */
+    if (!vnode.data.show) {
+      leave(vnode, rm);
+    } else {
+      rm();
+    }
+  }
+} : {};
+
+var platformModules = [
+  attrs,
+  klass,
+  events,
+  domProps,
+  style,
+  transition
+];
+
+/*  */
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+var modules = platformModules.concat(baseModules);
+
+var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
+
+/**
+ * Not type checking this file because flow doesn't like attaching
+ * properties to Elements.
+ */
+
+/* istanbul ignore if */
+if (isIE9) {
+  // http://www.matts411.com/post/internet-explorer-9-oninput/
+  document.addEventListener('selectionchange', function () {
+    var el = document.activeElement;
+    if (el && el.vmodel) {
+      trigger(el, 'input');
+    }
+  });
+}
+
+var model$1 = {
+  inserted: function inserted (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      var cb = function () {
+        setSelected(el, binding, vnode.context);
+      };
+      cb();
+      /* istanbul ignore if */
+      if (isIE || isEdge) {
+        setTimeout(cb, 0);
+      }
+    } else if (vnode.tag === 'textarea' || el.type === 'text') {
+      el._vModifiers = binding.modifiers;
+      if (!binding.modifiers.lazy) {
+        if (!isAndroid) {
+          el.addEventListener('compositionstart', onCompositionStart);
+          el.addEventListener('compositionend', onCompositionEnd);
+        }
+        /* istanbul ignore if */
+        if (isIE9) {
+          el.vmodel = true;
+        }
+      }
+    }
+  },
+  componentUpdated: function componentUpdated (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      setSelected(el, binding, vnode.context);
+      // in case the options rendered by v-for have changed,
+      // it's possible that the value is out-of-sync with the rendered options.
+      // detect such cases and filter out values that no longer has a matching
+      // option in the DOM.
+      var needReset = el.multiple
+        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
+        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
+      if (needReset) {
+        trigger(el, 'change');
+      }
+    }
+  }
+};
+
+function setSelected (el, binding, vm) {
+  var value = binding.value;
+  var isMultiple = el.multiple;
+  if (isMultiple && !Array.isArray(value)) {
+    "development" !== 'production' && warn(
+      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
+      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
+      vm
+    );
+    return
+  }
+  var selected, option;
+  for (var i = 0, l = el.options.length; i < l; i++) {
+    option = el.options[i];
+    if (isMultiple) {
+      selected = looseIndexOf(value, getValue(option)) > -1;
+      if (option.selected !== selected) {
+        option.selected = selected;
+      }
+    } else {
+      if (looseEqual(getValue(option), value)) {
+        if (el.selectedIndex !== i) {
+          el.selectedIndex = i;
+        }
+        return
+      }
+    }
+  }
+  if (!isMultiple) {
+    el.selectedIndex = -1;
+  }
+}
+
+function hasNoMatchingOption (value, options) {
+  for (var i = 0, l = options.length; i < l; i++) {
+    if (looseEqual(getValue(options[i]), value)) {
+      return false
+    }
+  }
+  return true
+}
+
+function getValue (option) {
+  return '_value' in option
+    ? option._value
+    : option.value
+}
+
+function onCompositionStart (e) {
+  e.target.composing = true;
+}
+
+function onCompositionEnd (e) {
+  e.target.composing = false;
+  trigger(e.target, 'input');
+}
+
+function trigger (el, type) {
+  var e = document.createEvent('HTMLEvents');
+  e.initEvent(type, true, true);
+  el.dispatchEvent(e);
+}
+
+/*  */
+
+// recursively search for possible transition defined inside the component root
+function locateNode (vnode) {
+  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
+    ? locateNode(vnode.componentInstance._vnode)
+    : vnode
+}
+
+var show = {
+  bind: function bind (el, ref, vnode) {
+    var value = ref.value;
+
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    var originalDisplay = el.__vOriginalDisplay =
+      el.style.display === 'none' ? '' : el.style.display;
+    if (value && transition && !isIE9) {
+      vnode.data.show = true;
+      enter(vnode, function () {
+        el.style.display = originalDisplay;
+      });
+    } else {
+      el.style.display = value ? originalDisplay : 'none';
+    }
+  },
+
+  update: function update (el, ref, vnode) {
+    var value = ref.value;
+    var oldValue = ref.oldValue;
+
+    /* istanbul ignore if */
+    if (value === oldValue) { return }
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    if (transition && !isIE9) {
+      vnode.data.show = true;
+      if (value) {
+        enter(vnode, function () {
+          el.style.display = el.__vOriginalDisplay;
+        });
+      } else {
+        leave(vnode, function () {
+          el.style.display = 'none';
+        });
+      }
+    } else {
+      el.style.display = value ? el.__vOriginalDisplay : 'none';
+    }
+  },
+
+  unbind: function unbind (
+    el,
+    binding,
+    vnode,
+    oldVnode,
+    isDestroy
+  ) {
+    if (!isDestroy) {
+      el.style.display = el.__vOriginalDisplay;
+    }
+  }
+};
+
+var platformDirectives = {
+  model: model$1,
+  show: show
+};
+
+/*  */
+
+// Provides transition support for a single element/component.
+// supports transition mode (out-in / in-out)
+
+var transitionProps = {
+  name: String,
+  appear: Boolean,
+  css: Boolean,
+  mode: String,
+  type: String,
+  enterClass: String,
+  leaveClass: String,
+  enterToClass: String,
+  leaveToClass: String,
+  enterActiveClass: String,
+  leaveActiveClass: String,
+  appearClass: String,
+  appearActiveClass: String,
+  appearToClass: String,
+  duration: [Number, String, Object]
+};
+
+// in case the child is also an abstract component, e.g. <keep-alive>
+// we want to recursively retrieve the real component to be rendered
+function getRealChild (vnode) {
+  var compOptions = vnode && vnode.componentOptions;
+  if (compOptions && compOptions.Ctor.options.abstract) {
+    return getRealChild(getFirstComponentChild(compOptions.children))
+  } else {
+    return vnode
+  }
+}
+
+function extractTransitionData (comp) {
+  var data = {};
+  var options = comp.$options;
+  // props
+  for (var key in options.propsData) {
+    data[key] = comp[key];
+  }
+  // events.
+  // extract listeners and pass them directly to the transition methods
+  var listeners = options._parentListeners;
+  for (var key$1 in listeners) {
+    data[camelize(key$1)] = listeners[key$1];
+  }
+  return data
+}
+
+function placeholder (h, rawChild) {
+  return /\d-keep-alive$/.test(rawChild.tag)
+    ? h('keep-alive')
+    : null
+}
+
+function hasParentTransition (vnode) {
+  while ((vnode = vnode.parent)) {
+    if (vnode.data.transition) {
+      return true
+    }
+  }
+}
+
+function isSameChild (child, oldChild) {
+  return oldChild.key === child.key && oldChild.tag === child.tag
+}
+
+var Transition = {
+  name: 'transition',
+  props: transitionProps,
+  abstract: true,
+
+  render: function render (h) {
+    var this$1 = this;
+
+    var children = this.$slots.default;
+    if (!children) {
+      return
+    }
+
+    // filter out text nodes (possible whitespaces)
+    children = children.filter(function (c) { return c.tag; });
+    /* istanbul ignore if */
+    if (!children.length) {
+      return
+    }
+
+    // warn multiple elements
+    if ("development" !== 'production' && children.length > 1) {
+      warn(
+        '<transition> can only be used on a single element. Use ' +
+        '<transition-group> for lists.',
+        this.$parent
+      );
+    }
+
+    var mode = this.mode;
+
+    // warn invalid mode
+    if ("development" !== 'production' &&
+        mode && mode !== 'in-out' && mode !== 'out-in') {
+      warn(
+        'invalid <transition> mode: ' + mode,
+        this.$parent
+      );
+    }
+
+    var rawChild = children[0];
+
+    // if this is a component root node and the component's
+    // parent container node also has transition, skip.
+    if (hasParentTransition(this.$vnode)) {
+      return rawChild
+    }
+
+    // apply transition data to child
+    // use getRealChild() to ignore abstract components e.g. keep-alive
+    var child = getRealChild(rawChild);
+    /* istanbul ignore if */
+    if (!child) {
+      return rawChild
+    }
+
+    if (this._leaving) {
+      return placeholder(h, rawChild)
+    }
+
+    // ensure a key that is unique to the vnode type and to this transition
+    // component instance. This key will be used to remove pending leaving nodes
+    // during entering.
+    var id = "__transition-" + (this._uid) + "-";
+    child.key = child.key == null
+      ? id + child.tag
+      : isPrimitive(child.key)
+        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
+        : child.key;
+
+    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
+    var oldRawChild = this._vnode;
+    var oldChild = getRealChild(oldRawChild);
+
+    // mark v-show
+    // so that the transition module can hand over the control to the directive
+    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
+      child.data.show = true;
+    }
+
+    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
+      // replace old child transition data with fresh one
+      // important for dynamic transitions!
+      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
+      // handle transition mode
+      if (mode === 'out-in') {
+        // return placeholder node and queue update when leave finishes
+        this._leaving = true;
+        mergeVNodeHook(oldData, 'afterLeave', function () {
+          this$1._leaving = false;
+          this$1.$forceUpdate();
+        });
+        return placeholder(h, rawChild)
+      } else if (mode === 'in-out') {
+        var delayedLeave;
+        var performLeave = function () { delayedLeave(); };
+        mergeVNodeHook(data, 'afterEnter', performLeave);
+        mergeVNodeHook(data, 'enterCancelled', performLeave);
+        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
+      }
+    }
+
+    return rawChild
+  }
+};
+
+/*  */
+
+// Provides transition support for list items.
+// supports move transitions using the FLIP technique.
+
+// Because the vdom's children update algorithm is "unstable" - i.e.
+// it doesn't guarantee the relative positioning of removed elements,
+// we force transition-group to update its children into two passes:
+// in the first pass, we remove all nodes that need to be removed,
+// triggering their leaving transition; in the second pass, we insert/move
+// into the final desired state. This way in the second pass removed
+// nodes will remain where they should be.
+
+var props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps);
+
+delete props.mode;
+
+var TransitionGroup = {
+  props: props,
+
+  render: function render (h) {
+    var tag = this.tag || this.$vnode.data.tag || 'span';
+    var map = Object.create(null);
+    var prevChildren = this.prevChildren = this.children;
+    var rawChildren = this.$slots.default || [];
+    var children = this.children = [];
+    var transitionData = extractTransitionData(this);
+
+    for (var i = 0; i < rawChildren.length; i++) {
+      var c = rawChildren[i];
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c);
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData;
+        } else {
+          var opts = c.componentOptions;
+          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
+          warn(("<transition-group> children must be keyed: <" + name + ">"));
+        }
+      }
+    }
+
+    if (prevChildren) {
+      var kept = [];
+      var removed = [];
+      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
+        var c$1 = prevChildren[i$1];
+        c$1.data.transition = transitionData;
+        c$1.data.pos = c$1.elm.getBoundingClientRect();
+        if (map[c$1.key]) {
+          kept.push(c$1);
+        } else {
+          removed.push(c$1);
+        }
+      }
+      this.kept = h(tag, null, kept);
+      this.removed = removed;
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate: function beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    );
+    this._vnode = this.kept;
+  },
+
+  updated: function updated () {
+    var children = this.prevChildren;
+    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
+    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
+      return
+    }
+
+    // we divide the work into three loops to avoid mixing DOM reads and writes
+    // in each iteration - which helps prevent layout thrashing.
+    children.forEach(callPendingCbs);
+    children.forEach(recordPosition);
+    children.forEach(applyTranslation);
+
+    // force reflow to put everything in position
+    var body = document.body;
+    var f = body.offsetHeight; // eslint-disable-line
+
+    children.forEach(function (c) {
+      if (c.data.moved) {
+        var el = c.elm;
+        var s = el.style;
+        addTransitionClass(el, moveClass);
+        s.transform = s.WebkitTransform = s.transitionDuration = '';
+        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
+          if (!e || /transform$/.test(e.propertyName)) {
+            el.removeEventListener(transitionEndEvent, cb);
+            el._moveCb = null;
+            removeTransitionClass(el, moveClass);
+          }
+        });
+      }
+    });
+  },
+
+  methods: {
+    hasMove: function hasMove (el, moveClass) {
+      /* istanbul ignore if */
+      if (!hasTransition) {
+        return false
+      }
+      if (this._hasMove != null) {
+        return this._hasMove
+      }
+      // Detect whether an element with the move class applied has
+      // CSS transitions. Since the element may be inside an entering
+      // transition at this very moment, we make a clone of it and remove
+      // all other transition classes applied to ensure only the move class
+      // is applied.
+      var clone = el.cloneNode();
+      if (el._transitionClasses) {
+        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
+      }
+      addClass(clone, moveClass);
+      clone.style.display = 'none';
+      this.$el.appendChild(clone);
+      var info = getTransitionInfo(clone);
+      this.$el.removeChild(clone);
+      return (this._hasMove = info.hasTransform)
+    }
+  }
+};
+
+function callPendingCbs (c) {
+  /* istanbul ignore if */
+  if (c.elm._moveCb) {
+    c.elm._moveCb();
+  }
+  /* istanbul ignore if */
+  if (c.elm._enterCb) {
+    c.elm._enterCb();
+  }
+}
+
+function recordPosition (c) {
+  c.data.newPos = c.elm.getBoundingClientRect();
+}
+
+function applyTranslation (c) {
+  var oldPos = c.data.pos;
+  var newPos = c.data.newPos;
+  var dx = oldPos.left - newPos.left;
+  var dy = oldPos.top - newPos.top;
+  if (dx || dy) {
+    c.data.moved = true;
+    var s = c.elm.style;
+    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
+    s.transitionDuration = '0s';
+  }
+}
+
+var platformComponents = {
+  Transition: Transition,
+  TransitionGroup: TransitionGroup
+};
+
+/*  */
+
+// install platform specific utils
+Vue$3.config.mustUseProp = mustUseProp;
+Vue$3.config.isReservedTag = isReservedTag;
+Vue$3.config.getTagNamespace = getTagNamespace;
+Vue$3.config.isUnknownElement = isUnknownElement;
+
+// install platform runtime directives & components
+extend(Vue$3.options.directives, platformDirectives);
+extend(Vue$3.options.components, platformComponents);
+
+// install platform patch function
+Vue$3.prototype.__patch__ = inBrowser ? patch : noop;
+
+// public mount method
+Vue$3.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && inBrowser ? query(el) : undefined;
+  return mountComponent(this, el, hydrating)
+};
+
+// devtools global hook
+/* istanbul ignore next */
+setTimeout(function () {
+  if (config.devtools) {
+    if (devtools) {
+      devtools.emit('init', Vue$3);
+    } else if ("development" !== 'production' && isChrome) {
+      console[console.info ? 'info' : 'log'](
+        'Download the Vue Devtools extension for a better development experience:\n' +
+        'https://github.com/vuejs/vue-devtools'
+      );
+    }
+  }
+  if ("development" !== 'production' &&
+      config.productionTip !== false &&
+      inBrowser && typeof console !== 'undefined') {
+    console[console.info ? 'info' : 'log'](
+      "You are running Vue in development mode.\n" +
+      "Make sure to turn on production mode when deploying for production.\n" +
+      "See more tips at https://vuejs.org/guide/deployment.html"
+    );
+  }
+}, 0);
+
+/*  */
+
+// check whether current browser encodes a char inside attribute values
+function shouldDecode (content, encoded) {
+  var div = document.createElement('div');
+  div.innerHTML = "<div a=\"" + content + "\">";
+  return div.innerHTML.indexOf(encoded) > 0
+}
+
+// #3663
+// IE encodes newlines inside attribute values while other browsers don't
+var shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false;
+
+/*  */
+
+var isUnaryTag = makeMap(
+  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +
+  'link,meta,param,source,track,wbr'
+);
+
+// Elements that you can, intentionally, leave open
+// (and which close themselves)
+var canBeLeftOpenTag = makeMap(
+  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'
+);
+
+// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
+// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
+var isNonPhrasingTag = makeMap(
+  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +
+  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +
+  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +
+  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +
+  'title,tr,track'
+);
+
+/*  */
+
+var decoder;
+
+function decode (html) {
+  decoder = decoder || document.createElement('div');
+  decoder.innerHTML = html;
+  return decoder.textContent
+}
+
+/**
+ * Not type-checking this file because it's mostly vendor code.
+ */
+
+/*!
+ * HTML Parser By John Resig (ejohn.org)
+ * Modified by Juriy "kangax" Zaytsev
+ * Original code by Erik Arvidsson, Mozilla Public License
+ * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
+ */
+
+// Regular Expressions for parsing tags and attributes
+var singleAttrIdentifier = /([^\s"'<>/=]+)/;
+var singleAttrAssign = /(?:=)/;
+var singleAttrValues = [
+  // attr value double quotes
+  /"([^"]*)"+/.source,
+  // attr value, single quotes
+  /'([^']*)'+/.source,
+  // attr value, no quotes
+  /([^\s"'=<>`]+)/.source
+];
+var attribute = new RegExp(
+  '^\\s*' + singleAttrIdentifier.source +
+  '(?:\\s*(' + singleAttrAssign.source + ')' +
+  '\\s*(?:' + singleAttrValues.join('|') + '))?'
+);
+
+// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
+// but for Vue templates we can enforce a simple charset
+var ncname = '[a-zA-Z_][\\w\\-\\.]*';
+var qnameCapture = '((?:' + ncname + '\\:)?' + ncname + ')';
+var startTagOpen = new RegExp('^<' + qnameCapture);
+var startTagClose = /^\s*(\/?)>/;
+var endTag = new RegExp('^<\\/' + qnameCapture + '[^>]*>');
+var doctype = /^<!DOCTYPE [^>]+>/i;
+var comment = /^<!--/;
+var conditionalComment = /^<!\[/;
+
+var IS_REGEX_CAPTURING_BROKEN = false;
+'x'.replace(/x(.)?/g, function (m, g) {
+  IS_REGEX_CAPTURING_BROKEN = g === '';
+});
+
+// Special Elements (can contain anything)
+var isScriptOrStyle = makeMap('script,style', true);
+var reCache = {};
+
+var decodingMap = {
+  '&lt;': '<',
+  '&gt;': '>',
+  '&quot;': '"',
+  '&amp;': '&',
+  '&#10;': '\n'
+};
+var encodedAttr = /&(?:lt|gt|quot|amp);/g;
+var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;
+
+function decodeAttr (value, shouldDecodeNewlines) {
+  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
+  return value.replace(re, function (match) { return decodingMap[match]; })
+}
+
+function parseHTML (html, options) {
+  var stack = [];
+  var expectHTML = options.expectHTML;
+  var isUnaryTag$$1 = options.isUnaryTag || no;
+  var index = 0;
+  var last, lastTag;
+  while (html) {
+    last = html;
+    // Make sure we're not in a script or style element
+    if (!lastTag || !isScriptOrStyle(lastTag)) {
+      var textEnd = html.indexOf('<');
+      if (textEnd === 0) {
+        // Comment:
+        if (comment.test(html)) {
+          var commentEnd = html.indexOf('-->');
+
+          if (commentEnd >= 0) {
+            advance(commentEnd + 3);
+            continue
+          }
+        }
+
+        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
+        if (conditionalComment.test(html)) {
+          var conditionalEnd = html.indexOf(']>');
+
+          if (conditionalEnd >= 0) {
+            advance(conditionalEnd + 2);
+            continue
+          }
+        }
+
+        // Doctype:
+        var doctypeMatch = html.match(doctype);
+        if (doctypeMatch) {
+          advance(doctypeMatch[0].length);
+          continue
+        }
+
+        // End tag:
+        var endTagMatch = html.match(endTag);
+        if (endTagMatch) {
+          var curIndex = index;
+          advance(endTagMatch[0].length);
+          parseEndTag(endTagMatch[1], curIndex, index);
+          continue
+        }
+
+        // Start tag:
+        var startTagMatch = parseStartTag();
+        if (startTagMatch) {
+          handleStartTag(startTagMatch);
+          continue
+        }
+      }
+
+      var text = (void 0), rest$1 = (void 0), next = (void 0);
+      if (textEnd >= 0) {
+        rest$1 = html.slice(textEnd);
+        while (
+          !endTag.test(rest$1) &&
+          !startTagOpen.test(rest$1) &&
+          !comment.test(rest$1) &&
+          !conditionalComment.test(rest$1)
+        ) {
+          // < in plain text, be forgiving and treat it as text
+          next = rest$1.indexOf('<', 1);
+          if (next < 0) { break }
+          textEnd += next;
+          rest$1 = html.slice(textEnd);
+        }
+        text = html.substring(0, textEnd);
+        advance(textEnd);
+      }
+
+      if (textEnd < 0) {
+        text = html;
+        html = '';
+      }
+
+      if (options.chars && text) {
+        options.chars(text);
+      }
+    } else {
+      var stackedTag = lastTag.toLowerCase();
+      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
+      var endTagLength = 0;
+      var rest = html.replace(reStackedTag, function (all, text, endTag) {
+        endTagLength = endTag.length;
+        if (stackedTag !== 'script' && stackedTag !== 'style' && stackedTag !== 'noscript') {
+          text = text
+            .replace(/<!--([\s\S]*?)-->/g, '$1')
+            .replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
+        }
+        if (options.chars) {
+          options.chars(text);
+        }
+        return ''
+      });
+      index += html.length - rest.length;
+      html = rest;
+      parseEndTag(stackedTag, index - endTagLength, index);
+    }
+
+    if (html === last) {
+      options.chars && options.chars(html);
+      if ("development" !== 'production' && !stack.length && options.warn) {
+        options.warn(("Mal-formatted tag at end of template: \"" + html + "\""));
+      }
+      break
+    }
+  }
+
+  // Clean up any remaining tags
+  parseEndTag();
+
+  function advance (n) {
+    index += n;
+    html = html.substring(n);
+  }
+
+  function parseStartTag () {
+    var start = html.match(startTagOpen);
+    if (start) {
+      var match = {
+        tagName: start[1],
+        attrs: [],
+        start: index
+      };
+      advance(start[0].length);
+      var end, attr;
+      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
+        advance(attr[0].length);
+        match.attrs.push(attr);
+      }
+      if (end) {
+        match.unarySlash = end[1];
+        advance(end[0].length);
+        match.end = index;
+        return match
+      }
+    }
+  }
+
+  function handleStartTag (match) {
+    var tagName = match.tagName;
+    var unarySlash = match.unarySlash;
+
+    if (expectHTML) {
+      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
+        parseEndTag(lastTag);
+      }
+      if (canBeLeftOpenTag(tagName) && lastTag === tagName) {
+        parseEndTag(tagName);
+      }
+    }
+
+    var unary = isUnaryTag$$1(tagName) || tagName === 'html' && lastTag === 'head' || !!unarySlash;
+
+    var l = match.attrs.length;
+    var attrs = new Array(l);
+    for (var i = 0; i < l; i++) {
+      var args = match.attrs[i];
+      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
+      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
+        if (args[3] === '') { delete args[3]; }
+        if (args[4] === '') { delete args[4]; }
+        if (args[5] === '') { delete args[5]; }
+      }
+      var value = args[3] || args[4] || args[5] || '';
+      attrs[i] = {
+        name: args[1],
+        value: decodeAttr(
+          value,
+          options.shouldDecodeNewlines
+        )
+      };
+    }
+
+    if (!unary) {
+      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
+      lastTag = tagName;
+    }
+
+    if (options.start) {
+      options.start(tagName, attrs, unary, match.start, match.end);
+    }
+  }
+
+  function parseEndTag (tagName, start, end) {
+    var pos, lowerCasedTagName;
+    if (start == null) { start = index; }
+    if (end == null) { end = index; }
+
+    if (tagName) {
+      lowerCasedTagName = tagName.toLowerCase();
+    }
+
+    // Find the closest opened tag of the same type
+    if (tagName) {
+      for (pos = stack.length - 1; pos >= 0; pos--) {
+        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
+          break
+        }
+      }
+    } else {
+      // If no tag name is provided, clean shop
+      pos = 0;
+    }
+
+    if (pos >= 0) {
+      // Close all the open elements, up the stack
+      for (var i = stack.length - 1; i >= pos; i--) {
+        if ("development" !== 'production' &&
+            (i > pos || !tagName) &&
+            options.warn) {
+          options.warn(
+            ("tag <" + (stack[i].tag) + "> has no matching end tag.")
+          );
+        }
+        if (options.end) {
+          options.end(stack[i].tag, start, end);
+        }
+      }
+
+      // Remove the open elements from the stack
+      stack.length = pos;
+      lastTag = pos && stack[pos - 1].tag;
+    } else if (lowerCasedTagName === 'br') {
+      if (options.start) {
+        options.start(tagName, [], true, start, end);
+      }
+    } else if (lowerCasedTagName === 'p') {
+      if (options.start) {
+        options.start(tagName, [], false, start, end);
+      }
+      if (options.end) {
+        options.end(tagName, start, end);
+      }
+    }
+  }
+}
+
+/*  */
+
+var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
+var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;
+
+var buildRegex = cached(function (delimiters) {
+  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
+  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
+  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
+});
+
+function parseText (
+  text,
+  delimiters
+) {
+  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
+  if (!tagRE.test(text)) {
+    return
+  }
+  var tokens = [];
+  var lastIndex = tagRE.lastIndex = 0;
+  var match, index;
+  while ((match = tagRE.exec(text))) {
+    index = match.index;
+    // push text token
+    if (index > lastIndex) {
+      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
+    }
+    // tag token
+    var exp = parseFilters(match[1].trim());
+    tokens.push(("_s(" + exp + ")"));
+    lastIndex = index + match[0].length;
+  }
+  if (lastIndex < text.length) {
+    tokens.push(JSON.stringify(text.slice(lastIndex)));
+  }
+  return tokens.join('+')
+}
+
+/*  */
+
+var dirRE = /^v-|^@|^:/;
+var onRE = /^@|^v-on:/;
+var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
+var forIteratorRE = /\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/;
+var bindRE = /^:|^v-bind:/;
+var argRE = /:(.*)$/;
+var modifierRE = /\.[^.]+/g;
+
+var decodeHTMLCached = cached(decode);
+
+// configurable state
+var warn$2;
+var platformGetTagNamespace;
+var platformMustUseProp;
+var platformIsPreTag;
+var preTransforms;
+var transforms;
+var postTransforms;
+var delimiters;
+
+/**
+ * Convert HTML string to AST.
+ */
+function parse (
+  template,
+  options
+) {
+  warn$2 = options.warn || baseWarn;
+  platformGetTagNamespace = options.getTagNamespace || no;
+  platformMustUseProp = options.mustUseProp || no;
+  platformIsPreTag = options.isPreTag || no;
+  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
+  transforms = pluckModuleFunction(options.modules, 'transformNode');
+  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');
+  delimiters = options.delimiters;
+
+  var stack = [];
+  var preserveWhitespace = options.preserveWhitespace !== false;
+  var root;
+  var currentParent;
+  var inVPre = false;
+  var inPre = false;
+  var warned = false;
+
+  function endPre (element) {
+    // check pre state
+    if (element.pre) {
+      inVPre = false;
+    }
+    if (platformIsPreTag(element.tag)) {
+      inPre = false;
+    }
+  }
+
+  parseHTML(template, {
+    warn: warn$2,
+    expectHTML: options.expectHTML,
+    isUnaryTag: options.isUnaryTag,
+    shouldDecodeNewlines: options.shouldDecodeNewlines,
+    start: function start (tag, attrs, unary) {
+      // check namespace.
+      // inherit parent ns if there is one
+      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);
+
+      // handle IE svg bug
+      /* istanbul ignore if */
+      if (isIE && ns === 'svg') {
+        attrs = guardIESVGBug(attrs);
+      }
+
+      var element = {
+        type: 1,
+        tag: tag,
+        attrsList: attrs,
+        attrsMap: makeAttrsMap(attrs),
+        parent: currentParent,
+        children: []
+      };
+      if (ns) {
+        element.ns = ns;
+      }
+
+      if (isForbiddenTag(element) && !isServerRendering()) {
+        element.forbidden = true;
+        "development" !== 'production' && warn$2(
+          'Templates should only be responsible for mapping the state to the ' +
+          'UI. Avoid placing tags with side-effects in your templates, such as ' +
+          "<" + tag + ">" + ', as they will not be parsed.'
+        );
+      }
+
+      // apply pre-transforms
+      for (var i = 0; i < preTransforms.length; i++) {
+        preTransforms[i](element, options);
+      }
+
+      if (!inVPre) {
+        processPre(element);
+        if (element.pre) {
+          inVPre = true;
+        }
+      }
+      if (platformIsPreTag(element.tag)) {
+        inPre = true;
+      }
+      if (inVPre) {
+        processRawAttrs(element);
+      } else {
+        processFor(element);
+        processIf(element);
+        processOnce(element);
+        processKey(element);
+
+        // determine whether this is a plain element after
+        // removing structural attributes
+        element.plain = !element.key && !attrs.length;
+
+        processRef(element);
+        processSlot(element);
+        processComponent(element);
+        for (var i$1 = 0; i$1 < transforms.length; i$1++) {
+          transforms[i$1](element, options);
+        }
+        processAttrs(element);
+      }
+
+      function checkRootConstraints (el) {
+        if ("development" !== 'production' && !warned) {
+          if (el.tag === 'slot' || el.tag === 'template') {
+            warned = true;
+            warn$2(
+              "Cannot use <" + (el.tag) + "> as component root element because it may " +
+              'contain multiple nodes.'
+            );
+          }
+          if (el.attrsMap.hasOwnProperty('v-for')) {
+            warned = true;
+            warn$2(
+              'Cannot use v-for on stateful component root element because ' +
+              'it renders multiple elements.'
+            );
+          }
+        }
+      }
+
+      // tree management
+      if (!root) {
+        root = element;
+        checkRootConstraints(root);
+      } else if (!stack.length) {
+        // allow root elements with v-if, v-else-if and v-else
+        if (root.if && (element.elseif || element.else)) {
+          checkRootConstraints(element);
+          addIfCondition(root, {
+            exp: element.elseif,
+            block: element
+          });
+        } else if ("development" !== 'production' && !warned) {
+          warned = true;
+          warn$2(
+            "Component template should contain exactly one root element. " +
+            "If you are using v-if on multiple elements, " +
+            "use v-else-if to chain them instead."
+          );
+        }
+      }
+      if (currentParent && !element.forbidden) {
+        if (element.elseif || element.else) {
+          processIfConditions(element, currentParent);
+        } else if (element.slotScope) { // scoped slot
+          currentParent.plain = false;
+          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
+        } else {
+          currentParent.children.push(element);
+          element.parent = currentParent;
+        }
+      }
+      if (!unary) {
+        currentParent = element;
+        stack.push(element);
+      } else {
+        endPre(element);
+      }
+      // apply post-transforms
+      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {
+        postTransforms[i$2](element, options);
+      }
+    },
+
+    end: function end () {
+      // remove trailing whitespace
+      var element = stack[stack.length - 1];
+      var lastNode = element.children[element.children.length - 1];
+      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
+        element.children.pop();
+      }
+      // pop stack
+      stack.length -= 1;
+      currentParent = stack[stack.length - 1];
+      endPre(element);
+    },
+
+    chars: function chars (text) {
+      if (!currentParent) {
+        if ("development" !== 'production' && !warned && text === template) {
+          warned = true;
+          warn$2(
+            'Component template requires a root element, rather than just text.'
+          );
+        }
+        return
+      }
+      // IE textarea placeholder bug
+      /* istanbul ignore if */
+      if (isIE &&
+          currentParent.tag === 'textarea' &&
+          currentParent.attrsMap.placeholder === text) {
+        return
+      }
+      var children = currentParent.children;
+      text = inPre || text.trim()
+        ? decodeHTMLCached(text)
+        // only preserve whitespace if its not right after a starting tag
+        : preserveWhitespace && children.length ? ' ' : '';
+      if (text) {
+        var expression;
+        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
+          children.push({
+            type: 2,
+            expression: expression,
+            text: text
+          });
+        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
+          children.push({
+            type: 3,
+            text: text
+          });
+        }
+      }
+    }
+  });
+  return root
+}
+
+function processPre (el) {
+  if (getAndRemoveAttr(el, 'v-pre') != null) {
+    el.pre = true;
+  }
+}
+
+function processRawAttrs (el) {
+  var l = el.attrsList.length;
+  if (l) {
+    var attrs = el.attrs = new Array(l);
+    for (var i = 0; i < l; i++) {
+      attrs[i] = {
+        name: el.attrsList[i].name,
+        value: JSON.stringify(el.attrsList[i].value)
+      };
+    }
+  } else if (!el.pre) {
+    // non root node in pre blocks with no attributes
+    el.plain = true;
+  }
+}
+
+function processKey (el) {
+  var exp = getBindingAttr(el, 'key');
+  if (exp) {
+    if ("development" !== 'production' && el.tag === 'template') {
+      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
+    }
+    el.key = exp;
+  }
+}
+
+function processRef (el) {
+  var ref = getBindingAttr(el, 'ref');
+  if (ref) {
+    el.ref = ref;
+    el.refInFor = checkInFor(el);
+  }
+}
+
+function processFor (el) {
+  var exp;
+  if ((exp = getAndRemoveAttr(el, 'v-for'))) {
+    var inMatch = exp.match(forAliasRE);
+    if (!inMatch) {
+      "development" !== 'production' && warn$2(
+        ("Invalid v-for expression: " + exp)
+      );
+      return
+    }
+    el.for = inMatch[2].trim();
+    var alias = inMatch[1].trim();
+    var iteratorMatch = alias.match(forIteratorRE);
+    if (iteratorMatch) {
+      el.alias = iteratorMatch[1].trim();
+      el.iterator1 = iteratorMatch[2].trim();
+      if (iteratorMatch[3]) {
+        el.iterator2 = iteratorMatch[3].trim();
+      }
+    } else {
+      el.alias = alias;
+    }
+  }
+}
+
+function processIf (el) {
+  var exp = getAndRemoveAttr(el, 'v-if');
+  if (exp) {
+    el.if = exp;
+    addIfCondition(el, {
+      exp: exp,
+      block: el
+    });
+  } else {
+    if (getAndRemoveAttr(el, 'v-else') != null) {
+      el.else = true;
+    }
+    var elseif = getAndRemoveAttr(el, 'v-else-if');
+    if (elseif) {
+      el.elseif = elseif;
+    }
+  }
+}
+
+function processIfConditions (el, parent) {
+  var prev = findPrevElement(parent.children);
+  if (prev && prev.if) {
+    addIfCondition(prev, {
+      exp: el.elseif,
+      block: el
+    });
+  } else {
+    warn$2(
+      "v-" + (el.elseif ? ('else-if="' + el.elseif + '"') : 'else') + " " +
+      "used on element <" + (el.tag) + "> without corresponding v-if."
+    );
+  }
+}
+
+function findPrevElement (children) {
+  var i = children.length;
+  while (i--) {
+    if (children[i].type === 1) {
+      return children[i]
+    } else {
+      if ("development" !== 'production' && children[i].text !== ' ') {
+        warn$2(
+          "text \"" + (children[i].text.trim()) + "\" between v-if and v-else(-if) " +
+          "will be ignored."
+        );
+      }
+      children.pop();
+    }
+  }
+}
+
+function addIfCondition (el, condition) {
+  if (!el.ifConditions) {
+    el.ifConditions = [];
+  }
+  el.ifConditions.push(condition);
+}
+
+function processOnce (el) {
+  var once$$1 = getAndRemoveAttr(el, 'v-once');
+  if (once$$1 != null) {
+    el.once = true;
+  }
+}
+
+function processSlot (el) {
+  if (el.tag === 'slot') {
+    el.slotName = getBindingAttr(el, 'name');
+    if ("development" !== 'production' && el.key) {
+      warn$2(
+        "`key` does not work on <slot> because slots are abstract outlets " +
+        "and can possibly expand into multiple elements. " +
+        "Use the key on a wrapping element instead."
+      );
+    }
+  } else {
+    var slotTarget = getBindingAttr(el, 'slot');
+    if (slotTarget) {
+      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
+    }
+    if (el.tag === 'template') {
+      el.slotScope = getAndRemoveAttr(el, 'scope');
+    }
+  }
+}
+
+function processComponent (el) {
+  var binding;
+  if ((binding = getBindingAttr(el, 'is'))) {
+    el.component = binding;
+  }
+  if (getAndRemoveAttr(el, 'inline-template') != null) {
+    el.inlineTemplate = true;
+  }
+}
+
+function processAttrs (el) {
+  var list = el.attrsList;
+  var i, l, name, rawName, value, arg, modifiers, isProp;
+  for (i = 0, l = list.length; i < l; i++) {
+    name = rawName = list[i].name;
+    value = list[i].value;
+    if (dirRE.test(name)) {
+      // mark element as dynamic
+      el.hasBindings = true;
+      // modifiers
+      modifiers = parseModifiers(name);
+      if (modifiers) {
+        name = name.replace(modifierRE, '');
+      }
+      if (bindRE.test(name)) { // v-bind
+        name = name.replace(bindRE, '');
+        value = parseFilters(value);
+        isProp = false;
+        if (modifiers) {
+          if (modifiers.prop) {
+            isProp = true;
+            name = camelize(name);
+            if (name === 'innerHtml') { name = 'innerHTML'; }
+          }
+          if (modifiers.camel) {
+            name = camelize(name);
+          }
+        }
+        if (isProp || platformMustUseProp(el.tag, el.attrsMap.type, name)) {
+          addProp(el, name, value);
+        } else {
+          addAttr(el, name, value);
+        }
+      } else if (onRE.test(name)) { // v-on
+        name = name.replace(onRE, '');
+        addHandler(el, name, value, modifiers);
+      } else { // normal directives
+        name = name.replace(dirRE, '');
+        // parse arg
+        var argMatch = name.match(argRE);
+        if (argMatch && (arg = argMatch[1])) {
+          name = name.slice(0, -(arg.length + 1));
+        }
+        addDirective(el, name, rawName, value, arg, modifiers);
+        if ("development" !== 'production' && name === 'model') {
+          checkForAliasModel(el, value);
+        }
+      }
+    } else {
+      // literal attribute
+      {
+        var expression = parseText(value, delimiters);
+        if (expression) {
+          warn$2(
+            name + "=\"" + value + "\": " +
+            'Interpolation inside attributes has been removed. ' +
+            'Use v-bind or the colon shorthand instead. For example, ' +
+            'instead of <div id="{{ val }}">, use <div :id="val">.'
+          );
+        }
+      }
+      addAttr(el, name, JSON.stringify(value));
+    }
+  }
+}
+
+function checkInFor (el) {
+  var parent = el;
+  while (parent) {
+    if (parent.for !== undefined) {
+      return true
+    }
+    parent = parent.parent;
+  }
+  return false
+}
+
+function parseModifiers (name) {
+  var match = name.match(modifierRE);
+  if (match) {
+    var ret = {};
+    match.forEach(function (m) { ret[m.slice(1)] = true; });
+    return ret
+  }
+}
+
+function makeAttrsMap (attrs) {
+  var map = {};
+  for (var i = 0, l = attrs.length; i < l; i++) {
+    if ("development" !== 'production' && map[attrs[i].name] && !isIE) {
+      warn$2('duplicate attribute: ' + attrs[i].name);
+    }
+    map[attrs[i].name] = attrs[i].value;
+  }
+  return map
+}
+
+function isForbiddenTag (el) {
+  return (
+    el.tag === 'style' ||
+    (el.tag === 'script' && (
+      !el.attrsMap.type ||
+      el.attrsMap.type === 'text/javascript'
+    ))
+  )
+}
+
+var ieNSBug = /^xmlns:NS\d+/;
+var ieNSPrefix = /^NS\d+:/;
+
+/* istanbul ignore next */
+function guardIESVGBug (attrs) {
+  var res = [];
+  for (var i = 0; i < attrs.length; i++) {
+    var attr = attrs[i];
+    if (!ieNSBug.test(attr.name)) {
+      attr.name = attr.name.replace(ieNSPrefix, '');
+      res.push(attr);
+    }
+  }
+  return res
+}
+
+function checkForAliasModel (el, value) {
+  var _el = el;
+  while (_el) {
+    if (_el.for && _el.alias === value) {
+      warn$2(
+        "<" + (el.tag) + " v-model=\"" + value + "\">: " +
+        "You are binding v-model directly to a v-for iteration alias. " +
+        "This will not be able to modify the v-for source array because " +
+        "writing to the alias is like modifying a function local variable. " +
+        "Consider using an array of objects and use v-model on an object property instead."
+      );
+    }
+    _el = _el.parent;
+  }
+}
+
+/*  */
+
+var isStaticKey;
+var isPlatformReservedTag;
+
+var genStaticKeysCached = cached(genStaticKeys$1);
+
+/**
+ * Goal of the optimizer: walk the generated template AST tree
+ * and detect sub-trees that are purely static, i.e. parts of
+ * the DOM that never needs to change.
+ *
+ * Once we detect these sub-trees, we can:
+ *
+ * 1. Hoist them into constants, so that we no longer need to
+ *    create fresh nodes for them on each re-render;
+ * 2. Completely skip them in the patching process.
+ */
+function optimize (root, options) {
+  if (!root) { return }
+  isStaticKey = genStaticKeysCached(options.staticKeys || '');
+  isPlatformReservedTag = options.isReservedTag || no;
+  // first pass: mark all non-static nodes.
+  markStatic$1(root);
+  // second pass: mark static roots.
+  markStaticRoots(root, false);
+}
+
+function genStaticKeys$1 (keys) {
+  return makeMap(
+    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
+    (keys ? ',' + keys : '')
+  )
+}
+
+function markStatic$1 (node) {
+  node.static = isStatic(node);
+  if (node.type === 1) {
+    // do not make component slot content static. this avoids
+    // 1. components not able to mutate slot nodes
+    // 2. static slot content fails for hot-reloading
+    if (
+      !isPlatformReservedTag(node.tag) &&
+      node.tag !== 'slot' &&
+      node.attrsMap['inline-template'] == null
+    ) {
+      return
+    }
+    for (var i = 0, l = node.children.length; i < l; i++) {
+      var child = node.children[i];
+      markStatic$1(child);
+      if (!child.static) {
+        node.static = false;
+      }
+    }
+  }
+}
+
+function markStaticRoots (node, isInFor) {
+  if (node.type === 1) {
+    if (node.static || node.once) {
+      node.staticInFor = isInFor;
+    }
+    // For a node to qualify as a static root, it should have children that
+    // are not just static text. Otherwise the cost of hoisting out will
+    // outweigh the benefits and it's better off to just always render it fresh.
+    if (node.static && node.children.length && !(
+      node.children.length === 1 &&
+      node.children[0].type === 3
+    )) {
+      node.staticRoot = true;
+      return
+    } else {
+      node.staticRoot = false;
+    }
+    if (node.children) {
+      for (var i = 0, l = node.children.length; i < l; i++) {
+        markStaticRoots(node.children[i], isInFor || !!node.for);
+      }
+    }
+    if (node.ifConditions) {
+      walkThroughConditionsBlocks(node.ifConditions, isInFor);
+    }
+  }
+}
+
+function walkThroughConditionsBlocks (conditionBlocks, isInFor) {
+  for (var i = 1, len = conditionBlocks.length; i < len; i++) {
+    markStaticRoots(conditionBlocks[i].block, isInFor);
+  }
+}
+
+function isStatic (node) {
+  if (node.type === 2) { // expression
+    return false
+  }
+  if (node.type === 3) { // text
+    return true
+  }
+  return !!(node.pre || (
+    !node.hasBindings && // no dynamic bindings
+    !node.if && !node.for && // not v-if or v-for or v-else
+    !isBuiltInTag(node.tag) && // not a built-in
+    isPlatformReservedTag(node.tag) && // not a component
+    !isDirectChildOfTemplateFor(node) &&
+    Object.keys(node).every(isStaticKey)
+  ))
+}
+
+function isDirectChildOfTemplateFor (node) {
+  while (node.parent) {
+    node = node.parent;
+    if (node.tag !== 'template') {
+      return false
+    }
+    if (node.for) {
+      return true
+    }
+  }
+  return false
+}
+
+/*  */
+
+var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
+var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;
+
+// keyCode aliases
+var keyCodes = {
+  esc: 27,
+  tab: 9,
+  enter: 13,
+  space: 32,
+  up: 38,
+  left: 37,
+  right: 39,
+  down: 40,
+  'delete': [8, 46]
+};
+
+// #4868: modifiers that prevent the execution of the listener
+// need to explicitly return null so that we can determine whether to remove
+// the listener for .once
+var genGuard = function (condition) { return ("if(" + condition + ")return null;"); };
+
+var modifierCode = {
+  stop: '$event.stopPropagation();',
+  prevent: '$event.preventDefault();',
+  self: genGuard("$event.target !== $event.currentTarget"),
+  ctrl: genGuard("!$event.ctrlKey"),
+  shift: genGuard("!$event.shiftKey"),
+  alt: genGuard("!$event.altKey"),
+  meta: genGuard("!$event.metaKey"),
+  left: genGuard("'button' in $event && $event.button !== 0"),
+  middle: genGuard("'button' in $event && $event.button !== 1"),
+  right: genGuard("'button' in $event && $event.button !== 2")
+};
+
+function genHandlers (events, native) {
+  var res = native ? 'nativeOn:{' : 'on:{';
+  for (var name in events) {
+    res += "\"" + name + "\":" + (genHandler(name, events[name])) + ",";
+  }
+  return res.slice(0, -1) + '}'
+}
+
+function genHandler (
+  name,
+  handler
+) {
+  if (!handler) {
+    return 'function(){}'
+  }
+
+  if (Array.isArray(handler)) {
+    return ("[" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + "]")
+  }
+
+  var isMethodPath = simplePathRE.test(handler.value);
+  var isFunctionExpression = fnExpRE.test(handler.value);
+
+  if (!handler.modifiers) {
+    return isMethodPath || isFunctionExpression
+      ? handler.value
+      : ("function($event){" + (handler.value) + "}") // inline statement
+  } else {
+    var code = '';
+    var keys = [];
+    for (var key in handler.modifiers) {
+      if (modifierCode[key]) {
+        code += modifierCode[key];
+        // left/right
+        if (keyCodes[key]) {
+          keys.push(key);
+        }
+      } else {
+        keys.push(key);
+      }
+    }
+    if (keys.length) {
+      code += genKeyFilter(keys);
+    }
+    var handlerCode = isMethodPath
+      ? handler.value + '($event)'
+      : isFunctionExpression
+        ? ("(" + (handler.value) + ")($event)")
+        : handler.value;
+    return ("function($event){" + code + handlerCode + "}")
+  }
+}
+
+function genKeyFilter (keys) {
+  return ("if(!('button' in $event)&&" + (keys.map(genFilterCode).join('&&')) + ")return null;")
+}
+
+function genFilterCode (key) {
+  var keyVal = parseInt(key, 10);
+  if (keyVal) {
+    return ("$event.keyCode!==" + keyVal)
+  }
+  var alias = keyCodes[key];
+  return ("_k($event.keyCode," + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + ")")
+}
+
+/*  */
+
+function bind$1 (el, dir) {
+  el.wrapData = function (code) {
+    return ("_b(" + code + ",'" + (el.tag) + "'," + (dir.value) + (dir.modifiers && dir.modifiers.prop ? ',true' : '') + ")")
+  };
+}
+
+/*  */
+
+var baseDirectives = {
+  bind: bind$1,
+  cloak: noop
+};
+
+/*  */
+
+// configurable state
+var warn$3;
+var transforms$1;
+var dataGenFns;
+var platformDirectives$1;
+var isPlatformReservedTag$1;
+var staticRenderFns;
+var onceCount;
+var currentOptions;
+
+function generate (
+  ast,
+  options
+) {
+  // save previous staticRenderFns so generate calls can be nested
+  var prevStaticRenderFns = staticRenderFns;
+  var currentStaticRenderFns = staticRenderFns = [];
+  var prevOnceCount = onceCount;
+  onceCount = 0;
+  currentOptions = options;
+  warn$3 = options.warn || baseWarn;
+  transforms$1 = pluckModuleFunction(options.modules, 'transformCode');
+  dataGenFns = pluckModuleFunction(options.modules, 'genData');
+  platformDirectives$1 = options.directives || {};
+  isPlatformReservedTag$1 = options.isReservedTag || no;
+  var code = ast ? genElement(ast) : '_c("div")';
+  staticRenderFns = prevStaticRenderFns;
+  onceCount = prevOnceCount;
+  return {
+    render: ("with(this){return " + code + "}"),
+    staticRenderFns: currentStaticRenderFns
+  }
+}
+
+function genElement (el) {
+  if (el.staticRoot && !el.staticProcessed) {
+    return genStatic(el)
+  } else if (el.once && !el.onceProcessed) {
+    return genOnce(el)
+  } else if (el.for && !el.forProcessed) {
+    return genFor(el)
+  } else if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.tag === 'template' && !el.slotTarget) {
+    return genChildren(el) || 'void 0'
+  } else if (el.tag === 'slot') {
+    return genSlot(el)
+  } else {
+    // component or element
+    var code;
+    if (el.component) {
+      code = genComponent(el.component, el);
+    } else {
+      var data = el.plain ? undefined : genData(el);
+
+      var children = el.inlineTemplate ? null : genChildren(el, true);
+      code = "_c('" + (el.tag) + "'" + (data ? ("," + data) : '') + (children ? ("," + children) : '') + ")";
+    }
+    // module transforms
+    for (var i = 0; i < transforms$1.length; i++) {
+      code = transforms$1[i](el, code);
+    }
+    return code
+  }
+}
+
+// hoist static sub-trees out
+function genStatic (el) {
+  el.staticProcessed = true;
+  staticRenderFns.push(("with(this){return " + (genElement(el)) + "}"));
+  return ("_m(" + (staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + ")")
+}
+
+// v-once
+function genOnce (el) {
+  el.onceProcessed = true;
+  if (el.if && !el.ifProcessed) {
+    return genIf(el)
+  } else if (el.staticInFor) {
+    var key = '';
+    var parent = el.parent;
+    while (parent) {
+      if (parent.for) {
+        key = parent.key;
+        break
+      }
+      parent = parent.parent;
+    }
+    if (!key) {
+      "development" !== 'production' && warn$3(
+        "v-once can only be used inside v-for that is keyed. "
+      );
+      return genElement(el)
+    }
+    return ("_o(" + (genElement(el)) + "," + (onceCount++) + (key ? ("," + key) : "") + ")")
+  } else {
+    return genStatic(el)
+  }
+}
+
+function genIf (el) {
+  el.ifProcessed = true; // avoid recursion
+  return genIfConditions(el.ifConditions.slice())
+}
+
+function genIfConditions (conditions) {
+  if (!conditions.length) {
+    return '_e()'
+  }
+
+  var condition = conditions.shift();
+  if (condition.exp) {
+    return ("(" + (condition.exp) + ")?" + (genTernaryExp(condition.block)) + ":" + (genIfConditions(conditions)))
+  } else {
+    return ("" + (genTernaryExp(condition.block)))
+  }
+
+  // v-if with v-once should generate code like (a)?_m(0):_m(1)
+  function genTernaryExp (el) {
+    return el.once ? genOnce(el) : genElement(el)
+  }
+}
+
+function genFor (el) {
+  var exp = el.for;
+  var alias = el.alias;
+  var iterator1 = el.iterator1 ? ("," + (el.iterator1)) : '';
+  var iterator2 = el.iterator2 ? ("," + (el.iterator2)) : '';
+
+  if (
+    "development" !== 'production' &&
+    maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key
+  ) {
+    warn$3(
+      "<" + (el.tag) + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " +
+      "v-for should have explicit keys. " +
+      "See https://vuejs.org/guide/list.html#key for more info.",
+      true /* tip */
+    );
+  }
+
+  el.forProcessed = true; // avoid recursion
+  return "_l((" + exp + ")," +
+    "function(" + alias + iterator1 + iterator2 + "){" +
+      "return " + (genElement(el)) +
+    '})'
+}
+
+function genData (el) {
+  var data = '{';
+
+  // directives first.
+  // directives may mutate the el's other properties before they are generated.
+  var dirs = genDirectives(el);
+  if (dirs) { data += dirs + ','; }
+
+  // key
+  if (el.key) {
+    data += "key:" + (el.key) + ",";
+  }
+  // ref
+  if (el.ref) {
+    data += "ref:" + (el.ref) + ",";
+  }
+  if (el.refInFor) {
+    data += "refInFor:true,";
+  }
+  // pre
+  if (el.pre) {
+    data += "pre:true,";
+  }
+  // record original tag name for components using "is" attribute
+  if (el.component) {
+    data += "tag:\"" + (el.tag) + "\",";
+  }
+  // module data generation functions
+  for (var i = 0; i < dataGenFns.length; i++) {
+    data += dataGenFns[i](el);
+  }
+  // attributes
+  if (el.attrs) {
+    data += "attrs:{" + (genProps(el.attrs)) + "},";
+  }
+  // DOM props
+  if (el.props) {
+    data += "domProps:{" + (genProps(el.props)) + "},";
+  }
+  // event handlers
+  if (el.events) {
+    data += (genHandlers(el.events)) + ",";
+  }
+  if (el.nativeEvents) {
+    data += (genHandlers(el.nativeEvents, true)) + ",";
+  }
+  // slot target
+  if (el.slotTarget) {
+    data += "slot:" + (el.slotTarget) + ",";
+  }
+  // scoped slots
+  if (el.scopedSlots) {
+    data += (genScopedSlots(el.scopedSlots)) + ",";
+  }
+  // component v-model
+  if (el.model) {
+    data += "model:{value:" + (el.model.value) + ",callback:" + (el.model.callback) + ",expression:" + (el.model.expression) + "},";
+  }
+  // inline-template
+  if (el.inlineTemplate) {
+    var inlineTemplate = genInlineTemplate(el);
+    if (inlineTemplate) {
+      data += inlineTemplate + ",";
+    }
+  }
+  data = data.replace(/,$/, '') + '}';
+  // v-bind data wrap
+  if (el.wrapData) {
+    data = el.wrapData(data);
+  }
+  return data
+}
+
+function genDirectives (el) {
+  var dirs = el.directives;
+  if (!dirs) { return }
+  var res = 'directives:[';
+  var hasRuntime = false;
+  var i, l, dir, needRuntime;
+  for (i = 0, l = dirs.length; i < l; i++) {
+    dir = dirs[i];
+    needRuntime = true;
+    var gen = platformDirectives$1[dir.name] || baseDirectives[dir.name];
+    if (gen) {
+      // compile-time directive that manipulates AST.
+      // returns true if it also needs a runtime counterpart.
+      needRuntime = !!gen(el, dir, warn$3);
+    }
+    if (needRuntime) {
+      hasRuntime = true;
+      res += "{name:\"" + (dir.name) + "\",rawName:\"" + (dir.rawName) + "\"" + (dir.value ? (",value:(" + (dir.value) + "),expression:" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (",arg:\"" + (dir.arg) + "\"") : '') + (dir.modifiers ? (",modifiers:" + (JSON.stringify(dir.modifiers))) : '') + "},";
+    }
+  }
+  if (hasRuntime) {
+    return res.slice(0, -1) + ']'
+  }
+}
+
+function genInlineTemplate (el) {
+  var ast = el.children[0];
+  if ("development" !== 'production' && (
+    el.children.length > 1 || ast.type !== 1
+  )) {
+    warn$3('Inline-template components must have exactly one child element.');
+  }
+  if (ast.type === 1) {
+    var inlineRenderFns = generate(ast, currentOptions);
+    return ("inlineTemplate:{render:function(){" + (inlineRenderFns.render) + "},staticRenderFns:[" + (inlineRenderFns.staticRenderFns.map(function (code) { return ("function(){" + code + "}"); }).join(',')) + "]}")
+  }
+}
+
+function genScopedSlots (slots) {
+  return ("scopedSlots:_u([" + (Object.keys(slots).map(function (key) { return genScopedSlot(key, slots[key]); }).join(',')) + "])")
+}
+
+function genScopedSlot (key, el) {
+  return "[" + key + ",function(" + (String(el.attrsMap.scope)) + "){" +
+    "return " + (el.tag === 'template'
+      ? genChildren(el) || 'void 0'
+      : genElement(el)) + "}]"
+}
+
+function genChildren (el, checkSkip) {
+  var children = el.children;
+  if (children.length) {
+    var el$1 = children[0];
+    // optimize single v-for
+    if (children.length === 1 &&
+        el$1.for &&
+        el$1.tag !== 'template' &&
+        el$1.tag !== 'slot') {
+      return genElement(el$1)
+    }
+    var normalizationType = checkSkip ? getNormalizationType(children) : 0;
+    return ("[" + (children.map(genNode).join(',')) + "]" + (normalizationType ? ("," + normalizationType) : ''))
+  }
+}
+
+// determine the normalization needed for the children array.
+// 0: no normalization needed
+// 1: simple normalization needed (possible 1-level deep nested array)
+// 2: full normalization needed
+function getNormalizationType (children) {
+  var res = 0;
+  for (var i = 0; i < children.length; i++) {
+    var el = children[i];
+    if (el.type !== 1) {
+      continue
+    }
+    if (needsNormalization(el) ||
+        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {
+      res = 2;
+      break
+    }
+    if (maybeComponent(el) ||
+        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {
+      res = 1;
+    }
+  }
+  return res
+}
+
+function needsNormalization (el) {
+  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'
+}
+
+function maybeComponent (el) {
+  return !isPlatformReservedTag$1(el.tag)
+}
+
+function genNode (node) {
+  if (node.type === 1) {
+    return genElement(node)
+  } else {
+    return genText(node)
+  }
+}
+
+function genText (text) {
+  return ("_v(" + (text.type === 2
+    ? text.expression // no need for () because already wrapped in _s()
+    : transformSpecialNewlines(JSON.stringify(text.text))) + ")")
+}
+
+function genSlot (el) {
+  var slotName = el.slotName || '"default"';
+  var children = genChildren(el);
+  var res = "_t(" + slotName + (children ? ("," + children) : '');
+  var attrs = el.attrs && ("{" + (el.attrs.map(function (a) { return ((camelize(a.name)) + ":" + (a.value)); }).join(',')) + "}");
+  var bind$$1 = el.attrsMap['v-bind'];
+  if ((attrs || bind$$1) && !children) {
+    res += ",null";
+  }
+  if (attrs) {
+    res += "," + attrs;
+  }
+  if (bind$$1) {
+    res += (attrs ? '' : ',null') + "," + bind$$1;
+  }
+  return res + ')'
+}
+
+// componentName is el.component, take it as argument to shun flow's pessimistic refinement
+function genComponent (componentName, el) {
+  var children = el.inlineTemplate ? null : genChildren(el, true);
+  return ("_c(" + componentName + "," + (genData(el)) + (children ? ("," + children) : '') + ")")
+}
+
+function genProps (props) {
+  var res = '';
+  for (var i = 0; i < props.length; i++) {
+    var prop = props[i];
+    res += "\"" + (prop.name) + "\":" + (transformSpecialNewlines(prop.value)) + ",";
+  }
+  return res.slice(0, -1)
+}
+
+// #3895, #4268
+function transformSpecialNewlines (text) {
+  return text
+    .replace(/\u2028/g, '\\u2028')
+    .replace(/\u2029/g, '\\u2029')
+}
+
+/*  */
+
+// these keywords should not appear inside expressions, but operators like
+// typeof, instanceof and in are allowed
+var prohibitedKeywordRE = new RegExp('\\b' + (
+  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +
+  'super,throw,while,yield,delete,export,import,return,switch,default,' +
+  'extends,finally,continue,debugger,function,arguments'
+).split(',').join('\\b|\\b') + '\\b');
+
+// these unary operators should not be used as property/method names
+var unaryOperatorsRE = new RegExp('\\b' + (
+  'delete,typeof,void'
+).split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');
+
+// check valid identifier for v-for
+var identRE = /[A-Za-z_$][\w$]*/;
+
+// strip strings in expressions
+var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
+
+// detect problematic expressions in a template
+function detectErrors (ast) {
+  var errors = [];
+  if (ast) {
+    checkNode(ast, errors);
+  }
+  return errors
+}
+
+function checkNode (node, errors) {
+  if (node.type === 1) {
+    for (var name in node.attrsMap) {
+      if (dirRE.test(name)) {
+        var value = node.attrsMap[name];
+        if (value) {
+          if (name === 'v-for') {
+            checkFor(node, ("v-for=\"" + value + "\""), errors);
+          } else if (onRE.test(name)) {
+            checkEvent(value, (name + "=\"" + value + "\""), errors);
+          } else {
+            checkExpression(value, (name + "=\"" + value + "\""), errors);
+          }
+        }
+      }
+    }
+    if (node.children) {
+      for (var i = 0; i < node.children.length; i++) {
+        checkNode(node.children[i], errors);
+      }
+    }
+  } else if (node.type === 2) {
+    checkExpression(node.expression, node.text, errors);
+  }
+}
+
+function checkEvent (exp, text, errors) {
+  var keywordMatch = exp.replace(stripStringRE, '').match(unaryOperatorsRE);
+  if (keywordMatch) {
+    errors.push(
+      "avoid using JavaScript unary operator as property name: " +
+      "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
+    );
+  }
+  checkExpression(exp, text, errors);
+}
+
+function checkFor (node, text, errors) {
+  checkExpression(node.for || '', text, errors);
+  checkIdentifier(node.alias, 'v-for alias', text, errors);
+  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
+  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
+}
+
+function checkIdentifier (ident, type, text, errors) {
+  if (typeof ident === 'string' && !identRE.test(ident)) {
+    errors.push(("invalid " + type + " \"" + ident + "\" in expression: " + (text.trim())));
+  }
+}
+
+function checkExpression (exp, text, errors) {
+  try {
+    new Function(("return " + exp));
+  } catch (e) {
+    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
+    if (keywordMatch) {
+      errors.push(
+        "avoid using JavaScript keyword as property name: " +
+        "\"" + (keywordMatch[0]) + "\" in expression " + (text.trim())
+      );
+    } else {
+      errors.push(("invalid expression: " + (text.trim())));
+    }
+  }
+}
+
+/*  */
+
+function baseCompile (
+  template,
+  options
+) {
+  var ast = parse(template.trim(), options);
+  optimize(ast, options);
+  var code = generate(ast, options);
+  return {
+    ast: ast,
+    render: code.render,
+    staticRenderFns: code.staticRenderFns
+  }
+}
+
+function makeFunction (code, errors) {
+  try {
+    return new Function(code)
+  } catch (err) {
+    errors.push({ err: err, code: code });
+    return noop
+  }
+}
+
+function createCompiler (baseOptions) {
+  var functionCompileCache = Object.create(null);
+
+  function compile (
+    template,
+    options
+  ) {
+    var finalOptions = Object.create(baseOptions);
+    var errors = [];
+    var tips = [];
+    finalOptions.warn = function (msg, tip$$1) {
+      (tip$$1 ? tips : errors).push(msg);
+    };
+
+    if (options) {
+      // merge custom modules
+      if (options.modules) {
+        finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
+      }
+      // merge custom directives
+      if (options.directives) {
+        finalOptions.directives = extend(
+          Object.create(baseOptions.directives),
+          options.directives
+        );
+      }
+      // copy other options
+      for (var key in options) {
+        if (key !== 'modules' && key !== 'directives') {
+          finalOptions[key] = options[key];
+        }
+      }
+    }
+
+    var compiled = baseCompile(template, finalOptions);
+    {
+      errors.push.apply(errors, detectErrors(compiled.ast));
+    }
+    compiled.errors = errors;
+    compiled.tips = tips;
+    return compiled
+  }
+
+  function compileToFunctions (
+    template,
+    options,
+    vm
+  ) {
+    options = options || {};
+
+    /* istanbul ignore if */
+    {
+      // detect possible CSP restriction
+      try {
+        new Function('return 1');
+      } catch (e) {
+        if (e.toString().match(/unsafe-eval|CSP/)) {
+          warn(
+            'It seems you are using the standalone build of Vue.js in an ' +
+            'environment with Content Security Policy that prohibits unsafe-eval. ' +
+            'The template compiler cannot work in this environment. Consider ' +
+            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
+            'templates into render functions.'
+          );
+        }
+      }
+    }
+
+    // check cache
+    var key = options.delimiters
+      ? String(options.delimiters) + template
+      : template;
+    if (functionCompileCache[key]) {
+      return functionCompileCache[key]
+    }
+
+    // compile
+    var compiled = compile(template, options);
+
+    // check compilation errors/tips
+    {
+      if (compiled.errors && compiled.errors.length) {
+        warn(
+          "Error compiling template:\n\n" + template + "\n\n" +
+          compiled.errors.map(function (e) { return ("- " + e); }).join('\n') + '\n',
+          vm
+        );
+      }
+      if (compiled.tips && compiled.tips.length) {
+        compiled.tips.forEach(function (msg) { return tip(msg, vm); });
+      }
+    }
+
+    // turn code into functions
+    var res = {};
+    var fnGenErrors = [];
+    res.render = makeFunction(compiled.render, fnGenErrors);
+    var l = compiled.staticRenderFns.length;
+    res.staticRenderFns = new Array(l);
+    for (var i = 0; i < l; i++) {
+      res.staticRenderFns[i] = makeFunction(compiled.staticRenderFns[i], fnGenErrors);
+    }
+
+    // check function generation errors.
+    // this should only happen if there is a bug in the compiler itself.
+    // mostly for codegen development use
+    /* istanbul ignore if */
+    {
+      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
+        warn(
+          "Failed to generate render function:\n\n" +
+          fnGenErrors.map(function (ref) {
+            var err = ref.err;
+            var code = ref.code;
+
+            return ((err.toString()) + " in\n\n" + code + "\n");
+        }).join('\n'),
+          vm
+        );
+      }
+    }
+
+    return (functionCompileCache[key] = res)
+  }
+
+  return {
+    compile: compile,
+    compileToFunctions: compileToFunctions
+  }
+}
+
+/*  */
+
+function transformNode (el, options) {
+  var warn = options.warn || baseWarn;
+  var staticClass = getAndRemoveAttr(el, 'class');
+  if ("development" !== 'production' && staticClass) {
+    var expression = parseText(staticClass, options.delimiters);
+    if (expression) {
+      warn(
+        "class=\"" + staticClass + "\": " +
+        'Interpolation inside attributes has been removed. ' +
+        'Use v-bind or the colon shorthand instead. For example, ' +
+        'instead of <div class="{{ val }}">, use <div :class="val">.'
+      );
+    }
+  }
+  if (staticClass) {
+    el.staticClass = JSON.stringify(staticClass);
+  }
+  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
+  if (classBinding) {
+    el.classBinding = classBinding;
+  }
+}
+
+function genData$1 (el) {
+  var data = '';
+  if (el.staticClass) {
+    data += "staticClass:" + (el.staticClass) + ",";
+  }
+  if (el.classBinding) {
+    data += "class:" + (el.classBinding) + ",";
+  }
+  return data
+}
+
+var klass$1 = {
+  staticKeys: ['staticClass'],
+  transformNode: transformNode,
+  genData: genData$1
+};
+
+/*  */
+
+function transformNode$1 (el, options) {
+  var warn = options.warn || baseWarn;
+  var staticStyle = getAndRemoveAttr(el, 'style');
+  if (staticStyle) {
+    /* istanbul ignore if */
+    {
+      var expression = parseText(staticStyle, options.delimiters);
+      if (expression) {
+        warn(
+          "style=\"" + staticStyle + "\": " +
+          'Interpolation inside attributes has been removed. ' +
+          'Use v-bind or the colon shorthand instead. For example, ' +
+          'instead of <div style="{{ val }}">, use <div :style="val">.'
+        );
+      }
+    }
+    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
+  }
+
+  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
+  if (styleBinding) {
+    el.styleBinding = styleBinding;
+  }
+}
+
+function genData$2 (el) {
+  var data = '';
+  if (el.staticStyle) {
+    data += "staticStyle:" + (el.staticStyle) + ",";
+  }
+  if (el.styleBinding) {
+    data += "style:(" + (el.styleBinding) + "),";
+  }
+  return data
+}
+
+var style$1 = {
+  staticKeys: ['staticStyle'],
+  transformNode: transformNode$1,
+  genData: genData$2
+};
+
+var modules$1 = [
+  klass$1,
+  style$1
+];
+
+/*  */
+
+function text (el, dir) {
+  if (dir.value) {
+    addProp(el, 'textContent', ("_s(" + (dir.value) + ")"));
+  }
+}
+
+/*  */
+
+function html (el, dir) {
+  if (dir.value) {
+    addProp(el, 'innerHTML', ("_s(" + (dir.value) + ")"));
+  }
+}
+
+var directives$1 = {
+  model: model,
+  text: text,
+  html: html
+};
+
+/*  */
+
+var baseOptions = {
+  expectHTML: true,
+  modules: modules$1,
+  directives: directives$1,
+  isPreTag: isPreTag,
+  isUnaryTag: isUnaryTag,
+  mustUseProp: mustUseProp,
+  isReservedTag: isReservedTag,
+  getTagNamespace: getTagNamespace,
+  staticKeys: genStaticKeys(modules$1)
+};
+
+var ref$1 = createCompiler(baseOptions);
+var compileToFunctions = ref$1.compileToFunctions;
+
+/*  */
+
+var idToTemplate = cached(function (id) {
+  var el = query(id);
+  return el && el.innerHTML
+});
+
+var mount = Vue$3.prototype.$mount;
+Vue$3.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && query(el);
+
+  /* istanbul ignore if */
+  if (el === document.body || el === document.documentElement) {
+    "development" !== 'production' && warn(
+      "Do not mount Vue to <html> or <body> - mount to normal elements instead."
+    );
+    return this
+  }
+
+  var options = this.$options;
+  // resolve template/el and convert to render function
+  if (!options.render) {
+    var template = options.template;
+    if (template) {
+      if (typeof template === 'string') {
+        if (template.charAt(0) === '#') {
+          template = idToTemplate(template);
+          /* istanbul ignore if */
+          if ("development" !== 'production' && !template) {
+            warn(
+              ("Template element not found or is empty: " + (options.template)),
+              this
+            );
+          }
+        }
+      } else if (template.nodeType) {
+        template = template.innerHTML;
+      } else {
+        {
+          warn('invalid template option:' + template, this);
+        }
+        return this
+      }
+    } else if (el) {
+      template = getOuterHTML(el);
+    }
+    if (template) {
+      /* istanbul ignore if */
+      if ("development" !== 'production' && config.performance && perf) {
+        perf.mark('compile');
+      }
+
+      var ref = compileToFunctions(template, {
+        shouldDecodeNewlines: shouldDecodeNewlines,
+        delimiters: options.delimiters
+      }, this);
+      var render = ref.render;
+      var staticRenderFns = ref.staticRenderFns;
+      options.render = render;
+      options.staticRenderFns = staticRenderFns;
+
+      /* istanbul ignore if */
+      if ("development" !== 'production' && config.performance && perf) {
+        perf.mark('compile end');
+        perf.measure(((this._name) + " compile"), 'compile', 'compile end');
+      }
+    }
+  }
+  return mount.call(this, el, hydrating)
+};
+
+/**
+ * Get outerHTML of elements, taking care
+ * of SVG elements in IE as well.
+ */
+function getOuterHTML (el) {
+  if (el.outerHTML) {
+    return el.outerHTML
+  } else {
+    var container = document.createElement('div');
+    container.appendChild(el.cloneNode(true));
+    return container.innerHTML
+  }
+}
+
+Vue$3.compile = compileToFunctions;
+
+return Vue$3;
+
+})));
Index: public/node_modules/vue/src/core/instance/lifecycle.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/lifecycle.js	(revision )
+++ public/node_modules/vue/src/core/instance/lifecycle.js	(revision )
@@ -0,0 +1,306 @@
+/* @flow */
+
+import config from '../config'
+import { perf } from '../util/perf'
+import Watcher from '../observer/watcher'
+import { createEmptyVNode } from '../vdom/vnode'
+import { observerState } from '../observer/index'
+import { updateComponentListeners } from './events'
+import { resolveSlots } from './render-helpers/resolve-slots'
+
+import {
+  warn,
+  noop,
+  remove,
+  handleError,
+  emptyObject,
+  validateProp
+} from '../util/index'
+
+export let activeInstance: any = null
+
+export function initLifecycle (vm: Component) {
+  const options = vm.$options
+
+  // locate first non-abstract parent
+  let parent = options.parent
+  if (parent && !options.abstract) {
+    while (parent.$options.abstract && parent.$parent) {
+      parent = parent.$parent
+    }
+    parent.$children.push(vm)
+  }
+
+  vm.$parent = parent
+  vm.$root = parent ? parent.$root : vm
+
+  vm.$children = []
+  vm.$refs = {}
+
+  vm._watcher = null
+  vm._inactive = null
+  vm._directInactive = false
+  vm._isMounted = false
+  vm._isDestroyed = false
+  vm._isBeingDestroyed = false
+}
+
+export function lifecycleMixin (Vue: Class<Component>) {
+  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
+    const vm: Component = this
+    if (vm._isMounted) {
+      callHook(vm, 'beforeUpdate')
+    }
+    const prevEl = vm.$el
+    const prevVnode = vm._vnode
+    const prevActiveInstance = activeInstance
+    activeInstance = vm
+    vm._vnode = vnode
+    // Vue.prototype.__patch__ is injected in entry points
+    // based on the rendering backend used.
+    if (!prevVnode) {
+      // initial render
+      vm.$el = vm.__patch__(
+        vm.$el, vnode, hydrating, false /* removeOnly */,
+        vm.$options._parentElm,
+        vm.$options._refElm
+      )
+    } else {
+      // updates
+      vm.$el = vm.__patch__(prevVnode, vnode)
+    }
+    activeInstance = prevActiveInstance
+    // update __vue__ reference
+    if (prevEl) {
+      prevEl.__vue__ = null
+    }
+    if (vm.$el) {
+      vm.$el.__vue__ = vm
+    }
+    // if parent is an HOC, update its $el as well
+    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
+      vm.$parent.$el = vm.$el
+    }
+    // updated hook is called by the scheduler to ensure that children are
+    // updated in a parent's updated hook.
+  }
+
+  Vue.prototype.$forceUpdate = function () {
+    const vm: Component = this
+    if (vm._watcher) {
+      vm._watcher.update()
+    }
+  }
+
+  Vue.prototype.$destroy = function () {
+    const vm: Component = this
+    if (vm._isBeingDestroyed) {
+      return
+    }
+    callHook(vm, 'beforeDestroy')
+    vm._isBeingDestroyed = true
+    // remove self from parent
+    const parent = vm.$parent
+    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
+      remove(parent.$children, vm)
+    }
+    // teardown watchers
+    if (vm._watcher) {
+      vm._watcher.teardown()
+    }
+    let i = vm._watchers.length
+    while (i--) {
+      vm._watchers[i].teardown()
+    }
+    // remove reference from data ob
+    // frozen object may not have observer.
+    if (vm._data.__ob__) {
+      vm._data.__ob__.vmCount--
+    }
+    // call the last hook...
+    vm._isDestroyed = true
+    callHook(vm, 'destroyed')
+    // turn off all instance listeners.
+    vm.$off()
+    // remove __vue__ reference
+    if (vm.$el) {
+      vm.$el.__vue__ = null
+    }
+    // invoke destroy hooks on current rendered tree
+    vm.__patch__(vm._vnode, null)
+  }
+}
+
+export function mountComponent (
+  vm: Component,
+  el: ?Element,
+  hydrating?: boolean
+): Component {
+  vm.$el = el
+  if (!vm.$options.render) {
+    vm.$options.render = createEmptyVNode
+    if (process.env.NODE_ENV !== 'production') {
+      /* istanbul ignore if */
+      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
+        vm.$options.el || el) {
+        warn(
+          'You are using the runtime-only build of Vue where the template ' +
+          'compiler is not available. Either pre-compile the templates into ' +
+          'render functions, or use the compiler-included build.',
+          vm
+        )
+      } else {
+        warn(
+          'Failed to mount component: template or render function not defined.',
+          vm
+        )
+      }
+    }
+  }
+  callHook(vm, 'beforeMount')
+
+  let updateComponent
+  /* istanbul ignore if */
+  if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+    updateComponent = () => {
+      const name = vm._name
+      const startTag = `start ${name}`
+      const endTag = `end ${name}`
+      perf.mark(startTag)
+      const vnode = vm._render()
+      perf.mark(endTag)
+      perf.measure(`${name} render`, startTag, endTag)
+      perf.mark(startTag)
+      vm._update(vnode, hydrating)
+      perf.mark(endTag)
+      perf.measure(`${name} patch`, startTag, endTag)
+    }
+  } else {
+    updateComponent = () => {
+      vm._update(vm._render(), hydrating)
+    }
+  }
+
+  vm._watcher = new Watcher(vm, updateComponent, noop)
+  hydrating = false
+
+  // manually mounted instance, call mounted on self
+  // mounted is called for render-created child components in its inserted hook
+  if (vm.$vnode == null) {
+    vm._isMounted = true
+    callHook(vm, 'mounted')
+  }
+  return vm
+}
+
+export function updateChildComponent (
+  vm: Component,
+  propsData: ?Object,
+  listeners: ?Object,
+  parentVnode: VNode,
+  renderChildren: ?Array<VNode>
+) {
+  // determine whether component has slot children
+  // we need to do this before overwriting $options._renderChildren
+  const hasChildren = !!(
+    renderChildren ||               // has new static slots
+    vm.$options._renderChildren ||  // has old static slots
+    parentVnode.data.scopedSlots || // has new scoped slots
+    vm.$scopedSlots !== emptyObject // has old scoped slots
+  )
+
+  vm.$options._parentVnode = parentVnode
+  vm.$vnode = parentVnode // update vm's placeholder node without re-render
+  if (vm._vnode) { // update child tree's parent
+    vm._vnode.parent = parentVnode
+  }
+  vm.$options._renderChildren = renderChildren
+
+  // update props
+  if (propsData && vm.$options.props) {
+    observerState.shouldConvert = false
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = true
+    }
+    const props = vm._props
+    const propKeys = vm.$options._propKeys || []
+    for (let i = 0; i < propKeys.length; i++) {
+      const key = propKeys[i]
+      props[key] = validateProp(key, vm.$options.props, propsData, vm)
+    }
+    observerState.shouldConvert = true
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = false
+    }
+    // keep a copy of raw propsData
+    vm.$options.propsData = propsData
+  }
+  // update listeners
+  if (listeners) {
+    const oldListeners = vm.$options._parentListeners
+    vm.$options._parentListeners = listeners
+    updateComponentListeners(vm, listeners, oldListeners)
+  }
+  // resolve slots + force update if has children
+  if (hasChildren) {
+    vm.$slots = resolveSlots(renderChildren, parentVnode.context)
+    vm.$forceUpdate()
+  }
+}
+
+function isInInactiveTree (vm) {
+  while (vm && (vm = vm.$parent)) {
+    if (vm._inactive) return true
+  }
+  return false
+}
+
+export function activateChildComponent (vm: Component, direct?: boolean) {
+  if (direct) {
+    vm._directInactive = false
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  } else if (vm._directInactive) {
+    return
+  }
+  if (vm._inactive || vm._inactive == null) {
+    vm._inactive = false
+    for (let i = 0; i < vm.$children.length; i++) {
+      activateChildComponent(vm.$children[i])
+    }
+    callHook(vm, 'activated')
+  }
+}
+
+export function deactivateChildComponent (vm: Component, direct?: boolean) {
+  if (direct) {
+    vm._directInactive = true
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  }
+  if (!vm._inactive) {
+    vm._inactive = true
+    for (let i = 0; i < vm.$children.length; i++) {
+      deactivateChildComponent(vm.$children[i])
+    }
+    callHook(vm, 'deactivated')
+  }
+}
+
+export function callHook (vm: Component, hook: string) {
+  const handlers = vm.$options[hook]
+  if (handlers) {
+    for (let i = 0, j = handlers.length; i < j; i++) {
+      try {
+        handlers[i].call(vm)
+      } catch (e) {
+        handleError(e, vm, `${hook} hook`)
+      }
+    }
+  }
+  if (vm._hasHookEvent) {
+    vm.$emit('hook:' + hook)
+  }
+}
Index: public/node_modules/vue/src/core/instance/render-helpers/bind-object-props.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render-helpers/bind-object-props.js	(revision )
+++ public/node_modules/vue/src/core/instance/render-helpers/bind-object-props.js	(revision )
@@ -0,0 +1,39 @@
+/* @flow */
+
+import config from 'core/config'
+import { isObject, warn, toObject } from 'core/util/index'
+
+/**
+ * Runtime helper for merging v-bind="object" into a VNode's data.
+ */
+export function bindObjectProps (
+  data: any,
+  tag: string,
+  value: any,
+  asProp?: boolean
+): VNodeData {
+  if (value) {
+    if (!isObject(value)) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'v-bind without argument expects an Object or Array value',
+        this
+      )
+    } else {
+      if (Array.isArray(value)) {
+        value = toObject(value)
+      }
+      for (const key in value) {
+        if (key === 'class' || key === 'style') {
+          data[key] = value[key]
+        } else {
+          const type = data.attrs && data.attrs.type
+          const hash = asProp || config.mustUseProp(tag, type, key)
+            ? data.domProps || (data.domProps = {})
+            : data.attrs || (data.attrs = {})
+          hash[key] = value[key]
+        }
+      }
+    }
+  }
+  return data
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/readme.md	(revision )
@@ -0,0 +1,33 @@
+# lowercase-keys [![Build Status](https://travis-ci.org/sindresorhus/lowercase-keys.svg?branch=master)](https://travis-ci.org/sindresorhus/lowercase-keys)
+
+> Lowercase the keys of an object
+
+
+## Install
+
+```
+$ npm install --save lowercase-keys
+```
+
+
+## Usage
+
+```js
+var lowercaseKeys = require('lowercase-keys');
+
+lowercaseKeys({FOO: true, bAr: false});
+//=> {foo: true, bar: false}
+```
+
+
+## API
+
+### lowercaseKeys(object)
+
+Lowercases the keys and returns a new object.
+
+
+
+## License
+
+MIT  [Sindre Sorhus](http://sindresorhus.com)
Index: public/node_modules/vue/src/core/instance/render-helpers/render-list.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render-helpers/render-list.js	(revision )
+++ public/node_modules/vue/src/core/instance/render-helpers/render-list.js	(revision )
@@ -0,0 +1,32 @@
+/* @flow */
+
+import { isObject } from 'core/util/index'
+
+/**
+ * Runtime helper for rendering v-for lists.
+ */
+export function renderList (
+  val: any,
+  render: () => VNode
+): ?Array<VNode> {
+  let ret: ?Array<VNode>, i, l, keys, key
+  if (Array.isArray(val) || typeof val === 'string') {
+    ret = new Array(val.length)
+    for (i = 0, l = val.length; i < l; i++) {
+      ret[i] = render(val[i], i)
+    }
+  } else if (typeof val === 'number') {
+    ret = new Array(val)
+    for (i = 0; i < val; i++) {
+      ret[i] = render(i + 1, i)
+    }
+  } else if (isObject(val)) {
+    keys = Object.keys(val)
+    ret = new Array(keys.length)
+    for (i = 0, l = keys.length; i < l; i++) {
+      key = keys[i]
+      ret[i] = render(val[key], key, i)
+    }
+  }
+  return ret
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/index.js	(revision )
@@ -0,0 +1,58 @@
+var buffer = require('buffer')
+
+if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
+  module.exports = buffer
+} else {
+  // Copy properties from require('buffer')
+  Object.keys(buffer).forEach(function (prop) {
+    exports[prop] = buffer[prop]
+  })
+  exports.Buffer = SafeBuffer
+}
+
+function SafeBuffer (arg, encodingOrOffset, length) {
+  return Buffer(arg, encodingOrOffset, length)
+}
+
+// Copy static methods from Buffer
+Object.keys(Buffer).forEach(function (prop) {
+  SafeBuffer[prop] = Buffer[prop]
+})
+
+SafeBuffer.from = function (arg, encodingOrOffset, length) {
+  if (typeof arg === 'number') {
+    throw new TypeError('Argument must not be a number')
+  }
+  return Buffer(arg, encodingOrOffset, length)
+}
+
+SafeBuffer.alloc = function (size, fill, encoding) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  var buf = Buffer(size)
+  if (fill !== undefined) {
+    if (typeof encoding === 'string') {
+      buf.fill(fill, encoding)
+    } else {
+      buf.fill(fill)
+    }
+  } else {
+    buf.fill(0)
+  }
+  return buf
+}
+
+SafeBuffer.allocUnsafe = function (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  return Buffer(size)
+}
+
+SafeBuffer.allocUnsafeSlow = function (size) {
+  if (typeof size !== 'number') {
+    throw new TypeError('Argument must be a number')
+  }
+  return buffer.SlowBuffer(size)
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/index.js	(revision )
@@ -0,0 +1,44 @@
+'use strict';
+var captureStackTrace = require('capture-stack-trace');
+
+function inherits(ctor, superCtor) {
+	ctor.super_ = superCtor;
+	ctor.prototype = Object.create(superCtor.prototype, {
+		constructor: {
+			value: ctor,
+			enumerable: false,
+			writable: true,
+			configurable: true
+		}
+	});
+}
+
+module.exports = function createErrorClass(className, setup) {
+	if (typeof className !== 'string') {
+		throw new TypeError('Expected className to be a string');
+	}
+
+	if (/[^0-9a-zA-Z_$]/.test(className)) {
+		throw new Error('className contains invalid characters');
+	}
+
+	setup = setup || function (message) {
+		this.message = message;
+	};
+
+	var ErrorClass = function () {
+		Object.defineProperty(this, 'name', {
+			configurable: true,
+			value: className,
+			writable: true
+		});
+
+		captureStackTrace(this, this.constructor);
+
+		setup.apply(this, arguments);
+	};
+
+	inherits(ErrorClass, Error);
+
+	return ErrorClass;
+};
Index: public/node_modules/vue/src/core/global-api/assets.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/global-api/assets.js	(revision )
+++ public/node_modules/vue/src/core/global-api/assets.js	(revision )
@@ -0,0 +1,39 @@
+/* @flow */
+
+import config from '../config'
+import { warn, isPlainObject } from '../util/index'
+
+export function initAssetRegisters (Vue: GlobalAPI) {
+  /**
+   * Create asset registration methods.
+   */
+  config._assetTypes.forEach(type => {
+    Vue[type] = function (
+      id: string,
+      definition: Function | Object
+    ): Function | Object | void {
+      if (!definition) {
+        return this.options[type + 's'][id]
+      } else {
+        /* istanbul ignore if */
+        if (process.env.NODE_ENV !== 'production') {
+          if (type === 'component' && config.isReservedTag(id)) {
+            warn(
+              'Do not use built-in or reserved HTML elements as component ' +
+              'id: ' + id
+            )
+          }
+        }
+        if (type === 'component' && isPlainObject(definition)) {
+          definition.name = definition.name || id
+          definition = this.options._base.extend(definition)
+        }
+        if (type === 'directive' && typeof definition === 'function') {
+          definition = { bind: definition, update: definition }
+        }
+        this.options[type + 's'][id] = definition
+        return definition
+      }
+    }
+  })
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/package.json	(revision )
@@ -0,0 +1,49 @@
+{
+  "name": "lowercase-keys",
+  "version": "1.0.0",
+  "description": "Lowercase the keys of an object",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/lowercase-keys"
+  },
+  "author": {
+    "name": "Sindre Sorhus",
+    "email": "sindresorhus@gmail.com",
+    "url": "sindresorhus.com"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "node test.js"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "object",
+    "assign",
+    "extend",
+    "properties",
+    "lowercase",
+    "lower-case",
+    "case",
+    "keys",
+    "key"
+  ],
+  "devDependencies": {
+    "ava": "0.0.4"
+  },
+  "readme": "# lowercase-keys [![Build Status](https://travis-ci.org/sindresorhus/lowercase-keys.svg?branch=master)](https://travis-ci.org/sindresorhus/lowercase-keys)\n\n> Lowercase the keys of an object\n\n\n## Install\n\n```\n$ npm install --save lowercase-keys\n```\n\n\n## Usage\n\n```js\nvar lowercaseKeys = require('lowercase-keys');\n\nlowercaseKeys({FOO: true, bAr: false});\n//=> {foo: true, bar: false}\n```\n\n\n## API\n\n### lowercaseKeys(object)\n\nLowercases the keys and returns a new object.\n\n\n\n## License\n\nMIT  [Sindre Sorhus](http://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/lowercase-keys/issues"
+  },
+  "_id": "lowercase-keys@1.0.0",
+  "dist": {
+    "shasum": "353329f46ec06edd0cfa77655abbf089e0ff842d"
+  },
+  "_from": "lowercase-keys@^1.0.0",
+  "_resolved": "https://registry.npmjs.org/lowercase-keys/-/lowercase-keys-1.0.0.tgz"
+}
Index: public/node_modules/vue/src/core/config.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/config.js	(revision )
+++ public/node_modules/vue/src/core/config.js	(revision )
@@ -0,0 +1,127 @@
+/* @flow */
+
+import { no, noop, identity } from 'shared/util'
+
+export type Config = {
+  // user
+  optionMergeStrategies: { [key: string]: Function };
+  silent: boolean;
+  productionTip: boolean;
+  performance: boolean;
+  devtools: boolean;
+  errorHandler: ?(err: Error, vm: Component, info: string) => void;
+  ignoredElements: Array<string>;
+  keyCodes: { [key: string]: number | Array<number> };
+  // platform
+  isReservedTag: (x?: string) => boolean;
+  parsePlatformTagName: (x: string) => string;
+  isUnknownElement: (x?: string) => boolean;
+  getTagNamespace: (x?: string) => string | void;
+  mustUseProp: (tag: string, type: ?string, name: string) => boolean;
+  // internal
+  _assetTypes: Array<string>;
+  _lifecycleHooks: Array<string>;
+  _maxUpdateCount: number;
+};
+
+const config: Config = {
+  /**
+   * Option merge strategies (used in core/util/options)
+   */
+  optionMergeStrategies: Object.create(null),
+
+  /**
+   * Whether to suppress warnings.
+   */
+  silent: false,
+
+  /**
+   * Show production mode tip message on boot?
+   */
+  productionTip: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to enable devtools
+   */
+  devtools: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to record perf
+   */
+  performance: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Error handler for watcher errors
+   */
+  errorHandler: null,
+
+  /**
+   * Ignore certain custom elements
+   */
+  ignoredElements: [],
+
+  /**
+   * Custom user key aliases for v-on
+   */
+  keyCodes: Object.create(null),
+
+  /**
+   * Check if a tag is reserved so that it cannot be registered as a
+   * component. This is platform-dependent and may be overwritten.
+   */
+  isReservedTag: no,
+
+  /**
+   * Check if a tag is an unknown element.
+   * Platform-dependent.
+   */
+  isUnknownElement: no,
+
+  /**
+   * Get the namespace of an element
+   */
+  getTagNamespace: noop,
+
+  /**
+   * Parse the real tag name for the specific platform.
+   */
+  parsePlatformTagName: identity,
+
+  /**
+   * Check if an attribute must be bound using property, e.g. value
+   * Platform-dependent.
+   */
+  mustUseProp: no,
+
+  /**
+   * List of asset types that a component can own.
+   */
+  _assetTypes: [
+    'component',
+    'directive',
+    'filter'
+  ],
+
+  /**
+   * List of lifecycle hooks.
+   */
+  _lifecycleHooks: [
+    'beforeCreate',
+    'created',
+    'beforeMount',
+    'mounted',
+    'beforeUpdate',
+    'updated',
+    'beforeDestroy',
+    'destroyed',
+    'activated',
+    'deactivated'
+  ],
+
+  /**
+   * Max circular updates allowed in a scheduler flush cycle.
+   */
+  _maxUpdateCount: 100
+}
+
+export default config
Index: public/node_modules/vue/src/platforms/weex/compiler/modules/style.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/modules/style.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/modules/style.js	(revision )
@@ -0,0 +1,82 @@
+/* @flow */
+
+import { cached, camelize } from 'shared/util'
+import { parseText } from 'compiler/parser/text-parser'
+import {
+  getAndRemoveAttr,
+  getBindingAttr,
+  baseWarn
+} from 'compiler/helpers'
+
+type StaticStyleResult = {
+  dynamic: boolean,
+  styleResult: string
+};
+
+const normalize = cached(camelize)
+
+function transformNode (el: ASTElement, options: CompilerOptions) {
+  const warn = options.warn || baseWarn
+  const staticStyle = getAndRemoveAttr(el, 'style')
+  const { dynamic, styleResult } = parseStaticStyle(staticStyle, options)
+  if (process.env.NODE_ENV !== 'production' && dynamic) {
+    warn(
+      `style="${String(staticStyle)}": ` +
+      'Interpolation inside attributes has been deprecated. ' +
+      'Use v-bind or the colon shorthand instead.'
+    )
+  }
+  if (!dynamic && styleResult) {
+    el.staticStyle = styleResult
+  }
+  const styleBinding = getBindingAttr(el, 'style', false /* getStatic */)
+  if (styleBinding) {
+    el.styleBinding = styleBinding
+  } else if (dynamic) {
+    el.styleBinding = styleResult
+  }
+}
+
+function genData (el: ASTElement): string {
+  let data = ''
+  if (el.staticStyle) {
+    data += `staticStyle:${el.staticStyle},`
+  }
+  if (el.styleBinding) {
+    data += `style:${el.styleBinding},`
+  }
+  return data
+}
+
+function parseStaticStyle (staticStyle: ?string, options: CompilerOptions): StaticStyleResult {
+  // "width: 200px; height: 200px;" -> {width: 200, height: 200}
+  // "width: 200px; height: {{y}}" -> {width: 200, height: y}
+  let dynamic = false
+  let styleResult = ''
+  if (staticStyle) {
+    const styleList = staticStyle.trim().split(';').map(style => {
+      const result = style.trim().split(':')
+      if (result.length !== 2) {
+        return
+      }
+      const key = normalize(result[0].trim())
+      const value = result[1].trim()
+      const dynamicValue = parseText(value, options.delimiters)
+      if (dynamicValue) {
+        dynamic = true
+        return key + ':' + dynamicValue
+      }
+      return key + ':' + JSON.stringify(value)
+    }).filter(result => result)
+    if (styleList.length) {
+      styleResult = '{' + styleList.join(',') + '}'
+    }
+  }
+  return { dynamic, styleResult }
+}
+
+export default {
+  staticKeys: ['staticStyle'],
+  transformNode,
+  genData
+}
Index: public/node_modules/vue/src/platforms/web/server/directives/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/directives/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/directives/index.js	(revision )
@@ -0,0 +1,5 @@
+import show from './show'
+
+export default {
+  show
+}
Index: public/node_modules/vue-select2/dist/vue-select.js.map
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/dist/vue-select.js.map	(revision )
+++ public/node_modules/vue-select2/dist/vue-select.js.map	(revision )
@@ -0,0 +1,1 @@
+{"version":3,"sources":["webpack:///webpack/bootstrap 4b33c9b1ba403aec0760","webpack:///./src/vue-select.js","webpack:///./src/value-text-matcher.js"],"names":[],"mappings":";;;;;;AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAwC;AACxC;AACA,UAAS,6BAA6B,GAAG,6BAA6B;AACtE;AACA,UAAS,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACpG,UAAS,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAA+F,KAAK;AACpG,uGAAsG,UAAU;AAChH;AACA,4EAA2E,UAAU;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,uCAAsC;AACtC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA8C;AAC9C,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA,MAAK;AACL,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,oEAAmE,6BAA6B,GAAG,6BAA6B;AAChI;AACA,aAAY,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACvG,aAAY,4BAA4B,6BAA6B,GAAG,6BAA6B,EAAE;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA,QAAO;AACP;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,6DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,iBAAiB;AACpC;AACA,sBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC;;AAEjC;AACA,2CAA0C,QAAQ;AAClD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,E","file":"vue-select.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 4b33c9b1ba403aec0760\n **/","/**\n * The default language used by this component.\n */\nvar DEFAULT_LANGUAGE = \"en-US\";\n\n/**\n * A bootstrap style selection (combobox) control using the select2 plugin.\n *\n * @param options\n *    the array of options of the selection control. It could be an array of\n *    strings, e.g., \"['opt1', 'opt2']\"; or an array of objects specifying\n *    the text and value of each option, e.g.,\n *    \"[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]\";\n *    or it could be an array of objects specifying the option group, e.g.\n *    \"[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},\n *      {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]\".\n * @param model\n *    the model bind to the control, which must be a two way binding variable.\n * @param searchable\n *    the optional flag indicates whether to show the search box. Default value\n *    is false.\n * @param matchValue\n *    the optional flag indicates whether the searching should match both the\n *    texts and values of options. Default value is true.\n * @param language\n *    the optional code of language used by the select2 plugin. If it is not set,\n *    and the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin is used,\n *    the component will use the language code `$language` provided by the\n *    [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin; otherwise, the\n *    component will use the default value \"en-US\".\n * @param theme\n *    the optional name of the theme of the select2. Default value is \"bootstrap\".\n * @param name\n *    the optional name of the selection control.\n * @author Haixing Hu\n */\nmodule.exports = {\n  replace: true,\n  inherit: false,\n  template: \"<select class='form-control' v-model='model' :name='name' style='width: 100%'>\"\n          +   \"<option v-if='optionsType === \\\"values\\\"' v-for='val in options' :value='val'>{{val}}</option>\"\n          +   \"<option v-if='optionsType === \\\"options\\\"' v-for='opt in options' :value='opt.value'>{{opt.text}}</option>\"\n          +   \"<optgroup v-if='optionsType === \\\"groups\\\"' v-for='group in options' :label='group.label'>\"\n          +     \"<option v-for='opt in group.options' :value='opt.value'>{{opt.text}}</option>\"\n          +   \"</optgroup>\"\n          + \"</select>\",\n  props: {\n    options: {\n      type: Array,\n      required: true\n    },\n    model: {\n      required: true,\n      twoWay: true\n    },\n    searchable: {\n      type: Boolean,\n      required: false,\n      default: false\n    },\n    matchValue: {\n      type: Boolean,\n      required: false,\n      default: true\n    },\n    name: {\n      type: String,\n      required: false,\n      default: \"\"\n    },\n    language: {\n      type: String,\n      required: false,\n      default: \"\"\n    },\n    theme: {\n      type: String,\n      required: false,\n      default: \"bootstrap\"\n    }\n  },\n  data: function() {\n    return {\n      optionsType: \"unknown\"\n    }\n  },\n  beforeCompile: function() {\n    this.isChanging = false;\n    this.control = null;\n    this.optionsType = this.getOptionsType();\n  },\n  watch: {\n    \"options\": function(val, oldVal) {\n      //console.debug(\"options.change\");\n      this.optionsType = this.getOptionsType();\n      var found = this.inOptions(this.model);\n      var newValue = (found ? this.model : null);\n      this.control.removeData(\"data\");  // remove the cached options data\n      // note that setting the model will automatically changed in the \"change\"\n      // event of the select2 control\n      this.control.val(newValue).trigger(\"change\");\n    },\n    \"model\": function(val, oldVal) {\n      //console.debug(\"model.change\");\n      if (! this.isChanging) {\n        this.isChanging = true;\n        this.control.val(val).trigger(\"change\");\n        this.isChanging = false;\n      }\n    }\n  },\n  ready: function() {\n    var language = this.language;\n    if (language === null || language === \"\") {\n      if (this.$language) {\n        language = this.$language;\n      } else {\n        language = DEFAULT_LANGUAGE;\n      }\n    }\n    var args = {\n      theme: this.theme,\n      language: this.getLanguageCode(language)\n    };\n    if (! this.searchable) {\n      args.minimumResultsForSearch = Infinity;  // hide the search box\n    } else {\n      if (this.matchValue) {\n        args.matcher = require(\"./value-text-matcher.js\");\n      }\n    }\n    this.control = $(this.$el);\n    this.control.select2(args);\n    var me = this;\n    this.control.on(\"change\", function(e) {\n      //console.debug(\"control.change\");\n      if (! me.isChanging) {\n        me.isChanging = true;\n        me.model = me.control.val();\n        me.$nextTick(function () {\n          me.isChanging = false;\n        });\n      }\n    });\n  },\n  methods: {\n\n    /**\n     * Gets the type of the `options` property of this component.\n     *\n     * The `options` property of this component may have the following types:\n     * - \"values\": the `options` is an array of strings, e.g., `[value1, value2, value3]`;\n     * - \"options\": the `options` is an array of options, e.g., `[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]`;\n     * - \"groups\": the `options` is an array of option groups, e.g.,\n     *   `[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},\n     *     {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]`;\n     *\n     * @param options\n     *    the new options.\n     * @return\n     *    the string representing the type of the `options` property of this\n     *    component.\n     */\n    getOptionsType: function() {\n      if (this.options.length === 0) {\n        return \"values\";\n      }\n      var el = this.options[0];\n      if (typeof el == \"string\" || el instanceof String) {\n        return \"values\";\n      } else if (typeof el.text !== \"undefined\") {\n        return \"options\";\n      } else if (typeof el.label !== \"undefined\") {\n        return \"groups\";\n      } else {\n        return \"unknown\";\n      }\n    },\n\n    /**\n     * Tests whether a specified value exists in the options.\n     *\n     * @param value\n     *    the value to test.\n     * @return\n     *    true if the specified value exists in the options; false otherwise.\n     */\n    inOptions: function(value) {\n      var type = this.getOptionsType();\n      var list = this.options;\n      var i, j;\n      switch (type) {\n      case \"values\":\n        for (i = 0; i < list.length; ++i) {\n          if (value === list[i]) {\n            return true;\n          }\n        }\n        break;\n      case \"options\":\n        for (i = 0; i < list.length; ++i) {\n          if (value === list[i].value) {\n            return true;\n          }\n        }\n        break;\n      case \"groups\":\n        for (i = 0; i < list.length; ++i) {\n          var options = list[i].options;\n          for (j = 0; j < options.length; ++j) {\n            if (value === options[j].value) {\n              return true;\n            }\n          }\n        }\n        break;\n      default:\n        break;\n      }\n      return false;\n    },\n\n    /**\n     * Gets the language code from the \"language-country\" locale code.\n     *\n     * The function will strip the language code before the first \"-\" of a\n     * locale code. For example, pass \"en-US\" will returns \"en\". But for some\n     * special locales, the function reserves the locale code. For example,\n     * the \"zh-CN\" for the simplified Chinese and the \"zh-TW\" for the\n     * traditional Chinese.\n     *\n     * @param locale\n     *    A locale code.\n     * @return\n     *    the language code of the locale.\n     */\n    getLanguageCode: function(locale) {\n      if (locale === null || locale.length === 0) {\n        return \"en\";\n      }\n      if (locale.length <= 2) {\n        return locale;\n      } else {\n        switch (locale) {\n          case \"pt-BR\":\n          case \"zh-CN\":\n          case \"zh-TW\":\n            return locale;\n          default:\n            // reserve only the first two letters language code\n            return locale.substr(0, 2);\n        }\n      }\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/vue-select.js\n ** module id = 0\n ** module chunks = 0\n **/","\nvar DIACRITICS = {\n  '\\u24B6': 'A',\n  '\\uFF21': 'A',\n  '\\u00C0': 'A',\n  '\\u00C1': 'A',\n  '\\u00C2': 'A',\n  '\\u1EA6': 'A',\n  '\\u1EA4': 'A',\n  '\\u1EAA': 'A',\n  '\\u1EA8': 'A',\n  '\\u00C3': 'A',\n  '\\u0100': 'A',\n  '\\u0102': 'A',\n  '\\u1EB0': 'A',\n  '\\u1EAE': 'A',\n  '\\u1EB4': 'A',\n  '\\u1EB2': 'A',\n  '\\u0226': 'A',\n  '\\u01E0': 'A',\n  '\\u00C4': 'A',\n  '\\u01DE': 'A',\n  '\\u1EA2': 'A',\n  '\\u00C5': 'A',\n  '\\u01FA': 'A',\n  '\\u01CD': 'A',\n  '\\u0200': 'A',\n  '\\u0202': 'A',\n  '\\u1EA0': 'A',\n  '\\u1EAC': 'A',\n  '\\u1EB6': 'A',\n  '\\u1E00': 'A',\n  '\\u0104': 'A',\n  '\\u023A': 'A',\n  '\\u2C6F': 'A',\n  '\\uA732': 'AA',\n  '\\u00C6': 'AE',\n  '\\u01FC': 'AE',\n  '\\u01E2': 'AE',\n  '\\uA734': 'AO',\n  '\\uA736': 'AU',\n  '\\uA738': 'AV',\n  '\\uA73A': 'AV',\n  '\\uA73C': 'AY',\n  '\\u24B7': 'B',\n  '\\uFF22': 'B',\n  '\\u1E02': 'B',\n  '\\u1E04': 'B',\n  '\\u1E06': 'B',\n  '\\u0243': 'B',\n  '\\u0182': 'B',\n  '\\u0181': 'B',\n  '\\u24B8': 'C',\n  '\\uFF23': 'C',\n  '\\u0106': 'C',\n  '\\u0108': 'C',\n  '\\u010A': 'C',\n  '\\u010C': 'C',\n  '\\u00C7': 'C',\n  '\\u1E08': 'C',\n  '\\u0187': 'C',\n  '\\u023B': 'C',\n  '\\uA73E': 'C',\n  '\\u24B9': 'D',\n  '\\uFF24': 'D',\n  '\\u1E0A': 'D',\n  '\\u010E': 'D',\n  '\\u1E0C': 'D',\n  '\\u1E10': 'D',\n  '\\u1E12': 'D',\n  '\\u1E0E': 'D',\n  '\\u0110': 'D',\n  '\\u018B': 'D',\n  '\\u018A': 'D',\n  '\\u0189': 'D',\n  '\\uA779': 'D',\n  '\\u01F1': 'DZ',\n  '\\u01C4': 'DZ',\n  '\\u01F2': 'Dz',\n  '\\u01C5': 'Dz',\n  '\\u24BA': 'E',\n  '\\uFF25': 'E',\n  '\\u00C8': 'E',\n  '\\u00C9': 'E',\n  '\\u00CA': 'E',\n  '\\u1EC0': 'E',\n  '\\u1EBE': 'E',\n  '\\u1EC4': 'E',\n  '\\u1EC2': 'E',\n  '\\u1EBC': 'E',\n  '\\u0112': 'E',\n  '\\u1E14': 'E',\n  '\\u1E16': 'E',\n  '\\u0114': 'E',\n  '\\u0116': 'E',\n  '\\u00CB': 'E',\n  '\\u1EBA': 'E',\n  '\\u011A': 'E',\n  '\\u0204': 'E',\n  '\\u0206': 'E',\n  '\\u1EB8': 'E',\n  '\\u1EC6': 'E',\n  '\\u0228': 'E',\n  '\\u1E1C': 'E',\n  '\\u0118': 'E',\n  '\\u1E18': 'E',\n  '\\u1E1A': 'E',\n  '\\u0190': 'E',\n  '\\u018E': 'E',\n  '\\u24BB': 'F',\n  '\\uFF26': 'F',\n  '\\u1E1E': 'F',\n  '\\u0191': 'F',\n  '\\uA77B': 'F',\n  '\\u24BC': 'G',\n  '\\uFF27': 'G',\n  '\\u01F4': 'G',\n  '\\u011C': 'G',\n  '\\u1E20': 'G',\n  '\\u011E': 'G',\n  '\\u0120': 'G',\n  '\\u01E6': 'G',\n  '\\u0122': 'G',\n  '\\u01E4': 'G',\n  '\\u0193': 'G',\n  '\\uA7A0': 'G',\n  '\\uA77D': 'G',\n  '\\uA77E': 'G',\n  '\\u24BD': 'H',\n  '\\uFF28': 'H',\n  '\\u0124': 'H',\n  '\\u1E22': 'H',\n  '\\u1E26': 'H',\n  '\\u021E': 'H',\n  '\\u1E24': 'H',\n  '\\u1E28': 'H',\n  '\\u1E2A': 'H',\n  '\\u0126': 'H',\n  '\\u2C67': 'H',\n  '\\u2C75': 'H',\n  '\\uA78D': 'H',\n  '\\u24BE': 'I',\n  '\\uFF29': 'I',\n  '\\u00CC': 'I',\n  '\\u00CD': 'I',\n  '\\u00CE': 'I',\n  '\\u0128': 'I',\n  '\\u012A': 'I',\n  '\\u012C': 'I',\n  '\\u0130': 'I',\n  '\\u00CF': 'I',\n  '\\u1E2E': 'I',\n  '\\u1EC8': 'I',\n  '\\u01CF': 'I',\n  '\\u0208': 'I',\n  '\\u020A': 'I',\n  '\\u1ECA': 'I',\n  '\\u012E': 'I',\n  '\\u1E2C': 'I',\n  '\\u0197': 'I',\n  '\\u24BF': 'J',\n  '\\uFF2A': 'J',\n  '\\u0134': 'J',\n  '\\u0248': 'J',\n  '\\u24C0': 'K',\n  '\\uFF2B': 'K',\n  '\\u1E30': 'K',\n  '\\u01E8': 'K',\n  '\\u1E32': 'K',\n  '\\u0136': 'K',\n  '\\u1E34': 'K',\n  '\\u0198': 'K',\n  '\\u2C69': 'K',\n  '\\uA740': 'K',\n  '\\uA742': 'K',\n  '\\uA744': 'K',\n  '\\uA7A2': 'K',\n  '\\u24C1': 'L',\n  '\\uFF2C': 'L',\n  '\\u013F': 'L',\n  '\\u0139': 'L',\n  '\\u013D': 'L',\n  '\\u1E36': 'L',\n  '\\u1E38': 'L',\n  '\\u013B': 'L',\n  '\\u1E3C': 'L',\n  '\\u1E3A': 'L',\n  '\\u0141': 'L',\n  '\\u023D': 'L',\n  '\\u2C62': 'L',\n  '\\u2C60': 'L',\n  '\\uA748': 'L',\n  '\\uA746': 'L',\n  '\\uA780': 'L',\n  '\\u01C7': 'LJ',\n  '\\u01C8': 'Lj',\n  '\\u24C2': 'M',\n  '\\uFF2D': 'M',\n  '\\u1E3E': 'M',\n  '\\u1E40': 'M',\n  '\\u1E42': 'M',\n  '\\u2C6E': 'M',\n  '\\u019C': 'M',\n  '\\u24C3': 'N',\n  '\\uFF2E': 'N',\n  '\\u01F8': 'N',\n  '\\u0143': 'N',\n  '\\u00D1': 'N',\n  '\\u1E44': 'N',\n  '\\u0147': 'N',\n  '\\u1E46': 'N',\n  '\\u0145': 'N',\n  '\\u1E4A': 'N',\n  '\\u1E48': 'N',\n  '\\u0220': 'N',\n  '\\u019D': 'N',\n  '\\uA790': 'N',\n  '\\uA7A4': 'N',\n  '\\u01CA': 'NJ',\n  '\\u01CB': 'Nj',\n  '\\u24C4': 'O',\n  '\\uFF2F': 'O',\n  '\\u00D2': 'O',\n  '\\u00D3': 'O',\n  '\\u00D4': 'O',\n  '\\u1ED2': 'O',\n  '\\u1ED0': 'O',\n  '\\u1ED6': 'O',\n  '\\u1ED4': 'O',\n  '\\u00D5': 'O',\n  '\\u1E4C': 'O',\n  '\\u022C': 'O',\n  '\\u1E4E': 'O',\n  '\\u014C': 'O',\n  '\\u1E50': 'O',\n  '\\u1E52': 'O',\n  '\\u014E': 'O',\n  '\\u022E': 'O',\n  '\\u0230': 'O',\n  '\\u00D6': 'O',\n  '\\u022A': 'O',\n  '\\u1ECE': 'O',\n  '\\u0150': 'O',\n  '\\u01D1': 'O',\n  '\\u020C': 'O',\n  '\\u020E': 'O',\n  '\\u01A0': 'O',\n  '\\u1EDC': 'O',\n  '\\u1EDA': 'O',\n  '\\u1EE0': 'O',\n  '\\u1EDE': 'O',\n  '\\u1EE2': 'O',\n  '\\u1ECC': 'O',\n  '\\u1ED8': 'O',\n  '\\u01EA': 'O',\n  '\\u01EC': 'O',\n  '\\u00D8': 'O',\n  '\\u01FE': 'O',\n  '\\u0186': 'O',\n  '\\u019F': 'O',\n  '\\uA74A': 'O',\n  '\\uA74C': 'O',\n  '\\u01A2': 'OI',\n  '\\uA74E': 'OO',\n  '\\u0222': 'OU',\n  '\\u24C5': 'P',\n  '\\uFF30': 'P',\n  '\\u1E54': 'P',\n  '\\u1E56': 'P',\n  '\\u01A4': 'P',\n  '\\u2C63': 'P',\n  '\\uA750': 'P',\n  '\\uA752': 'P',\n  '\\uA754': 'P',\n  '\\u24C6': 'Q',\n  '\\uFF31': 'Q',\n  '\\uA756': 'Q',\n  '\\uA758': 'Q',\n  '\\u024A': 'Q',\n  '\\u24C7': 'R',\n  '\\uFF32': 'R',\n  '\\u0154': 'R',\n  '\\u1E58': 'R',\n  '\\u0158': 'R',\n  '\\u0210': 'R',\n  '\\u0212': 'R',\n  '\\u1E5A': 'R',\n  '\\u1E5C': 'R',\n  '\\u0156': 'R',\n  '\\u1E5E': 'R',\n  '\\u024C': 'R',\n  '\\u2C64': 'R',\n  '\\uA75A': 'R',\n  '\\uA7A6': 'R',\n  '\\uA782': 'R',\n  '\\u24C8': 'S',\n  '\\uFF33': 'S',\n  '\\u1E9E': 'S',\n  '\\u015A': 'S',\n  '\\u1E64': 'S',\n  '\\u015C': 'S',\n  '\\u1E60': 'S',\n  '\\u0160': 'S',\n  '\\u1E66': 'S',\n  '\\u1E62': 'S',\n  '\\u1E68': 'S',\n  '\\u0218': 'S',\n  '\\u015E': 'S',\n  '\\u2C7E': 'S',\n  '\\uA7A8': 'S',\n  '\\uA784': 'S',\n  '\\u24C9': 'T',\n  '\\uFF34': 'T',\n  '\\u1E6A': 'T',\n  '\\u0164': 'T',\n  '\\u1E6C': 'T',\n  '\\u021A': 'T',\n  '\\u0162': 'T',\n  '\\u1E70': 'T',\n  '\\u1E6E': 'T',\n  '\\u0166': 'T',\n  '\\u01AC': 'T',\n  '\\u01AE': 'T',\n  '\\u023E': 'T',\n  '\\uA786': 'T',\n  '\\uA728': 'TZ',\n  '\\u24CA': 'U',\n  '\\uFF35': 'U',\n  '\\u00D9': 'U',\n  '\\u00DA': 'U',\n  '\\u00DB': 'U',\n  '\\u0168': 'U',\n  '\\u1E78': 'U',\n  '\\u016A': 'U',\n  '\\u1E7A': 'U',\n  '\\u016C': 'U',\n  '\\u00DC': 'U',\n  '\\u01DB': 'U',\n  '\\u01D7': 'U',\n  '\\u01D5': 'U',\n  '\\u01D9': 'U',\n  '\\u1EE6': 'U',\n  '\\u016E': 'U',\n  '\\u0170': 'U',\n  '\\u01D3': 'U',\n  '\\u0214': 'U',\n  '\\u0216': 'U',\n  '\\u01AF': 'U',\n  '\\u1EEA': 'U',\n  '\\u1EE8': 'U',\n  '\\u1EEE': 'U',\n  '\\u1EEC': 'U',\n  '\\u1EF0': 'U',\n  '\\u1EE4': 'U',\n  '\\u1E72': 'U',\n  '\\u0172': 'U',\n  '\\u1E76': 'U',\n  '\\u1E74': 'U',\n  '\\u0244': 'U',\n  '\\u24CB': 'V',\n  '\\uFF36': 'V',\n  '\\u1E7C': 'V',\n  '\\u1E7E': 'V',\n  '\\u01B2': 'V',\n  '\\uA75E': 'V',\n  '\\u0245': 'V',\n  '\\uA760': 'VY',\n  '\\u24CC': 'W',\n  '\\uFF37': 'W',\n  '\\u1E80': 'W',\n  '\\u1E82': 'W',\n  '\\u0174': 'W',\n  '\\u1E86': 'W',\n  '\\u1E84': 'W',\n  '\\u1E88': 'W',\n  '\\u2C72': 'W',\n  '\\u24CD': 'X',\n  '\\uFF38': 'X',\n  '\\u1E8A': 'X',\n  '\\u1E8C': 'X',\n  '\\u24CE': 'Y',\n  '\\uFF39': 'Y',\n  '\\u1EF2': 'Y',\n  '\\u00DD': 'Y',\n  '\\u0176': 'Y',\n  '\\u1EF8': 'Y',\n  '\\u0232': 'Y',\n  '\\u1E8E': 'Y',\n  '\\u0178': 'Y',\n  '\\u1EF6': 'Y',\n  '\\u1EF4': 'Y',\n  '\\u01B3': 'Y',\n  '\\u024E': 'Y',\n  '\\u1EFE': 'Y',\n  '\\u24CF': 'Z',\n  '\\uFF3A': 'Z',\n  '\\u0179': 'Z',\n  '\\u1E90': 'Z',\n  '\\u017B': 'Z',\n  '\\u017D': 'Z',\n  '\\u1E92': 'Z',\n  '\\u1E94': 'Z',\n  '\\u01B5': 'Z',\n  '\\u0224': 'Z',\n  '\\u2C7F': 'Z',\n  '\\u2C6B': 'Z',\n  '\\uA762': 'Z',\n  '\\u24D0': 'a',\n  '\\uFF41': 'a',\n  '\\u1E9A': 'a',\n  '\\u00E0': 'a',\n  '\\u00E1': 'a',\n  '\\u00E2': 'a',\n  '\\u1EA7': 'a',\n  '\\u1EA5': 'a',\n  '\\u1EAB': 'a',\n  '\\u1EA9': 'a',\n  '\\u00E3': 'a',\n  '\\u0101': 'a',\n  '\\u0103': 'a',\n  '\\u1EB1': 'a',\n  '\\u1EAF': 'a',\n  '\\u1EB5': 'a',\n  '\\u1EB3': 'a',\n  '\\u0227': 'a',\n  '\\u01E1': 'a',\n  '\\u00E4': 'a',\n  '\\u01DF': 'a',\n  '\\u1EA3': 'a',\n  '\\u00E5': 'a',\n  '\\u01FB': 'a',\n  '\\u01CE': 'a',\n  '\\u0201': 'a',\n  '\\u0203': 'a',\n  '\\u1EA1': 'a',\n  '\\u1EAD': 'a',\n  '\\u1EB7': 'a',\n  '\\u1E01': 'a',\n  '\\u0105': 'a',\n  '\\u2C65': 'a',\n  '\\u0250': 'a',\n  '\\uA733': 'aa',\n  '\\u00E6': 'ae',\n  '\\u01FD': 'ae',\n  '\\u01E3': 'ae',\n  '\\uA735': 'ao',\n  '\\uA737': 'au',\n  '\\uA739': 'av',\n  '\\uA73B': 'av',\n  '\\uA73D': 'ay',\n  '\\u24D1': 'b',\n  '\\uFF42': 'b',\n  '\\u1E03': 'b',\n  '\\u1E05': 'b',\n  '\\u1E07': 'b',\n  '\\u0180': 'b',\n  '\\u0183': 'b',\n  '\\u0253': 'b',\n  '\\u24D2': 'c',\n  '\\uFF43': 'c',\n  '\\u0107': 'c',\n  '\\u0109': 'c',\n  '\\u010B': 'c',\n  '\\u010D': 'c',\n  '\\u00E7': 'c',\n  '\\u1E09': 'c',\n  '\\u0188': 'c',\n  '\\u023C': 'c',\n  '\\uA73F': 'c',\n  '\\u2184': 'c',\n  '\\u24D3': 'd',\n  '\\uFF44': 'd',\n  '\\u1E0B': 'd',\n  '\\u010F': 'd',\n  '\\u1E0D': 'd',\n  '\\u1E11': 'd',\n  '\\u1E13': 'd',\n  '\\u1E0F': 'd',\n  '\\u0111': 'd',\n  '\\u018C': 'd',\n  '\\u0256': 'd',\n  '\\u0257': 'd',\n  '\\uA77A': 'd',\n  '\\u01F3': 'dz',\n  '\\u01C6': 'dz',\n  '\\u24D4': 'e',\n  '\\uFF45': 'e',\n  '\\u00E8': 'e',\n  '\\u00E9': 'e',\n  '\\u00EA': 'e',\n  '\\u1EC1': 'e',\n  '\\u1EBF': 'e',\n  '\\u1EC5': 'e',\n  '\\u1EC3': 'e',\n  '\\u1EBD': 'e',\n  '\\u0113': 'e',\n  '\\u1E15': 'e',\n  '\\u1E17': 'e',\n  '\\u0115': 'e',\n  '\\u0117': 'e',\n  '\\u00EB': 'e',\n  '\\u1EBB': 'e',\n  '\\u011B': 'e',\n  '\\u0205': 'e',\n  '\\u0207': 'e',\n  '\\u1EB9': 'e',\n  '\\u1EC7': 'e',\n  '\\u0229': 'e',\n  '\\u1E1D': 'e',\n  '\\u0119': 'e',\n  '\\u1E19': 'e',\n  '\\u1E1B': 'e',\n  '\\u0247': 'e',\n  '\\u025B': 'e',\n  '\\u01DD': 'e',\n  '\\u24D5': 'f',\n  '\\uFF46': 'f',\n  '\\u1E1F': 'f',\n  '\\u0192': 'f',\n  '\\uA77C': 'f',\n  '\\u24D6': 'g',\n  '\\uFF47': 'g',\n  '\\u01F5': 'g',\n  '\\u011D': 'g',\n  '\\u1E21': 'g',\n  '\\u011F': 'g',\n  '\\u0121': 'g',\n  '\\u01E7': 'g',\n  '\\u0123': 'g',\n  '\\u01E5': 'g',\n  '\\u0260': 'g',\n  '\\uA7A1': 'g',\n  '\\u1D79': 'g',\n  '\\uA77F': 'g',\n  '\\u24D7': 'h',\n  '\\uFF48': 'h',\n  '\\u0125': 'h',\n  '\\u1E23': 'h',\n  '\\u1E27': 'h',\n  '\\u021F': 'h',\n  '\\u1E25': 'h',\n  '\\u1E29': 'h',\n  '\\u1E2B': 'h',\n  '\\u1E96': 'h',\n  '\\u0127': 'h',\n  '\\u2C68': 'h',\n  '\\u2C76': 'h',\n  '\\u0265': 'h',\n  '\\u0195': 'hv',\n  '\\u24D8': 'i',\n  '\\uFF49': 'i',\n  '\\u00EC': 'i',\n  '\\u00ED': 'i',\n  '\\u00EE': 'i',\n  '\\u0129': 'i',\n  '\\u012B': 'i',\n  '\\u012D': 'i',\n  '\\u00EF': 'i',\n  '\\u1E2F': 'i',\n  '\\u1EC9': 'i',\n  '\\u01D0': 'i',\n  '\\u0209': 'i',\n  '\\u020B': 'i',\n  '\\u1ECB': 'i',\n  '\\u012F': 'i',\n  '\\u1E2D': 'i',\n  '\\u0268': 'i',\n  '\\u0131': 'i',\n  '\\u24D9': 'j',\n  '\\uFF4A': 'j',\n  '\\u0135': 'j',\n  '\\u01F0': 'j',\n  '\\u0249': 'j',\n  '\\u24DA': 'k',\n  '\\uFF4B': 'k',\n  '\\u1E31': 'k',\n  '\\u01E9': 'k',\n  '\\u1E33': 'k',\n  '\\u0137': 'k',\n  '\\u1E35': 'k',\n  '\\u0199': 'k',\n  '\\u2C6A': 'k',\n  '\\uA741': 'k',\n  '\\uA743': 'k',\n  '\\uA745': 'k',\n  '\\uA7A3': 'k',\n  '\\u24DB': 'l',\n  '\\uFF4C': 'l',\n  '\\u0140': 'l',\n  '\\u013A': 'l',\n  '\\u013E': 'l',\n  '\\u1E37': 'l',\n  '\\u1E39': 'l',\n  '\\u013C': 'l',\n  '\\u1E3D': 'l',\n  '\\u1E3B': 'l',\n  '\\u017F': 'l',\n  '\\u0142': 'l',\n  '\\u019A': 'l',\n  '\\u026B': 'l',\n  '\\u2C61': 'l',\n  '\\uA749': 'l',\n  '\\uA781': 'l',\n  '\\uA747': 'l',\n  '\\u01C9': 'lj',\n  '\\u24DC': 'm',\n  '\\uFF4D': 'm',\n  '\\u1E3F': 'm',\n  '\\u1E41': 'm',\n  '\\u1E43': 'm',\n  '\\u0271': 'm',\n  '\\u026F': 'm',\n  '\\u24DD': 'n',\n  '\\uFF4E': 'n',\n  '\\u01F9': 'n',\n  '\\u0144': 'n',\n  '\\u00F1': 'n',\n  '\\u1E45': 'n',\n  '\\u0148': 'n',\n  '\\u1E47': 'n',\n  '\\u0146': 'n',\n  '\\u1E4B': 'n',\n  '\\u1E49': 'n',\n  '\\u019E': 'n',\n  '\\u0272': 'n',\n  '\\u0149': 'n',\n  '\\uA791': 'n',\n  '\\uA7A5': 'n',\n  '\\u01CC': 'nj',\n  '\\u24DE': 'o',\n  '\\uFF4F': 'o',\n  '\\u00F2': 'o',\n  '\\u00F3': 'o',\n  '\\u00F4': 'o',\n  '\\u1ED3': 'o',\n  '\\u1ED1': 'o',\n  '\\u1ED7': 'o',\n  '\\u1ED5': 'o',\n  '\\u00F5': 'o',\n  '\\u1E4D': 'o',\n  '\\u022D': 'o',\n  '\\u1E4F': 'o',\n  '\\u014D': 'o',\n  '\\u1E51': 'o',\n  '\\u1E53': 'o',\n  '\\u014F': 'o',\n  '\\u022F': 'o',\n  '\\u0231': 'o',\n  '\\u00F6': 'o',\n  '\\u022B': 'o',\n  '\\u1ECF': 'o',\n  '\\u0151': 'o',\n  '\\u01D2': 'o',\n  '\\u020D': 'o',\n  '\\u020F': 'o',\n  '\\u01A1': 'o',\n  '\\u1EDD': 'o',\n  '\\u1EDB': 'o',\n  '\\u1EE1': 'o',\n  '\\u1EDF': 'o',\n  '\\u1EE3': 'o',\n  '\\u1ECD': 'o',\n  '\\u1ED9': 'o',\n  '\\u01EB': 'o',\n  '\\u01ED': 'o',\n  '\\u00F8': 'o',\n  '\\u01FF': 'o',\n  '\\u0254': 'o',\n  '\\uA74B': 'o',\n  '\\uA74D': 'o',\n  '\\u0275': 'o',\n  '\\u01A3': 'oi',\n  '\\u0223': 'ou',\n  '\\uA74F': 'oo',\n  '\\u24DF': 'p',\n  '\\uFF50': 'p',\n  '\\u1E55': 'p',\n  '\\u1E57': 'p',\n  '\\u01A5': 'p',\n  '\\u1D7D': 'p',\n  '\\uA751': 'p',\n  '\\uA753': 'p',\n  '\\uA755': 'p',\n  '\\u24E0': 'q',\n  '\\uFF51': 'q',\n  '\\u024B': 'q',\n  '\\uA757': 'q',\n  '\\uA759': 'q',\n  '\\u24E1': 'r',\n  '\\uFF52': 'r',\n  '\\u0155': 'r',\n  '\\u1E59': 'r',\n  '\\u0159': 'r',\n  '\\u0211': 'r',\n  '\\u0213': 'r',\n  '\\u1E5B': 'r',\n  '\\u1E5D': 'r',\n  '\\u0157': 'r',\n  '\\u1E5F': 'r',\n  '\\u024D': 'r',\n  '\\u027D': 'r',\n  '\\uA75B': 'r',\n  '\\uA7A7': 'r',\n  '\\uA783': 'r',\n  '\\u24E2': 's',\n  '\\uFF53': 's',\n  '\\u00DF': 's',\n  '\\u015B': 's',\n  '\\u1E65': 's',\n  '\\u015D': 's',\n  '\\u1E61': 's',\n  '\\u0161': 's',\n  '\\u1E67': 's',\n  '\\u1E63': 's',\n  '\\u1E69': 's',\n  '\\u0219': 's',\n  '\\u015F': 's',\n  '\\u023F': 's',\n  '\\uA7A9': 's',\n  '\\uA785': 's',\n  '\\u1E9B': 's',\n  '\\u24E3': 't',\n  '\\uFF54': 't',\n  '\\u1E6B': 't',\n  '\\u1E97': 't',\n  '\\u0165': 't',\n  '\\u1E6D': 't',\n  '\\u021B': 't',\n  '\\u0163': 't',\n  '\\u1E71': 't',\n  '\\u1E6F': 't',\n  '\\u0167': 't',\n  '\\u01AD': 't',\n  '\\u0288': 't',\n  '\\u2C66': 't',\n  '\\uA787': 't',\n  '\\uA729': 'tz',\n  '\\u24E4': 'u',\n  '\\uFF55': 'u',\n  '\\u00F9': 'u',\n  '\\u00FA': 'u',\n  '\\u00FB': 'u',\n  '\\u0169': 'u',\n  '\\u1E79': 'u',\n  '\\u016B': 'u',\n  '\\u1E7B': 'u',\n  '\\u016D': 'u',\n  '\\u00FC': 'u',\n  '\\u01DC': 'u',\n  '\\u01D8': 'u',\n  '\\u01D6': 'u',\n  '\\u01DA': 'u',\n  '\\u1EE7': 'u',\n  '\\u016F': 'u',\n  '\\u0171': 'u',\n  '\\u01D4': 'u',\n  '\\u0215': 'u',\n  '\\u0217': 'u',\n  '\\u01B0': 'u',\n  '\\u1EEB': 'u',\n  '\\u1EE9': 'u',\n  '\\u1EEF': 'u',\n  '\\u1EED': 'u',\n  '\\u1EF1': 'u',\n  '\\u1EE5': 'u',\n  '\\u1E73': 'u',\n  '\\u0173': 'u',\n  '\\u1E77': 'u',\n  '\\u1E75': 'u',\n  '\\u0289': 'u',\n  '\\u24E5': 'v',\n  '\\uFF56': 'v',\n  '\\u1E7D': 'v',\n  '\\u1E7F': 'v',\n  '\\u028B': 'v',\n  '\\uA75F': 'v',\n  '\\u028C': 'v',\n  '\\uA761': 'vy',\n  '\\u24E6': 'w',\n  '\\uFF57': 'w',\n  '\\u1E81': 'w',\n  '\\u1E83': 'w',\n  '\\u0175': 'w',\n  '\\u1E87': 'w',\n  '\\u1E85': 'w',\n  '\\u1E98': 'w',\n  '\\u1E89': 'w',\n  '\\u2C73': 'w',\n  '\\u24E7': 'x',\n  '\\uFF58': 'x',\n  '\\u1E8B': 'x',\n  '\\u1E8D': 'x',\n  '\\u24E8': 'y',\n  '\\uFF59': 'y',\n  '\\u1EF3': 'y',\n  '\\u00FD': 'y',\n  '\\u0177': 'y',\n  '\\u1EF9': 'y',\n  '\\u0233': 'y',\n  '\\u1E8F': 'y',\n  '\\u00FF': 'y',\n  '\\u1EF7': 'y',\n  '\\u1E99': 'y',\n  '\\u1EF5': 'y',\n  '\\u01B4': 'y',\n  '\\u024F': 'y',\n  '\\u1EFF': 'y',\n  '\\u24E9': 'z',\n  '\\uFF5A': 'z',\n  '\\u017A': 'z',\n  '\\u1E91': 'z',\n  '\\u017C': 'z',\n  '\\u017E': 'z',\n  '\\u1E93': 'z',\n  '\\u1E95': 'z',\n  '\\u01B6': 'z',\n  '\\u0225': 'z',\n  '\\u0240': 'z',\n  '\\u2C6C': 'z',\n  '\\uA763': 'z',\n  '\\u0386': '\\u0391',\n  '\\u0388': '\\u0395',\n  '\\u0389': '\\u0397',\n  '\\u038A': '\\u0399',\n  '\\u03AA': '\\u0399',\n  '\\u038C': '\\u039F',\n  '\\u038E': '\\u03A5',\n  '\\u03AB': '\\u03A5',\n  '\\u038F': '\\u03A9',\n  '\\u03AC': '\\u03B1',\n  '\\u03AD': '\\u03B5',\n  '\\u03AE': '\\u03B7',\n  '\\u03AF': '\\u03B9',\n  '\\u03CA': '\\u03B9',\n  '\\u0390': '\\u03B9',\n  '\\u03CC': '\\u03BF',\n  '\\u03CD': '\\u03C5',\n  '\\u03CB': '\\u03C5',\n  '\\u03B0': '\\u03C5',\n  '\\u03C9': '\\u03C9',\n  '\\u03C2': '\\u03C3'\n};\n\n\nfunction stripDiacritics (text) {\n  // Used 'uni range + named function' from http://jsperf.com/diacritics/18\n  function match(a) {\n    return DIACRITICS[a] || a;\n  }\n  return text.replace(/[^\\u0000-\\u007E]/g, match);\n}\n\n// The following matcher is a modification version of the default matcher\n// of select2\nmodule.exports = matcher = function(params, data) {\n  // Always return the object if there is nothing to compare\n  if ($.trim(params.term) === '') {\n    return data;\n  }\n\n  // Do a recursive check for options with children\n  if (data.children && data.children.length > 0) {\n    // Clone the data object if there are children\n    // This is required as we modify the object to remove any non-matches\n    var match = $.extend(true, {}, data);\n\n    // Check each child of the option\n    for (var c = data.children.length - 1; c >= 0; c--) {\n      var child = data.children[c];\n\n      var matches = matcher(params, child);\n\n      // If there wasn't a match, remove the object in the array\n      if (matches == null) {\n        match.children.splice(c, 1);\n      }\n    }\n\n    // If any children matched, return the new object\n    if (match.children.length > 0) {\n      return match;\n    }\n\n    // If there were no matching children, check just the plain object\n    return matcher(params, match);\n  }\n\n  var original = stripDiacritics(data.text).toUpperCase();\n  var term = stripDiacritics(params.term).toUpperCase();\n\n  // Check if the text contains the term\n  if (original.indexOf(term) > -1) {\n    return data;\n  }\n\n  // add by Haixing Hu: also match the value of an option\n  if (data.id) {\n    var originalValue = stripDiacritics(data.id).toUpperCase();\n    if (originalValue.indexOf(term) > -1) {\n      return data;\n    }\n  }\n\n  // If it doesn't contain the term, don't return anything\n  return null;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/value-text-matcher.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}
\ No newline at end of file
Index: public/node_modules/vue/src/platforms/web/runtime/modules/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/modules/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/modules/index.js	(revision )
@@ -0,0 +1,15 @@
+import attrs from './attrs'
+import klass from './class'
+import events from './events'
+import domProps from './dom-props'
+import style from './style'
+import transition from './transition'
+
+export default [
+  attrs,
+  klass,
+  events,
+  domProps,
+  style,
+  transition
+]
Index: public/node_modules/vue/src/core/instance/events.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/events.js	(revision )
+++ public/node_modules/vue/src/core/instance/events.js	(revision )
@@ -0,0 +1,117 @@
+/* @flow */
+
+import { toArray } from '../util/index'
+import { updateListeners } from '../vdom/helpers/index'
+
+export function initEvents (vm: Component) {
+  vm._events = Object.create(null)
+  vm._hasHookEvent = false
+  // init parent attached events
+  const listeners = vm.$options._parentListeners
+  if (listeners) {
+    updateComponentListeners(vm, listeners)
+  }
+}
+
+let target: Component
+
+function add (event, fn, once) {
+  if (once) {
+    target.$once(event, fn)
+  } else {
+    target.$on(event, fn)
+  }
+}
+
+function remove (event, fn) {
+  target.$off(event, fn)
+}
+
+export function updateComponentListeners (
+  vm: Component,
+  listeners: Object,
+  oldListeners: ?Object
+) {
+  target = vm
+  updateListeners(listeners, oldListeners || {}, add, remove, vm)
+}
+
+export function eventsMixin (Vue: Class<Component>) {
+  const hookRE = /^hook:/
+  Vue.prototype.$on = function (event: string | Array<string>, fn: Function): Component {
+    const vm: Component = this
+    if (Array.isArray(event)) {
+      for (let i = 0, l = event.length; i < l; i++) {
+        this.$on(event[i], fn)
+      }
+    } else {
+      (vm._events[event] || (vm._events[event] = [])).push(fn)
+      // optimize hook:event cost by using a boolean flag marked at registration
+      // instead of a hash lookup
+      if (hookRE.test(event)) {
+        vm._hasHookEvent = true
+      }
+    }
+    return vm
+  }
+
+  Vue.prototype.$once = function (event: string, fn: Function): Component {
+    const vm: Component = this
+    function on () {
+      vm.$off(event, on)
+      fn.apply(vm, arguments)
+    }
+    on.fn = fn
+    vm.$on(event, on)
+    return vm
+  }
+
+  Vue.prototype.$off = function (event?: string | Array<string>, fn?: Function): Component {
+    const vm: Component = this
+    // all
+    if (!arguments.length) {
+      vm._events = Object.create(null)
+      return vm
+    }
+    // array of events
+    if (Array.isArray(event)) {
+      for (let i = 0, l = event.length; i < l; i++) {
+        this.$off(event[i], fn)
+      }
+      return vm
+    }
+    // specific event
+    const cbs = vm._events[event]
+    if (!cbs) {
+      return vm
+    }
+    if (arguments.length === 1) {
+      vm._events[event] = null
+      return vm
+    }
+    // specific handler
+    let cb
+    let i = cbs.length
+    while (i--) {
+      cb = cbs[i]
+      if (cb === fn || cb.fn === fn) {
+        cbs.splice(i, 1)
+        break
+      }
+    }
+    return vm
+  }
+
+  Vue.prototype.$emit = function (event: string): Component {
+    const vm: Component = this
+    let cbs = vm._events[event]
+    if (cbs) {
+      cbs = cbs.length > 1 ? toArray(cbs) : cbs
+      const args = toArray(arguments, 1)
+      for (let i = 0, l = cbs.length; i < l; i++) {
+        cbs[i].apply(vm, args)
+      }
+    }
+    return vm
+  }
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/unzip-response/package.json	(revision )
@@ -0,0 +1,63 @@
+{
+  "name": "unzip-response",
+  "version": "2.0.1",
+  "description": "Unzip a HTTP response if needed",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/unzip-response"
+  },
+  "maintainers": [
+    {
+      "name": "Sindre Sorhus",
+      "email": "sindresorhus@gmail.com",
+      "url": "sindresorhus.com"
+    },
+    {
+      "name": "Vsevolod Strukchinsky",
+      "email": "floatdrop@gmail.com",
+      "url": "github.com/floatdrop"
+    }
+  ],
+  "engines": {
+    "node": ">=4"
+  },
+  "scripts": {
+    "test": "xo && ava"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "http",
+    "unzip",
+    "zlib",
+    "gzip",
+    "deflate",
+    "incoming",
+    "message",
+    "response",
+    "stream"
+  ],
+  "devDependencies": {
+    "ava": "*",
+    "get-stream": "^2.3.0",
+    "pify": "^2.3.0",
+    "rfpify": "^1.0.0",
+    "xo": "*"
+  },
+  "xo": {
+    "esnext": true
+  },
+  "readme": "# unzip-response [![Build Status](https://travis-ci.org/sindresorhus/unzip-response.svg?branch=master)](https://travis-ci.org/sindresorhus/unzip-response)\n\n> Unzip a HTTP response if needed\n\nUnzips the response from [`http.request`](https://nodejs.org/api/http.html#http_http_request_options_callback) if it's gzipped/deflated, otherwise just passes it through.\n\n\n## Install\n\n```\n$ npm install --save unzip-response\n```\n\n\n## Usage\n\n```js\nconst http = require('http');\nconst unzipResponse = require('unzip-response');\n\nhttp.get('http://sindresorhus.com', res => {\n\tres = unzipResponse(res);\n});\n```\n\n\n## License\n\nMIT  [Sindre Sorhus](https://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/unzip-response/issues"
+  },
+  "_id": "unzip-response@2.0.1",
+  "dist": {
+    "shasum": "8779491e688f42c84cd5253ae776932f911aff89"
+  },
+  "_from": "unzip-response@^2.0.1",
+  "_resolved": "https://registry.npmjs.org/unzip-response/-/unzip-response-2.0.1.tgz"
+}
Index: public/node_modules/vue/src/core/instance/render-helpers/resolve-filter.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render-helpers/resolve-filter.js	(revision )
+++ public/node_modules/vue/src/core/instance/render-helpers/resolve-filter.js	(revision )
@@ -0,0 +1,10 @@
+/* @flow */
+
+import { identity, resolveAsset } from 'core/util/index'
+
+/**
+ * Runtime helper for resolving filters
+ */
+export function resolveFilter (id: string): Function {
+  return resolveAsset(this.$options, 'filters', id, true) || identity
+}
Index: public/node_modules/vue-resource/test/data/valid.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/data/valid.json	(revision )
+++ public/node_modules/vue-resource/test/data/valid.json	(revision )
@@ -0,0 +1,1 @@
+{"foo": "bar"}
\ No newline at end of file
Index: public/node_modules/vue/src/core/instance/render-helpers/resolve-slots.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render-helpers/resolve-slots.js	(revision )
+++ public/node_modules/vue/src/core/instance/render-helpers/resolve-slots.js	(revision )
@@ -0,0 +1,51 @@
+/* @flow */
+
+/**
+ * Runtime helper for resolving raw children VNodes into a slot object.
+ */
+export function resolveSlots (
+  children: ?Array<VNode>,
+  context: ?Component
+): { [key: string]: Array<VNode> } {
+  const slots = {}
+  if (!children) {
+    return slots
+  }
+  const defaultSlot = []
+  let name, child
+  for (let i = 0, l = children.length; i < l; i++) {
+    child = children[i]
+    // named slots should only be respected if the vnode was rendered in the
+    // same context.
+    if ((child.context === context || child.functionalContext === context) &&
+        child.data && (name = child.data.slot)) {
+      const slot = (slots[name] || (slots[name] = []))
+      if (child.tag === 'template') {
+        slot.push.apply(slot, child.children)
+      } else {
+        slot.push(child)
+      }
+    } else {
+      defaultSlot.push(child)
+    }
+  }
+  // ignore whitespace
+  if (!defaultSlot.every(isWhitespace)) {
+    slots.default = defaultSlot
+  }
+  return slots
+}
+
+function isWhitespace (node: VNode): boolean {
+  return node.isComment || node.text === ' '
+}
+
+export function resolveScopedSlots (
+  fns: Array<[string, Function]>
+): { [key: string]: Function } {
+  const res = {}
+  for (let i = 0; i < fns.length; i++) {
+    res[fns[i][0]] = fns[i][1]
+  }
+  return res
+}
Index: public/node_modules/vue/src/platforms/web/runtime/components/transition.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/components/transition.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/components/transition.js	(revision )
@@ -0,0 +1,175 @@
+/* @flow */
+
+// Provides transition support for a single element/component.
+// supports transition mode (out-in / in-out)
+
+import { warn } from 'core/util/index'
+import { camelize, extend, isPrimitive } from 'shared/util'
+import { mergeVNodeHook, getFirstComponentChild } from 'core/vdom/helpers/index'
+
+export const transitionProps = {
+  name: String,
+  appear: Boolean,
+  css: Boolean,
+  mode: String,
+  type: String,
+  enterClass: String,
+  leaveClass: String,
+  enterToClass: String,
+  leaveToClass: String,
+  enterActiveClass: String,
+  leaveActiveClass: String,
+  appearClass: String,
+  appearActiveClass: String,
+  appearToClass: String,
+  duration: [Number, String, Object]
+}
+
+// in case the child is also an abstract component, e.g. <keep-alive>
+// we want to recursively retrieve the real component to be rendered
+function getRealChild (vnode: ?VNode): ?VNode {
+  const compOptions: ?VNodeComponentOptions = vnode && vnode.componentOptions
+  if (compOptions && compOptions.Ctor.options.abstract) {
+    return getRealChild(getFirstComponentChild(compOptions.children))
+  } else {
+    return vnode
+  }
+}
+
+export function extractTransitionData (comp: Component): Object {
+  const data = {}
+  const options: ComponentOptions = comp.$options
+  // props
+  for (const key in options.propsData) {
+    data[key] = comp[key]
+  }
+  // events.
+  // extract listeners and pass them directly to the transition methods
+  const listeners: ?Object = options._parentListeners
+  for (const key in listeners) {
+    data[camelize(key)] = listeners[key]
+  }
+  return data
+}
+
+function placeholder (h: Function, rawChild: VNode): ?VNode {
+  return /\d-keep-alive$/.test(rawChild.tag)
+    ? h('keep-alive')
+    : null
+}
+
+function hasParentTransition (vnode: VNode): ?boolean {
+  while ((vnode = vnode.parent)) {
+    if (vnode.data.transition) {
+      return true
+    }
+  }
+}
+
+function isSameChild (child: VNode, oldChild: VNode): boolean {
+  return oldChild.key === child.key && oldChild.tag === child.tag
+}
+
+export default {
+  name: 'transition',
+  props: transitionProps,
+  abstract: true,
+
+  render (h: Function) {
+    let children: ?Array<VNode> = this.$slots.default
+    if (!children) {
+      return
+    }
+
+    // filter out text nodes (possible whitespaces)
+    children = children.filter((c: VNode) => c.tag)
+    /* istanbul ignore if */
+    if (!children.length) {
+      return
+    }
+
+    // warn multiple elements
+    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
+      warn(
+        '<transition> can only be used on a single element. Use ' +
+        '<transition-group> for lists.',
+        this.$parent
+      )
+    }
+
+    const mode: string = this.mode
+
+    // warn invalid mode
+    if (process.env.NODE_ENV !== 'production' &&
+        mode && mode !== 'in-out' && mode !== 'out-in') {
+      warn(
+        'invalid <transition> mode: ' + mode,
+        this.$parent
+      )
+    }
+
+    const rawChild: VNode = children[0]
+
+    // if this is a component root node and the component's
+    // parent container node also has transition, skip.
+    if (hasParentTransition(this.$vnode)) {
+      return rawChild
+    }
+
+    // apply transition data to child
+    // use getRealChild() to ignore abstract components e.g. keep-alive
+    const child: ?VNode = getRealChild(rawChild)
+    /* istanbul ignore if */
+    if (!child) {
+      return rawChild
+    }
+
+    if (this._leaving) {
+      return placeholder(h, rawChild)
+    }
+
+    // ensure a key that is unique to the vnode type and to this transition
+    // component instance. This key will be used to remove pending leaving nodes
+    // during entering.
+    const id: string = `__transition-${this._uid}-`
+    child.key = child.key == null
+      ? id + child.tag
+      : isPrimitive(child.key)
+        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
+        : child.key
+
+    const data: Object = (child.data || (child.data = {})).transition = extractTransitionData(this)
+    const oldRawChild: VNode = this._vnode
+    const oldChild: VNode = getRealChild(oldRawChild)
+
+    // mark v-show
+    // so that the transition module can hand over the control to the directive
+    if (child.data.directives && child.data.directives.some(d => d.name === 'show')) {
+      child.data.show = true
+    }
+
+    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
+      // replace old child transition data with fresh one
+      // important for dynamic transitions!
+      const oldData: Object = oldChild && (oldChild.data.transition = extend({}, data))
+      // handle transition mode
+      if (mode === 'out-in') {
+        // return placeholder node and queue update when leave finishes
+        this._leaving = true
+        mergeVNodeHook(oldData, 'afterLeave', () => {
+          this._leaving = false
+          this.$forceUpdate()
+        })
+        return placeholder(h, rawChild)
+      } else if (mode === 'in-out') {
+        let delayedLeave
+        const performLeave = () => { delayedLeave() }
+        mergeVNodeHook(data, 'afterEnter', performLeave)
+        mergeVNodeHook(data, 'enterCancelled', performLeave)
+        mergeVNodeHook(oldData, 'delayLeave', leave => { delayedLeave = leave })
+      }
+    }
+
+    return rawChild
+  }
+}
Index: app/Http/Controllers/Web/FormAdminController.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/Http/Controllers/Web/FormAdminController.php	(revision 3d426e1c0d52d26cb969fee1b80a5af3508614bb)
+++ app/Http/Controllers/Web/FormAdminController.php	(revision )
@@ -132,7 +132,13 @@
     {
         $formId = $request->input('formId');
         $forms = Form::where('creator', Auth::user()->id)->get();
-        return view('web.form.invite', ['forms' => $forms, 'formId' => $formId]);
+        return view('web.form.invite_vue', ['forms' => json_encode($forms), 'formId' => $formId]);
+    }
+
+    //
+    public function getOwnForms()
+    {
+        return response()->json(Auth::user()->ownForms);
     }
 
     /**
Index: public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/timed-out/index.js	(revision )
@@ -0,0 +1,55 @@
+'use strict';
+
+module.exports = function (req, time) {
+	if (req.timeoutTimer) {
+		return req;
+	}
+
+	var delays = isNaN(time) ? time : {socket: time, connect: time};
+	var host = req._headers ? (' to ' + req._headers.host) : '';
+
+	if (delays.connect !== undefined) {
+		req.timeoutTimer = setTimeout(function timeoutHandler() {
+			req.abort();
+			var e = new Error('Connection timed out on request' + host);
+			e.code = 'ETIMEDOUT';
+			req.emit('error', e);
+		}, delays.connect);
+	}
+
+	// Clear the connection timeout timer once a socket is assigned to the
+	// request and is connected.
+	req.on('socket', function assign(socket) {
+		// Socket may come from Agent pool and may be already connected.
+		if (!(socket.connecting || socket._connecting)) {
+			connect();
+			return;
+		}
+
+		socket.once('connect', connect);
+	});
+
+	function clear() {
+		if (req.timeoutTimer) {
+			clearTimeout(req.timeoutTimer);
+			req.timeoutTimer = null;
+		}
+	}
+
+	function connect() {
+		clear();
+
+		if (delays.socket !== undefined) {
+			// Abort the request if there is no activity on the socket for more
+			// than `delays.socket` milliseconds.
+			req.setTimeout(delays.socket, function socketTimeoutHandler() {
+				req.abort();
+				var e = new Error('Socket timed out on request' + host);
+				e.code = 'ESOCKETTIMEDOUT';
+				req.emit('error', e);
+			});
+		}
+	}
+
+	return req.on('error', clear);
+};
Index: public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/node_modules/capture-stack-trace/readme.md	(revision )
@@ -0,0 +1,36 @@
+# capture-stack-trace [![Build Status](https://travis-ci.org/floatdrop/capture-stack-trace.svg?branch=master)](https://travis-ci.org/floatdrop/capture-stack-trace)
+
+> Ponyfill for Error.captureStackTrace
+
+
+## Install
+
+```
+$ npm install --save capture-stack-trace
+```
+
+
+## Usage
+
+```js
+var captureStackTrace = require('capture-stack-trace');
+
+captureStackTrace({});
+// => {stack: ...}
+```
+
+
+## API
+
+### captureStackTrace(error)
+
+#### error
+
+*Required*  
+Type: `Object`
+
+Target Object, that will recieve stack property.
+
+## License
+
+MIT  [Vsevolod Strukchinsky](http://github.com/floatdrop)
Index: public/node_modules/vue/src/core/observer/array.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/observer/array.js	(revision )
+++ public/node_modules/vue/src/core/observer/array.js	(revision )
@@ -0,0 +1,53 @@
+/*
+ * not type checking this file because flow doesn't play well with
+ * dynamically accessing methods on Array prototype
+ */
+
+import { def } from '../util/index'
+
+const arrayProto = Array.prototype
+export const arrayMethods = Object.create(arrayProto)
+
+/**
+ * Intercept mutating methods and emit events
+ */
+;[
+  'push',
+  'pop',
+  'shift',
+  'unshift',
+  'splice',
+  'sort',
+  'reverse'
+]
+.forEach(function (method) {
+  // cache original method
+  const original = arrayProto[method]
+  def(arrayMethods, method, function mutator () {
+    // avoid leaking arguments:
+    // http://jsperf.com/closure-with-arguments
+    let i = arguments.length
+    const args = new Array(i)
+    while (i--) {
+      args[i] = arguments[i]
+    }
+    const result = original.apply(this, args)
+    const ob = this.__ob__
+    let inserted
+    switch (method) {
+      case 'push':
+        inserted = args
+        break
+      case 'unshift':
+        inserted = args
+        break
+      case 'splice':
+        inserted = args.slice(2)
+        break
+    }
+    if (inserted) ob.observeArray(inserted)
+    // notify change
+    ob.dep.notify()
+    return result
+  })
+})
Index: public/node_modules/vue/types/options.d.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/types/options.d.ts	(revision )
+++ public/node_modules/vue/types/options.d.ts	(revision )
@@ -0,0 +1,107 @@
+import { Vue, CreateElement } from "./vue";
+import { VNode, VNodeData, VNodeDirective } from "./vnode";
+
+type Constructor = {
+  new (...args: any[]): any;
+}
+
+export type Component = typeof Vue | ComponentOptions<Vue> | FunctionalComponentOptions;
+export type AsyncComponent = (
+  resolve: (component: Component) => void,
+  reject: (reason?: any) => void
+) => Promise<Component> | Component | void;
+
+export interface ComponentOptions<V extends Vue> {
+  data?: Object | ((this: V) => Object);
+  props?: string[] | { [key: string]: PropOptions | Constructor | Constructor[] };
+  propsData?: Object;
+  computed?: { [key: string]: ((this: V) => any) | ComputedOptions<V> };
+  methods?: { [key: string]: (this: V, ...args: any[]) => any };
+  watch?: { [key: string]: ({ handler: WatchHandler<V, any> } & WatchOptions) | WatchHandler<V, any> | string };
+
+  el?: Element | String;
+  template?: string;
+  render?(this: V, createElement: CreateElement): VNode;
+  renderError?: (h: () => VNode, err: Error) => VNode;
+  staticRenderFns?: ((createElement: CreateElement) => VNode)[];
+
+  beforeCreate?(this: V): void;
+  created?(this: V): void;
+  beforeDestroy?(this: V): void;
+  destroyed?(this: V): void;
+  beforeMount?(this: V): void;
+  mounted?(this: V): void;
+  beforeUpdate?(this: V): void;
+  updated?(this: V): void;
+  activated?(this: V): void;
+  deactivated?(this: V): void;
+
+  directives?: { [key: string]: DirectiveOptions | DirectiveFunction };
+  components?: { [key: string]: Component | AsyncComponent };
+  transitions?: { [key: string]: Object };
+  filters?: { [key: string]: Function };
+
+  provide?: Object | (() => Object);
+  inject?: { [key: string]: string | symbol } | Array<string>;
+
+  model?: {
+    prop?: string;
+    event?: string;
+  };
+
+  parent?: Vue;
+  mixins?: (ComponentOptions<Vue> | typeof Vue)[];
+  name?: string;
+  extends?: ComponentOptions<Vue> | typeof Vue;
+  delimiters?: [string, string];
+}
+
+export interface FunctionalComponentOptions {
+  props?: string[] | { [key: string]: PropOptions | Constructor | Constructor[] };
+  functional: boolean;
+  render(this: never, createElement: CreateElement, context: RenderContext): VNode;
+  name?: string;
+}
+
+export interface RenderContext {
+  props: any;
+  children: VNode[];
+  slots(): any;
+  data: VNodeData;
+  parent: Vue;
+}
+
+export interface PropOptions {
+  type?: Constructor | Constructor[] | null;
+  required?: boolean;
+  default?: any;
+  validator?(value: any): boolean;
+}
+
+export interface ComputedOptions<V> {
+  get?(this: V): any;
+  set?(this: V, value: any): void;
+  cache?: boolean;
+}
+
+export type WatchHandler<V, T> = (this: V, val: T, oldVal: T) => void;
+
+export interface WatchOptions {
+  deep?: boolean;
+  immediate?: boolean;
+}
+
+export type DirectiveFunction = (
+  el: HTMLElement,
+  binding: VNodeDirective,
+  vnode: VNode,
+  oldVnode: VNode
+) => void;
+
+export interface DirectiveOptions {
+  bind?: DirectiveFunction;
+  inserted?: DirectiveFunction;
+  update?: DirectiveFunction;
+  componentUpdated?: DirectiveFunction;
+  unbind?: DirectiveFunction;
+}
Index: public/node_modules/vue/dist/vue.runtime.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.runtime.js	(revision )
+++ public/node_modules/vue/dist/vue.runtime.js	(revision )
@@ -0,0 +1,6721 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+(function (global, factory) {
+	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
+	typeof define === 'function' && define.amd ? define(factory) :
+	(global.Vue = factory());
+}(this, (function () { 'use strict';
+
+/*  */
+
+/**
+ * Convert a value to a string that is actually rendered.
+ */
+function _toString (val) {
+  return val == null
+    ? ''
+    : typeof val === 'object'
+      ? JSON.stringify(val, null, 2)
+      : String(val)
+}
+
+/**
+ * Convert a input value to a number for persistence.
+ * If the conversion fails, return original string.
+ */
+function toNumber (val) {
+  var n = parseFloat(val);
+  return isNaN(n) ? val : n
+}
+
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ */
+function makeMap (
+  str,
+  expectsLowerCase
+) {
+  var map = Object.create(null);
+  var list = str.split(',');
+  for (var i = 0; i < list.length; i++) {
+    map[list[i]] = true;
+  }
+  return expectsLowerCase
+    ? function (val) { return map[val.toLowerCase()]; }
+    : function (val) { return map[val]; }
+}
+
+/**
+ * Check if a tag is a built-in tag.
+ */
+var isBuiltInTag = makeMap('slot,component', true);
+
+/**
+ * Remove an item from an array
+ */
+function remove (arr, item) {
+  if (arr.length) {
+    var index = arr.indexOf(item);
+    if (index > -1) {
+      return arr.splice(index, 1)
+    }
+  }
+}
+
+/**
+ * Check whether the object has the property.
+ */
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+function hasOwn (obj, key) {
+  return hasOwnProperty.call(obj, key)
+}
+
+/**
+ * Check if value is primitive
+ */
+function isPrimitive (value) {
+  return typeof value === 'string' || typeof value === 'number'
+}
+
+/**
+ * Create a cached version of a pure function.
+ */
+function cached (fn) {
+  var cache = Object.create(null);
+  return (function cachedFn (str) {
+    var hit = cache[str];
+    return hit || (cache[str] = fn(str))
+  })
+}
+
+/**
+ * Camelize a hyphen-delimited string.
+ */
+var camelizeRE = /-(\w)/g;
+var camelize = cached(function (str) {
+  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
+});
+
+/**
+ * Capitalize a string.
+ */
+var capitalize = cached(function (str) {
+  return str.charAt(0).toUpperCase() + str.slice(1)
+});
+
+/**
+ * Hyphenate a camelCase string.
+ */
+var hyphenateRE = /([^-])([A-Z])/g;
+var hyphenate = cached(function (str) {
+  return str
+    .replace(hyphenateRE, '$1-$2')
+    .replace(hyphenateRE, '$1-$2')
+    .toLowerCase()
+});
+
+/**
+ * Simple bind, faster than native
+ */
+function bind (fn, ctx) {
+  function boundFn (a) {
+    var l = arguments.length;
+    return l
+      ? l > 1
+        ? fn.apply(ctx, arguments)
+        : fn.call(ctx, a)
+      : fn.call(ctx)
+  }
+  // record original fn length
+  boundFn._length = fn.length;
+  return boundFn
+}
+
+/**
+ * Convert an Array-like object to a real Array.
+ */
+function toArray (list, start) {
+  start = start || 0;
+  var i = list.length - start;
+  var ret = new Array(i);
+  while (i--) {
+    ret[i] = list[i + start];
+  }
+  return ret
+}
+
+/**
+ * Mix properties into target object.
+ */
+function extend (to, _from) {
+  for (var key in _from) {
+    to[key] = _from[key];
+  }
+  return to
+}
+
+/**
+ * Quick object check - this is primarily used to tell
+ * Objects from primitive values when we know the value
+ * is a JSON-compliant type.
+ */
+function isObject (obj) {
+  return obj !== null && typeof obj === 'object'
+}
+
+/**
+ * Strict object type check. Only returns true
+ * for plain JavaScript objects.
+ */
+var toString = Object.prototype.toString;
+var OBJECT_STRING = '[object Object]';
+function isPlainObject (obj) {
+  return toString.call(obj) === OBJECT_STRING
+}
+
+/**
+ * Merge an Array of Objects into a single Object.
+ */
+function toObject (arr) {
+  var res = {};
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i]);
+    }
+  }
+  return res
+}
+
+/**
+ * Perform no operation.
+ */
+function noop () {}
+
+/**
+ * Always return false.
+ */
+var no = function () { return false; };
+
+/**
+ * Return same value
+ */
+var identity = function (_) { return _; };
+
+/**
+ * Generate a static keys string from compiler modules.
+ */
+
+
+/**
+ * Check if two values are loosely equal - that is,
+ * if they are plain objects, do they have the same shape?
+ */
+function looseEqual (a, b) {
+  var isObjectA = isObject(a);
+  var isObjectB = isObject(b);
+  if (isObjectA && isObjectB) {
+    try {
+      return JSON.stringify(a) === JSON.stringify(b)
+    } catch (e) {
+      // possible circular reference
+      return a === b
+    }
+  } else if (!isObjectA && !isObjectB) {
+    return String(a) === String(b)
+  } else {
+    return false
+  }
+}
+
+function looseIndexOf (arr, val) {
+  for (var i = 0; i < arr.length; i++) {
+    if (looseEqual(arr[i], val)) { return i }
+  }
+  return -1
+}
+
+/**
+ * Ensure a function is called only once.
+ */
+function once (fn) {
+  var called = false;
+  return function () {
+    if (!called) {
+      called = true;
+      fn();
+    }
+  }
+}
+
+/*  */
+
+var config = {
+  /**
+   * Option merge strategies (used in core/util/options)
+   */
+  optionMergeStrategies: Object.create(null),
+
+  /**
+   * Whether to suppress warnings.
+   */
+  silent: false,
+
+  /**
+   * Show production mode tip message on boot?
+   */
+  productionTip: "development" !== 'production',
+
+  /**
+   * Whether to enable devtools
+   */
+  devtools: "development" !== 'production',
+
+  /**
+   * Whether to record perf
+   */
+  performance: "development" !== 'production',
+
+  /**
+   * Error handler for watcher errors
+   */
+  errorHandler: null,
+
+  /**
+   * Ignore certain custom elements
+   */
+  ignoredElements: [],
+
+  /**
+   * Custom user key aliases for v-on
+   */
+  keyCodes: Object.create(null),
+
+  /**
+   * Check if a tag is reserved so that it cannot be registered as a
+   * component. This is platform-dependent and may be overwritten.
+   */
+  isReservedTag: no,
+
+  /**
+   * Check if a tag is an unknown element.
+   * Platform-dependent.
+   */
+  isUnknownElement: no,
+
+  /**
+   * Get the namespace of an element
+   */
+  getTagNamespace: noop,
+
+  /**
+   * Parse the real tag name for the specific platform.
+   */
+  parsePlatformTagName: identity,
+
+  /**
+   * Check if an attribute must be bound using property, e.g. value
+   * Platform-dependent.
+   */
+  mustUseProp: no,
+
+  /**
+   * List of asset types that a component can own.
+   */
+  _assetTypes: [
+    'component',
+    'directive',
+    'filter'
+  ],
+
+  /**
+   * List of lifecycle hooks.
+   */
+  _lifecycleHooks: [
+    'beforeCreate',
+    'created',
+    'beforeMount',
+    'mounted',
+    'beforeUpdate',
+    'updated',
+    'beforeDestroy',
+    'destroyed',
+    'activated',
+    'deactivated'
+  ],
+
+  /**
+   * Max circular updates allowed in a scheduler flush cycle.
+   */
+  _maxUpdateCount: 100
+};
+
+/*  */
+/* globals MutationObserver */
+
+// can we use __proto__?
+var hasProto = '__proto__' in {};
+
+// Browser environment sniffing
+var inBrowser = typeof window !== 'undefined';
+var UA = inBrowser && window.navigator.userAgent.toLowerCase();
+var isIE = UA && /msie|trident/.test(UA);
+var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
+var isEdge = UA && UA.indexOf('edge/') > 0;
+var isAndroid = UA && UA.indexOf('android') > 0;
+var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
+var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
+
+// this needs to be lazy-evaled because vue may be required before
+// vue-server-renderer can set VUE_ENV
+var _isServer;
+var isServerRendering = function () {
+  if (_isServer === undefined) {
+    /* istanbul ignore if */
+    if (!inBrowser && typeof global !== 'undefined') {
+      // detect presence of vue-server-renderer and avoid
+      // Webpack shimming the process
+      _isServer = global['process'].env.VUE_ENV === 'server';
+    } else {
+      _isServer = false;
+    }
+  }
+  return _isServer
+};
+
+// detect devtools
+var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
+
+/* istanbul ignore next */
+function isNative (Ctor) {
+  return /native code/.test(Ctor.toString())
+}
+
+var hasSymbol =
+  typeof Symbol !== 'undefined' && isNative(Symbol) &&
+  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
+
+/**
+ * Defer a task to execute it asynchronously.
+ */
+var nextTick = (function () {
+  var callbacks = [];
+  var pending = false;
+  var timerFunc;
+
+  function nextTickHandler () {
+    pending = false;
+    var copies = callbacks.slice(0);
+    callbacks.length = 0;
+    for (var i = 0; i < copies.length; i++) {
+      copies[i]();
+    }
+  }
+
+  // the nextTick behavior leverages the microtask queue, which can be accessed
+  // via either native Promise.then or MutationObserver.
+  // MutationObserver has wider support, however it is seriously bugged in
+  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
+  // completely stops working after triggering a few times... so, if native
+  // Promise is available, we will use it:
+  /* istanbul ignore if */
+  if (typeof Promise !== 'undefined' && isNative(Promise)) {
+    var p = Promise.resolve();
+    var logError = function (err) { console.error(err); };
+    timerFunc = function () {
+      p.then(nextTickHandler).catch(logError);
+      // in problematic UIWebViews, Promise.then doesn't completely break, but
+      // it can get stuck in a weird state where callbacks are pushed into the
+      // microtask queue but the queue isn't being flushed, until the browser
+      // needs to do some other work, e.g. handle a timer. Therefore we can
+      // "force" the microtask queue to be flushed by adding an empty timer.
+      if (isIOS) { setTimeout(noop); }
+    };
+  } else if (typeof MutationObserver !== 'undefined' && (
+    isNative(MutationObserver) ||
+    // PhantomJS and iOS 7.x
+    MutationObserver.toString() === '[object MutationObserverConstructor]'
+  )) {
+    // use MutationObserver where native Promise is not available,
+    // e.g. PhantomJS IE11, iOS7, Android 4.4
+    var counter = 1;
+    var observer = new MutationObserver(nextTickHandler);
+    var textNode = document.createTextNode(String(counter));
+    observer.observe(textNode, {
+      characterData: true
+    });
+    timerFunc = function () {
+      counter = (counter + 1) % 2;
+      textNode.data = String(counter);
+    };
+  } else {
+    // fallback to setTimeout
+    /* istanbul ignore next */
+    timerFunc = function () {
+      setTimeout(nextTickHandler, 0);
+    };
+  }
+
+  return function queueNextTick (cb, ctx) {
+    var _resolve;
+    callbacks.push(function () {
+      if (cb) { cb.call(ctx); }
+      if (_resolve) { _resolve(ctx); }
+    });
+    if (!pending) {
+      pending = true;
+      timerFunc();
+    }
+    if (!cb && typeof Promise !== 'undefined') {
+      return new Promise(function (resolve) {
+        _resolve = resolve;
+      })
+    }
+  }
+})();
+
+var _Set;
+/* istanbul ignore if */
+if (typeof Set !== 'undefined' && isNative(Set)) {
+  // use native Set when available.
+  _Set = Set;
+} else {
+  // a non-standard Set polyfill that only works with primitive keys.
+  _Set = (function () {
+    function Set () {
+      this.set = Object.create(null);
+    }
+    Set.prototype.has = function has (key) {
+      return this.set[key] === true
+    };
+    Set.prototype.add = function add (key) {
+      this.set[key] = true;
+    };
+    Set.prototype.clear = function clear () {
+      this.set = Object.create(null);
+    };
+
+    return Set;
+  }());
+}
+
+var perf;
+
+{
+  perf = inBrowser && window.performance;
+  if (perf && (!perf.mark || !perf.measure)) {
+    perf = undefined;
+  }
+}
+
+/*  */
+
+var emptyObject = Object.freeze({});
+
+/**
+ * Check if a string starts with $ or _
+ */
+function isReserved (str) {
+  var c = (str + '').charCodeAt(0);
+  return c === 0x24 || c === 0x5F
+}
+
+/**
+ * Define a property.
+ */
+function def (obj, key, val, enumerable) {
+  Object.defineProperty(obj, key, {
+    value: val,
+    enumerable: !!enumerable,
+    writable: true,
+    configurable: true
+  });
+}
+
+/**
+ * Parse simple path.
+ */
+var bailRE = /[^\w.$]/;
+function parsePath (path) {
+  if (bailRE.test(path)) {
+    return
+  }
+  var segments = path.split('.');
+  return function (obj) {
+    for (var i = 0; i < segments.length; i++) {
+      if (!obj) { return }
+      obj = obj[segments[i]];
+    }
+    return obj
+  }
+}
+
+var warn = noop;
+var tip = noop;
+var formatComponentName;
+
+{
+  var hasConsole = typeof console !== 'undefined';
+  var classifyRE = /(?:^|[-_])(\w)/g;
+  var classify = function (str) { return str
+    .replace(classifyRE, function (c) { return c.toUpperCase(); })
+    .replace(/[-_]/g, ''); };
+
+  warn = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.error("[Vue warn]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  tip = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.warn("[Vue tip]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  formatComponentName = function (vm, includeFile) {
+    if (vm.$root === vm) {
+      return '<Root>'
+    }
+    var name = vm._isVue
+      ? vm.$options.name || vm.$options._componentTag
+      : vm.name;
+
+    var file = vm._isVue && vm.$options.__file;
+    if (!name && file) {
+      var match = file.match(/([^/\\]+)\.vue$/);
+      name = match && match[1];
+    }
+
+    return (
+      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
+      (file && includeFile !== false ? (" at " + file) : '')
+    )
+  };
+
+  var formatLocation = function (str) {
+    if (str === "<Anonymous>") {
+      str += " - use the \"name\" option for better debugging messages.";
+    }
+    return ("\n(found in " + str + ")")
+  };
+}
+
+/*  */
+
+
+var uid$1 = 0;
+
+/**
+ * A dep is an observable that can have multiple
+ * directives subscribing to it.
+ */
+var Dep = function Dep () {
+  this.id = uid$1++;
+  this.subs = [];
+};
+
+Dep.prototype.addSub = function addSub (sub) {
+  this.subs.push(sub);
+};
+
+Dep.prototype.removeSub = function removeSub (sub) {
+  remove(this.subs, sub);
+};
+
+Dep.prototype.depend = function depend () {
+  if (Dep.target) {
+    Dep.target.addDep(this);
+  }
+};
+
+Dep.prototype.notify = function notify () {
+  // stabilize the subscriber list first
+  var subs = this.subs.slice();
+  for (var i = 0, l = subs.length; i < l; i++) {
+    subs[i].update();
+  }
+};
+
+// the current target watcher being evaluated.
+// this is globally unique because there could be only one
+// watcher being evaluated at any time.
+Dep.target = null;
+var targetStack = [];
+
+function pushTarget (_target) {
+  if (Dep.target) { targetStack.push(Dep.target); }
+  Dep.target = _target;
+}
+
+function popTarget () {
+  Dep.target = targetStack.pop();
+}
+
+/*
+ * not type checking this file because flow doesn't play well with
+ * dynamically accessing methods on Array prototype
+ */
+
+var arrayProto = Array.prototype;
+var arrayMethods = Object.create(arrayProto);[
+  'push',
+  'pop',
+  'shift',
+  'unshift',
+  'splice',
+  'sort',
+  'reverse'
+]
+.forEach(function (method) {
+  // cache original method
+  var original = arrayProto[method];
+  def(arrayMethods, method, function mutator () {
+    var arguments$1 = arguments;
+
+    // avoid leaking arguments:
+    // http://jsperf.com/closure-with-arguments
+    var i = arguments.length;
+    var args = new Array(i);
+    while (i--) {
+      args[i] = arguments$1[i];
+    }
+    var result = original.apply(this, args);
+    var ob = this.__ob__;
+    var inserted;
+    switch (method) {
+      case 'push':
+        inserted = args;
+        break
+      case 'unshift':
+        inserted = args;
+        break
+      case 'splice':
+        inserted = args.slice(2);
+        break
+    }
+    if (inserted) { ob.observeArray(inserted); }
+    // notify change
+    ob.dep.notify();
+    return result
+  });
+});
+
+/*  */
+
+var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
+
+/**
+ * By default, when a reactive property is set, the new value is
+ * also converted to become reactive. However when passing down props,
+ * we don't want to force conversion because the value may be a nested value
+ * under a frozen data structure. Converting it would defeat the optimization.
+ */
+var observerState = {
+  shouldConvert: true,
+  isSettingProps: false
+};
+
+/**
+ * Observer class that are attached to each observed
+ * object. Once attached, the observer converts target
+ * object's property keys into getter/setters that
+ * collect dependencies and dispatches updates.
+ */
+var Observer = function Observer (value) {
+  this.value = value;
+  this.dep = new Dep();
+  this.vmCount = 0;
+  def(value, '__ob__', this);
+  if (Array.isArray(value)) {
+    var augment = hasProto
+      ? protoAugment
+      : copyAugment;
+    augment(value, arrayMethods, arrayKeys);
+    this.observeArray(value);
+  } else {
+    this.walk(value);
+  }
+};
+
+/**
+ * Walk through each property and convert them into
+ * getter/setters. This method should only be called when
+ * value type is Object.
+ */
+Observer.prototype.walk = function walk (obj) {
+  var keys = Object.keys(obj);
+  for (var i = 0; i < keys.length; i++) {
+    defineReactive$$1(obj, keys[i], obj[keys[i]]);
+  }
+};
+
+/**
+ * Observe a list of Array items.
+ */
+Observer.prototype.observeArray = function observeArray (items) {
+  for (var i = 0, l = items.length; i < l; i++) {
+    observe(items[i]);
+  }
+};
+
+// helpers
+
+/**
+ * Augment an target Object or Array by intercepting
+ * the prototype chain using __proto__
+ */
+function protoAugment (target, src) {
+  /* eslint-disable no-proto */
+  target.__proto__ = src;
+  /* eslint-enable no-proto */
+}
+
+/**
+ * Augment an target Object or Array by defining
+ * hidden properties.
+ */
+/* istanbul ignore next */
+function copyAugment (target, src, keys) {
+  for (var i = 0, l = keys.length; i < l; i++) {
+    var key = keys[i];
+    def(target, key, src[key]);
+  }
+}
+
+/**
+ * Attempt to create an observer instance for a value,
+ * returns the new observer if successfully observed,
+ * or the existing observer if the value already has one.
+ */
+function observe (value, asRootData) {
+  if (!isObject(value)) {
+    return
+  }
+  var ob;
+  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+    ob = value.__ob__;
+  } else if (
+    observerState.shouldConvert &&
+    !isServerRendering() &&
+    (Array.isArray(value) || isPlainObject(value)) &&
+    Object.isExtensible(value) &&
+    !value._isVue
+  ) {
+    ob = new Observer(value);
+  }
+  if (asRootData && ob) {
+    ob.vmCount++;
+  }
+  return ob
+}
+
+/**
+ * Define a reactive property on an Object.
+ */
+function defineReactive$$1 (
+  obj,
+  key,
+  val,
+  customSetter
+) {
+  var dep = new Dep();
+
+  var property = Object.getOwnPropertyDescriptor(obj, key);
+  if (property && property.configurable === false) {
+    return
+  }
+
+  // cater for pre-defined getter/setters
+  var getter = property && property.get;
+  var setter = property && property.set;
+
+  var childOb = observe(val);
+  Object.defineProperty(obj, key, {
+    enumerable: true,
+    configurable: true,
+    get: function reactiveGetter () {
+      var value = getter ? getter.call(obj) : val;
+      if (Dep.target) {
+        dep.depend();
+        if (childOb) {
+          childOb.dep.depend();
+        }
+        if (Array.isArray(value)) {
+          dependArray(value);
+        }
+      }
+      return value
+    },
+    set: function reactiveSetter (newVal) {
+      var value = getter ? getter.call(obj) : val;
+      /* eslint-disable no-self-compare */
+      if (newVal === value || (newVal !== newVal && value !== value)) {
+        return
+      }
+      /* eslint-enable no-self-compare */
+      if ("development" !== 'production' && customSetter) {
+        customSetter();
+      }
+      if (setter) {
+        setter.call(obj, newVal);
+      } else {
+        val = newVal;
+      }
+      childOb = observe(newVal);
+      dep.notify();
+    }
+  });
+}
+
+/**
+ * Set a property on an object. Adds the new property and
+ * triggers change notification if the property doesn't
+ * already exist.
+ */
+function set (target, key, val) {
+  if (Array.isArray(target)) {
+    target.length = Math.max(target.length, key);
+    target.splice(key, 1, val);
+    return val
+  }
+  if (hasOwn(target, key)) {
+    target[key] = val;
+    return val
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    "development" !== 'production' && warn(
+      'Avoid adding reactive properties to a Vue instance or its root $data ' +
+      'at runtime - declare it upfront in the data option.'
+    );
+    return val
+  }
+  if (!ob) {
+    target[key] = val;
+    return val
+  }
+  defineReactive$$1(ob.value, key, val);
+  ob.dep.notify();
+  return val
+}
+
+/**
+ * Delete a property and trigger change if necessary.
+ */
+function del (target, key) {
+  if (Array.isArray(target)) {
+    target.splice(key, 1);
+    return
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    "development" !== 'production' && warn(
+      'Avoid deleting properties on a Vue instance or its root $data ' +
+      '- just set it to null.'
+    );
+    return
+  }
+  if (!hasOwn(target, key)) {
+    return
+  }
+  delete target[key];
+  if (!ob) {
+    return
+  }
+  ob.dep.notify();
+}
+
+/**
+ * Collect dependencies on array elements when the array is touched, since
+ * we cannot intercept array element access like property getters.
+ */
+function dependArray (value) {
+  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
+    e = value[i];
+    e && e.__ob__ && e.__ob__.dep.depend();
+    if (Array.isArray(e)) {
+      dependArray(e);
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Option overwriting strategies are functions that handle
+ * how to merge a parent option value and a child option
+ * value into the final value.
+ */
+var strats = config.optionMergeStrategies;
+
+/**
+ * Options with restrictions
+ */
+{
+  strats.el = strats.propsData = function (parent, child, vm, key) {
+    if (!vm) {
+      warn(
+        "option \"" + key + "\" can only be used during instance " +
+        'creation with the `new` keyword.'
+      );
+    }
+    return defaultStrat(parent, child)
+  };
+}
+
+/**
+ * Helper that recursively merges two data objects together.
+ */
+function mergeData (to, from) {
+  if (!from) { return to }
+  var key, toVal, fromVal;
+  var keys = Object.keys(from);
+  for (var i = 0; i < keys.length; i++) {
+    key = keys[i];
+    toVal = to[key];
+    fromVal = from[key];
+    if (!hasOwn(to, key)) {
+      set(to, key, fromVal);
+    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
+      mergeData(toVal, fromVal);
+    }
+  }
+  return to
+}
+
+/**
+ * Data
+ */
+strats.data = function (
+  parentVal,
+  childVal,
+  vm
+) {
+  if (!vm) {
+    // in a Vue.extend merge, both should be functions
+    if (!childVal) {
+      return parentVal
+    }
+    if (typeof childVal !== 'function') {
+      "development" !== 'production' && warn(
+        'The "data" option should be a function ' +
+        'that returns a per-instance value in component ' +
+        'definitions.',
+        vm
+      );
+      return parentVal
+    }
+    if (!parentVal) {
+      return childVal
+    }
+    // when parentVal & childVal are both present,
+    // we need to return a function that returns the
+    // merged result of both functions... no need to
+    // check if parentVal is a function here because
+    // it has to be a function to pass previous merges.
+    return function mergedDataFn () {
+      return mergeData(
+        childVal.call(this),
+        parentVal.call(this)
+      )
+    }
+  } else if (parentVal || childVal) {
+    return function mergedInstanceDataFn () {
+      // instance merge
+      var instanceData = typeof childVal === 'function'
+        ? childVal.call(vm)
+        : childVal;
+      var defaultData = typeof parentVal === 'function'
+        ? parentVal.call(vm)
+        : undefined;
+      if (instanceData) {
+        return mergeData(instanceData, defaultData)
+      } else {
+        return defaultData
+      }
+    }
+  }
+};
+
+/**
+ * Hooks and props are merged as arrays.
+ */
+function mergeHook (
+  parentVal,
+  childVal
+) {
+  return childVal
+    ? parentVal
+      ? parentVal.concat(childVal)
+      : Array.isArray(childVal)
+        ? childVal
+        : [childVal]
+    : parentVal
+}
+
+config._lifecycleHooks.forEach(function (hook) {
+  strats[hook] = mergeHook;
+});
+
+/**
+ * Assets
+ *
+ * When a vm is present (instance creation), we need to do
+ * a three-way merge between constructor options, instance
+ * options and parent options.
+ */
+function mergeAssets (parentVal, childVal) {
+  var res = Object.create(parentVal || null);
+  return childVal
+    ? extend(res, childVal)
+    : res
+}
+
+config._assetTypes.forEach(function (type) {
+  strats[type + 's'] = mergeAssets;
+});
+
+/**
+ * Watchers.
+ *
+ * Watchers hashes should not overwrite one
+ * another, so we merge them as arrays.
+ */
+strats.watch = function (parentVal, childVal) {
+  /* istanbul ignore if */
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = {};
+  extend(ret, parentVal);
+  for (var key in childVal) {
+    var parent = ret[key];
+    var child = childVal[key];
+    if (parent && !Array.isArray(parent)) {
+      parent = [parent];
+    }
+    ret[key] = parent
+      ? parent.concat(child)
+      : [child];
+  }
+  return ret
+};
+
+/**
+ * Other object hashes.
+ */
+strats.props =
+strats.methods =
+strats.computed = function (parentVal, childVal) {
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = Object.create(null);
+  extend(ret, parentVal);
+  extend(ret, childVal);
+  return ret
+};
+
+/**
+ * Default strategy.
+ */
+var defaultStrat = function (parentVal, childVal) {
+  return childVal === undefined
+    ? parentVal
+    : childVal
+};
+
+/**
+ * Validate component names
+ */
+function checkComponents (options) {
+  for (var key in options.components) {
+    var lower = key.toLowerCase();
+    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
+      warn(
+        'Do not use built-in or reserved HTML elements as component ' +
+        'id: ' + key
+      );
+    }
+  }
+}
+
+/**
+ * Ensure all props option syntax are normalized into the
+ * Object-based format.
+ */
+function normalizeProps (options) {
+  var props = options.props;
+  if (!props) { return }
+  var res = {};
+  var i, val, name;
+  if (Array.isArray(props)) {
+    i = props.length;
+    while (i--) {
+      val = props[i];
+      if (typeof val === 'string') {
+        name = camelize(val);
+        res[name] = { type: null };
+      } else {
+        warn('props must be strings when using array syntax.');
+      }
+    }
+  } else if (isPlainObject(props)) {
+    for (var key in props) {
+      val = props[key];
+      name = camelize(key);
+      res[name] = isPlainObject(val)
+        ? val
+        : { type: val };
+    }
+  }
+  options.props = res;
+}
+
+/**
+ * Normalize raw function directives into object format.
+ */
+function normalizeDirectives (options) {
+  var dirs = options.directives;
+  if (dirs) {
+    for (var key in dirs) {
+      var def = dirs[key];
+      if (typeof def === 'function') {
+        dirs[key] = { bind: def, update: def };
+      }
+    }
+  }
+}
+
+/**
+ * Merge two option objects into a new one.
+ * Core utility used in both instantiation and inheritance.
+ */
+function mergeOptions (
+  parent,
+  child,
+  vm
+) {
+  {
+    checkComponents(child);
+  }
+  normalizeProps(child);
+  normalizeDirectives(child);
+  var extendsFrom = child.extends;
+  if (extendsFrom) {
+    parent = typeof extendsFrom === 'function'
+      ? mergeOptions(parent, extendsFrom.options, vm)
+      : mergeOptions(parent, extendsFrom, vm);
+  }
+  if (child.mixins) {
+    for (var i = 0, l = child.mixins.length; i < l; i++) {
+      var mixin = child.mixins[i];
+      if (mixin.prototype instanceof Vue$2) {
+        mixin = mixin.options;
+      }
+      parent = mergeOptions(parent, mixin, vm);
+    }
+  }
+  var options = {};
+  var key;
+  for (key in parent) {
+    mergeField(key);
+  }
+  for (key in child) {
+    if (!hasOwn(parent, key)) {
+      mergeField(key);
+    }
+  }
+  function mergeField (key) {
+    var strat = strats[key] || defaultStrat;
+    options[key] = strat(parent[key], child[key], vm, key);
+  }
+  return options
+}
+
+/**
+ * Resolve an asset.
+ * This function is used because child instances need access
+ * to assets defined in its ancestor chain.
+ */
+function resolveAsset (
+  options,
+  type,
+  id,
+  warnMissing
+) {
+  /* istanbul ignore if */
+  if (typeof id !== 'string') {
+    return
+  }
+  var assets = options[type];
+  // check local registration variations first
+  if (hasOwn(assets, id)) { return assets[id] }
+  var camelizedId = camelize(id);
+  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
+  var PascalCaseId = capitalize(camelizedId);
+  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
+  // fallback to prototype chain
+  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
+  if ("development" !== 'production' && warnMissing && !res) {
+    warn(
+      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
+      options
+    );
+  }
+  return res
+}
+
+/*  */
+
+function validateProp (
+  key,
+  propOptions,
+  propsData,
+  vm
+) {
+  var prop = propOptions[key];
+  var absent = !hasOwn(propsData, key);
+  var value = propsData[key];
+  // handle boolean props
+  if (isType(Boolean, prop.type)) {
+    if (absent && !hasOwn(prop, 'default')) {
+      value = false;
+    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
+      value = true;
+    }
+  }
+  // check default value
+  if (value === undefined) {
+    value = getPropDefaultValue(vm, prop, key);
+    // since the default value is a fresh copy,
+    // make sure to observe it.
+    var prevShouldConvert = observerState.shouldConvert;
+    observerState.shouldConvert = true;
+    observe(value);
+    observerState.shouldConvert = prevShouldConvert;
+  }
+  {
+    assertProp(prop, key, value, vm, absent);
+  }
+  return value
+}
+
+/**
+ * Get the default value of a prop.
+ */
+function getPropDefaultValue (vm, prop, key) {
+  // no default, return undefined
+  if (!hasOwn(prop, 'default')) {
+    return undefined
+  }
+  var def = prop.default;
+  // warn against non-factory defaults for Object & Array
+  if ("development" !== 'production' && isObject(def)) {
+    warn(
+      'Invalid default value for prop "' + key + '": ' +
+      'Props with type Object/Array must use a factory function ' +
+      'to return the default value.',
+      vm
+    );
+  }
+  // the raw prop value was also undefined from previous render,
+  // return previous default value to avoid unnecessary watcher trigger
+  if (vm && vm.$options.propsData &&
+    vm.$options.propsData[key] === undefined &&
+    vm._props[key] !== undefined) {
+    return vm._props[key]
+  }
+  // call factory function for non-Function types
+  // a value is Function if its prototype is function even across different execution context
+  return typeof def === 'function' && getType(prop.type) !== 'Function'
+    ? def.call(vm)
+    : def
+}
+
+/**
+ * Assert whether a prop is valid.
+ */
+function assertProp (
+  prop,
+  name,
+  value,
+  vm,
+  absent
+) {
+  if (prop.required && absent) {
+    warn(
+      'Missing required prop: "' + name + '"',
+      vm
+    );
+    return
+  }
+  if (value == null && !prop.required) {
+    return
+  }
+  var type = prop.type;
+  var valid = !type || type === true;
+  var expectedTypes = [];
+  if (type) {
+    if (!Array.isArray(type)) {
+      type = [type];
+    }
+    for (var i = 0; i < type.length && !valid; i++) {
+      var assertedType = assertType(value, type[i]);
+      expectedTypes.push(assertedType.expectedType || '');
+      valid = assertedType.valid;
+    }
+  }
+  if (!valid) {
+    warn(
+      'Invalid prop: type check failed for prop "' + name + '".' +
+      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
+      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
+      vm
+    );
+    return
+  }
+  var validator = prop.validator;
+  if (validator) {
+    if (!validator(value)) {
+      warn(
+        'Invalid prop: custom validator check failed for prop "' + name + '".',
+        vm
+      );
+    }
+  }
+}
+
+/**
+ * Assert the type of a value
+ */
+function assertType (value, type) {
+  var valid;
+  var expectedType = getType(type);
+  if (expectedType === 'String') {
+    valid = typeof value === (expectedType = 'string');
+  } else if (expectedType === 'Number') {
+    valid = typeof value === (expectedType = 'number');
+  } else if (expectedType === 'Boolean') {
+    valid = typeof value === (expectedType = 'boolean');
+  } else if (expectedType === 'Function') {
+    valid = typeof value === (expectedType = 'function');
+  } else if (expectedType === 'Object') {
+    valid = isPlainObject(value);
+  } else if (expectedType === 'Array') {
+    valid = Array.isArray(value);
+  } else {
+    valid = value instanceof type;
+  }
+  return {
+    valid: valid,
+    expectedType: expectedType
+  }
+}
+
+/**
+ * Use function string name to check built-in types,
+ * because a simple equality check will fail when running
+ * across different vms / iframes.
+ */
+function getType (fn) {
+  var match = fn && fn.toString().match(/^\s*function (\w+)/);
+  return match && match[1]
+}
+
+function isType (type, fn) {
+  if (!Array.isArray(fn)) {
+    return getType(fn) === getType(type)
+  }
+  for (var i = 0, len = fn.length; i < len; i++) {
+    if (getType(fn[i]) === getType(type)) {
+      return true
+    }
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function handleError (err, vm, info) {
+  if (config.errorHandler) {
+    config.errorHandler.call(null, err, vm, info);
+  } else {
+    {
+      warn(("Error in " + info + ":"), vm);
+    }
+    /* istanbul ignore else */
+    if (inBrowser && typeof console !== 'undefined') {
+      console.error(err);
+    } else {
+      throw err
+    }
+  }
+}
+
+/* not type checking this file because flow doesn't play well with Proxy */
+
+var initProxy;
+
+{
+  var allowedGlobals = makeMap(
+    'Infinity,undefined,NaN,isFinite,isNaN,' +
+    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
+    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
+    'require' // for Webpack/Browserify
+  );
+
+  var warnNonPresent = function (target, key) {
+    warn(
+      "Property or method \"" + key + "\" is not defined on the instance but " +
+      "referenced during render. Make sure to declare reactive data " +
+      "properties in the data option.",
+      target
+    );
+  };
+
+  var hasProxy =
+    typeof Proxy !== 'undefined' &&
+    Proxy.toString().match(/native code/);
+
+  if (hasProxy) {
+    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
+    config.keyCodes = new Proxy(config.keyCodes, {
+      set: function set (target, key, value) {
+        if (isBuiltInModifier(key)) {
+          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
+          return false
+        } else {
+          target[key] = value;
+          return true
+        }
+      }
+    });
+  }
+
+  var hasHandler = {
+    has: function has (target, key) {
+      var has = key in target;
+      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
+      if (!has && !isAllowed) {
+        warnNonPresent(target, key);
+      }
+      return has || !isAllowed
+    }
+  };
+
+  var getHandler = {
+    get: function get (target, key) {
+      if (typeof key === 'string' && !(key in target)) {
+        warnNonPresent(target, key);
+      }
+      return target[key]
+    }
+  };
+
+  initProxy = function initProxy (vm) {
+    if (hasProxy) {
+      // determine which proxy handler to use
+      var options = vm.$options;
+      var handlers = options.render && options.render._withStripped
+        ? getHandler
+        : hasHandler;
+      vm._renderProxy = new Proxy(vm, handlers);
+    } else {
+      vm._renderProxy = vm;
+    }
+  };
+}
+
+/*  */
+
+var VNode = function VNode (
+  tag,
+  data,
+  children,
+  text,
+  elm,
+  context,
+  componentOptions
+) {
+  this.tag = tag;
+  this.data = data;
+  this.children = children;
+  this.text = text;
+  this.elm = elm;
+  this.ns = undefined;
+  this.context = context;
+  this.functionalContext = undefined;
+  this.key = data && data.key;
+  this.componentOptions = componentOptions;
+  this.componentInstance = undefined;
+  this.parent = undefined;
+  this.raw = false;
+  this.isStatic = false;
+  this.isRootInsert = true;
+  this.isComment = false;
+  this.isCloned = false;
+  this.isOnce = false;
+};
+
+var prototypeAccessors = { child: {} };
+
+// DEPRECATED: alias for componentInstance for backwards compat.
+/* istanbul ignore next */
+prototypeAccessors.child.get = function () {
+  return this.componentInstance
+};
+
+Object.defineProperties( VNode.prototype, prototypeAccessors );
+
+var createEmptyVNode = function () {
+  var node = new VNode();
+  node.text = '';
+  node.isComment = true;
+  return node
+};
+
+function createTextVNode (val) {
+  return new VNode(undefined, undefined, undefined, String(val))
+}
+
+// optimized shallow clone
+// used for static nodes and slot nodes because they may be reused across
+// multiple renders, cloning them avoids errors when DOM manipulations rely
+// on their elm reference.
+function cloneVNode (vnode) {
+  var cloned = new VNode(
+    vnode.tag,
+    vnode.data,
+    vnode.children,
+    vnode.text,
+    vnode.elm,
+    vnode.context,
+    vnode.componentOptions
+  );
+  cloned.ns = vnode.ns;
+  cloned.isStatic = vnode.isStatic;
+  cloned.key = vnode.key;
+  cloned.isCloned = true;
+  return cloned
+}
+
+function cloneVNodes (vnodes) {
+  var len = vnodes.length;
+  var res = new Array(len);
+  for (var i = 0; i < len; i++) {
+    res[i] = cloneVNode(vnodes[i]);
+  }
+  return res
+}
+
+/*  */
+
+var normalizeEvent = cached(function (name) {
+  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
+  name = once$$1 ? name.slice(1) : name;
+  var capture = name.charAt(0) === '!';
+  name = capture ? name.slice(1) : name;
+  return {
+    name: name,
+    once: once$$1,
+    capture: capture
+  }
+});
+
+function createFnInvoker (fns) {
+  function invoker () {
+    var arguments$1 = arguments;
+
+    var fns = invoker.fns;
+    if (Array.isArray(fns)) {
+      for (var i = 0; i < fns.length; i++) {
+        fns[i].apply(null, arguments$1);
+      }
+    } else {
+      // return handler return value for single handlers
+      return fns.apply(null, arguments)
+    }
+  }
+  invoker.fns = fns;
+  return invoker
+}
+
+function updateListeners (
+  on,
+  oldOn,
+  add,
+  remove$$1,
+  vm
+) {
+  var name, cur, old, event;
+  for (name in on) {
+    cur = on[name];
+    old = oldOn[name];
+    event = normalizeEvent(name);
+    if (!cur) {
+      "development" !== 'production' && warn(
+        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
+        vm
+      );
+    } else if (!old) {
+      if (!cur.fns) {
+        cur = on[name] = createFnInvoker(cur);
+      }
+      add(event.name, cur, event.once, event.capture);
+    } else if (cur !== old) {
+      old.fns = cur;
+      on[name] = old;
+    }
+  }
+  for (name in oldOn) {
+    if (!on[name]) {
+      event = normalizeEvent(name);
+      remove$$1(event.name, oldOn[name], event.capture);
+    }
+  }
+}
+
+/*  */
+
+function mergeVNodeHook (def, hookKey, hook) {
+  var invoker;
+  var oldHook = def[hookKey];
+
+  function wrappedHook () {
+    hook.apply(this, arguments);
+    // important: remove merged hook to ensure it's called only once
+    // and prevent memory leak
+    remove(invoker.fns, wrappedHook);
+  }
+
+  if (!oldHook) {
+    // no existing hook
+    invoker = createFnInvoker([wrappedHook]);
+  } else {
+    /* istanbul ignore if */
+    if (oldHook.fns && oldHook.merged) {
+      // already a merged invoker
+      invoker = oldHook;
+      invoker.fns.push(wrappedHook);
+    } else {
+      // existing plain hook
+      invoker = createFnInvoker([oldHook, wrappedHook]);
+    }
+  }
+
+  invoker.merged = true;
+  def[hookKey] = invoker;
+}
+
+/*  */
+
+// The template compiler attempts to minimize the need for normalization by
+// statically analyzing the template at compile time.
+//
+// For plain HTML markup, normalization can be completely skipped because the
+// generated render function is guaranteed to return Array<VNode>. There are
+// two cases where extra normalization is needed:
+
+// 1. When the children contains components - because a functional component
+// may return an Array instead of a single root. In this case, just a simple
+// normalization is needed - if any child is an Array, we flatten the whole
+// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
+// because functional components already normalize their own children.
+function simpleNormalizeChildren (children) {
+  for (var i = 0; i < children.length; i++) {
+    if (Array.isArray(children[i])) {
+      return Array.prototype.concat.apply([], children)
+    }
+  }
+  return children
+}
+
+// 2. When the children contains constructs that always generated nested Arrays,
+// e.g. <template>, <slot>, v-for, or when the children is provided by user
+// with hand-written render functions / JSX. In such cases a full normalization
+// is needed to cater to all possible types of children values.
+function normalizeChildren (children) {
+  return isPrimitive(children)
+    ? [createTextVNode(children)]
+    : Array.isArray(children)
+      ? normalizeArrayChildren(children)
+      : undefined
+}
+
+function normalizeArrayChildren (children, nestedIndex) {
+  var res = [];
+  var i, c, last;
+  for (i = 0; i < children.length; i++) {
+    c = children[i];
+    if (c == null || typeof c === 'boolean') { continue }
+    last = res[res.length - 1];
+    //  nested
+    if (Array.isArray(c)) {
+      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
+    } else if (isPrimitive(c)) {
+      if (last && last.text) {
+        last.text += String(c);
+      } else if (c !== '') {
+        // convert primitive to vnode
+        res.push(createTextVNode(c));
+      }
+    } else {
+      if (c.text && last && last.text) {
+        res[res.length - 1] = createTextVNode(last.text + c.text);
+      } else {
+        // default key for nested array children (likely generated by v-for)
+        if (c.tag && c.key == null && nestedIndex != null) {
+          c.key = "__vlist" + nestedIndex + "_" + i + "__";
+        }
+        res.push(c);
+      }
+    }
+  }
+  return res
+}
+
+/*  */
+
+function getFirstComponentChild (children) {
+  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
+}
+
+/*  */
+
+function initEvents (vm) {
+  vm._events = Object.create(null);
+  vm._hasHookEvent = false;
+  // init parent attached events
+  var listeners = vm.$options._parentListeners;
+  if (listeners) {
+    updateComponentListeners(vm, listeners);
+  }
+}
+
+var target;
+
+function add (event, fn, once$$1) {
+  if (once$$1) {
+    target.$once(event, fn);
+  } else {
+    target.$on(event, fn);
+  }
+}
+
+function remove$1 (event, fn) {
+  target.$off(event, fn);
+}
+
+function updateComponentListeners (
+  vm,
+  listeners,
+  oldListeners
+) {
+  target = vm;
+  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
+}
+
+function eventsMixin (Vue) {
+  var hookRE = /^hook:/;
+  Vue.prototype.$on = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    if (Array.isArray(event)) {
+      for (var i = 0, l = event.length; i < l; i++) {
+        this$1.$on(event[i], fn);
+      }
+    } else {
+      (vm._events[event] || (vm._events[event] = [])).push(fn);
+      // optimize hook:event cost by using a boolean flag marked at registration
+      // instead of a hash lookup
+      if (hookRE.test(event)) {
+        vm._hasHookEvent = true;
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$once = function (event, fn) {
+    var vm = this;
+    function on () {
+      vm.$off(event, on);
+      fn.apply(vm, arguments);
+    }
+    on.fn = fn;
+    vm.$on(event, on);
+    return vm
+  };
+
+  Vue.prototype.$off = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    // all
+    if (!arguments.length) {
+      vm._events = Object.create(null);
+      return vm
+    }
+    // array of events
+    if (Array.isArray(event)) {
+      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
+        this$1.$off(event[i$1], fn);
+      }
+      return vm
+    }
+    // specific event
+    var cbs = vm._events[event];
+    if (!cbs) {
+      return vm
+    }
+    if (arguments.length === 1) {
+      vm._events[event] = null;
+      return vm
+    }
+    // specific handler
+    var cb;
+    var i = cbs.length;
+    while (i--) {
+      cb = cbs[i];
+      if (cb === fn || cb.fn === fn) {
+        cbs.splice(i, 1);
+        break
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$emit = function (event) {
+    var vm = this;
+    var cbs = vm._events[event];
+    if (cbs) {
+      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
+      var args = toArray(arguments, 1);
+      for (var i = 0, l = cbs.length; i < l; i++) {
+        cbs[i].apply(vm, args);
+      }
+    }
+    return vm
+  };
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving raw children VNodes into a slot object.
+ */
+function resolveSlots (
+  children,
+  context
+) {
+  var slots = {};
+  if (!children) {
+    return slots
+  }
+  var defaultSlot = [];
+  var name, child;
+  for (var i = 0, l = children.length; i < l; i++) {
+    child = children[i];
+    // named slots should only be respected if the vnode was rendered in the
+    // same context.
+    if ((child.context === context || child.functionalContext === context) &&
+        child.data && (name = child.data.slot)) {
+      var slot = (slots[name] || (slots[name] = []));
+      if (child.tag === 'template') {
+        slot.push.apply(slot, child.children);
+      } else {
+        slot.push(child);
+      }
+    } else {
+      defaultSlot.push(child);
+    }
+  }
+  // ignore whitespace
+  if (!defaultSlot.every(isWhitespace)) {
+    slots.default = defaultSlot;
+  }
+  return slots
+}
+
+function isWhitespace (node) {
+  return node.isComment || node.text === ' '
+}
+
+function resolveScopedSlots (
+  fns
+) {
+  var res = {};
+  for (var i = 0; i < fns.length; i++) {
+    res[fns[i][0]] = fns[i][1];
+  }
+  return res
+}
+
+/*  */
+
+var activeInstance = null;
+
+function initLifecycle (vm) {
+  var options = vm.$options;
+
+  // locate first non-abstract parent
+  var parent = options.parent;
+  if (parent && !options.abstract) {
+    while (parent.$options.abstract && parent.$parent) {
+      parent = parent.$parent;
+    }
+    parent.$children.push(vm);
+  }
+
+  vm.$parent = parent;
+  vm.$root = parent ? parent.$root : vm;
+
+  vm.$children = [];
+  vm.$refs = {};
+
+  vm._watcher = null;
+  vm._inactive = null;
+  vm._directInactive = false;
+  vm._isMounted = false;
+  vm._isDestroyed = false;
+  vm._isBeingDestroyed = false;
+}
+
+function lifecycleMixin (Vue) {
+  Vue.prototype._update = function (vnode, hydrating) {
+    var vm = this;
+    if (vm._isMounted) {
+      callHook(vm, 'beforeUpdate');
+    }
+    var prevEl = vm.$el;
+    var prevVnode = vm._vnode;
+    var prevActiveInstance = activeInstance;
+    activeInstance = vm;
+    vm._vnode = vnode;
+    // Vue.prototype.__patch__ is injected in entry points
+    // based on the rendering backend used.
+    if (!prevVnode) {
+      // initial render
+      vm.$el = vm.__patch__(
+        vm.$el, vnode, hydrating, false /* removeOnly */,
+        vm.$options._parentElm,
+        vm.$options._refElm
+      );
+    } else {
+      // updates
+      vm.$el = vm.__patch__(prevVnode, vnode);
+    }
+    activeInstance = prevActiveInstance;
+    // update __vue__ reference
+    if (prevEl) {
+      prevEl.__vue__ = null;
+    }
+    if (vm.$el) {
+      vm.$el.__vue__ = vm;
+    }
+    // if parent is an HOC, update its $el as well
+    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
+      vm.$parent.$el = vm.$el;
+    }
+    // updated hook is called by the scheduler to ensure that children are
+    // updated in a parent's updated hook.
+  };
+
+  Vue.prototype.$forceUpdate = function () {
+    var vm = this;
+    if (vm._watcher) {
+      vm._watcher.update();
+    }
+  };
+
+  Vue.prototype.$destroy = function () {
+    var vm = this;
+    if (vm._isBeingDestroyed) {
+      return
+    }
+    callHook(vm, 'beforeDestroy');
+    vm._isBeingDestroyed = true;
+    // remove self from parent
+    var parent = vm.$parent;
+    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
+      remove(parent.$children, vm);
+    }
+    // teardown watchers
+    if (vm._watcher) {
+      vm._watcher.teardown();
+    }
+    var i = vm._watchers.length;
+    while (i--) {
+      vm._watchers[i].teardown();
+    }
+    // remove reference from data ob
+    // frozen object may not have observer.
+    if (vm._data.__ob__) {
+      vm._data.__ob__.vmCount--;
+    }
+    // call the last hook...
+    vm._isDestroyed = true;
+    callHook(vm, 'destroyed');
+    // turn off all instance listeners.
+    vm.$off();
+    // remove __vue__ reference
+    if (vm.$el) {
+      vm.$el.__vue__ = null;
+    }
+    // invoke destroy hooks on current rendered tree
+    vm.__patch__(vm._vnode, null);
+  };
+}
+
+function mountComponent (
+  vm,
+  el,
+  hydrating
+) {
+  vm.$el = el;
+  if (!vm.$options.render) {
+    vm.$options.render = createEmptyVNode;
+    {
+      /* istanbul ignore if */
+      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
+        vm.$options.el || el) {
+        warn(
+          'You are using the runtime-only build of Vue where the template ' +
+          'compiler is not available. Either pre-compile the templates into ' +
+          'render functions, or use the compiler-included build.',
+          vm
+        );
+      } else {
+        warn(
+          'Failed to mount component: template or render function not defined.',
+          vm
+        );
+      }
+    }
+  }
+  callHook(vm, 'beforeMount');
+
+  var updateComponent;
+  /* istanbul ignore if */
+  if ("development" !== 'production' && config.performance && perf) {
+    updateComponent = function () {
+      var name = vm._name;
+      var startTag = "start " + name;
+      var endTag = "end " + name;
+      perf.mark(startTag);
+      var vnode = vm._render();
+      perf.mark(endTag);
+      perf.measure((name + " render"), startTag, endTag);
+      perf.mark(startTag);
+      vm._update(vnode, hydrating);
+      perf.mark(endTag);
+      perf.measure((name + " patch"), startTag, endTag);
+    };
+  } else {
+    updateComponent = function () {
+      vm._update(vm._render(), hydrating);
+    };
+  }
+
+  vm._watcher = new Watcher(vm, updateComponent, noop);
+  hydrating = false;
+
+  // manually mounted instance, call mounted on self
+  // mounted is called for render-created child components in its inserted hook
+  if (vm.$vnode == null) {
+    vm._isMounted = true;
+    callHook(vm, 'mounted');
+  }
+  return vm
+}
+
+function updateChildComponent (
+  vm,
+  propsData,
+  listeners,
+  parentVnode,
+  renderChildren
+) {
+  // determine whether component has slot children
+  // we need to do this before overwriting $options._renderChildren
+  var hasChildren = !!(
+    renderChildren ||               // has new static slots
+    vm.$options._renderChildren ||  // has old static slots
+    parentVnode.data.scopedSlots || // has new scoped slots
+    vm.$scopedSlots !== emptyObject // has old scoped slots
+  );
+
+  vm.$options._parentVnode = parentVnode;
+  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
+  if (vm._vnode) { // update child tree's parent
+    vm._vnode.parent = parentVnode;
+  }
+  vm.$options._renderChildren = renderChildren;
+
+  // update props
+  if (propsData && vm.$options.props) {
+    observerState.shouldConvert = false;
+    {
+      observerState.isSettingProps = true;
+    }
+    var props = vm._props;
+    var propKeys = vm.$options._propKeys || [];
+    for (var i = 0; i < propKeys.length; i++) {
+      var key = propKeys[i];
+      props[key] = validateProp(key, vm.$options.props, propsData, vm);
+    }
+    observerState.shouldConvert = true;
+    {
+      observerState.isSettingProps = false;
+    }
+    // keep a copy of raw propsData
+    vm.$options.propsData = propsData;
+  }
+  // update listeners
+  if (listeners) {
+    var oldListeners = vm.$options._parentListeners;
+    vm.$options._parentListeners = listeners;
+    updateComponentListeners(vm, listeners, oldListeners);
+  }
+  // resolve slots + force update if has children
+  if (hasChildren) {
+    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
+    vm.$forceUpdate();
+  }
+}
+
+function isInInactiveTree (vm) {
+  while (vm && (vm = vm.$parent)) {
+    if (vm._inactive) { return true }
+  }
+  return false
+}
+
+function activateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = false;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  } else if (vm._directInactive) {
+    return
+  }
+  if (vm._inactive || vm._inactive == null) {
+    vm._inactive = false;
+    for (var i = 0; i < vm.$children.length; i++) {
+      activateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'activated');
+  }
+}
+
+function deactivateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = true;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  }
+  if (!vm._inactive) {
+    vm._inactive = true;
+    for (var i = 0; i < vm.$children.length; i++) {
+      deactivateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'deactivated');
+  }
+}
+
+function callHook (vm, hook) {
+  var handlers = vm.$options[hook];
+  if (handlers) {
+    for (var i = 0, j = handlers.length; i < j; i++) {
+      try {
+        handlers[i].call(vm);
+      } catch (e) {
+        handleError(e, vm, (hook + " hook"));
+      }
+    }
+  }
+  if (vm._hasHookEvent) {
+    vm.$emit('hook:' + hook);
+  }
+}
+
+/*  */
+
+
+var queue = [];
+var has = {};
+var circular = {};
+var waiting = false;
+var flushing = false;
+var index = 0;
+
+/**
+ * Reset the scheduler's state.
+ */
+function resetSchedulerState () {
+  queue.length = 0;
+  has = {};
+  {
+    circular = {};
+  }
+  waiting = flushing = false;
+}
+
+/**
+ * Flush both queues and run the watchers.
+ */
+function flushSchedulerQueue () {
+  flushing = true;
+  var watcher, id, vm;
+
+  // Sort queue before flush.
+  // This ensures that:
+  // 1. Components are updated from parent to child. (because parent is always
+  //    created before the child)
+  // 2. A component's user watchers are run before its render watcher (because
+  //    user watchers are created before the render watcher)
+  // 3. If a component is destroyed during a parent component's watcher run,
+  //    its watchers can be skipped.
+  queue.sort(function (a, b) { return a.id - b.id; });
+
+  // do not cache length because more watchers might be pushed
+  // as we run existing watchers
+  for (index = 0; index < queue.length; index++) {
+    watcher = queue[index];
+    id = watcher.id;
+    has[id] = null;
+    watcher.run();
+    // in dev build, check and stop circular updates.
+    if ("development" !== 'production' && has[id] != null) {
+      circular[id] = (circular[id] || 0) + 1;
+      if (circular[id] > config._maxUpdateCount) {
+        warn(
+          'You may have an infinite update loop ' + (
+            watcher.user
+              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
+              : "in a component render function."
+          ),
+          watcher.vm
+        );
+        break
+      }
+    }
+  }
+
+  // call updated hooks
+  index = queue.length;
+  while (index--) {
+    watcher = queue[index];
+    vm = watcher.vm;
+    if (vm._watcher === watcher && vm._isMounted) {
+      callHook(vm, 'updated');
+    }
+  }
+
+  // devtool hook
+  /* istanbul ignore if */
+  if (devtools && config.devtools) {
+    devtools.emit('flush');
+  }
+
+  resetSchedulerState();
+}
+
+/**
+ * Push a watcher into the watcher queue.
+ * Jobs with duplicate IDs will be skipped unless it's
+ * pushed when the queue is being flushed.
+ */
+function queueWatcher (watcher) {
+  var id = watcher.id;
+  if (has[id] == null) {
+    has[id] = true;
+    if (!flushing) {
+      queue.push(watcher);
+    } else {
+      // if already flushing, splice the watcher based on its id
+      // if already past its id, it will be run next immediately.
+      var i = queue.length - 1;
+      while (i >= 0 && queue[i].id > watcher.id) {
+        i--;
+      }
+      queue.splice(Math.max(i, index) + 1, 0, watcher);
+    }
+    // queue the flush
+    if (!waiting) {
+      waiting = true;
+      nextTick(flushSchedulerQueue);
+    }
+  }
+}
+
+/*  */
+
+var uid$2 = 0;
+
+/**
+ * A watcher parses an expression, collects dependencies,
+ * and fires callback when the expression value changes.
+ * This is used for both the $watch() api and directives.
+ */
+var Watcher = function Watcher (
+  vm,
+  expOrFn,
+  cb,
+  options
+) {
+  this.vm = vm;
+  vm._watchers.push(this);
+  // options
+  if (options) {
+    this.deep = !!options.deep;
+    this.user = !!options.user;
+    this.lazy = !!options.lazy;
+    this.sync = !!options.sync;
+  } else {
+    this.deep = this.user = this.lazy = this.sync = false;
+  }
+  this.cb = cb;
+  this.id = ++uid$2; // uid for batching
+  this.active = true;
+  this.dirty = this.lazy; // for lazy watchers
+  this.deps = [];
+  this.newDeps = [];
+  this.depIds = new _Set();
+  this.newDepIds = new _Set();
+  this.expression = expOrFn.toString();
+  // parse expression for getter
+  if (typeof expOrFn === 'function') {
+    this.getter = expOrFn;
+  } else {
+    this.getter = parsePath(expOrFn);
+    if (!this.getter) {
+      this.getter = function () {};
+      "development" !== 'production' && warn(
+        "Failed watching path: \"" + expOrFn + "\" " +
+        'Watcher only accepts simple dot-delimited paths. ' +
+        'For full control, use a function instead.',
+        vm
+      );
+    }
+  }
+  this.value = this.lazy
+    ? undefined
+    : this.get();
+};
+
+/**
+ * Evaluate the getter, and re-collect dependencies.
+ */
+Watcher.prototype.get = function get () {
+  pushTarget(this);
+  var value;
+  var vm = this.vm;
+  if (this.user) {
+    try {
+      value = this.getter.call(vm, vm);
+    } catch (e) {
+      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
+    }
+  } else {
+    value = this.getter.call(vm, vm);
+  }
+  // "touch" every property so they are all tracked as
+  // dependencies for deep watching
+  if (this.deep) {
+    traverse(value);
+  }
+  popTarget();
+  this.cleanupDeps();
+  return value
+};
+
+/**
+ * Add a dependency to this directive.
+ */
+Watcher.prototype.addDep = function addDep (dep) {
+  var id = dep.id;
+  if (!this.newDepIds.has(id)) {
+    this.newDepIds.add(id);
+    this.newDeps.push(dep);
+    if (!this.depIds.has(id)) {
+      dep.addSub(this);
+    }
+  }
+};
+
+/**
+ * Clean up for dependency collection.
+ */
+Watcher.prototype.cleanupDeps = function cleanupDeps () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    var dep = this$1.deps[i];
+    if (!this$1.newDepIds.has(dep.id)) {
+      dep.removeSub(this$1);
+    }
+  }
+  var tmp = this.depIds;
+  this.depIds = this.newDepIds;
+  this.newDepIds = tmp;
+  this.newDepIds.clear();
+  tmp = this.deps;
+  this.deps = this.newDeps;
+  this.newDeps = tmp;
+  this.newDeps.length = 0;
+};
+
+/**
+ * Subscriber interface.
+ * Will be called when a dependency changes.
+ */
+Watcher.prototype.update = function update () {
+  /* istanbul ignore else */
+  if (this.lazy) {
+    this.dirty = true;
+  } else if (this.sync) {
+    this.run();
+  } else {
+    queueWatcher(this);
+  }
+};
+
+/**
+ * Scheduler job interface.
+ * Will be called by the scheduler.
+ */
+Watcher.prototype.run = function run () {
+  if (this.active) {
+    var value = this.get();
+    if (
+      value !== this.value ||
+      // Deep watchers and watchers on Object/Arrays should fire even
+      // when the value is the same, because the value may
+      // have mutated.
+      isObject(value) ||
+      this.deep
+    ) {
+      // set new value
+      var oldValue = this.value;
+      this.value = value;
+      if (this.user) {
+        try {
+          this.cb.call(this.vm, value, oldValue);
+        } catch (e) {
+          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
+        }
+      } else {
+        this.cb.call(this.vm, value, oldValue);
+      }
+    }
+  }
+};
+
+/**
+ * Evaluate the value of the watcher.
+ * This only gets called for lazy watchers.
+ */
+Watcher.prototype.evaluate = function evaluate () {
+  this.value = this.get();
+  this.dirty = false;
+};
+
+/**
+ * Depend on all deps collected by this watcher.
+ */
+Watcher.prototype.depend = function depend () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    this$1.deps[i].depend();
+  }
+};
+
+/**
+ * Remove self from all dependencies' subscriber list.
+ */
+Watcher.prototype.teardown = function teardown () {
+    var this$1 = this;
+
+  if (this.active) {
+    // remove self from vm's watcher list
+    // this is a somewhat expensive operation so we skip it
+    // if the vm is being destroyed.
+    if (!this.vm._isBeingDestroyed) {
+      remove(this.vm._watchers, this);
+    }
+    var i = this.deps.length;
+    while (i--) {
+      this$1.deps[i].removeSub(this$1);
+    }
+    this.active = false;
+  }
+};
+
+/**
+ * Recursively traverse an object to evoke all converted
+ * getters, so that every nested property inside the object
+ * is collected as a "deep" dependency.
+ */
+var seenObjects = new _Set();
+function traverse (val) {
+  seenObjects.clear();
+  _traverse(val, seenObjects);
+}
+
+function _traverse (val, seen) {
+  var i, keys;
+  var isA = Array.isArray(val);
+  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
+    return
+  }
+  if (val.__ob__) {
+    var depId = val.__ob__.dep.id;
+    if (seen.has(depId)) {
+      return
+    }
+    seen.add(depId);
+  }
+  if (isA) {
+    i = val.length;
+    while (i--) { _traverse(val[i], seen); }
+  } else {
+    keys = Object.keys(val);
+    i = keys.length;
+    while (i--) { _traverse(val[keys[i]], seen); }
+  }
+}
+
+/*  */
+
+var sharedPropertyDefinition = {
+  enumerable: true,
+  configurable: true,
+  get: noop,
+  set: noop
+};
+
+function proxy (target, sourceKey, key) {
+  sharedPropertyDefinition.get = function proxyGetter () {
+    return this[sourceKey][key]
+  };
+  sharedPropertyDefinition.set = function proxySetter (val) {
+    this[sourceKey][key] = val;
+  };
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function initState (vm) {
+  vm._watchers = [];
+  var opts = vm.$options;
+  if (opts.props) { initProps(vm, opts.props); }
+  if (opts.methods) { initMethods(vm, opts.methods); }
+  if (opts.data) {
+    initData(vm);
+  } else {
+    observe(vm._data = {}, true /* asRootData */);
+  }
+  if (opts.computed) { initComputed(vm, opts.computed); }
+  if (opts.watch) { initWatch(vm, opts.watch); }
+}
+
+var isReservedProp = { key: 1, ref: 1, slot: 1 };
+
+function initProps (vm, propsOptions) {
+  var propsData = vm.$options.propsData || {};
+  var props = vm._props = {};
+  // cache prop keys so that future props updates can iterate using Array
+  // instead of dynamic object key enumeration.
+  var keys = vm.$options._propKeys = [];
+  var isRoot = !vm.$parent;
+  // root instance props should be converted
+  observerState.shouldConvert = isRoot;
+  var loop = function ( key ) {
+    keys.push(key);
+    var value = validateProp(key, propsOptions, propsData, vm);
+    /* istanbul ignore else */
+    {
+      if (isReservedProp[key]) {
+        warn(
+          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
+          vm
+        );
+      }
+      defineReactive$$1(props, key, value, function () {
+        if (vm.$parent && !observerState.isSettingProps) {
+          warn(
+            "Avoid mutating a prop directly since the value will be " +
+            "overwritten whenever the parent component re-renders. " +
+            "Instead, use a data or computed property based on the prop's " +
+            "value. Prop being mutated: \"" + key + "\"",
+            vm
+          );
+        }
+      });
+    }
+    // static props are already proxied on the component's prototype
+    // during Vue.extend(). We only need to proxy props defined at
+    // instantiation here.
+    if (!(key in vm)) {
+      proxy(vm, "_props", key);
+    }
+  };
+
+  for (var key in propsOptions) loop( key );
+  observerState.shouldConvert = true;
+}
+
+function initData (vm) {
+  var data = vm.$options.data;
+  data = vm._data = typeof data === 'function'
+    ? data.call(vm)
+    : data || {};
+  if (!isPlainObject(data)) {
+    data = {};
+    "development" !== 'production' && warn(
+      'data functions should return an object:\n' +
+      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
+      vm
+    );
+  }
+  // proxy data on instance
+  var keys = Object.keys(data);
+  var props = vm.$options.props;
+  var i = keys.length;
+  while (i--) {
+    if (props && hasOwn(props, keys[i])) {
+      "development" !== 'production' && warn(
+        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
+        "Use prop default value instead.",
+        vm
+      );
+    } else if (!isReserved(keys[i])) {
+      proxy(vm, "_data", keys[i]);
+    }
+  }
+  // observe data
+  observe(data, true /* asRootData */);
+}
+
+var computedWatcherOptions = { lazy: true };
+
+function initComputed (vm, computed) {
+  var watchers = vm._computedWatchers = Object.create(null);
+
+  for (var key in computed) {
+    var userDef = computed[key];
+    var getter = typeof userDef === 'function' ? userDef : userDef.get;
+    // create internal watcher for the computed property.
+    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);
+
+    // component-defined computed properties are already defined on the
+    // component prototype. We only need to define computed properties defined
+    // at instantiation here.
+    if (!(key in vm)) {
+      defineComputed(vm, key, userDef);
+    }
+  }
+}
+
+function defineComputed (target, key, userDef) {
+  if (typeof userDef === 'function') {
+    sharedPropertyDefinition.get = createComputedGetter(key);
+    sharedPropertyDefinition.set = noop;
+  } else {
+    sharedPropertyDefinition.get = userDef.get
+      ? userDef.cache !== false
+        ? createComputedGetter(key)
+        : userDef.get
+      : noop;
+    sharedPropertyDefinition.set = userDef.set
+      ? userDef.set
+      : noop;
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function createComputedGetter (key) {
+  return function computedGetter () {
+    var watcher = this._computedWatchers && this._computedWatchers[key];
+    if (watcher) {
+      if (watcher.dirty) {
+        watcher.evaluate();
+      }
+      if (Dep.target) {
+        watcher.depend();
+      }
+      return watcher.value
+    }
+  }
+}
+
+function initMethods (vm, methods) {
+  var props = vm.$options.props;
+  for (var key in methods) {
+    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
+    {
+      if (methods[key] == null) {
+        warn(
+          "method \"" + key + "\" has an undefined value in the component definition. " +
+          "Did you reference the function correctly?",
+          vm
+        );
+      }
+      if (props && hasOwn(props, key)) {
+        warn(
+          ("method \"" + key + "\" has already been defined as a prop."),
+          vm
+        );
+      }
+    }
+  }
+}
+
+function initWatch (vm, watch) {
+  for (var key in watch) {
+    var handler = watch[key];
+    if (Array.isArray(handler)) {
+      for (var i = 0; i < handler.length; i++) {
+        createWatcher(vm, key, handler[i]);
+      }
+    } else {
+      createWatcher(vm, key, handler);
+    }
+  }
+}
+
+function createWatcher (vm, key, handler) {
+  var options;
+  if (isPlainObject(handler)) {
+    options = handler;
+    handler = handler.handler;
+  }
+  if (typeof handler === 'string') {
+    handler = vm[handler];
+  }
+  vm.$watch(key, handler, options);
+}
+
+function stateMixin (Vue) {
+  // flow somehow has problems with directly declared definition object
+  // when using Object.defineProperty, so we have to procedurally build up
+  // the object here.
+  var dataDef = {};
+  dataDef.get = function () { return this._data };
+  var propsDef = {};
+  propsDef.get = function () { return this._props };
+  {
+    dataDef.set = function (newData) {
+      warn(
+        'Avoid replacing instance root $data. ' +
+        'Use nested data properties instead.',
+        this
+      );
+    };
+    propsDef.set = function () {
+      warn("$props is readonly.", this);
+    };
+  }
+  Object.defineProperty(Vue.prototype, '$data', dataDef);
+  Object.defineProperty(Vue.prototype, '$props', propsDef);
+
+  Vue.prototype.$set = set;
+  Vue.prototype.$delete = del;
+
+  Vue.prototype.$watch = function (
+    expOrFn,
+    cb,
+    options
+  ) {
+    var vm = this;
+    options = options || {};
+    options.user = true;
+    var watcher = new Watcher(vm, expOrFn, cb, options);
+    if (options.immediate) {
+      cb.call(vm, watcher.value);
+    }
+    return function unwatchFn () {
+      watcher.teardown();
+    }
+  };
+}
+
+/*  */
+
+var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy };
+var hooksToMerge = Object.keys(hooks);
+
+function createComponent (
+  Ctor,
+  data,
+  context,
+  children,
+  tag
+) {
+  if (!Ctor) {
+    return
+  }
+
+  var baseCtor = context.$options._base;
+  if (isObject(Ctor)) {
+    Ctor = baseCtor.extend(Ctor);
+  }
+
+  if (typeof Ctor !== 'function') {
+    {
+      warn(("Invalid Component definition: " + (String(Ctor))), context);
+    }
+    return
+  }
+
+  // async component
+  if (!Ctor.cid) {
+    if (Ctor.resolved) {
+      Ctor = Ctor.resolved;
+    } else {
+      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
+        // it's ok to queue this on every render because
+        // $forceUpdate is buffered by the scheduler.
+        context.$forceUpdate();
+      });
+      if (!Ctor) {
+        // return nothing if this is indeed an async component
+        // wait for the callback to trigger parent update.
+        return
+      }
+    }
+  }
+
+  // resolve constructor options in case global mixins are applied after
+  // component constructor creation
+  resolveConstructorOptions(Ctor);
+
+  data = data || {};
+
+  // transform component v-model data into props & events
+  if (data.model) {
+    transformModel(Ctor.options, data);
+  }
+
+  // extract props
+  var propsData = extractProps(data, Ctor);
+
+  // functional component
+  if (Ctor.options.functional) {
+    return createFunctionalComponent(Ctor, propsData, data, context, children)
+  }
+
+  // extract listeners, since these needs to be treated as
+  // child component listeners instead of DOM listeners
+  var listeners = data.on;
+  // replace with listeners with .native modifier
+  data.on = data.nativeOn;
+
+  if (Ctor.options.abstract) {
+    // abstract components do not keep anything
+    // other than props & listeners
+    data = {};
+  }
+
+  // merge component management hooks onto the placeholder node
+  mergeHooks(data);
+
+  // return a placeholder vnode
+  var name = Ctor.options.name || tag;
+  var vnode = new VNode(
+    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
+    data, undefined, undefined, undefined, context,
+    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
+  );
+  return vnode
+}
+
+function createFunctionalComponent (
+  Ctor,
+  propsData,
+  data,
+  context,
+  children
+) {
+  var props = {};
+  var propOptions = Ctor.options.props;
+  if (propOptions) {
+    for (var key in propOptions) {
+      props[key] = validateProp(key, propOptions, propsData);
+    }
+  }
+  // ensure the createElement function in functional components
+  // gets a unique context - this is necessary for correct named slot check
+  var _context = Object.create(context);
+  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
+  var vnode = Ctor.options.render.call(null, h, {
+    props: props,
+    data: data,
+    parent: context,
+    children: children,
+    slots: function () { return resolveSlots(children, context); }
+  });
+  if (vnode instanceof VNode) {
+    vnode.functionalContext = context;
+    if (data.slot) {
+      (vnode.data || (vnode.data = {})).slot = data.slot;
+    }
+  }
+  return vnode
+}
+
+function createComponentInstanceForVnode (
+  vnode, // we know it's MountedComponentVNode but flow doesn't
+  parent, // activeInstance in lifecycle state
+  parentElm,
+  refElm
+) {
+  var vnodeComponentOptions = vnode.componentOptions;
+  var options = {
+    _isComponent: true,
+    parent: parent,
+    propsData: vnodeComponentOptions.propsData,
+    _componentTag: vnodeComponentOptions.tag,
+    _parentVnode: vnode,
+    _parentListeners: vnodeComponentOptions.listeners,
+    _renderChildren: vnodeComponentOptions.children,
+    _parentElm: parentElm || null,
+    _refElm: refElm || null
+  };
+  // check inline-template render functions
+  var inlineTemplate = vnode.data.inlineTemplate;
+  if (inlineTemplate) {
+    options.render = inlineTemplate.render;
+    options.staticRenderFns = inlineTemplate.staticRenderFns;
+  }
+  return new vnodeComponentOptions.Ctor(options)
+}
+
+function init (
+  vnode,
+  hydrating,
+  parentElm,
+  refElm
+) {
+  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
+    var child = vnode.componentInstance = createComponentInstanceForVnode(
+      vnode,
+      activeInstance,
+      parentElm,
+      refElm
+    );
+    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
+  } else if (vnode.data.keepAlive) {
+    // kept-alive components, treat as a patch
+    var mountedNode = vnode; // work around flow
+    prepatch(mountedNode, mountedNode);
+  }
+}
+
+function prepatch (
+  oldVnode,
+  vnode
+) {
+  var options = vnode.componentOptions;
+  var child = vnode.componentInstance = oldVnode.componentInstance;
+  updateChildComponent(
+    child,
+    options.propsData, // updated props
+    options.listeners, // updated listeners
+    vnode, // new parent vnode
+    options.children // new children
+  );
+}
+
+function insert (vnode) {
+  if (!vnode.componentInstance._isMounted) {
+    vnode.componentInstance._isMounted = true;
+    callHook(vnode.componentInstance, 'mounted');
+  }
+  if (vnode.data.keepAlive) {
+    activateChildComponent(vnode.componentInstance, true /* direct */);
+  }
+}
+
+function destroy (vnode) {
+  if (!vnode.componentInstance._isDestroyed) {
+    if (!vnode.data.keepAlive) {
+      vnode.componentInstance.$destroy();
+    } else {
+      deactivateChildComponent(vnode.componentInstance, true /* direct */);
+    }
+  }
+}
+
+function resolveAsyncComponent (
+  factory,
+  baseCtor,
+  cb
+) {
+  if (factory.requested) {
+    // pool callbacks
+    factory.pendingCallbacks.push(cb);
+  } else {
+    factory.requested = true;
+    var cbs = factory.pendingCallbacks = [cb];
+    var sync = true;
+
+    var resolve = function (res) {
+      if (isObject(res)) {
+        res = baseCtor.extend(res);
+      }
+      // cache resolved
+      factory.resolved = res;
+      // invoke callbacks only if this is not a synchronous resolve
+      // (async resolves are shimmed as synchronous during SSR)
+      if (!sync) {
+        for (var i = 0, l = cbs.length; i < l; i++) {
+          cbs[i](res);
+        }
+      }
+    };
+
+    var reject = function (reason) {
+      "development" !== 'production' && warn(
+        "Failed to resolve async component: " + (String(factory)) +
+        (reason ? ("\nReason: " + reason) : '')
+      );
+    };
+
+    var res = factory(resolve, reject);
+
+    // handle promise
+    if (res && typeof res.then === 'function' && !factory.resolved) {
+      res.then(resolve, reject);
+    }
+
+    sync = false;
+    // return in case resolved synchronously
+    return factory.resolved
+  }
+}
+
+function extractProps (data, Ctor) {
+  // we are only extracting raw values here.
+  // validation and default values are handled in the child
+  // component itself.
+  var propOptions = Ctor.options.props;
+  if (!propOptions) {
+    return
+  }
+  var res = {};
+  var attrs = data.attrs;
+  var props = data.props;
+  var domProps = data.domProps;
+  if (attrs || props || domProps) {
+    for (var key in propOptions) {
+      var altKey = hyphenate(key);
+      checkProp(res, props, key, altKey, true) ||
+      checkProp(res, attrs, key, altKey) ||
+      checkProp(res, domProps, key, altKey);
+    }
+  }
+  return res
+}
+
+function checkProp (
+  res,
+  hash,
+  key,
+  altKey,
+  preserve
+) {
+  if (hash) {
+    if (hasOwn(hash, key)) {
+      res[key] = hash[key];
+      if (!preserve) {
+        delete hash[key];
+      }
+      return true
+    } else if (hasOwn(hash, altKey)) {
+      res[key] = hash[altKey];
+      if (!preserve) {
+        delete hash[altKey];
+      }
+      return true
+    }
+  }
+  return false
+}
+
+function mergeHooks (data) {
+  if (!data.hook) {
+    data.hook = {};
+  }
+  for (var i = 0; i < hooksToMerge.length; i++) {
+    var key = hooksToMerge[i];
+    var fromParent = data.hook[key];
+    var ours = hooks[key];
+    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
+  }
+}
+
+function mergeHook$1 (one, two) {
+  return function (a, b, c, d) {
+    one(a, b, c, d);
+    two(a, b, c, d);
+  }
+}
+
+// transform component v-model info (value and callback) into
+// prop and event handler respectively.
+function transformModel (options, data) {
+  var prop = (options.model && options.model.prop) || 'value';
+  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
+  var on = data.on || (data.on = {});
+  if (on[event]) {
+    on[event] = [data.model.callback].concat(on[event]);
+  } else {
+    on[event] = data.model.callback;
+  }
+}
+
+/*  */
+
+var SIMPLE_NORMALIZE = 1;
+var ALWAYS_NORMALIZE = 2;
+
+// wrapper function for providing a more flexible interface
+// without getting yelled at by flow
+function createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType,
+  alwaysNormalize
+) {
+  if (Array.isArray(data) || isPrimitive(data)) {
+    normalizationType = children;
+    children = data;
+    data = undefined;
+  }
+  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
+  return _createElement(context, tag, data, children, normalizationType)
+}
+
+function _createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType
+) {
+  if (data && data.__ob__) {
+    "development" !== 'production' && warn(
+      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
+      'Always create fresh vnode data objects in each render!',
+      context
+    );
+    return createEmptyVNode()
+  }
+  if (!tag) {
+    // in case of component :is set to falsy value
+    return createEmptyVNode()
+  }
+  // support single function children as default scoped slot
+  if (Array.isArray(children) &&
+      typeof children[0] === 'function') {
+    data = data || {};
+    data.scopedSlots = { default: children[0] };
+    children.length = 0;
+  }
+  if (normalizationType === ALWAYS_NORMALIZE) {
+    children = normalizeChildren(children);
+  } else if (normalizationType === SIMPLE_NORMALIZE) {
+    children = simpleNormalizeChildren(children);
+  }
+  var vnode, ns;
+  if (typeof tag === 'string') {
+    var Ctor;
+    ns = config.getTagNamespace(tag);
+    if (config.isReservedTag(tag)) {
+      // platform built-in elements
+      vnode = new VNode(
+        config.parsePlatformTagName(tag), data, children,
+        undefined, undefined, context
+      );
+    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
+      // component
+      vnode = createComponent(Ctor, data, context, children, tag);
+    } else {
+      // unknown or unlisted namespaced elements
+      // check at runtime because it may get assigned a namespace when its
+      // parent normalizes children
+      vnode = new VNode(
+        tag, data, children,
+        undefined, undefined, context
+      );
+    }
+  } else {
+    // direct component options / constructor
+    vnode = createComponent(tag, data, context, children);
+  }
+  if (vnode) {
+    if (ns) { applyNS(vnode, ns); }
+    return vnode
+  } else {
+    return createEmptyVNode()
+  }
+}
+
+function applyNS (vnode, ns) {
+  vnode.ns = ns;
+  if (vnode.tag === 'foreignObject') {
+    // use default namespace inside foreignObject
+    return
+  }
+  if (vnode.children) {
+    for (var i = 0, l = vnode.children.length; i < l; i++) {
+      var child = vnode.children[i];
+      if (child.tag && !child.ns) {
+        applyNS(child, ns);
+      }
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering v-for lists.
+ */
+function renderList (
+  val,
+  render
+) {
+  var ret, i, l, keys, key;
+  if (Array.isArray(val) || typeof val === 'string') {
+    ret = new Array(val.length);
+    for (i = 0, l = val.length; i < l; i++) {
+      ret[i] = render(val[i], i);
+    }
+  } else if (typeof val === 'number') {
+    ret = new Array(val);
+    for (i = 0; i < val; i++) {
+      ret[i] = render(i + 1, i);
+    }
+  } else if (isObject(val)) {
+    keys = Object.keys(val);
+    ret = new Array(keys.length);
+    for (i = 0, l = keys.length; i < l; i++) {
+      key = keys[i];
+      ret[i] = render(val[key], key, i);
+    }
+  }
+  return ret
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering <slot>
+ */
+function renderSlot (
+  name,
+  fallback,
+  props,
+  bindObject
+) {
+  var scopedSlotFn = this.$scopedSlots[name];
+  if (scopedSlotFn) { // scoped slot
+    props = props || {};
+    if (bindObject) {
+      extend(props, bindObject);
+    }
+    return scopedSlotFn(props) || fallback
+  } else {
+    var slotNodes = this.$slots[name];
+    // warn duplicate slot usage
+    if (slotNodes && "development" !== 'production') {
+      slotNodes._rendered && warn(
+        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
+        "- this will likely cause render errors.",
+        this
+      );
+      slotNodes._rendered = true;
+    }
+    return slotNodes || fallback
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving filters
+ */
+function resolveFilter (id) {
+  return resolveAsset(this.$options, 'filters', id, true) || identity
+}
+
+/*  */
+
+/**
+ * Runtime helper for checking keyCodes from config.
+ */
+function checkKeyCodes (
+  eventKeyCode,
+  key,
+  builtInAlias
+) {
+  var keyCodes = config.keyCodes[key] || builtInAlias;
+  if (Array.isArray(keyCodes)) {
+    return keyCodes.indexOf(eventKeyCode) === -1
+  } else {
+    return keyCodes !== eventKeyCode
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for merging v-bind="object" into a VNode's data.
+ */
+function bindObjectProps (
+  data,
+  tag,
+  value,
+  asProp
+) {
+  if (value) {
+    if (!isObject(value)) {
+      "development" !== 'production' && warn(
+        'v-bind without argument expects an Object or Array value',
+        this
+      );
+    } else {
+      if (Array.isArray(value)) {
+        value = toObject(value);
+      }
+      for (var key in value) {
+        if (key === 'class' || key === 'style') {
+          data[key] = value[key];
+        } else {
+          var type = data.attrs && data.attrs.type;
+          var hash = asProp || config.mustUseProp(tag, type, key)
+            ? data.domProps || (data.domProps = {})
+            : data.attrs || (data.attrs = {});
+          hash[key] = value[key];
+        }
+      }
+    }
+  }
+  return data
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering static trees.
+ */
+function renderStatic (
+  index,
+  isInFor
+) {
+  var tree = this._staticTrees[index];
+  // if has already-rendered static tree and not inside v-for,
+  // we can reuse the same tree by doing a shallow clone.
+  if (tree && !isInFor) {
+    return Array.isArray(tree)
+      ? cloneVNodes(tree)
+      : cloneVNode(tree)
+  }
+  // otherwise, render a fresh tree.
+  tree = this._staticTrees[index] =
+    this.$options.staticRenderFns[index].call(this._renderProxy);
+  markStatic(tree, ("__static__" + index), false);
+  return tree
+}
+
+/**
+ * Runtime helper for v-once.
+ * Effectively it means marking the node as static with a unique key.
+ */
+function markOnce (
+  tree,
+  index,
+  key
+) {
+  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
+  return tree
+}
+
+function markStatic (
+  tree,
+  key,
+  isOnce
+) {
+  if (Array.isArray(tree)) {
+    for (var i = 0; i < tree.length; i++) {
+      if (tree[i] && typeof tree[i] !== 'string') {
+        markStaticNode(tree[i], (key + "_" + i), isOnce);
+      }
+    }
+  } else {
+    markStaticNode(tree, key, isOnce);
+  }
+}
+
+function markStaticNode (node, key, isOnce) {
+  node.isStatic = true;
+  node.key = key;
+  node.isOnce = isOnce;
+}
+
+/*  */
+
+function initRender (vm) {
+  vm.$vnode = null; // the placeholder node in parent tree
+  vm._vnode = null; // the root of the child tree
+  vm._staticTrees = null;
+  var parentVnode = vm.$options._parentVnode;
+  var renderContext = parentVnode && parentVnode.context;
+  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
+  vm.$scopedSlots = emptyObject;
+  // bind the createElement fn to this instance
+  // so that we get proper render context inside it.
+  // args order: tag, data, children, normalizationType, alwaysNormalize
+  // internal version is used by render functions compiled from templates
+  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
+  // normalization is always applied for the public version, used in
+  // user-written render functions.
+  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
+}
+
+function renderMixin (Vue) {
+  Vue.prototype.$nextTick = function (fn) {
+    return nextTick(fn, this)
+  };
+
+  Vue.prototype._render = function () {
+    var vm = this;
+    var ref = vm.$options;
+    var render = ref.render;
+    var staticRenderFns = ref.staticRenderFns;
+    var _parentVnode = ref._parentVnode;
+
+    if (vm._isMounted) {
+      // clone slot nodes on re-renders
+      for (var key in vm.$slots) {
+        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
+      }
+    }
+
+    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;
+
+    if (staticRenderFns && !vm._staticTrees) {
+      vm._staticTrees = [];
+    }
+    // set parent vnode. this allows render functions to have access
+    // to the data on the placeholder node.
+    vm.$vnode = _parentVnode;
+    // render self
+    var vnode;
+    try {
+      vnode = render.call(vm._renderProxy, vm.$createElement);
+    } catch (e) {
+      handleError(e, vm, "render function");
+      // return error render result,
+      // or previous vnode to prevent render error causing blank component
+      /* istanbul ignore else */
+      {
+        vnode = vm.$options.renderError
+          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
+          : vm._vnode;
+      }
+    }
+    // return empty vnode in case the render function errored out
+    if (!(vnode instanceof VNode)) {
+      if ("development" !== 'production' && Array.isArray(vnode)) {
+        warn(
+          'Multiple root nodes returned from render function. Render function ' +
+          'should return a single root node.',
+          vm
+        );
+      }
+      vnode = createEmptyVNode();
+    }
+    // set parent
+    vnode.parent = _parentVnode;
+    return vnode
+  };
+
+  // internal render helpers.
+  // these are exposed on the instance prototype to reduce generated render
+  // code size.
+  Vue.prototype._o = markOnce;
+  Vue.prototype._n = toNumber;
+  Vue.prototype._s = _toString;
+  Vue.prototype._l = renderList;
+  Vue.prototype._t = renderSlot;
+  Vue.prototype._q = looseEqual;
+  Vue.prototype._i = looseIndexOf;
+  Vue.prototype._m = renderStatic;
+  Vue.prototype._f = resolveFilter;
+  Vue.prototype._k = checkKeyCodes;
+  Vue.prototype._b = bindObjectProps;
+  Vue.prototype._v = createTextVNode;
+  Vue.prototype._e = createEmptyVNode;
+  Vue.prototype._u = resolveScopedSlots;
+}
+
+/*  */
+
+function initProvide (vm) {
+  var provide = vm.$options.provide;
+  if (provide) {
+    vm._provided = typeof provide === 'function'
+      ? provide.call(vm)
+      : provide;
+  }
+}
+
+function initInjections (vm) {
+  var inject = vm.$options.inject;
+  if (inject) {
+    // inject is :any because flow is not smart enough to figure out cached
+    // isArray here
+    var isArray = Array.isArray(inject);
+    var keys = isArray
+      ? inject
+      : hasSymbol
+        ? Reflect.ownKeys(inject)
+        : Object.keys(inject);
+
+    for (var i = 0; i < keys.length; i++) {
+      var key = keys[i];
+      var provideKey = isArray ? key : inject[key];
+      var source = vm;
+      while (source) {
+        if (source._provided && provideKey in source._provided) {
+          vm[key] = source._provided[provideKey];
+          break
+        }
+        source = source.$parent;
+      }
+    }
+  }
+}
+
+/*  */
+
+var uid = 0;
+
+function initMixin (Vue) {
+  Vue.prototype._init = function (options) {
+    /* istanbul ignore if */
+    if ("development" !== 'production' && config.performance && perf) {
+      perf.mark('init');
+    }
+
+    var vm = this;
+    // a uid
+    vm._uid = uid++;
+    // a flag to avoid this being observed
+    vm._isVue = true;
+    // merge options
+    if (options && options._isComponent) {
+      // optimize internal component instantiation
+      // since dynamic options merging is pretty slow, and none of the
+      // internal component options needs special treatment.
+      initInternalComponent(vm, options);
+    } else {
+      vm.$options = mergeOptions(
+        resolveConstructorOptions(vm.constructor),
+        options || {},
+        vm
+      );
+    }
+    /* istanbul ignore else */
+    {
+      initProxy(vm);
+    }
+    // expose real self
+    vm._self = vm;
+    initLifecycle(vm);
+    initEvents(vm);
+    initRender(vm);
+    callHook(vm, 'beforeCreate');
+    initInjections(vm); // resolve injections before data/props
+    initState(vm);
+    initProvide(vm); // resolve provide after data/props
+    callHook(vm, 'created');
+
+    /* istanbul ignore if */
+    if ("development" !== 'production' && config.performance && perf) {
+      vm._name = formatComponentName(vm, false);
+      perf.mark('init end');
+      perf.measure(((vm._name) + " init"), 'init', 'init end');
+    }
+
+    if (vm.$options.el) {
+      vm.$mount(vm.$options.el);
+    }
+  };
+}
+
+function initInternalComponent (vm, options) {
+  var opts = vm.$options = Object.create(vm.constructor.options);
+  // doing this because it's faster than dynamic enumeration.
+  opts.parent = options.parent;
+  opts.propsData = options.propsData;
+  opts._parentVnode = options._parentVnode;
+  opts._parentListeners = options._parentListeners;
+  opts._renderChildren = options._renderChildren;
+  opts._componentTag = options._componentTag;
+  opts._parentElm = options._parentElm;
+  opts._refElm = options._refElm;
+  if (options.render) {
+    opts.render = options.render;
+    opts.staticRenderFns = options.staticRenderFns;
+  }
+}
+
+function resolveConstructorOptions (Ctor) {
+  var options = Ctor.options;
+  if (Ctor.super) {
+    var superOptions = resolveConstructorOptions(Ctor.super);
+    var cachedSuperOptions = Ctor.superOptions;
+    if (superOptions !== cachedSuperOptions) {
+      // super option changed,
+      // need to resolve new options.
+      Ctor.superOptions = superOptions;
+      // check if there are any late-modified/attached options (#4976)
+      var modifiedOptions = resolveModifiedOptions(Ctor);
+      // update base extend options
+      if (modifiedOptions) {
+        extend(Ctor.extendOptions, modifiedOptions);
+      }
+      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
+      if (options.name) {
+        options.components[options.name] = Ctor;
+      }
+    }
+  }
+  return options
+}
+
+function resolveModifiedOptions (Ctor) {
+  var modified;
+  var latest = Ctor.options;
+  var sealed = Ctor.sealedOptions;
+  for (var key in latest) {
+    if (latest[key] !== sealed[key]) {
+      if (!modified) { modified = {}; }
+      modified[key] = dedupe(latest[key], sealed[key]);
+    }
+  }
+  return modified
+}
+
+function dedupe (latest, sealed) {
+  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
+  // between merges
+  if (Array.isArray(latest)) {
+    var res = [];
+    sealed = Array.isArray(sealed) ? sealed : [sealed];
+    for (var i = 0; i < latest.length; i++) {
+      if (sealed.indexOf(latest[i]) < 0) {
+        res.push(latest[i]);
+      }
+    }
+    return res
+  } else {
+    return latest
+  }
+}
+
+function Vue$2 (options) {
+  if ("development" !== 'production' &&
+    !(this instanceof Vue$2)) {
+    warn('Vue is a constructor and should be called with the `new` keyword');
+  }
+  this._init(options);
+}
+
+initMixin(Vue$2);
+stateMixin(Vue$2);
+eventsMixin(Vue$2);
+lifecycleMixin(Vue$2);
+renderMixin(Vue$2);
+
+/*  */
+
+function initUse (Vue) {
+  Vue.use = function (plugin) {
+    /* istanbul ignore if */
+    if (plugin.installed) {
+      return
+    }
+    // additional parameters
+    var args = toArray(arguments, 1);
+    args.unshift(this);
+    if (typeof plugin.install === 'function') {
+      plugin.install.apply(plugin, args);
+    } else if (typeof plugin === 'function') {
+      plugin.apply(null, args);
+    }
+    plugin.installed = true;
+    return this
+  };
+}
+
+/*  */
+
+function initMixin$1 (Vue) {
+  Vue.mixin = function (mixin) {
+    this.options = mergeOptions(this.options, mixin);
+  };
+}
+
+/*  */
+
+function initExtend (Vue) {
+  /**
+   * Each instance constructor, including Vue, has a unique
+   * cid. This enables us to create wrapped "child
+   * constructors" for prototypal inheritance and cache them.
+   */
+  Vue.cid = 0;
+  var cid = 1;
+
+  /**
+   * Class inheritance
+   */
+  Vue.extend = function (extendOptions) {
+    extendOptions = extendOptions || {};
+    var Super = this;
+    var SuperId = Super.cid;
+    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
+    if (cachedCtors[SuperId]) {
+      return cachedCtors[SuperId]
+    }
+
+    var name = extendOptions.name || Super.options.name;
+    {
+      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+        warn(
+          'Invalid component name: "' + name + '". Component names ' +
+          'can only contain alphanumeric characters and the hyphen, ' +
+          'and must start with a letter.'
+        );
+      }
+    }
+
+    var Sub = function VueComponent (options) {
+      this._init(options);
+    };
+    Sub.prototype = Object.create(Super.prototype);
+    Sub.prototype.constructor = Sub;
+    Sub.cid = cid++;
+    Sub.options = mergeOptions(
+      Super.options,
+      extendOptions
+    );
+    Sub['super'] = Super;
+
+    // For props and computed properties, we define the proxy getters on
+    // the Vue instances at extension time, on the extended prototype. This
+    // avoids Object.defineProperty calls for each instance created.
+    if (Sub.options.props) {
+      initProps$1(Sub);
+    }
+    if (Sub.options.computed) {
+      initComputed$1(Sub);
+    }
+
+    // allow further extension/mixin/plugin usage
+    Sub.extend = Super.extend;
+    Sub.mixin = Super.mixin;
+    Sub.use = Super.use;
+
+    // create asset registers, so extended classes
+    // can have their private assets too.
+    config._assetTypes.forEach(function (type) {
+      Sub[type] = Super[type];
+    });
+    // enable recursive self-lookup
+    if (name) {
+      Sub.options.components[name] = Sub;
+    }
+
+    // keep a reference to the super options at extension time.
+    // later at instantiation we can check if Super's options have
+    // been updated.
+    Sub.superOptions = Super.options;
+    Sub.extendOptions = extendOptions;
+    Sub.sealedOptions = extend({}, Sub.options);
+
+    // cache constructor
+    cachedCtors[SuperId] = Sub;
+    return Sub
+  };
+}
+
+function initProps$1 (Comp) {
+  var props = Comp.options.props;
+  for (var key in props) {
+    proxy(Comp.prototype, "_props", key);
+  }
+}
+
+function initComputed$1 (Comp) {
+  var computed = Comp.options.computed;
+  for (var key in computed) {
+    defineComputed(Comp.prototype, key, computed[key]);
+  }
+}
+
+/*  */
+
+function initAssetRegisters (Vue) {
+  /**
+   * Create asset registration methods.
+   */
+  config._assetTypes.forEach(function (type) {
+    Vue[type] = function (
+      id,
+      definition
+    ) {
+      if (!definition) {
+        return this.options[type + 's'][id]
+      } else {
+        /* istanbul ignore if */
+        {
+          if (type === 'component' && config.isReservedTag(id)) {
+            warn(
+              'Do not use built-in or reserved HTML elements as component ' +
+              'id: ' + id
+            );
+          }
+        }
+        if (type === 'component' && isPlainObject(definition)) {
+          definition.name = definition.name || id;
+          definition = this.options._base.extend(definition);
+        }
+        if (type === 'directive' && typeof definition === 'function') {
+          definition = { bind: definition, update: definition };
+        }
+        this.options[type + 's'][id] = definition;
+        return definition
+      }
+    };
+  });
+}
+
+/*  */
+
+var patternTypes = [String, RegExp];
+
+function getComponentName (opts) {
+  return opts && (opts.Ctor.options.name || opts.tag)
+}
+
+function matches (pattern, name) {
+  if (typeof pattern === 'string') {
+    return pattern.split(',').indexOf(name) > -1
+  } else if (pattern instanceof RegExp) {
+    return pattern.test(name)
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function pruneCache (cache, filter) {
+  for (var key in cache) {
+    var cachedNode = cache[key];
+    if (cachedNode) {
+      var name = getComponentName(cachedNode.componentOptions);
+      if (name && !filter(name)) {
+        pruneCacheEntry(cachedNode);
+        cache[key] = null;
+      }
+    }
+  }
+}
+
+function pruneCacheEntry (vnode) {
+  if (vnode) {
+    if (!vnode.componentInstance._inactive) {
+      callHook(vnode.componentInstance, 'deactivated');
+    }
+    vnode.componentInstance.$destroy();
+  }
+}
+
+var KeepAlive = {
+  name: 'keep-alive',
+  abstract: true,
+
+  props: {
+    include: patternTypes,
+    exclude: patternTypes
+  },
+
+  created: function created () {
+    this.cache = Object.create(null);
+  },
+
+  destroyed: function destroyed () {
+    var this$1 = this;
+
+    for (var key in this$1.cache) {
+      pruneCacheEntry(this$1.cache[key]);
+    }
+  },
+
+  watch: {
+    include: function include (val) {
+      pruneCache(this.cache, function (name) { return matches(val, name); });
+    },
+    exclude: function exclude (val) {
+      pruneCache(this.cache, function (name) { return !matches(val, name); });
+    }
+  },
+
+  render: function render () {
+    var vnode = getFirstComponentChild(this.$slots.default);
+    var componentOptions = vnode && vnode.componentOptions;
+    if (componentOptions) {
+      // check pattern
+      var name = getComponentName(componentOptions);
+      if (name && (
+        (this.include && !matches(this.include, name)) ||
+        (this.exclude && matches(this.exclude, name))
+      )) {
+        return vnode
+      }
+      var key = vnode.key == null
+        // same constructor may get registered as different local components
+        // so cid alone is not enough (#3269)
+        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
+        : vnode.key;
+      if (this.cache[key]) {
+        vnode.componentInstance = this.cache[key].componentInstance;
+      } else {
+        this.cache[key] = vnode;
+      }
+      vnode.data.keepAlive = true;
+    }
+    return vnode
+  }
+};
+
+var builtInComponents = {
+  KeepAlive: KeepAlive
+};
+
+/*  */
+
+function initGlobalAPI (Vue) {
+  // config
+  var configDef = {};
+  configDef.get = function () { return config; };
+  {
+    configDef.set = function () {
+      warn(
+        'Do not replace the Vue.config object, set individual fields instead.'
+      );
+    };
+  }
+  Object.defineProperty(Vue, 'config', configDef);
+
+  // exposed util methods.
+  // NOTE: these are not considered part of the public API - avoid relying on
+  // them unless you are aware of the risk.
+  Vue.util = {
+    warn: warn,
+    extend: extend,
+    mergeOptions: mergeOptions,
+    defineReactive: defineReactive$$1
+  };
+
+  Vue.set = set;
+  Vue.delete = del;
+  Vue.nextTick = nextTick;
+
+  Vue.options = Object.create(null);
+  config._assetTypes.forEach(function (type) {
+    Vue.options[type + 's'] = Object.create(null);
+  });
+
+  // this is used to identify the "base" constructor to extend all plain-object
+  // components with in Weex's multi-instance scenarios.
+  Vue.options._base = Vue;
+
+  extend(Vue.options.components, builtInComponents);
+
+  initUse(Vue);
+  initMixin$1(Vue);
+  initExtend(Vue);
+  initAssetRegisters(Vue);
+}
+
+initGlobalAPI(Vue$2);
+
+Object.defineProperty(Vue$2.prototype, '$isServer', {
+  get: isServerRendering
+});
+
+Vue$2.version = '2.2.2';
+
+/*  */
+
+// attributes that should be using props for binding
+var acceptValue = makeMap('input,textarea,option,select');
+var mustUseProp = function (tag, type, attr) {
+  return (
+    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
+    (attr === 'selected' && tag === 'option') ||
+    (attr === 'checked' && tag === 'input') ||
+    (attr === 'muted' && tag === 'video')
+  )
+};
+
+var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
+
+var isBooleanAttr = makeMap(
+  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
+  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
+  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
+  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
+  'required,reversed,scoped,seamless,selected,sortable,translate,' +
+  'truespeed,typemustmatch,visible'
+);
+
+var xlinkNS = 'http://www.w3.org/1999/xlink';
+
+var isXlink = function (name) {
+  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
+};
+
+var getXlinkProp = function (name) {
+  return isXlink(name) ? name.slice(6, name.length) : ''
+};
+
+var isFalsyAttrValue = function (val) {
+  return val == null || val === false
+};
+
+/*  */
+
+function genClassForVnode (vnode) {
+  var data = vnode.data;
+  var parentNode = vnode;
+  var childNode = vnode;
+  while (childNode.componentInstance) {
+    childNode = childNode.componentInstance._vnode;
+    if (childNode.data) {
+      data = mergeClassData(childNode.data, data);
+    }
+  }
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data) {
+      data = mergeClassData(data, parentNode.data);
+    }
+  }
+  return genClassFromData(data)
+}
+
+function mergeClassData (child, parent) {
+  return {
+    staticClass: concat(child.staticClass, parent.staticClass),
+    class: child.class
+      ? [child.class, parent.class]
+      : parent.class
+  }
+}
+
+function genClassFromData (data) {
+  var dynamicClass = data.class;
+  var staticClass = data.staticClass;
+  if (staticClass || dynamicClass) {
+    return concat(staticClass, stringifyClass(dynamicClass))
+  }
+  /* istanbul ignore next */
+  return ''
+}
+
+function concat (a, b) {
+  return a ? b ? (a + ' ' + b) : a : (b || '')
+}
+
+function stringifyClass (value) {
+  var res = '';
+  if (!value) {
+    return res
+  }
+  if (typeof value === 'string') {
+    return value
+  }
+  if (Array.isArray(value)) {
+    var stringified;
+    for (var i = 0, l = value.length; i < l; i++) {
+      if (value[i]) {
+        if ((stringified = stringifyClass(value[i]))) {
+          res += stringified + ' ';
+        }
+      }
+    }
+    return res.slice(0, -1)
+  }
+  if (isObject(value)) {
+    for (var key in value) {
+      if (value[key]) { res += key + ' '; }
+    }
+    return res.slice(0, -1)
+  }
+  /* istanbul ignore next */
+  return res
+}
+
+/*  */
+
+var namespaceMap = {
+  svg: 'http://www.w3.org/2000/svg',
+  math: 'http://www.w3.org/1998/Math/MathML'
+};
+
+var isHTMLTag = makeMap(
+  'html,body,base,head,link,meta,style,title,' +
+  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
+  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
+  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
+  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
+  'embed,object,param,source,canvas,script,noscript,del,ins,' +
+  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
+  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
+  'output,progress,select,textarea,' +
+  'details,dialog,menu,menuitem,summary,' +
+  'content,element,shadow,template'
+);
+
+// this map is intentionally selective, only covering SVG elements that may
+// contain child elements.
+var isSVG = makeMap(
+  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
+  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
+  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
+  true
+);
+
+
+
+var isReservedTag = function (tag) {
+  return isHTMLTag(tag) || isSVG(tag)
+};
+
+function getTagNamespace (tag) {
+  if (isSVG(tag)) {
+    return 'svg'
+  }
+  // basic support for MathML
+  // note it doesn't support other MathML elements being component roots
+  if (tag === 'math') {
+    return 'math'
+  }
+}
+
+var unknownElementCache = Object.create(null);
+function isUnknownElement (tag) {
+  /* istanbul ignore if */
+  if (!inBrowser) {
+    return true
+  }
+  if (isReservedTag(tag)) {
+    return false
+  }
+  tag = tag.toLowerCase();
+  /* istanbul ignore if */
+  if (unknownElementCache[tag] != null) {
+    return unknownElementCache[tag]
+  }
+  var el = document.createElement(tag);
+  if (tag.indexOf('-') > -1) {
+    // http://stackoverflow.com/a/28210364/1070244
+    return (unknownElementCache[tag] = (
+      el.constructor === window.HTMLUnknownElement ||
+      el.constructor === window.HTMLElement
+    ))
+  } else {
+    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
+  }
+}
+
+/*  */
+
+/**
+ * Query an element selector if it's not an element already.
+ */
+function query (el) {
+  if (typeof el === 'string') {
+    var selected = document.querySelector(el);
+    if (!selected) {
+      "development" !== 'production' && warn(
+        'Cannot find element: ' + el
+      );
+      return document.createElement('div')
+    }
+    return selected
+  } else {
+    return el
+  }
+}
+
+/*  */
+
+function createElement$1 (tagName, vnode) {
+  var elm = document.createElement(tagName);
+  if (tagName !== 'select') {
+    return elm
+  }
+  // false or null will remove the attribute but undefined will not
+  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
+    elm.setAttribute('multiple', 'multiple');
+  }
+  return elm
+}
+
+function createElementNS (namespace, tagName) {
+  return document.createElementNS(namespaceMap[namespace], tagName)
+}
+
+function createTextNode (text) {
+  return document.createTextNode(text)
+}
+
+function createComment (text) {
+  return document.createComment(text)
+}
+
+function insertBefore (parentNode, newNode, referenceNode) {
+  parentNode.insertBefore(newNode, referenceNode);
+}
+
+function removeChild (node, child) {
+  node.removeChild(child);
+}
+
+function appendChild (node, child) {
+  node.appendChild(child);
+}
+
+function parentNode (node) {
+  return node.parentNode
+}
+
+function nextSibling (node) {
+  return node.nextSibling
+}
+
+function tagName (node) {
+  return node.tagName
+}
+
+function setTextContent (node, text) {
+  node.textContent = text;
+}
+
+function setAttribute (node, key, val) {
+  node.setAttribute(key, val);
+}
+
+
+var nodeOps = Object.freeze({
+	createElement: createElement$1,
+	createElementNS: createElementNS,
+	createTextNode: createTextNode,
+	createComment: createComment,
+	insertBefore: insertBefore,
+	removeChild: removeChild,
+	appendChild: appendChild,
+	parentNode: parentNode,
+	nextSibling: nextSibling,
+	tagName: tagName,
+	setTextContent: setTextContent,
+	setAttribute: setAttribute
+});
+
+/*  */
+
+var ref = {
+  create: function create (_, vnode) {
+    registerRef(vnode);
+  },
+  update: function update (oldVnode, vnode) {
+    if (oldVnode.data.ref !== vnode.data.ref) {
+      registerRef(oldVnode, true);
+      registerRef(vnode);
+    }
+  },
+  destroy: function destroy (vnode) {
+    registerRef(vnode, true);
+  }
+};
+
+function registerRef (vnode, isRemoval) {
+  var key = vnode.data.ref;
+  if (!key) { return }
+
+  var vm = vnode.context;
+  var ref = vnode.componentInstance || vnode.elm;
+  var refs = vm.$refs;
+  if (isRemoval) {
+    if (Array.isArray(refs[key])) {
+      remove(refs[key], ref);
+    } else if (refs[key] === ref) {
+      refs[key] = undefined;
+    }
+  } else {
+    if (vnode.data.refInFor) {
+      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
+        refs[key].push(ref);
+      } else {
+        refs[key] = [ref];
+      }
+    } else {
+      refs[key] = ref;
+    }
+  }
+}
+
+/**
+ * Virtual DOM patching algorithm based on Snabbdom by
+ * Simon Friis Vindum (@paldepind)
+ * Licensed under the MIT License
+ * https://github.com/paldepind/snabbdom/blob/master/LICENSE
+ *
+ * modified by Evan You (@yyx990803)
+ *
+
+/*
+ * Not type-checking this because this file is perf-critical and the cost
+ * of making flow understand it is not worth it.
+ */
+
+var emptyNode = new VNode('', {}, []);
+
+var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];
+
+function isUndef (s) {
+  return s == null
+}
+
+function isDef (s) {
+  return s != null
+}
+
+function sameVnode (vnode1, vnode2) {
+  return (
+    vnode1.key === vnode2.key &&
+    vnode1.tag === vnode2.tag &&
+    vnode1.isComment === vnode2.isComment &&
+    !vnode1.data === !vnode2.data
+  )
+}
+
+function createKeyToOldIdx (children, beginIdx, endIdx) {
+  var i, key;
+  var map = {};
+  for (i = beginIdx; i <= endIdx; ++i) {
+    key = children[i].key;
+    if (isDef(key)) { map[key] = i; }
+  }
+  return map
+}
+
+function createPatchFunction (backend) {
+  var i, j;
+  var cbs = {};
+
+  var modules = backend.modules;
+  var nodeOps = backend.nodeOps;
+
+  for (i = 0; i < hooks$1.length; ++i) {
+    cbs[hooks$1[i]] = [];
+    for (j = 0; j < modules.length; ++j) {
+      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
+    }
+  }
+
+  function emptyNodeAt (elm) {
+    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
+  }
+
+  function createRmCb (childElm, listeners) {
+    function remove$$1 () {
+      if (--remove$$1.listeners === 0) {
+        removeNode(childElm);
+      }
+    }
+    remove$$1.listeners = listeners;
+    return remove$$1
+  }
+
+  function removeNode (el) {
+    var parent = nodeOps.parentNode(el);
+    // element may have already been removed due to v-html / v-text
+    if (parent) {
+      nodeOps.removeChild(parent, el);
+    }
+  }
+
+  var inPre = 0;
+  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
+    vnode.isRootInsert = !nested; // for transition enter check
+    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
+      return
+    }
+
+    var data = vnode.data;
+    var children = vnode.children;
+    var tag = vnode.tag;
+    if (isDef(tag)) {
+      {
+        if (data && data.pre) {
+          inPre++;
+        }
+        if (
+          !inPre &&
+          !vnode.ns &&
+          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
+          config.isUnknownElement(tag)
+        ) {
+          warn(
+            'Unknown custom element: <' + tag + '> - did you ' +
+            'register the component correctly? For recursive components, ' +
+            'make sure to provide the "name" option.',
+            vnode.context
+          );
+        }
+      }
+      vnode.elm = vnode.ns
+        ? nodeOps.createElementNS(vnode.ns, tag)
+        : nodeOps.createElement(tag, vnode);
+      setScope(vnode);
+
+      /* istanbul ignore if */
+      {
+        createChildren(vnode, children, insertedVnodeQueue);
+        if (isDef(data)) {
+          invokeCreateHooks(vnode, insertedVnodeQueue);
+        }
+        insert(parentElm, vnode.elm, refElm);
+      }
+
+      if ("development" !== 'production' && data && data.pre) {
+        inPre--;
+      }
+    } else if (vnode.isComment) {
+      vnode.elm = nodeOps.createComment(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    } else {
+      vnode.elm = nodeOps.createTextNode(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    }
+  }
+
+  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i = vnode.data;
+    if (isDef(i)) {
+      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
+      if (isDef(i = i.hook) && isDef(i = i.init)) {
+        i(vnode, false /* hydrating */, parentElm, refElm);
+      }
+      // after calling the init hook, if the vnode is a child component
+      // it should've created a child instance and mounted it. the child
+      // component also has set the placeholder vnode's elm.
+      // in that case we can just return the element and be done.
+      if (isDef(vnode.componentInstance)) {
+        initComponent(vnode, insertedVnodeQueue);
+        if (isReactivated) {
+          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
+        }
+        return true
+      }
+    }
+  }
+
+  function initComponent (vnode, insertedVnodeQueue) {
+    if (vnode.data.pendingInsert) {
+      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
+    }
+    vnode.elm = vnode.componentInstance.$el;
+    if (isPatchable(vnode)) {
+      invokeCreateHooks(vnode, insertedVnodeQueue);
+      setScope(vnode);
+    } else {
+      // empty component root.
+      // skip all element-related modules except for ref (#3455)
+      registerRef(vnode);
+      // make sure to invoke the insert hook
+      insertedVnodeQueue.push(vnode);
+    }
+  }
+
+  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i;
+    // hack for #4339: a reactivated component with inner transition
+    // does not trigger because the inner node's created hooks are not called
+    // again. It's not ideal to involve module-specific logic in here but
+    // there doesn't seem to be a better way to do it.
+    var innerNode = vnode;
+    while (innerNode.componentInstance) {
+      innerNode = innerNode.componentInstance._vnode;
+      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
+        for (i = 0; i < cbs.activate.length; ++i) {
+          cbs.activate[i](emptyNode, innerNode);
+        }
+        insertedVnodeQueue.push(innerNode);
+        break
+      }
+    }
+    // unlike a newly created component,
+    // a reactivated keep-alive component doesn't insert itself
+    insert(parentElm, vnode.elm, refElm);
+  }
+
+  function insert (parent, elm, ref) {
+    if (parent) {
+      if (ref) {
+        nodeOps.insertBefore(parent, elm, ref);
+      } else {
+        nodeOps.appendChild(parent, elm);
+      }
+    }
+  }
+
+  function createChildren (vnode, children, insertedVnodeQueue) {
+    if (Array.isArray(children)) {
+      for (var i = 0; i < children.length; ++i) {
+        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
+      }
+    } else if (isPrimitive(vnode.text)) {
+      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
+    }
+  }
+
+  function isPatchable (vnode) {
+    while (vnode.componentInstance) {
+      vnode = vnode.componentInstance._vnode;
+    }
+    return isDef(vnode.tag)
+  }
+
+  function invokeCreateHooks (vnode, insertedVnodeQueue) {
+    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
+      cbs.create[i$1](emptyNode, vnode);
+    }
+    i = vnode.data.hook; // Reuse variable
+    if (isDef(i)) {
+      if (i.create) { i.create(emptyNode, vnode); }
+      if (i.insert) { insertedVnodeQueue.push(vnode); }
+    }
+  }
+
+  // set scope id attribute for scoped CSS.
+  // this is implemented as a special case to avoid the overhead
+  // of going through the normal attribute patching process.
+  function setScope (vnode) {
+    var i;
+    var ancestor = vnode;
+    while (ancestor) {
+      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
+        nodeOps.setAttribute(vnode.elm, i, '');
+      }
+      ancestor = ancestor.parent;
+    }
+    // for slot content they should also get the scopeId from the host instance.
+    if (isDef(i = activeInstance) &&
+        i !== vnode.context &&
+        isDef(i = i.$options._scopeId)) {
+      nodeOps.setAttribute(vnode.elm, i, '');
+    }
+  }
+
+  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
+    }
+  }
+
+  function invokeDestroyHook (vnode) {
+    var i, j;
+    var data = vnode.data;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
+      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
+    }
+    if (isDef(i = vnode.children)) {
+      for (j = 0; j < vnode.children.length; ++j) {
+        invokeDestroyHook(vnode.children[j]);
+      }
+    }
+  }
+
+  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      var ch = vnodes[startIdx];
+      if (isDef(ch)) {
+        if (isDef(ch.tag)) {
+          removeAndInvokeRemoveHook(ch);
+          invokeDestroyHook(ch);
+        } else { // Text node
+          removeNode(ch.elm);
+        }
+      }
+    }
+  }
+
+  function removeAndInvokeRemoveHook (vnode, rm) {
+    if (rm || isDef(vnode.data)) {
+      var listeners = cbs.remove.length + 1;
+      if (!rm) {
+        // directly removing
+        rm = createRmCb(vnode.elm, listeners);
+      } else {
+        // we have a recursively passed down rm callback
+        // increase the listeners count
+        rm.listeners += listeners;
+      }
+      // recursively invoke hooks on child component root node
+      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
+        removeAndInvokeRemoveHook(i, rm);
+      }
+      for (i = 0; i < cbs.remove.length; ++i) {
+        cbs.remove[i](vnode, rm);
+      }
+      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
+        i(vnode, rm);
+      } else {
+        rm();
+      }
+    } else {
+      removeNode(vnode.elm);
+    }
+  }
+
+  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
+    var oldStartIdx = 0;
+    var newStartIdx = 0;
+    var oldEndIdx = oldCh.length - 1;
+    var oldStartVnode = oldCh[0];
+    var oldEndVnode = oldCh[oldEndIdx];
+    var newEndIdx = newCh.length - 1;
+    var newStartVnode = newCh[0];
+    var newEndVnode = newCh[newEndIdx];
+    var oldKeyToIdx, idxInOld, elmToMove, refElm;
+
+    // removeOnly is a special flag used only by <transition-group>
+    // to ensure removed elements stay in correct relative positions
+    // during leaving transitions
+    var canMove = !removeOnly;
+
+    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
+      if (isUndef(oldStartVnode)) {
+        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
+      } else if (isUndef(oldEndVnode)) {
+        oldEndVnode = oldCh[--oldEndIdx];
+      } else if (sameVnode(oldStartVnode, newStartVnode)) {
+        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
+        oldStartVnode = oldCh[++oldStartIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else if (sameVnode(oldEndVnode, newEndVnode)) {
+        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
+        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
+        oldStartVnode = oldCh[++oldStartIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
+        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else {
+        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
+        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
+        if (isUndef(idxInOld)) { // New element
+          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+          newStartVnode = newCh[++newStartIdx];
+        } else {
+          elmToMove = oldCh[idxInOld];
+          /* istanbul ignore if */
+          if ("development" !== 'production' && !elmToMove) {
+            warn(
+              'It seems there are duplicate keys that is causing an update error. ' +
+              'Make sure each v-for item has a unique key.'
+            );
+          }
+          if (sameVnode(elmToMove, newStartVnode)) {
+            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
+            oldCh[idxInOld] = undefined;
+            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          } else {
+            // same key but different element. treat as new element
+            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          }
+        }
+      }
+    }
+    if (oldStartIdx > oldEndIdx) {
+      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
+      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
+    } else if (newStartIdx > newEndIdx) {
+      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
+    }
+  }
+
+  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
+    if (oldVnode === vnode) {
+      return
+    }
+    // reuse element for static trees.
+    // note we only do this if the vnode is cloned -
+    // if the new node is not cloned it means the render functions have been
+    // reset by the hot-reload-api and we need to do a proper re-render.
+    if (vnode.isStatic &&
+        oldVnode.isStatic &&
+        vnode.key === oldVnode.key &&
+        (vnode.isCloned || vnode.isOnce)) {
+      vnode.elm = oldVnode.elm;
+      vnode.componentInstance = oldVnode.componentInstance;
+      return
+    }
+    var i;
+    var data = vnode.data;
+    var hasData = isDef(data);
+    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
+      i(oldVnode, vnode);
+    }
+    var elm = vnode.elm = oldVnode.elm;
+    var oldCh = oldVnode.children;
+    var ch = vnode.children;
+    if (hasData && isPatchable(vnode)) {
+      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
+      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
+    }
+    if (isUndef(vnode.text)) {
+      if (isDef(oldCh) && isDef(ch)) {
+        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
+      } else if (isDef(ch)) {
+        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
+        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
+      } else if (isDef(oldCh)) {
+        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
+      } else if (isDef(oldVnode.text)) {
+        nodeOps.setTextContent(elm, '');
+      }
+    } else if (oldVnode.text !== vnode.text) {
+      nodeOps.setTextContent(elm, vnode.text);
+    }
+    if (hasData) {
+      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
+    }
+  }
+
+  function invokeInsertHook (vnode, queue, initial) {
+    // delay insert hooks for component root nodes, invoke them after the
+    // element is really inserted
+    if (initial && vnode.parent) {
+      vnode.parent.data.pendingInsert = queue;
+    } else {
+      for (var i = 0; i < queue.length; ++i) {
+        queue[i].data.hook.insert(queue[i]);
+      }
+    }
+  }
+
+  var bailed = false;
+  // list of modules that can skip create hook during hydration because they
+  // are already rendered on the client or has no need for initialization
+  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
+
+  // Note: this is a browser-only function so we can assume elms are DOM nodes.
+  function hydrate (elm, vnode, insertedVnodeQueue) {
+    {
+      if (!assertNodeMatch(elm, vnode)) {
+        return false
+      }
+    }
+    vnode.elm = elm;
+    var tag = vnode.tag;
+    var data = vnode.data;
+    var children = vnode.children;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
+      if (isDef(i = vnode.componentInstance)) {
+        // child component. it should have hydrated its own tree.
+        initComponent(vnode, insertedVnodeQueue);
+        return true
+      }
+    }
+    if (isDef(tag)) {
+      if (isDef(children)) {
+        // empty element, allow client to pick up and populate children
+        if (!elm.hasChildNodes()) {
+          createChildren(vnode, children, insertedVnodeQueue);
+        } else {
+          var childrenMatch = true;
+          var childNode = elm.firstChild;
+          for (var i$1 = 0; i$1 < children.length; i$1++) {
+            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
+              childrenMatch = false;
+              break
+            }
+            childNode = childNode.nextSibling;
+          }
+          // if childNode is not null, it means the actual childNodes list is
+          // longer than the virtual children list.
+          if (!childrenMatch || childNode) {
+            if ("development" !== 'production' &&
+                typeof console !== 'undefined' &&
+                !bailed) {
+              bailed = true;
+              console.warn('Parent: ', elm);
+              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
+            }
+            return false
+          }
+        }
+      }
+      if (isDef(data)) {
+        for (var key in data) {
+          if (!isRenderedModule(key)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue);
+            break
+          }
+        }
+      }
+    } else if (elm.data !== vnode.text) {
+      elm.data = vnode.text;
+    }
+    return true
+  }
+
+  function assertNodeMatch (node, vnode) {
+    if (vnode.tag) {
+      return (
+        vnode.tag.indexOf('vue-component') === 0 ||
+        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
+      )
+    } else {
+      return node.nodeType === (vnode.isComment ? 8 : 3)
+    }
+  }
+
+  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
+    if (!vnode) {
+      if (oldVnode) { invokeDestroyHook(oldVnode); }
+      return
+    }
+
+    var isInitialPatch = false;
+    var insertedVnodeQueue = [];
+
+    if (!oldVnode) {
+      // empty mount (likely as component), create new root element
+      isInitialPatch = true;
+      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
+    } else {
+      var isRealElement = isDef(oldVnode.nodeType);
+      if (!isRealElement && sameVnode(oldVnode, vnode)) {
+        // patch existing root node
+        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
+      } else {
+        if (isRealElement) {
+          // mounting to a real element
+          // check if this is server-rendered content and if we can perform
+          // a successful hydration.
+          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
+            oldVnode.removeAttribute('server-rendered');
+            hydrating = true;
+          }
+          if (hydrating) {
+            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
+              invokeInsertHook(vnode, insertedVnodeQueue, true);
+              return oldVnode
+            } else {
+              warn(
+                'The client-side rendered virtual DOM tree is not matching ' +
+                'server-rendered content. This is likely caused by incorrect ' +
+                'HTML markup, for example nesting block-level elements inside ' +
+                '<p>, or missing <tbody>. Bailing hydration and performing ' +
+                'full client-side render.'
+              );
+            }
+          }
+          // either not server-rendered, or hydration failed.
+          // create an empty node and replace it
+          oldVnode = emptyNodeAt(oldVnode);
+        }
+        // replacing existing element
+        var oldElm = oldVnode.elm;
+        var parentElm$1 = nodeOps.parentNode(oldElm);
+        createElm(
+          vnode,
+          insertedVnodeQueue,
+          // extremely rare edge case: do not insert if old element is in a
+          // leaving transition. Only happens when combining transition +
+          // keep-alive + HOCs. (#4590)
+          oldElm._leaveCb ? null : parentElm$1,
+          nodeOps.nextSibling(oldElm)
+        );
+
+        if (vnode.parent) {
+          // component root element replaced.
+          // update parent placeholder node element, recursively
+          var ancestor = vnode.parent;
+          while (ancestor) {
+            ancestor.elm = vnode.elm;
+            ancestor = ancestor.parent;
+          }
+          if (isPatchable(vnode)) {
+            for (var i = 0; i < cbs.create.length; ++i) {
+              cbs.create[i](emptyNode, vnode.parent);
+            }
+          }
+        }
+
+        if (parentElm$1 !== null) {
+          removeVnodes(parentElm$1, [oldVnode], 0, 0);
+        } else if (isDef(oldVnode.tag)) {
+          invokeDestroyHook(oldVnode);
+        }
+      }
+    }
+
+    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
+    return vnode.elm
+  }
+}
+
+/*  */
+
+var directives = {
+  create: updateDirectives,
+  update: updateDirectives,
+  destroy: function unbindDirectives (vnode) {
+    updateDirectives(vnode, emptyNode);
+  }
+};
+
+function updateDirectives (oldVnode, vnode) {
+  if (oldVnode.data.directives || vnode.data.directives) {
+    _update(oldVnode, vnode);
+  }
+}
+
+function _update (oldVnode, vnode) {
+  var isCreate = oldVnode === emptyNode;
+  var isDestroy = vnode === emptyNode;
+  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
+  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
+
+  var dirsWithInsert = [];
+  var dirsWithPostpatch = [];
+
+  var key, oldDir, dir;
+  for (key in newDirs) {
+    oldDir = oldDirs[key];
+    dir = newDirs[key];
+    if (!oldDir) {
+      // new directive, bind
+      callHook$1(dir, 'bind', vnode, oldVnode);
+      if (dir.def && dir.def.inserted) {
+        dirsWithInsert.push(dir);
+      }
+    } else {
+      // existing directive, update
+      dir.oldValue = oldDir.value;
+      callHook$1(dir, 'update', vnode, oldVnode);
+      if (dir.def && dir.def.componentUpdated) {
+        dirsWithPostpatch.push(dir);
+      }
+    }
+  }
+
+  if (dirsWithInsert.length) {
+    var callInsert = function () {
+      for (var i = 0; i < dirsWithInsert.length; i++) {
+        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
+      }
+    };
+    if (isCreate) {
+      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
+    } else {
+      callInsert();
+    }
+  }
+
+  if (dirsWithPostpatch.length) {
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
+      for (var i = 0; i < dirsWithPostpatch.length; i++) {
+        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
+      }
+    });
+  }
+
+  if (!isCreate) {
+    for (key in oldDirs) {
+      if (!newDirs[key]) {
+        // no longer present, unbind
+        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
+      }
+    }
+  }
+}
+
+var emptyModifiers = Object.create(null);
+
+function normalizeDirectives$1 (
+  dirs,
+  vm
+) {
+  var res = Object.create(null);
+  if (!dirs) {
+    return res
+  }
+  var i, dir;
+  for (i = 0; i < dirs.length; i++) {
+    dir = dirs[i];
+    if (!dir.modifiers) {
+      dir.modifiers = emptyModifiers;
+    }
+    res[getRawDirName(dir)] = dir;
+    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
+  }
+  return res
+}
+
+function getRawDirName (dir) {
+  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
+}
+
+function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
+  var fn = dir.def && dir.def[hook];
+  if (fn) {
+    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
+  }
+}
+
+var baseModules = [
+  ref,
+  directives
+];
+
+/*  */
+
+function updateAttrs (oldVnode, vnode) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  var key, cur, old;
+  var elm = vnode.elm;
+  var oldAttrs = oldVnode.data.attrs || {};
+  var attrs = vnode.data.attrs || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs);
+  }
+
+  for (key in attrs) {
+    cur = attrs[key];
+    old = oldAttrs[key];
+    if (old !== cur) {
+      setAttr(elm, key, cur);
+    }
+  }
+  // #4391: in IE9, setting type can reset value for input[type=radio]
+  /* istanbul ignore if */
+  if (isIE9 && attrs.value !== oldAttrs.value) {
+    setAttr(elm, 'value', attrs.value);
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      if (isXlink(key)) {
+        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
+      } else if (!isEnumeratedAttr(key)) {
+        elm.removeAttribute(key);
+      }
+    }
+  }
+}
+
+function setAttr (el, key, value) {
+  if (isBooleanAttr(key)) {
+    // set attribute for blank value
+    // e.g. <option disabled>Select one</option>
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, key);
+    }
+  } else if (isEnumeratedAttr(key)) {
+    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
+  } else if (isXlink(key)) {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
+    } else {
+      el.setAttributeNS(xlinkNS, key, value);
+    }
+  } else {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, value);
+    }
+  }
+}
+
+var attrs = {
+  create: updateAttrs,
+  update: updateAttrs
+};
+
+/*  */
+
+function updateClass (oldVnode, vnode) {
+  var el = vnode.elm;
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  var cls = genClassForVnode(vnode);
+
+  // handle transition classes
+  var transitionClass = el._transitionClasses;
+  if (transitionClass) {
+    cls = concat(cls, stringifyClass(transitionClass));
+  }
+
+  // set the class
+  if (cls !== el._prevClass) {
+    el.setAttribute('class', cls);
+    el._prevClass = cls;
+  }
+}
+
+var klass = {
+  create: updateClass,
+  update: updateClass
+};
+
+/*  */
+
+var validDivisionCharRE = /[\w).+\-_$\]]/;
+
+
+
+function wrapFilter (exp, filter) {
+  var i = filter.indexOf('(');
+  if (i < 0) {
+    // _f: resolveFilter
+    return ("_f(\"" + filter + "\")(" + exp + ")")
+  } else {
+    var name = filter.slice(0, i);
+    var args = filter.slice(i + 1);
+    return ("_f(\"" + name + "\")(" + exp + "," + args)
+  }
+}
+
+/*  */
+
+/*  */
+
+/**
+ * Cross-platform code generation for component v-model
+ */
+
+
+/**
+ * Cross-platform codegen helper for generating v-model value assignment code.
+ */
+
+
+/**
+ * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
+ *
+ * for loop possible cases:
+ *
+ * - test
+ * - test[idx]
+ * - test[test1[idx]]
+ * - test["a"][idx]
+ * - xxx.test[a[a].test1[idx]]
+ * - test.xxx.a["asa"][test1[idx]]
+ *
+ */
+
+var str;
+var index$1;
+
+/*  */
+
+// in some cases, the event used has to be determined at runtime
+// so we used some reserved tokens during compile.
+var RANGE_TOKEN = '__r';
+var CHECKBOX_RADIO_TOKEN = '__c';
+
+/*  */
+
+// normalize v-model event tokens that can only be determined at runtime.
+// it's important to place the event as the first in the array because
+// the whole point is ensuring the v-model callback gets called before
+// user-attached handlers.
+function normalizeEvents (on) {
+  var event;
+  /* istanbul ignore if */
+  if (on[RANGE_TOKEN]) {
+    // IE input[type=range] only supports `change` event
+    event = isIE ? 'change' : 'input';
+    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
+    delete on[RANGE_TOKEN];
+  }
+  if (on[CHECKBOX_RADIO_TOKEN]) {
+    // Chrome fires microtasks in between click/change, leads to #4521
+    event = isChrome ? 'click' : 'change';
+    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
+    delete on[CHECKBOX_RADIO_TOKEN];
+  }
+}
+
+var target$1;
+
+function add$1 (
+  event,
+  handler,
+  once,
+  capture
+) {
+  if (once) {
+    var oldHandler = handler;
+    var _target = target$1; // save current target element in closure
+    handler = function (ev) {
+      var res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments);
+      if (res !== null) {
+        remove$2(event, handler, capture, _target);
+      }
+    };
+  }
+  target$1.addEventListener(event, handler, capture);
+}
+
+function remove$2 (
+  event,
+  handler,
+  capture,
+  _target
+) {
+  (_target || target$1).removeEventListener(event, handler, capture);
+}
+
+function updateDOMListeners (oldVnode, vnode) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  var on = vnode.data.on || {};
+  var oldOn = oldVnode.data.on || {};
+  target$1 = vnode.elm;
+  normalizeEvents(on);
+  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
+}
+
+var events = {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+};
+
+/*  */
+
+function updateDOMProps (oldVnode, vnode) {
+  if (!oldVnode.data.domProps && !vnode.data.domProps) {
+    return
+  }
+  var key, cur;
+  var elm = vnode.elm;
+  var oldProps = oldVnode.data.domProps || {};
+  var props = vnode.data.domProps || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (props.__ob__) {
+    props = vnode.data.domProps = extend({}, props);
+  }
+
+  for (key in oldProps) {
+    if (props[key] == null) {
+      elm[key] = '';
+    }
+  }
+  for (key in props) {
+    cur = props[key];
+    // ignore children if the node has textContent or innerHTML,
+    // as these will throw away existing DOM nodes and cause removal errors
+    // on subsequent patches (#3360)
+    if (key === 'textContent' || key === 'innerHTML') {
+      if (vnode.children) { vnode.children.length = 0; }
+      if (cur === oldProps[key]) { continue }
+    }
+
+    if (key === 'value') {
+      // store value as _value as well since
+      // non-string values will be stringified
+      elm._value = cur;
+      // avoid resetting cursor position when value is the same
+      var strCur = cur == null ? '' : String(cur);
+      if (shouldUpdateValue(elm, vnode, strCur)) {
+        elm.value = strCur;
+      }
+    } else {
+      elm[key] = cur;
+    }
+  }
+}
+
+// check platforms/web/util/attrs.js acceptValue
+
+
+function shouldUpdateValue (
+  elm,
+  vnode,
+  checkVal
+) {
+  return (!elm.composing && (
+    vnode.tag === 'option' ||
+    isDirty(elm, checkVal) ||
+    isInputChanged(elm, checkVal)
+  ))
+}
+
+function isDirty (elm, checkVal) {
+  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
+  return document.activeElement !== elm && elm.value !== checkVal
+}
+
+function isInputChanged (elm, newVal) {
+  var value = elm.value;
+  var modifiers = elm._vModifiers; // injected by v-model runtime
+  if ((modifiers && modifiers.number) || elm.type === 'number') {
+    return toNumber(value) !== toNumber(newVal)
+  }
+  if (modifiers && modifiers.trim) {
+    return value.trim() !== newVal.trim()
+  }
+  return value !== newVal
+}
+
+var domProps = {
+  create: updateDOMProps,
+  update: updateDOMProps
+};
+
+/*  */
+
+var parseStyleText = cached(function (cssText) {
+  var res = {};
+  var listDelimiter = /;(?![^(]*\))/g;
+  var propertyDelimiter = /:(.+)/;
+  cssText.split(listDelimiter).forEach(function (item) {
+    if (item) {
+      var tmp = item.split(propertyDelimiter);
+      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
+    }
+  });
+  return res
+});
+
+// merge static and dynamic style data on the same vnode
+function normalizeStyleData (data) {
+  var style = normalizeStyleBinding(data.style);
+  // static style is pre-processed into an object during compilation
+  // and is always a fresh object, so it's safe to merge into it
+  return data.staticStyle
+    ? extend(data.staticStyle, style)
+    : style
+}
+
+// normalize possible array / string values into Object
+function normalizeStyleBinding (bindingStyle) {
+  if (Array.isArray(bindingStyle)) {
+    return toObject(bindingStyle)
+  }
+  if (typeof bindingStyle === 'string') {
+    return parseStyleText(bindingStyle)
+  }
+  return bindingStyle
+}
+
+/**
+ * parent component style should be after child's
+ * so that parent component's style could override it
+ */
+function getStyle (vnode, checkChild) {
+  var res = {};
+  var styleData;
+
+  if (checkChild) {
+    var childNode = vnode;
+    while (childNode.componentInstance) {
+      childNode = childNode.componentInstance._vnode;
+      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
+        extend(res, styleData);
+      }
+    }
+  }
+
+  if ((styleData = normalizeStyleData(vnode.data))) {
+    extend(res, styleData);
+  }
+
+  var parentNode = vnode;
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
+      extend(res, styleData);
+    }
+  }
+  return res
+}
+
+/*  */
+
+var cssVarRE = /^--/;
+var importantRE = /\s*!important$/;
+var setProp = function (el, name, val) {
+  /* istanbul ignore if */
+  if (cssVarRE.test(name)) {
+    el.style.setProperty(name, val);
+  } else if (importantRE.test(val)) {
+    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
+  } else {
+    el.style[normalize(name)] = val;
+  }
+};
+
+var prefixes = ['Webkit', 'Moz', 'ms'];
+
+var testEl;
+var normalize = cached(function (prop) {
+  testEl = testEl || document.createElement('div');
+  prop = camelize(prop);
+  if (prop !== 'filter' && (prop in testEl.style)) {
+    return prop
+  }
+  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
+  for (var i = 0; i < prefixes.length; i++) {
+    var prefixed = prefixes[i] + upper;
+    if (prefixed in testEl.style) {
+      return prefixed
+    }
+  }
+});
+
+function updateStyle (oldVnode, vnode) {
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+
+  if (!data.staticStyle && !data.style &&
+      !oldData.staticStyle && !oldData.style) {
+    return
+  }
+
+  var cur, name;
+  var el = vnode.elm;
+  var oldStaticStyle = oldVnode.data.staticStyle;
+  var oldStyleBinding = oldVnode.data.style || {};
+
+  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
+  var oldStyle = oldStaticStyle || oldStyleBinding;
+
+  var style = normalizeStyleBinding(vnode.data.style) || {};
+
+  vnode.data.style = style.__ob__ ? extend({}, style) : style;
+
+  var newStyle = getStyle(vnode, true);
+
+  for (name in oldStyle) {
+    if (newStyle[name] == null) {
+      setProp(el, name, '');
+    }
+  }
+  for (name in newStyle) {
+    cur = newStyle[name];
+    if (cur !== oldStyle[name]) {
+      // ie9 setting to null has no effect, must use empty string
+      setProp(el, name, cur == null ? '' : cur);
+    }
+  }
+}
+
+var style = {
+  create: updateStyle,
+  update: updateStyle
+};
+
+/*  */
+
+/**
+ * Add class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function addClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
+    } else {
+      el.classList.add(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    if (cur.indexOf(' ' + cls + ' ') < 0) {
+      el.setAttribute('class', (cur + cls).trim());
+    }
+  }
+}
+
+/**
+ * Remove class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function removeClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
+    } else {
+      el.classList.remove(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    var tar = ' ' + cls + ' ';
+    while (cur.indexOf(tar) >= 0) {
+      cur = cur.replace(tar, ' ');
+    }
+    el.setAttribute('class', cur.trim());
+  }
+}
+
+/*  */
+
+function resolveTransition (def$$1) {
+  if (!def$$1) {
+    return
+  }
+  /* istanbul ignore else */
+  if (typeof def$$1 === 'object') {
+    var res = {};
+    if (def$$1.css !== false) {
+      extend(res, autoCssTransition(def$$1.name || 'v'));
+    }
+    extend(res, def$$1);
+    return res
+  } else if (typeof def$$1 === 'string') {
+    return autoCssTransition(def$$1)
+  }
+}
+
+var autoCssTransition = cached(function (name) {
+  return {
+    enterClass: (name + "-enter"),
+    enterToClass: (name + "-enter-to"),
+    enterActiveClass: (name + "-enter-active"),
+    leaveClass: (name + "-leave"),
+    leaveToClass: (name + "-leave-to"),
+    leaveActiveClass: (name + "-leave-active")
+  }
+});
+
+var hasTransition = inBrowser && !isIE9;
+var TRANSITION = 'transition';
+var ANIMATION = 'animation';
+
+// Transition property/event sniffing
+var transitionProp = 'transition';
+var transitionEndEvent = 'transitionend';
+var animationProp = 'animation';
+var animationEndEvent = 'animationend';
+if (hasTransition) {
+  /* istanbul ignore if */
+  if (window.ontransitionend === undefined &&
+    window.onwebkittransitionend !== undefined) {
+    transitionProp = 'WebkitTransition';
+    transitionEndEvent = 'webkitTransitionEnd';
+  }
+  if (window.onanimationend === undefined &&
+    window.onwebkitanimationend !== undefined) {
+    animationProp = 'WebkitAnimation';
+    animationEndEvent = 'webkitAnimationEnd';
+  }
+}
+
+// binding to window is necessary to make hot reload work in IE in strict mode
+var raf = inBrowser && window.requestAnimationFrame
+  ? window.requestAnimationFrame.bind(window)
+  : setTimeout;
+
+function nextFrame (fn) {
+  raf(function () {
+    raf(fn);
+  });
+}
+
+function addTransitionClass (el, cls) {
+  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
+  addClass(el, cls);
+}
+
+function removeTransitionClass (el, cls) {
+  if (el._transitionClasses) {
+    remove(el._transitionClasses, cls);
+  }
+  removeClass(el, cls);
+}
+
+function whenTransitionEnds (
+  el,
+  expectedType,
+  cb
+) {
+  var ref = getTransitionInfo(el, expectedType);
+  var type = ref.type;
+  var timeout = ref.timeout;
+  var propCount = ref.propCount;
+  if (!type) { return cb() }
+  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
+  var ended = 0;
+  var end = function () {
+    el.removeEventListener(event, onEnd);
+    cb();
+  };
+  var onEnd = function (e) {
+    if (e.target === el) {
+      if (++ended >= propCount) {
+        end();
+      }
+    }
+  };
+  setTimeout(function () {
+    if (ended < propCount) {
+      end();
+    }
+  }, timeout + 1);
+  el.addEventListener(event, onEnd);
+}
+
+var transformRE = /\b(transform|all)(,|$)/;
+
+function getTransitionInfo (el, expectedType) {
+  var styles = window.getComputedStyle(el);
+  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
+  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
+  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
+  var animationDelays = styles[animationProp + 'Delay'].split(', ');
+  var animationDurations = styles[animationProp + 'Duration'].split(', ');
+  var animationTimeout = getTimeout(animationDelays, animationDurations);
+
+  var type;
+  var timeout = 0;
+  var propCount = 0;
+  /* istanbul ignore if */
+  if (expectedType === TRANSITION) {
+    if (transitionTimeout > 0) {
+      type = TRANSITION;
+      timeout = transitionTimeout;
+      propCount = transitionDurations.length;
+    }
+  } else if (expectedType === ANIMATION) {
+    if (animationTimeout > 0) {
+      type = ANIMATION;
+      timeout = animationTimeout;
+      propCount = animationDurations.length;
+    }
+  } else {
+    timeout = Math.max(transitionTimeout, animationTimeout);
+    type = timeout > 0
+      ? transitionTimeout > animationTimeout
+        ? TRANSITION
+        : ANIMATION
+      : null;
+    propCount = type
+      ? type === TRANSITION
+        ? transitionDurations.length
+        : animationDurations.length
+      : 0;
+  }
+  var hasTransform =
+    type === TRANSITION &&
+    transformRE.test(styles[transitionProp + 'Property']);
+  return {
+    type: type,
+    timeout: timeout,
+    propCount: propCount,
+    hasTransform: hasTransform
+  }
+}
+
+function getTimeout (delays, durations) {
+  /* istanbul ignore next */
+  while (delays.length < durations.length) {
+    delays = delays.concat(delays);
+  }
+
+  return Math.max.apply(null, durations.map(function (d, i) {
+    return toMs(d) + toMs(delays[i])
+  }))
+}
+
+function toMs (s) {
+  return Number(s.slice(0, -1)) * 1000
+}
+
+/*  */
+
+function enter (vnode, toggleDisplay) {
+  var el = vnode.elm;
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true;
+    el._leaveCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var enterClass = data.enterClass;
+  var enterToClass = data.enterToClass;
+  var enterActiveClass = data.enterActiveClass;
+  var appearClass = data.appearClass;
+  var appearToClass = data.appearToClass;
+  var appearActiveClass = data.appearActiveClass;
+  var beforeEnter = data.beforeEnter;
+  var enter = data.enter;
+  var afterEnter = data.afterEnter;
+  var enterCancelled = data.enterCancelled;
+  var beforeAppear = data.beforeAppear;
+  var appear = data.appear;
+  var afterAppear = data.afterAppear;
+  var appearCancelled = data.appearCancelled;
+  var duration = data.duration;
+
+  // activeInstance will always be the <transition> component managing this
+  // transition. One edge case to check is when the <transition> is placed
+  // as the root node of a child component. In that case we need to check
+  // <transition>'s parent for appear check.
+  var context = activeInstance;
+  var transitionNode = activeInstance.$vnode;
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent;
+    context = transitionNode.context;
+  }
+
+  var isAppear = !context._isMounted || !vnode.isRootInsert;
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  var startClass = isAppear && appearClass
+    ? appearClass
+    : enterClass;
+  var activeClass = isAppear && appearActiveClass
+    ? appearActiveClass
+    : enterActiveClass;
+  var toClass = isAppear && appearToClass
+    ? appearToClass
+    : enterToClass;
+
+  var beforeEnterHook = isAppear
+    ? (beforeAppear || beforeEnter)
+    : beforeEnter;
+  var enterHook = isAppear
+    ? (typeof appear === 'function' ? appear : enter)
+    : enter;
+  var afterEnterHook = isAppear
+    ? (afterAppear || afterEnter)
+    : afterEnter;
+  var enterCancelledHook = isAppear
+    ? (appearCancelled || enterCancelled)
+    : enterCancelled;
+
+  var explicitEnterDuration = toNumber(
+    isObject(duration)
+      ? duration.enter
+      : duration
+  );
+
+  if ("development" !== 'production' && explicitEnterDuration != null) {
+    checkDuration(explicitEnterDuration, 'enter', vnode);
+  }
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(enterHook);
+
+  var cb = el._enterCb = once(function () {
+    if (expectsCSS) {
+      removeTransitionClass(el, toClass);
+      removeTransitionClass(el, activeClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, startClass);
+      }
+      enterCancelledHook && enterCancelledHook(el);
+    } else {
+      afterEnterHook && afterEnterHook(el);
+    }
+    el._enterCb = null;
+  });
+
+  if (!vnode.data.show) {
+    // remove pending leave element on enter by injecting an insert hook
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
+      var parent = el.parentNode;
+      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
+      if (pendingNode &&
+          pendingNode.tag === vnode.tag &&
+          pendingNode.elm._leaveCb) {
+        pendingNode.elm._leaveCb();
+      }
+      enterHook && enterHook(el, cb);
+    });
+  }
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el);
+  if (expectsCSS) {
+    addTransitionClass(el, startClass);
+    addTransitionClass(el, activeClass);
+    nextFrame(function () {
+      addTransitionClass(el, toClass);
+      removeTransitionClass(el, startClass);
+      if (!cb.cancelled && !userWantsControl) {
+        if (isValidDuration(explicitEnterDuration)) {
+          setTimeout(cb, explicitEnterDuration);
+        } else {
+          whenTransitionEnds(el, type, cb);
+        }
+      }
+    });
+  }
+
+  if (vnode.data.show) {
+    toggleDisplay && toggleDisplay();
+    enterHook && enterHook(el, cb);
+  }
+
+  if (!expectsCSS && !userWantsControl) {
+    cb();
+  }
+}
+
+function leave (vnode, rm) {
+  var el = vnode.elm;
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true;
+    el._enterCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return rm()
+  }
+
+  /* istanbul ignore if */
+  if (el._leaveCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var leaveClass = data.leaveClass;
+  var leaveToClass = data.leaveToClass;
+  var leaveActiveClass = data.leaveActiveClass;
+  var beforeLeave = data.beforeLeave;
+  var leave = data.leave;
+  var afterLeave = data.afterLeave;
+  var leaveCancelled = data.leaveCancelled;
+  var delayLeave = data.delayLeave;
+  var duration = data.duration;
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(leave);
+
+  var explicitLeaveDuration = toNumber(
+    isObject(duration)
+      ? duration.leave
+      : duration
+  );
+
+  if ("development" !== 'production' && explicitLeaveDuration != null) {
+    checkDuration(explicitLeaveDuration, 'leave', vnode);
+  }
+
+  var cb = el._leaveCb = once(function () {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null;
+    }
+    if (expectsCSS) {
+      removeTransitionClass(el, leaveToClass);
+      removeTransitionClass(el, leaveActiveClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, leaveClass);
+      }
+      leaveCancelled && leaveCancelled(el);
+    } else {
+      rm();
+      afterLeave && afterLeave(el);
+    }
+    el._leaveCb = null;
+  });
+
+  if (delayLeave) {
+    delayLeave(performLeave);
+  } else {
+    performLeave();
+  }
+
+  function performLeave () {
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
+    }
+    beforeLeave && beforeLeave(el);
+    if (expectsCSS) {
+      addTransitionClass(el, leaveClass);
+      addTransitionClass(el, leaveActiveClass);
+      nextFrame(function () {
+        addTransitionClass(el, leaveToClass);
+        removeTransitionClass(el, leaveClass);
+        if (!cb.cancelled && !userWantsControl) {
+          if (isValidDuration(explicitLeaveDuration)) {
+            setTimeout(cb, explicitLeaveDuration);
+          } else {
+            whenTransitionEnds(el, type, cb);
+          }
+        }
+      });
+    }
+    leave && leave(el, cb);
+    if (!expectsCSS && !userWantsControl) {
+      cb();
+    }
+  }
+}
+
+// only used in dev mode
+function checkDuration (val, name, vnode) {
+  if (typeof val !== 'number') {
+    warn(
+      "<transition> explicit " + name + " duration is not a valid number - " +
+      "got " + (JSON.stringify(val)) + ".",
+      vnode.context
+    );
+  } else if (isNaN(val)) {
+    warn(
+      "<transition> explicit " + name + " duration is NaN - " +
+      'the duration expression might be incorrect.',
+      vnode.context
+    );
+  }
+}
+
+function isValidDuration (val) {
+  return typeof val === 'number' && !isNaN(val)
+}
+
+/**
+ * Normalize a transition hook's argument length. The hook may be:
+ * - a merged hook (invoker) with the original in .fns
+ * - a wrapped component method (check ._length)
+ * - a plain function (.length)
+ */
+function getHookArgumentsLength (fn) {
+  if (!fn) { return false }
+  var invokerFns = fn.fns;
+  if (invokerFns) {
+    // invoker
+    return getHookArgumentsLength(
+      Array.isArray(invokerFns)
+        ? invokerFns[0]
+        : invokerFns
+    )
+  } else {
+    return (fn._length || fn.length) > 1
+  }
+}
+
+function _enter (_, vnode) {
+  if (!vnode.data.show) {
+    enter(vnode);
+  }
+}
+
+var transition = inBrowser ? {
+  create: _enter,
+  activate: _enter,
+  remove: function remove$$1 (vnode, rm) {
+    /* istanbul ignore else */
+    if (!vnode.data.show) {
+      leave(vnode, rm);
+    } else {
+      rm();
+    }
+  }
+} : {};
+
+var platformModules = [
+  attrs,
+  klass,
+  events,
+  domProps,
+  style,
+  transition
+];
+
+/*  */
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+var modules = platformModules.concat(baseModules);
+
+var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
+
+/**
+ * Not type checking this file because flow doesn't like attaching
+ * properties to Elements.
+ */
+
+/* istanbul ignore if */
+if (isIE9) {
+  // http://www.matts411.com/post/internet-explorer-9-oninput/
+  document.addEventListener('selectionchange', function () {
+    var el = document.activeElement;
+    if (el && el.vmodel) {
+      trigger(el, 'input');
+    }
+  });
+}
+
+var model$1 = {
+  inserted: function inserted (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      var cb = function () {
+        setSelected(el, binding, vnode.context);
+      };
+      cb();
+      /* istanbul ignore if */
+      if (isIE || isEdge) {
+        setTimeout(cb, 0);
+      }
+    } else if (vnode.tag === 'textarea' || el.type === 'text') {
+      el._vModifiers = binding.modifiers;
+      if (!binding.modifiers.lazy) {
+        if (!isAndroid) {
+          el.addEventListener('compositionstart', onCompositionStart);
+          el.addEventListener('compositionend', onCompositionEnd);
+        }
+        /* istanbul ignore if */
+        if (isIE9) {
+          el.vmodel = true;
+        }
+      }
+    }
+  },
+  componentUpdated: function componentUpdated (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      setSelected(el, binding, vnode.context);
+      // in case the options rendered by v-for have changed,
+      // it's possible that the value is out-of-sync with the rendered options.
+      // detect such cases and filter out values that no longer has a matching
+      // option in the DOM.
+      var needReset = el.multiple
+        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
+        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
+      if (needReset) {
+        trigger(el, 'change');
+      }
+    }
+  }
+};
+
+function setSelected (el, binding, vm) {
+  var value = binding.value;
+  var isMultiple = el.multiple;
+  if (isMultiple && !Array.isArray(value)) {
+    "development" !== 'production' && warn(
+      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
+      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
+      vm
+    );
+    return
+  }
+  var selected, option;
+  for (var i = 0, l = el.options.length; i < l; i++) {
+    option = el.options[i];
+    if (isMultiple) {
+      selected = looseIndexOf(value, getValue(option)) > -1;
+      if (option.selected !== selected) {
+        option.selected = selected;
+      }
+    } else {
+      if (looseEqual(getValue(option), value)) {
+        if (el.selectedIndex !== i) {
+          el.selectedIndex = i;
+        }
+        return
+      }
+    }
+  }
+  if (!isMultiple) {
+    el.selectedIndex = -1;
+  }
+}
+
+function hasNoMatchingOption (value, options) {
+  for (var i = 0, l = options.length; i < l; i++) {
+    if (looseEqual(getValue(options[i]), value)) {
+      return false
+    }
+  }
+  return true
+}
+
+function getValue (option) {
+  return '_value' in option
+    ? option._value
+    : option.value
+}
+
+function onCompositionStart (e) {
+  e.target.composing = true;
+}
+
+function onCompositionEnd (e) {
+  e.target.composing = false;
+  trigger(e.target, 'input');
+}
+
+function trigger (el, type) {
+  var e = document.createEvent('HTMLEvents');
+  e.initEvent(type, true, true);
+  el.dispatchEvent(e);
+}
+
+/*  */
+
+// recursively search for possible transition defined inside the component root
+function locateNode (vnode) {
+  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
+    ? locateNode(vnode.componentInstance._vnode)
+    : vnode
+}
+
+var show = {
+  bind: function bind (el, ref, vnode) {
+    var value = ref.value;
+
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    var originalDisplay = el.__vOriginalDisplay =
+      el.style.display === 'none' ? '' : el.style.display;
+    if (value && transition && !isIE9) {
+      vnode.data.show = true;
+      enter(vnode, function () {
+        el.style.display = originalDisplay;
+      });
+    } else {
+      el.style.display = value ? originalDisplay : 'none';
+    }
+  },
+
+  update: function update (el, ref, vnode) {
+    var value = ref.value;
+    var oldValue = ref.oldValue;
+
+    /* istanbul ignore if */
+    if (value === oldValue) { return }
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    if (transition && !isIE9) {
+      vnode.data.show = true;
+      if (value) {
+        enter(vnode, function () {
+          el.style.display = el.__vOriginalDisplay;
+        });
+      } else {
+        leave(vnode, function () {
+          el.style.display = 'none';
+        });
+      }
+    } else {
+      el.style.display = value ? el.__vOriginalDisplay : 'none';
+    }
+  },
+
+  unbind: function unbind (
+    el,
+    binding,
+    vnode,
+    oldVnode,
+    isDestroy
+  ) {
+    if (!isDestroy) {
+      el.style.display = el.__vOriginalDisplay;
+    }
+  }
+};
+
+var platformDirectives = {
+  model: model$1,
+  show: show
+};
+
+/*  */
+
+// Provides transition support for a single element/component.
+// supports transition mode (out-in / in-out)
+
+var transitionProps = {
+  name: String,
+  appear: Boolean,
+  css: Boolean,
+  mode: String,
+  type: String,
+  enterClass: String,
+  leaveClass: String,
+  enterToClass: String,
+  leaveToClass: String,
+  enterActiveClass: String,
+  leaveActiveClass: String,
+  appearClass: String,
+  appearActiveClass: String,
+  appearToClass: String,
+  duration: [Number, String, Object]
+};
+
+// in case the child is also an abstract component, e.g. <keep-alive>
+// we want to recursively retrieve the real component to be rendered
+function getRealChild (vnode) {
+  var compOptions = vnode && vnode.componentOptions;
+  if (compOptions && compOptions.Ctor.options.abstract) {
+    return getRealChild(getFirstComponentChild(compOptions.children))
+  } else {
+    return vnode
+  }
+}
+
+function extractTransitionData (comp) {
+  var data = {};
+  var options = comp.$options;
+  // props
+  for (var key in options.propsData) {
+    data[key] = comp[key];
+  }
+  // events.
+  // extract listeners and pass them directly to the transition methods
+  var listeners = options._parentListeners;
+  for (var key$1 in listeners) {
+    data[camelize(key$1)] = listeners[key$1];
+  }
+  return data
+}
+
+function placeholder (h, rawChild) {
+  return /\d-keep-alive$/.test(rawChild.tag)
+    ? h('keep-alive')
+    : null
+}
+
+function hasParentTransition (vnode) {
+  while ((vnode = vnode.parent)) {
+    if (vnode.data.transition) {
+      return true
+    }
+  }
+}
+
+function isSameChild (child, oldChild) {
+  return oldChild.key === child.key && oldChild.tag === child.tag
+}
+
+var Transition = {
+  name: 'transition',
+  props: transitionProps,
+  abstract: true,
+
+  render: function render (h) {
+    var this$1 = this;
+
+    var children = this.$slots.default;
+    if (!children) {
+      return
+    }
+
+    // filter out text nodes (possible whitespaces)
+    children = children.filter(function (c) { return c.tag; });
+    /* istanbul ignore if */
+    if (!children.length) {
+      return
+    }
+
+    // warn multiple elements
+    if ("development" !== 'production' && children.length > 1) {
+      warn(
+        '<transition> can only be used on a single element. Use ' +
+        '<transition-group> for lists.',
+        this.$parent
+      );
+    }
+
+    var mode = this.mode;
+
+    // warn invalid mode
+    if ("development" !== 'production' &&
+        mode && mode !== 'in-out' && mode !== 'out-in') {
+      warn(
+        'invalid <transition> mode: ' + mode,
+        this.$parent
+      );
+    }
+
+    var rawChild = children[0];
+
+    // if this is a component root node and the component's
+    // parent container node also has transition, skip.
+    if (hasParentTransition(this.$vnode)) {
+      return rawChild
+    }
+
+    // apply transition data to child
+    // use getRealChild() to ignore abstract components e.g. keep-alive
+    var child = getRealChild(rawChild);
+    /* istanbul ignore if */
+    if (!child) {
+      return rawChild
+    }
+
+    if (this._leaving) {
+      return placeholder(h, rawChild)
+    }
+
+    // ensure a key that is unique to the vnode type and to this transition
+    // component instance. This key will be used to remove pending leaving nodes
+    // during entering.
+    var id = "__transition-" + (this._uid) + "-";
+    child.key = child.key == null
+      ? id + child.tag
+      : isPrimitive(child.key)
+        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
+        : child.key;
+
+    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
+    var oldRawChild = this._vnode;
+    var oldChild = getRealChild(oldRawChild);
+
+    // mark v-show
+    // so that the transition module can hand over the control to the directive
+    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
+      child.data.show = true;
+    }
+
+    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
+      // replace old child transition data with fresh one
+      // important for dynamic transitions!
+      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
+      // handle transition mode
+      if (mode === 'out-in') {
+        // return placeholder node and queue update when leave finishes
+        this._leaving = true;
+        mergeVNodeHook(oldData, 'afterLeave', function () {
+          this$1._leaving = false;
+          this$1.$forceUpdate();
+        });
+        return placeholder(h, rawChild)
+      } else if (mode === 'in-out') {
+        var delayedLeave;
+        var performLeave = function () { delayedLeave(); };
+        mergeVNodeHook(data, 'afterEnter', performLeave);
+        mergeVNodeHook(data, 'enterCancelled', performLeave);
+        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
+      }
+    }
+
+    return rawChild
+  }
+};
+
+/*  */
+
+// Provides transition support for list items.
+// supports move transitions using the FLIP technique.
+
+// Because the vdom's children update algorithm is "unstable" - i.e.
+// it doesn't guarantee the relative positioning of removed elements,
+// we force transition-group to update its children into two passes:
+// in the first pass, we remove all nodes that need to be removed,
+// triggering their leaving transition; in the second pass, we insert/move
+// into the final desired state. This way in the second pass removed
+// nodes will remain where they should be.
+
+var props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps);
+
+delete props.mode;
+
+var TransitionGroup = {
+  props: props,
+
+  render: function render (h) {
+    var tag = this.tag || this.$vnode.data.tag || 'span';
+    var map = Object.create(null);
+    var prevChildren = this.prevChildren = this.children;
+    var rawChildren = this.$slots.default || [];
+    var children = this.children = [];
+    var transitionData = extractTransitionData(this);
+
+    for (var i = 0; i < rawChildren.length; i++) {
+      var c = rawChildren[i];
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c);
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData;
+        } else {
+          var opts = c.componentOptions;
+          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
+          warn(("<transition-group> children must be keyed: <" + name + ">"));
+        }
+      }
+    }
+
+    if (prevChildren) {
+      var kept = [];
+      var removed = [];
+      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
+        var c$1 = prevChildren[i$1];
+        c$1.data.transition = transitionData;
+        c$1.data.pos = c$1.elm.getBoundingClientRect();
+        if (map[c$1.key]) {
+          kept.push(c$1);
+        } else {
+          removed.push(c$1);
+        }
+      }
+      this.kept = h(tag, null, kept);
+      this.removed = removed;
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate: function beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    );
+    this._vnode = this.kept;
+  },
+
+  updated: function updated () {
+    var children = this.prevChildren;
+    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
+    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
+      return
+    }
+
+    // we divide the work into three loops to avoid mixing DOM reads and writes
+    // in each iteration - which helps prevent layout thrashing.
+    children.forEach(callPendingCbs);
+    children.forEach(recordPosition);
+    children.forEach(applyTranslation);
+
+    // force reflow to put everything in position
+    var body = document.body;
+    var f = body.offsetHeight; // eslint-disable-line
+
+    children.forEach(function (c) {
+      if (c.data.moved) {
+        var el = c.elm;
+        var s = el.style;
+        addTransitionClass(el, moveClass);
+        s.transform = s.WebkitTransform = s.transitionDuration = '';
+        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
+          if (!e || /transform$/.test(e.propertyName)) {
+            el.removeEventListener(transitionEndEvent, cb);
+            el._moveCb = null;
+            removeTransitionClass(el, moveClass);
+          }
+        });
+      }
+    });
+  },
+
+  methods: {
+    hasMove: function hasMove (el, moveClass) {
+      /* istanbul ignore if */
+      if (!hasTransition) {
+        return false
+      }
+      if (this._hasMove != null) {
+        return this._hasMove
+      }
+      // Detect whether an element with the move class applied has
+      // CSS transitions. Since the element may be inside an entering
+      // transition at this very moment, we make a clone of it and remove
+      // all other transition classes applied to ensure only the move class
+      // is applied.
+      var clone = el.cloneNode();
+      if (el._transitionClasses) {
+        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
+      }
+      addClass(clone, moveClass);
+      clone.style.display = 'none';
+      this.$el.appendChild(clone);
+      var info = getTransitionInfo(clone);
+      this.$el.removeChild(clone);
+      return (this._hasMove = info.hasTransform)
+    }
+  }
+};
+
+function callPendingCbs (c) {
+  /* istanbul ignore if */
+  if (c.elm._moveCb) {
+    c.elm._moveCb();
+  }
+  /* istanbul ignore if */
+  if (c.elm._enterCb) {
+    c.elm._enterCb();
+  }
+}
+
+function recordPosition (c) {
+  c.data.newPos = c.elm.getBoundingClientRect();
+}
+
+function applyTranslation (c) {
+  var oldPos = c.data.pos;
+  var newPos = c.data.newPos;
+  var dx = oldPos.left - newPos.left;
+  var dy = oldPos.top - newPos.top;
+  if (dx || dy) {
+    c.data.moved = true;
+    var s = c.elm.style;
+    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
+    s.transitionDuration = '0s';
+  }
+}
+
+var platformComponents = {
+  Transition: Transition,
+  TransitionGroup: TransitionGroup
+};
+
+/*  */
+
+// install platform specific utils
+Vue$2.config.mustUseProp = mustUseProp;
+Vue$2.config.isReservedTag = isReservedTag;
+Vue$2.config.getTagNamespace = getTagNamespace;
+Vue$2.config.isUnknownElement = isUnknownElement;
+
+// install platform runtime directives & components
+extend(Vue$2.options.directives, platformDirectives);
+extend(Vue$2.options.components, platformComponents);
+
+// install platform patch function
+Vue$2.prototype.__patch__ = inBrowser ? patch : noop;
+
+// public mount method
+Vue$2.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && inBrowser ? query(el) : undefined;
+  return mountComponent(this, el, hydrating)
+};
+
+// devtools global hook
+/* istanbul ignore next */
+setTimeout(function () {
+  if (config.devtools) {
+    if (devtools) {
+      devtools.emit('init', Vue$2);
+    } else if ("development" !== 'production' && isChrome) {
+      console[console.info ? 'info' : 'log'](
+        'Download the Vue Devtools extension for a better development experience:\n' +
+        'https://github.com/vuejs/vue-devtools'
+      );
+    }
+  }
+  if ("development" !== 'production' &&
+      config.productionTip !== false &&
+      inBrowser && typeof console !== 'undefined') {
+    console[console.info ? 'info' : 'log'](
+      "You are running Vue in development mode.\n" +
+      "Make sure to turn on production mode when deploying for production.\n" +
+      "See more tips at https://vuejs.org/guide/deployment.html"
+    );
+  }
+}, 0);
+
+return Vue$2;
+
+})));
Index: public/node_modules/vue/src/platforms/web/util/class.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/util/class.js	(revision )
+++ public/node_modules/vue/src/platforms/web/util/class.js	(revision )
@@ -0,0 +1,76 @@
+/* @flow */
+
+import { isObject } from 'shared/util'
+
+export function genClassForVnode (vnode: VNode): string {
+  let data = vnode.data
+  let parentNode = vnode
+  let childNode = vnode
+  while (childNode.componentInstance) {
+    childNode = childNode.componentInstance._vnode
+    if (childNode.data) {
+      data = mergeClassData(childNode.data, data)
+    }
+  }
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data) {
+      data = mergeClassData(data, parentNode.data)
+    }
+  }
+  return genClassFromData(data)
+}
+
+function mergeClassData (child: VNodeData, parent: VNodeData): {
+  staticClass: string,
+  class: any
+} {
+  return {
+    staticClass: concat(child.staticClass, parent.staticClass),
+    class: child.class
+      ? [child.class, parent.class]
+      : parent.class
+  }
+}
+
+function genClassFromData (data: Object): string {
+  const dynamicClass = data.class
+  const staticClass = data.staticClass
+  if (staticClass || dynamicClass) {
+    return concat(staticClass, stringifyClass(dynamicClass))
+  }
+  /* istanbul ignore next */
+  return ''
+}
+
+export function concat (a: ?string, b: ?string): string {
+  return a ? b ? (a + ' ' + b) : a : (b || '')
+}
+
+export function stringifyClass (value: any): string {
+  let res = ''
+  if (!value) {
+    return res
+  }
+  if (typeof value === 'string') {
+    return value
+  }
+  if (Array.isArray(value)) {
+    let stringified
+    for (let i = 0, l = value.length; i < l; i++) {
+      if (value[i]) {
+        if ((stringified = stringifyClass(value[i]))) {
+          res += stringified + ' '
+        }
+      }
+    }
+    return res.slice(0, -1)
+  }
+  if (isObject(value)) {
+    for (const key in value) {
+      if (value[key]) res += key + ' '
+    }
+    return res.slice(0, -1)
+  }
+  /* istanbul ignore next */
+  return res
+}
Index: public/node_modules/vue/src/compiler/helpers.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/compiler/helpers.js	(revision )
+++ public/node_modules/vue/src/compiler/helpers.js	(revision )
@@ -0,0 +1,102 @@
+/* @flow */
+
+import { parseFilters } from './parser/filter-parser'
+
+export function baseWarn (msg: string) {
+  console.error(`[Vue compiler]: ${msg}`)
+}
+
+export function pluckModuleFunction<F: Function> (
+  modules: ?Array<Object>,
+  key: string
+): Array<F> {
+  return modules
+    ? modules.map(m => m[key]).filter(_ => _)
+    : []
+}
+
+export function addProp (el: ASTElement, name: string, value: string) {
+  (el.props || (el.props = [])).push({ name, value })
+}
+
+export function addAttr (el: ASTElement, name: string, value: string) {
+  (el.attrs || (el.attrs = [])).push({ name, value })
+}
+
+export function addDirective (
+  el: ASTElement,
+  name: string,
+  rawName: string,
+  value: string,
+  arg: ?string,
+  modifiers: ?ASTModifiers
+) {
+  (el.directives || (el.directives = [])).push({ name, rawName, value, arg, modifiers })
+}
+
+export function addHandler (
+  el: ASTElement,
+  name: string,
+  value: string,
+  modifiers: ?ASTModifiers,
+  important: ?boolean
+) {
+  // check capture modifier
+  if (modifiers && modifiers.capture) {
+    delete modifiers.capture
+    name = '!' + name // mark the event as captured
+  }
+  if (modifiers && modifiers.once) {
+    delete modifiers.once
+    name = '~' + name // mark the event as once
+  }
+  let events
+  if (modifiers && modifiers.native) {
+    delete modifiers.native
+    events = el.nativeEvents || (el.nativeEvents = {})
+  } else {
+    events = el.events || (el.events = {})
+  }
+  const newHandler = { value, modifiers }
+  const handlers = events[name]
+  /* istanbul ignore if */
+  if (Array.isArray(handlers)) {
+    important ? handlers.unshift(newHandler) : handlers.push(newHandler)
+  } else if (handlers) {
+    events[name] = important ? [newHandler, handlers] : [handlers, newHandler]
+  } else {
+    events[name] = newHandler
+  }
+}
+
+export function getBindingAttr (
+  el: ASTElement,
+  name: string,
+  getStatic?: boolean
+): ?string {
+  const dynamicValue =
+    getAndRemoveAttr(el, ':' + name) ||
+    getAndRemoveAttr(el, 'v-bind:' + name)
+  if (dynamicValue != null) {
+    return parseFilters(dynamicValue)
+  } else if (getStatic !== false) {
+    const staticValue = getAndRemoveAttr(el, name)
+    if (staticValue != null) {
+      return JSON.stringify(staticValue)
+    }
+  }
+}
+
+export function getAndRemoveAttr (el: ASTElement, name: string): ?string {
+  let val
+  if ((val = el.attrsMap[name]) != null) {
+    const list = el.attrsList
+    for (let i = 0, l = list.length; i < l; i++) {
+      if (list[i].name === name) {
+        list.splice(i, 1)
+        break
+      }
+    }
+  }
+  return val
+}
Index: public/node_modules/vue/src/core/observer/scheduler.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/observer/scheduler.js	(revision )
+++ public/node_modules/vue/src/core/observer/scheduler.js	(revision )
@@ -0,0 +1,117 @@
+/* @flow */
+
+import type Watcher from './watcher'
+import config from '../config'
+import { callHook } from '../instance/lifecycle'
+import {
+  warn,
+  nextTick,
+  devtools
+} from '../util/index'
+
+const queue: Array<Watcher> = []
+let has: { [key: number]: ?true } = {}
+let circular: { [key: number]: number } = {}
+let waiting = false
+let flushing = false
+let index = 0
+
+/**
+ * Reset the scheduler's state.
+ */
+function resetSchedulerState () {
+  queue.length = 0
+  has = {}
+  if (process.env.NODE_ENV !== 'production') {
+    circular = {}
+  }
+  waiting = flushing = false
+}
+
+/**
+ * Flush both queues and run the watchers.
+ */
+function flushSchedulerQueue () {
+  flushing = true
+  let watcher, id, vm
+
+  // Sort queue before flush.
+  // This ensures that:
+  // 1. Components are updated from parent to child. (because parent is always
+  //    created before the child)
+  // 2. A component's user watchers are run before its render watcher (because
+  //    user watchers are created before the render watcher)
+  // 3. If a component is destroyed during a parent component's watcher run,
+  //    its watchers can be skipped.
+  queue.sort((a, b) => a.id - b.id)
+
+  // do not cache length because more watchers might be pushed
+  // as we run existing watchers
+  for (index = 0; index < queue.length; index++) {
+    watcher = queue[index]
+    id = watcher.id
+    has[id] = null
+    watcher.run()
+    // in dev build, check and stop circular updates.
+    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
+      circular[id] = (circular[id] || 0) + 1
+      if (circular[id] > config._maxUpdateCount) {
+        warn(
+          'You may have an infinite update loop ' + (
+            watcher.user
+              ? `in watcher with expression "${watcher.expression}"`
+              : `in a component render function.`
+          ),
+          watcher.vm
+        )
+        break
+      }
+    }
+  }
+
+  // call updated hooks
+  index = queue.length
+  while (index--) {
+    watcher = queue[index]
+    vm = watcher.vm
+    if (vm._watcher === watcher && vm._isMounted) {
+      callHook(vm, 'updated')
+    }
+  }
+
+  // devtool hook
+  /* istanbul ignore if */
+  if (devtools && config.devtools) {
+    devtools.emit('flush')
+  }
+
+  resetSchedulerState()
+}
+
+/**
+ * Push a watcher into the watcher queue.
+ * Jobs with duplicate IDs will be skipped unless it's
+ * pushed when the queue is being flushed.
+ */
+export function queueWatcher (watcher: Watcher) {
+  const id = watcher.id
+  if (has[id] == null) {
+    has[id] = true
+    if (!flushing) {
+      queue.push(watcher)
+    } else {
+      // if already flushing, splice the watcher based on its id
+      // if already past its id, it will be run next immediately.
+      let i = queue.length - 1
+      while (i >= 0 && queue[i].id > watcher.id) {
+        i--
+      }
+      queue.splice(Math.max(i, index) + 1, 0, watcher)
+    }
+    // queue the flush
+    if (!waiting) {
+      waiting = true
+      nextTick(flushSchedulerQueue)
+    }
+  }
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/create-error-class/package.json	(revision )
@@ -0,0 +1,42 @@
+{
+  "name": "create-error-class",
+  "version": "3.0.2",
+  "description": "Create Error classes",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/floatdrop/create-error-class"
+  },
+  "author": {
+    "name": "Vsevolod Strukchinsky",
+    "email": "floatdrop@gmail.com",
+    "url": "github.com/floatdrop"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "mocha"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [],
+  "dependencies": {
+    "capture-stack-trace": "^1.0.0"
+  },
+  "devDependencies": {
+    "mocha": "*"
+  },
+  "readme": "# create-error-class [![Build Status](https://travis-ci.org/floatdrop/create-error-class.svg?branch=master)](https://travis-ci.org/floatdrop/create-error-class)\n\n> Create error class\n\n\n## Install\n\n```\n$ npm install --save create-error-class\n```\n\n\n## Usage\n\n```js\nvar createErrorClass = require('create-error-class');\n\nvar HTTPError = createErrorClass('HTTPError', function (props) {\n\tthis.message = 'Status code is ' + props.statusCode;\n});\n\nthrow new HTTPError({statusCode: 404});\n```\n\n\n## API\n\n### createErrorClass(className, [setup])\n\nReturn constructor of Errors with `className`.\n\n#### className\n\n*Required*  \nType: `string`\n\nClass name of Error Object. Should contain characters from `[0-9a-zA-Z_$]` range.\n\n#### setup\nType: `function`\n\nSetup function, that will be called after each Error object is created from constructor with context of Error object.\n\nBy default `setup` function sets `this.message` as first argument:\n\n```js\nvar MyError = createErrorClass('MyError');\n\nnew MyError('Something gone wrong!').message; // => 'Something gone wrong!'\n```\n\n## License\n\nMIT  [Vsevolod Strukchinsky](http://github.com/floatdrop)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/floatdrop/create-error-class/issues"
+  },
+  "_id": "create-error-class@3.0.2",
+  "dist": {
+    "shasum": "098f346e798a7e00b8e58455678ab3969f070504"
+  },
+  "_from": "create-error-class@^3.0.0",
+  "_resolved": "https://registry.npmjs.org/create-error-class/-/create-error-class-3.0.2.tgz"
+}
Index: public/node_modules/vue/dist/vue.runtime.esm.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.runtime.esm.js	(revision )
+++ public/node_modules/vue/dist/vue.runtime.esm.js	(revision )
@@ -0,0 +1,6721 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+/*  */
+
+/**
+ * Convert a value to a string that is actually rendered.
+ */
+function _toString (val) {
+  return val == null
+    ? ''
+    : typeof val === 'object'
+      ? JSON.stringify(val, null, 2)
+      : String(val)
+}
+
+/**
+ * Convert a input value to a number for persistence.
+ * If the conversion fails, return original string.
+ */
+function toNumber (val) {
+  var n = parseFloat(val);
+  return isNaN(n) ? val : n
+}
+
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ */
+function makeMap (
+  str,
+  expectsLowerCase
+) {
+  var map = Object.create(null);
+  var list = str.split(',');
+  for (var i = 0; i < list.length; i++) {
+    map[list[i]] = true;
+  }
+  return expectsLowerCase
+    ? function (val) { return map[val.toLowerCase()]; }
+    : function (val) { return map[val]; }
+}
+
+/**
+ * Check if a tag is a built-in tag.
+ */
+var isBuiltInTag = makeMap('slot,component', true);
+
+/**
+ * Remove an item from an array
+ */
+function remove (arr, item) {
+  if (arr.length) {
+    var index = arr.indexOf(item);
+    if (index > -1) {
+      return arr.splice(index, 1)
+    }
+  }
+}
+
+/**
+ * Check whether the object has the property.
+ */
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+function hasOwn (obj, key) {
+  return hasOwnProperty.call(obj, key)
+}
+
+/**
+ * Check if value is primitive
+ */
+function isPrimitive (value) {
+  return typeof value === 'string' || typeof value === 'number'
+}
+
+/**
+ * Create a cached version of a pure function.
+ */
+function cached (fn) {
+  var cache = Object.create(null);
+  return (function cachedFn (str) {
+    var hit = cache[str];
+    return hit || (cache[str] = fn(str))
+  })
+}
+
+/**
+ * Camelize a hyphen-delimited string.
+ */
+var camelizeRE = /-(\w)/g;
+var camelize = cached(function (str) {
+  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
+});
+
+/**
+ * Capitalize a string.
+ */
+var capitalize = cached(function (str) {
+  return str.charAt(0).toUpperCase() + str.slice(1)
+});
+
+/**
+ * Hyphenate a camelCase string.
+ */
+var hyphenateRE = /([^-])([A-Z])/g;
+var hyphenate = cached(function (str) {
+  return str
+    .replace(hyphenateRE, '$1-$2')
+    .replace(hyphenateRE, '$1-$2')
+    .toLowerCase()
+});
+
+/**
+ * Simple bind, faster than native
+ */
+function bind (fn, ctx) {
+  function boundFn (a) {
+    var l = arguments.length;
+    return l
+      ? l > 1
+        ? fn.apply(ctx, arguments)
+        : fn.call(ctx, a)
+      : fn.call(ctx)
+  }
+  // record original fn length
+  boundFn._length = fn.length;
+  return boundFn
+}
+
+/**
+ * Convert an Array-like object to a real Array.
+ */
+function toArray (list, start) {
+  start = start || 0;
+  var i = list.length - start;
+  var ret = new Array(i);
+  while (i--) {
+    ret[i] = list[i + start];
+  }
+  return ret
+}
+
+/**
+ * Mix properties into target object.
+ */
+function extend (to, _from) {
+  for (var key in _from) {
+    to[key] = _from[key];
+  }
+  return to
+}
+
+/**
+ * Quick object check - this is primarily used to tell
+ * Objects from primitive values when we know the value
+ * is a JSON-compliant type.
+ */
+function isObject (obj) {
+  return obj !== null && typeof obj === 'object'
+}
+
+/**
+ * Strict object type check. Only returns true
+ * for plain JavaScript objects.
+ */
+var toString = Object.prototype.toString;
+var OBJECT_STRING = '[object Object]';
+function isPlainObject (obj) {
+  return toString.call(obj) === OBJECT_STRING
+}
+
+/**
+ * Merge an Array of Objects into a single Object.
+ */
+function toObject (arr) {
+  var res = {};
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i]);
+    }
+  }
+  return res
+}
+
+/**
+ * Perform no operation.
+ */
+function noop () {}
+
+/**
+ * Always return false.
+ */
+var no = function () { return false; };
+
+/**
+ * Return same value
+ */
+var identity = function (_) { return _; };
+
+/**
+ * Generate a static keys string from compiler modules.
+ */
+
+
+/**
+ * Check if two values are loosely equal - that is,
+ * if they are plain objects, do they have the same shape?
+ */
+function looseEqual (a, b) {
+  var isObjectA = isObject(a);
+  var isObjectB = isObject(b);
+  if (isObjectA && isObjectB) {
+    try {
+      return JSON.stringify(a) === JSON.stringify(b)
+    } catch (e) {
+      // possible circular reference
+      return a === b
+    }
+  } else if (!isObjectA && !isObjectB) {
+    return String(a) === String(b)
+  } else {
+    return false
+  }
+}
+
+function looseIndexOf (arr, val) {
+  for (var i = 0; i < arr.length; i++) {
+    if (looseEqual(arr[i], val)) { return i }
+  }
+  return -1
+}
+
+/**
+ * Ensure a function is called only once.
+ */
+function once (fn) {
+  var called = false;
+  return function () {
+    if (!called) {
+      called = true;
+      fn();
+    }
+  }
+}
+
+/*  */
+
+var config = {
+  /**
+   * Option merge strategies (used in core/util/options)
+   */
+  optionMergeStrategies: Object.create(null),
+
+  /**
+   * Whether to suppress warnings.
+   */
+  silent: false,
+
+  /**
+   * Show production mode tip message on boot?
+   */
+  productionTip: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to enable devtools
+   */
+  devtools: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to record perf
+   */
+  performance: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Error handler for watcher errors
+   */
+  errorHandler: null,
+
+  /**
+   * Ignore certain custom elements
+   */
+  ignoredElements: [],
+
+  /**
+   * Custom user key aliases for v-on
+   */
+  keyCodes: Object.create(null),
+
+  /**
+   * Check if a tag is reserved so that it cannot be registered as a
+   * component. This is platform-dependent and may be overwritten.
+   */
+  isReservedTag: no,
+
+  /**
+   * Check if a tag is an unknown element.
+   * Platform-dependent.
+   */
+  isUnknownElement: no,
+
+  /**
+   * Get the namespace of an element
+   */
+  getTagNamespace: noop,
+
+  /**
+   * Parse the real tag name for the specific platform.
+   */
+  parsePlatformTagName: identity,
+
+  /**
+   * Check if an attribute must be bound using property, e.g. value
+   * Platform-dependent.
+   */
+  mustUseProp: no,
+
+  /**
+   * List of asset types that a component can own.
+   */
+  _assetTypes: [
+    'component',
+    'directive',
+    'filter'
+  ],
+
+  /**
+   * List of lifecycle hooks.
+   */
+  _lifecycleHooks: [
+    'beforeCreate',
+    'created',
+    'beforeMount',
+    'mounted',
+    'beforeUpdate',
+    'updated',
+    'beforeDestroy',
+    'destroyed',
+    'activated',
+    'deactivated'
+  ],
+
+  /**
+   * Max circular updates allowed in a scheduler flush cycle.
+   */
+  _maxUpdateCount: 100
+};
+
+/*  */
+/* globals MutationObserver */
+
+// can we use __proto__?
+var hasProto = '__proto__' in {};
+
+// Browser environment sniffing
+var inBrowser = typeof window !== 'undefined';
+var UA = inBrowser && window.navigator.userAgent.toLowerCase();
+var isIE = UA && /msie|trident/.test(UA);
+var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
+var isEdge = UA && UA.indexOf('edge/') > 0;
+var isAndroid = UA && UA.indexOf('android') > 0;
+var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
+var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
+
+// this needs to be lazy-evaled because vue may be required before
+// vue-server-renderer can set VUE_ENV
+var _isServer;
+var isServerRendering = function () {
+  if (_isServer === undefined) {
+    /* istanbul ignore if */
+    if (!inBrowser && typeof global !== 'undefined') {
+      // detect presence of vue-server-renderer and avoid
+      // Webpack shimming the process
+      _isServer = global['process'].env.VUE_ENV === 'server';
+    } else {
+      _isServer = false;
+    }
+  }
+  return _isServer
+};
+
+// detect devtools
+var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
+
+/* istanbul ignore next */
+function isNative (Ctor) {
+  return /native code/.test(Ctor.toString())
+}
+
+var hasSymbol =
+  typeof Symbol !== 'undefined' && isNative(Symbol) &&
+  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
+
+/**
+ * Defer a task to execute it asynchronously.
+ */
+var nextTick = (function () {
+  var callbacks = [];
+  var pending = false;
+  var timerFunc;
+
+  function nextTickHandler () {
+    pending = false;
+    var copies = callbacks.slice(0);
+    callbacks.length = 0;
+    for (var i = 0; i < copies.length; i++) {
+      copies[i]();
+    }
+  }
+
+  // the nextTick behavior leverages the microtask queue, which can be accessed
+  // via either native Promise.then or MutationObserver.
+  // MutationObserver has wider support, however it is seriously bugged in
+  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
+  // completely stops working after triggering a few times... so, if native
+  // Promise is available, we will use it:
+  /* istanbul ignore if */
+  if (typeof Promise !== 'undefined' && isNative(Promise)) {
+    var p = Promise.resolve();
+    var logError = function (err) { console.error(err); };
+    timerFunc = function () {
+      p.then(nextTickHandler).catch(logError);
+      // in problematic UIWebViews, Promise.then doesn't completely break, but
+      // it can get stuck in a weird state where callbacks are pushed into the
+      // microtask queue but the queue isn't being flushed, until the browser
+      // needs to do some other work, e.g. handle a timer. Therefore we can
+      // "force" the microtask queue to be flushed by adding an empty timer.
+      if (isIOS) { setTimeout(noop); }
+    };
+  } else if (typeof MutationObserver !== 'undefined' && (
+    isNative(MutationObserver) ||
+    // PhantomJS and iOS 7.x
+    MutationObserver.toString() === '[object MutationObserverConstructor]'
+  )) {
+    // use MutationObserver where native Promise is not available,
+    // e.g. PhantomJS IE11, iOS7, Android 4.4
+    var counter = 1;
+    var observer = new MutationObserver(nextTickHandler);
+    var textNode = document.createTextNode(String(counter));
+    observer.observe(textNode, {
+      characterData: true
+    });
+    timerFunc = function () {
+      counter = (counter + 1) % 2;
+      textNode.data = String(counter);
+    };
+  } else {
+    // fallback to setTimeout
+    /* istanbul ignore next */
+    timerFunc = function () {
+      setTimeout(nextTickHandler, 0);
+    };
+  }
+
+  return function queueNextTick (cb, ctx) {
+    var _resolve;
+    callbacks.push(function () {
+      if (cb) { cb.call(ctx); }
+      if (_resolve) { _resolve(ctx); }
+    });
+    if (!pending) {
+      pending = true;
+      timerFunc();
+    }
+    if (!cb && typeof Promise !== 'undefined') {
+      return new Promise(function (resolve) {
+        _resolve = resolve;
+      })
+    }
+  }
+})();
+
+var _Set;
+/* istanbul ignore if */
+if (typeof Set !== 'undefined' && isNative(Set)) {
+  // use native Set when available.
+  _Set = Set;
+} else {
+  // a non-standard Set polyfill that only works with primitive keys.
+  _Set = (function () {
+    function Set () {
+      this.set = Object.create(null);
+    }
+    Set.prototype.has = function has (key) {
+      return this.set[key] === true
+    };
+    Set.prototype.add = function add (key) {
+      this.set[key] = true;
+    };
+    Set.prototype.clear = function clear () {
+      this.set = Object.create(null);
+    };
+
+    return Set;
+  }());
+}
+
+var perf;
+
+if (process.env.NODE_ENV !== 'production') {
+  perf = inBrowser && window.performance;
+  if (perf && (!perf.mark || !perf.measure)) {
+    perf = undefined;
+  }
+}
+
+/*  */
+
+var emptyObject = Object.freeze({});
+
+/**
+ * Check if a string starts with $ or _
+ */
+function isReserved (str) {
+  var c = (str + '').charCodeAt(0);
+  return c === 0x24 || c === 0x5F
+}
+
+/**
+ * Define a property.
+ */
+function def (obj, key, val, enumerable) {
+  Object.defineProperty(obj, key, {
+    value: val,
+    enumerable: !!enumerable,
+    writable: true,
+    configurable: true
+  });
+}
+
+/**
+ * Parse simple path.
+ */
+var bailRE = /[^\w.$]/;
+function parsePath (path) {
+  if (bailRE.test(path)) {
+    return
+  }
+  var segments = path.split('.');
+  return function (obj) {
+    for (var i = 0; i < segments.length; i++) {
+      if (!obj) { return }
+      obj = obj[segments[i]];
+    }
+    return obj
+  }
+}
+
+var warn = noop;
+var tip = noop;
+var formatComponentName;
+
+if (process.env.NODE_ENV !== 'production') {
+  var hasConsole = typeof console !== 'undefined';
+  var classifyRE = /(?:^|[-_])(\w)/g;
+  var classify = function (str) { return str
+    .replace(classifyRE, function (c) { return c.toUpperCase(); })
+    .replace(/[-_]/g, ''); };
+
+  warn = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.error("[Vue warn]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  tip = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.warn("[Vue tip]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  formatComponentName = function (vm, includeFile) {
+    if (vm.$root === vm) {
+      return '<Root>'
+    }
+    var name = vm._isVue
+      ? vm.$options.name || vm.$options._componentTag
+      : vm.name;
+
+    var file = vm._isVue && vm.$options.__file;
+    if (!name && file) {
+      var match = file.match(/([^/\\]+)\.vue$/);
+      name = match && match[1];
+    }
+
+    return (
+      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
+      (file && includeFile !== false ? (" at " + file) : '')
+    )
+  };
+
+  var formatLocation = function (str) {
+    if (str === "<Anonymous>") {
+      str += " - use the \"name\" option for better debugging messages.";
+    }
+    return ("\n(found in " + str + ")")
+  };
+}
+
+/*  */
+
+
+var uid$1 = 0;
+
+/**
+ * A dep is an observable that can have multiple
+ * directives subscribing to it.
+ */
+var Dep = function Dep () {
+  this.id = uid$1++;
+  this.subs = [];
+};
+
+Dep.prototype.addSub = function addSub (sub) {
+  this.subs.push(sub);
+};
+
+Dep.prototype.removeSub = function removeSub (sub) {
+  remove(this.subs, sub);
+};
+
+Dep.prototype.depend = function depend () {
+  if (Dep.target) {
+    Dep.target.addDep(this);
+  }
+};
+
+Dep.prototype.notify = function notify () {
+  // stabilize the subscriber list first
+  var subs = this.subs.slice();
+  for (var i = 0, l = subs.length; i < l; i++) {
+    subs[i].update();
+  }
+};
+
+// the current target watcher being evaluated.
+// this is globally unique because there could be only one
+// watcher being evaluated at any time.
+Dep.target = null;
+var targetStack = [];
+
+function pushTarget (_target) {
+  if (Dep.target) { targetStack.push(Dep.target); }
+  Dep.target = _target;
+}
+
+function popTarget () {
+  Dep.target = targetStack.pop();
+}
+
+/*
+ * not type checking this file because flow doesn't play well with
+ * dynamically accessing methods on Array prototype
+ */
+
+var arrayProto = Array.prototype;
+var arrayMethods = Object.create(arrayProto);[
+  'push',
+  'pop',
+  'shift',
+  'unshift',
+  'splice',
+  'sort',
+  'reverse'
+]
+.forEach(function (method) {
+  // cache original method
+  var original = arrayProto[method];
+  def(arrayMethods, method, function mutator () {
+    var arguments$1 = arguments;
+
+    // avoid leaking arguments:
+    // http://jsperf.com/closure-with-arguments
+    var i = arguments.length;
+    var args = new Array(i);
+    while (i--) {
+      args[i] = arguments$1[i];
+    }
+    var result = original.apply(this, args);
+    var ob = this.__ob__;
+    var inserted;
+    switch (method) {
+      case 'push':
+        inserted = args;
+        break
+      case 'unshift':
+        inserted = args;
+        break
+      case 'splice':
+        inserted = args.slice(2);
+        break
+    }
+    if (inserted) { ob.observeArray(inserted); }
+    // notify change
+    ob.dep.notify();
+    return result
+  });
+});
+
+/*  */
+
+var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
+
+/**
+ * By default, when a reactive property is set, the new value is
+ * also converted to become reactive. However when passing down props,
+ * we don't want to force conversion because the value may be a nested value
+ * under a frozen data structure. Converting it would defeat the optimization.
+ */
+var observerState = {
+  shouldConvert: true,
+  isSettingProps: false
+};
+
+/**
+ * Observer class that are attached to each observed
+ * object. Once attached, the observer converts target
+ * object's property keys into getter/setters that
+ * collect dependencies and dispatches updates.
+ */
+var Observer = function Observer (value) {
+  this.value = value;
+  this.dep = new Dep();
+  this.vmCount = 0;
+  def(value, '__ob__', this);
+  if (Array.isArray(value)) {
+    var augment = hasProto
+      ? protoAugment
+      : copyAugment;
+    augment(value, arrayMethods, arrayKeys);
+    this.observeArray(value);
+  } else {
+    this.walk(value);
+  }
+};
+
+/**
+ * Walk through each property and convert them into
+ * getter/setters. This method should only be called when
+ * value type is Object.
+ */
+Observer.prototype.walk = function walk (obj) {
+  var keys = Object.keys(obj);
+  for (var i = 0; i < keys.length; i++) {
+    defineReactive$$1(obj, keys[i], obj[keys[i]]);
+  }
+};
+
+/**
+ * Observe a list of Array items.
+ */
+Observer.prototype.observeArray = function observeArray (items) {
+  for (var i = 0, l = items.length; i < l; i++) {
+    observe(items[i]);
+  }
+};
+
+// helpers
+
+/**
+ * Augment an target Object or Array by intercepting
+ * the prototype chain using __proto__
+ */
+function protoAugment (target, src) {
+  /* eslint-disable no-proto */
+  target.__proto__ = src;
+  /* eslint-enable no-proto */
+}
+
+/**
+ * Augment an target Object or Array by defining
+ * hidden properties.
+ */
+/* istanbul ignore next */
+function copyAugment (target, src, keys) {
+  for (var i = 0, l = keys.length; i < l; i++) {
+    var key = keys[i];
+    def(target, key, src[key]);
+  }
+}
+
+/**
+ * Attempt to create an observer instance for a value,
+ * returns the new observer if successfully observed,
+ * or the existing observer if the value already has one.
+ */
+function observe (value, asRootData) {
+  if (!isObject(value)) {
+    return
+  }
+  var ob;
+  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+    ob = value.__ob__;
+  } else if (
+    observerState.shouldConvert &&
+    !isServerRendering() &&
+    (Array.isArray(value) || isPlainObject(value)) &&
+    Object.isExtensible(value) &&
+    !value._isVue
+  ) {
+    ob = new Observer(value);
+  }
+  if (asRootData && ob) {
+    ob.vmCount++;
+  }
+  return ob
+}
+
+/**
+ * Define a reactive property on an Object.
+ */
+function defineReactive$$1 (
+  obj,
+  key,
+  val,
+  customSetter
+) {
+  var dep = new Dep();
+
+  var property = Object.getOwnPropertyDescriptor(obj, key);
+  if (property && property.configurable === false) {
+    return
+  }
+
+  // cater for pre-defined getter/setters
+  var getter = property && property.get;
+  var setter = property && property.set;
+
+  var childOb = observe(val);
+  Object.defineProperty(obj, key, {
+    enumerable: true,
+    configurable: true,
+    get: function reactiveGetter () {
+      var value = getter ? getter.call(obj) : val;
+      if (Dep.target) {
+        dep.depend();
+        if (childOb) {
+          childOb.dep.depend();
+        }
+        if (Array.isArray(value)) {
+          dependArray(value);
+        }
+      }
+      return value
+    },
+    set: function reactiveSetter (newVal) {
+      var value = getter ? getter.call(obj) : val;
+      /* eslint-disable no-self-compare */
+      if (newVal === value || (newVal !== newVal && value !== value)) {
+        return
+      }
+      /* eslint-enable no-self-compare */
+      if (process.env.NODE_ENV !== 'production' && customSetter) {
+        customSetter();
+      }
+      if (setter) {
+        setter.call(obj, newVal);
+      } else {
+        val = newVal;
+      }
+      childOb = observe(newVal);
+      dep.notify();
+    }
+  });
+}
+
+/**
+ * Set a property on an object. Adds the new property and
+ * triggers change notification if the property doesn't
+ * already exist.
+ */
+function set (target, key, val) {
+  if (Array.isArray(target)) {
+    target.length = Math.max(target.length, key);
+    target.splice(key, 1, val);
+    return val
+  }
+  if (hasOwn(target, key)) {
+    target[key] = val;
+    return val
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid adding reactive properties to a Vue instance or its root $data ' +
+      'at runtime - declare it upfront in the data option.'
+    );
+    return val
+  }
+  if (!ob) {
+    target[key] = val;
+    return val
+  }
+  defineReactive$$1(ob.value, key, val);
+  ob.dep.notify();
+  return val
+}
+
+/**
+ * Delete a property and trigger change if necessary.
+ */
+function del (target, key) {
+  if (Array.isArray(target)) {
+    target.splice(key, 1);
+    return
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid deleting properties on a Vue instance or its root $data ' +
+      '- just set it to null.'
+    );
+    return
+  }
+  if (!hasOwn(target, key)) {
+    return
+  }
+  delete target[key];
+  if (!ob) {
+    return
+  }
+  ob.dep.notify();
+}
+
+/**
+ * Collect dependencies on array elements when the array is touched, since
+ * we cannot intercept array element access like property getters.
+ */
+function dependArray (value) {
+  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
+    e = value[i];
+    e && e.__ob__ && e.__ob__.dep.depend();
+    if (Array.isArray(e)) {
+      dependArray(e);
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Option overwriting strategies are functions that handle
+ * how to merge a parent option value and a child option
+ * value into the final value.
+ */
+var strats = config.optionMergeStrategies;
+
+/**
+ * Options with restrictions
+ */
+if (process.env.NODE_ENV !== 'production') {
+  strats.el = strats.propsData = function (parent, child, vm, key) {
+    if (!vm) {
+      warn(
+        "option \"" + key + "\" can only be used during instance " +
+        'creation with the `new` keyword.'
+      );
+    }
+    return defaultStrat(parent, child)
+  };
+}
+
+/**
+ * Helper that recursively merges two data objects together.
+ */
+function mergeData (to, from) {
+  if (!from) { return to }
+  var key, toVal, fromVal;
+  var keys = Object.keys(from);
+  for (var i = 0; i < keys.length; i++) {
+    key = keys[i];
+    toVal = to[key];
+    fromVal = from[key];
+    if (!hasOwn(to, key)) {
+      set(to, key, fromVal);
+    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
+      mergeData(toVal, fromVal);
+    }
+  }
+  return to
+}
+
+/**
+ * Data
+ */
+strats.data = function (
+  parentVal,
+  childVal,
+  vm
+) {
+  if (!vm) {
+    // in a Vue.extend merge, both should be functions
+    if (!childVal) {
+      return parentVal
+    }
+    if (typeof childVal !== 'function') {
+      process.env.NODE_ENV !== 'production' && warn(
+        'The "data" option should be a function ' +
+        'that returns a per-instance value in component ' +
+        'definitions.',
+        vm
+      );
+      return parentVal
+    }
+    if (!parentVal) {
+      return childVal
+    }
+    // when parentVal & childVal are both present,
+    // we need to return a function that returns the
+    // merged result of both functions... no need to
+    // check if parentVal is a function here because
+    // it has to be a function to pass previous merges.
+    return function mergedDataFn () {
+      return mergeData(
+        childVal.call(this),
+        parentVal.call(this)
+      )
+    }
+  } else if (parentVal || childVal) {
+    return function mergedInstanceDataFn () {
+      // instance merge
+      var instanceData = typeof childVal === 'function'
+        ? childVal.call(vm)
+        : childVal;
+      var defaultData = typeof parentVal === 'function'
+        ? parentVal.call(vm)
+        : undefined;
+      if (instanceData) {
+        return mergeData(instanceData, defaultData)
+      } else {
+        return defaultData
+      }
+    }
+  }
+};
+
+/**
+ * Hooks and props are merged as arrays.
+ */
+function mergeHook (
+  parentVal,
+  childVal
+) {
+  return childVal
+    ? parentVal
+      ? parentVal.concat(childVal)
+      : Array.isArray(childVal)
+        ? childVal
+        : [childVal]
+    : parentVal
+}
+
+config._lifecycleHooks.forEach(function (hook) {
+  strats[hook] = mergeHook;
+});
+
+/**
+ * Assets
+ *
+ * When a vm is present (instance creation), we need to do
+ * a three-way merge between constructor options, instance
+ * options and parent options.
+ */
+function mergeAssets (parentVal, childVal) {
+  var res = Object.create(parentVal || null);
+  return childVal
+    ? extend(res, childVal)
+    : res
+}
+
+config._assetTypes.forEach(function (type) {
+  strats[type + 's'] = mergeAssets;
+});
+
+/**
+ * Watchers.
+ *
+ * Watchers hashes should not overwrite one
+ * another, so we merge them as arrays.
+ */
+strats.watch = function (parentVal, childVal) {
+  /* istanbul ignore if */
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = {};
+  extend(ret, parentVal);
+  for (var key in childVal) {
+    var parent = ret[key];
+    var child = childVal[key];
+    if (parent && !Array.isArray(parent)) {
+      parent = [parent];
+    }
+    ret[key] = parent
+      ? parent.concat(child)
+      : [child];
+  }
+  return ret
+};
+
+/**
+ * Other object hashes.
+ */
+strats.props =
+strats.methods =
+strats.computed = function (parentVal, childVal) {
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = Object.create(null);
+  extend(ret, parentVal);
+  extend(ret, childVal);
+  return ret
+};
+
+/**
+ * Default strategy.
+ */
+var defaultStrat = function (parentVal, childVal) {
+  return childVal === undefined
+    ? parentVal
+    : childVal
+};
+
+/**
+ * Validate component names
+ */
+function checkComponents (options) {
+  for (var key in options.components) {
+    var lower = key.toLowerCase();
+    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
+      warn(
+        'Do not use built-in or reserved HTML elements as component ' +
+        'id: ' + key
+      );
+    }
+  }
+}
+
+/**
+ * Ensure all props option syntax are normalized into the
+ * Object-based format.
+ */
+function normalizeProps (options) {
+  var props = options.props;
+  if (!props) { return }
+  var res = {};
+  var i, val, name;
+  if (Array.isArray(props)) {
+    i = props.length;
+    while (i--) {
+      val = props[i];
+      if (typeof val === 'string') {
+        name = camelize(val);
+        res[name] = { type: null };
+      } else if (process.env.NODE_ENV !== 'production') {
+        warn('props must be strings when using array syntax.');
+      }
+    }
+  } else if (isPlainObject(props)) {
+    for (var key in props) {
+      val = props[key];
+      name = camelize(key);
+      res[name] = isPlainObject(val)
+        ? val
+        : { type: val };
+    }
+  }
+  options.props = res;
+}
+
+/**
+ * Normalize raw function directives into object format.
+ */
+function normalizeDirectives (options) {
+  var dirs = options.directives;
+  if (dirs) {
+    for (var key in dirs) {
+      var def = dirs[key];
+      if (typeof def === 'function') {
+        dirs[key] = { bind: def, update: def };
+      }
+    }
+  }
+}
+
+/**
+ * Merge two option objects into a new one.
+ * Core utility used in both instantiation and inheritance.
+ */
+function mergeOptions (
+  parent,
+  child,
+  vm
+) {
+  if (process.env.NODE_ENV !== 'production') {
+    checkComponents(child);
+  }
+  normalizeProps(child);
+  normalizeDirectives(child);
+  var extendsFrom = child.extends;
+  if (extendsFrom) {
+    parent = typeof extendsFrom === 'function'
+      ? mergeOptions(parent, extendsFrom.options, vm)
+      : mergeOptions(parent, extendsFrom, vm);
+  }
+  if (child.mixins) {
+    for (var i = 0, l = child.mixins.length; i < l; i++) {
+      var mixin = child.mixins[i];
+      if (mixin.prototype instanceof Vue$2) {
+        mixin = mixin.options;
+      }
+      parent = mergeOptions(parent, mixin, vm);
+    }
+  }
+  var options = {};
+  var key;
+  for (key in parent) {
+    mergeField(key);
+  }
+  for (key in child) {
+    if (!hasOwn(parent, key)) {
+      mergeField(key);
+    }
+  }
+  function mergeField (key) {
+    var strat = strats[key] || defaultStrat;
+    options[key] = strat(parent[key], child[key], vm, key);
+  }
+  return options
+}
+
+/**
+ * Resolve an asset.
+ * This function is used because child instances need access
+ * to assets defined in its ancestor chain.
+ */
+function resolveAsset (
+  options,
+  type,
+  id,
+  warnMissing
+) {
+  /* istanbul ignore if */
+  if (typeof id !== 'string') {
+    return
+  }
+  var assets = options[type];
+  // check local registration variations first
+  if (hasOwn(assets, id)) { return assets[id] }
+  var camelizedId = camelize(id);
+  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
+  var PascalCaseId = capitalize(camelizedId);
+  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
+  // fallback to prototype chain
+  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
+  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
+    warn(
+      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
+      options
+    );
+  }
+  return res
+}
+
+/*  */
+
+function validateProp (
+  key,
+  propOptions,
+  propsData,
+  vm
+) {
+  var prop = propOptions[key];
+  var absent = !hasOwn(propsData, key);
+  var value = propsData[key];
+  // handle boolean props
+  if (isType(Boolean, prop.type)) {
+    if (absent && !hasOwn(prop, 'default')) {
+      value = false;
+    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
+      value = true;
+    }
+  }
+  // check default value
+  if (value === undefined) {
+    value = getPropDefaultValue(vm, prop, key);
+    // since the default value is a fresh copy,
+    // make sure to observe it.
+    var prevShouldConvert = observerState.shouldConvert;
+    observerState.shouldConvert = true;
+    observe(value);
+    observerState.shouldConvert = prevShouldConvert;
+  }
+  if (process.env.NODE_ENV !== 'production') {
+    assertProp(prop, key, value, vm, absent);
+  }
+  return value
+}
+
+/**
+ * Get the default value of a prop.
+ */
+function getPropDefaultValue (vm, prop, key) {
+  // no default, return undefined
+  if (!hasOwn(prop, 'default')) {
+    return undefined
+  }
+  var def = prop.default;
+  // warn against non-factory defaults for Object & Array
+  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
+    warn(
+      'Invalid default value for prop "' + key + '": ' +
+      'Props with type Object/Array must use a factory function ' +
+      'to return the default value.',
+      vm
+    );
+  }
+  // the raw prop value was also undefined from previous render,
+  // return previous default value to avoid unnecessary watcher trigger
+  if (vm && vm.$options.propsData &&
+    vm.$options.propsData[key] === undefined &&
+    vm._props[key] !== undefined) {
+    return vm._props[key]
+  }
+  // call factory function for non-Function types
+  // a value is Function if its prototype is function even across different execution context
+  return typeof def === 'function' && getType(prop.type) !== 'Function'
+    ? def.call(vm)
+    : def
+}
+
+/**
+ * Assert whether a prop is valid.
+ */
+function assertProp (
+  prop,
+  name,
+  value,
+  vm,
+  absent
+) {
+  if (prop.required && absent) {
+    warn(
+      'Missing required prop: "' + name + '"',
+      vm
+    );
+    return
+  }
+  if (value == null && !prop.required) {
+    return
+  }
+  var type = prop.type;
+  var valid = !type || type === true;
+  var expectedTypes = [];
+  if (type) {
+    if (!Array.isArray(type)) {
+      type = [type];
+    }
+    for (var i = 0; i < type.length && !valid; i++) {
+      var assertedType = assertType(value, type[i]);
+      expectedTypes.push(assertedType.expectedType || '');
+      valid = assertedType.valid;
+    }
+  }
+  if (!valid) {
+    warn(
+      'Invalid prop: type check failed for prop "' + name + '".' +
+      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
+      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
+      vm
+    );
+    return
+  }
+  var validator = prop.validator;
+  if (validator) {
+    if (!validator(value)) {
+      warn(
+        'Invalid prop: custom validator check failed for prop "' + name + '".',
+        vm
+      );
+    }
+  }
+}
+
+/**
+ * Assert the type of a value
+ */
+function assertType (value, type) {
+  var valid;
+  var expectedType = getType(type);
+  if (expectedType === 'String') {
+    valid = typeof value === (expectedType = 'string');
+  } else if (expectedType === 'Number') {
+    valid = typeof value === (expectedType = 'number');
+  } else if (expectedType === 'Boolean') {
+    valid = typeof value === (expectedType = 'boolean');
+  } else if (expectedType === 'Function') {
+    valid = typeof value === (expectedType = 'function');
+  } else if (expectedType === 'Object') {
+    valid = isPlainObject(value);
+  } else if (expectedType === 'Array') {
+    valid = Array.isArray(value);
+  } else {
+    valid = value instanceof type;
+  }
+  return {
+    valid: valid,
+    expectedType: expectedType
+  }
+}
+
+/**
+ * Use function string name to check built-in types,
+ * because a simple equality check will fail when running
+ * across different vms / iframes.
+ */
+function getType (fn) {
+  var match = fn && fn.toString().match(/^\s*function (\w+)/);
+  return match && match[1]
+}
+
+function isType (type, fn) {
+  if (!Array.isArray(fn)) {
+    return getType(fn) === getType(type)
+  }
+  for (var i = 0, len = fn.length; i < len; i++) {
+    if (getType(fn[i]) === getType(type)) {
+      return true
+    }
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function handleError (err, vm, info) {
+  if (config.errorHandler) {
+    config.errorHandler.call(null, err, vm, info);
+  } else {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Error in " + info + ":"), vm);
+    }
+    /* istanbul ignore else */
+    if (inBrowser && typeof console !== 'undefined') {
+      console.error(err);
+    } else {
+      throw err
+    }
+  }
+}
+
+/* not type checking this file because flow doesn't play well with Proxy */
+
+var initProxy;
+
+if (process.env.NODE_ENV !== 'production') {
+  var allowedGlobals = makeMap(
+    'Infinity,undefined,NaN,isFinite,isNaN,' +
+    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
+    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
+    'require' // for Webpack/Browserify
+  );
+
+  var warnNonPresent = function (target, key) {
+    warn(
+      "Property or method \"" + key + "\" is not defined on the instance but " +
+      "referenced during render. Make sure to declare reactive data " +
+      "properties in the data option.",
+      target
+    );
+  };
+
+  var hasProxy =
+    typeof Proxy !== 'undefined' &&
+    Proxy.toString().match(/native code/);
+
+  if (hasProxy) {
+    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
+    config.keyCodes = new Proxy(config.keyCodes, {
+      set: function set (target, key, value) {
+        if (isBuiltInModifier(key)) {
+          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
+          return false
+        } else {
+          target[key] = value;
+          return true
+        }
+      }
+    });
+  }
+
+  var hasHandler = {
+    has: function has (target, key) {
+      var has = key in target;
+      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
+      if (!has && !isAllowed) {
+        warnNonPresent(target, key);
+      }
+      return has || !isAllowed
+    }
+  };
+
+  var getHandler = {
+    get: function get (target, key) {
+      if (typeof key === 'string' && !(key in target)) {
+        warnNonPresent(target, key);
+      }
+      return target[key]
+    }
+  };
+
+  initProxy = function initProxy (vm) {
+    if (hasProxy) {
+      // determine which proxy handler to use
+      var options = vm.$options;
+      var handlers = options.render && options.render._withStripped
+        ? getHandler
+        : hasHandler;
+      vm._renderProxy = new Proxy(vm, handlers);
+    } else {
+      vm._renderProxy = vm;
+    }
+  };
+}
+
+/*  */
+
+var VNode = function VNode (
+  tag,
+  data,
+  children,
+  text,
+  elm,
+  context,
+  componentOptions
+) {
+  this.tag = tag;
+  this.data = data;
+  this.children = children;
+  this.text = text;
+  this.elm = elm;
+  this.ns = undefined;
+  this.context = context;
+  this.functionalContext = undefined;
+  this.key = data && data.key;
+  this.componentOptions = componentOptions;
+  this.componentInstance = undefined;
+  this.parent = undefined;
+  this.raw = false;
+  this.isStatic = false;
+  this.isRootInsert = true;
+  this.isComment = false;
+  this.isCloned = false;
+  this.isOnce = false;
+};
+
+var prototypeAccessors = { child: {} };
+
+// DEPRECATED: alias for componentInstance for backwards compat.
+/* istanbul ignore next */
+prototypeAccessors.child.get = function () {
+  return this.componentInstance
+};
+
+Object.defineProperties( VNode.prototype, prototypeAccessors );
+
+var createEmptyVNode = function () {
+  var node = new VNode();
+  node.text = '';
+  node.isComment = true;
+  return node
+};
+
+function createTextVNode (val) {
+  return new VNode(undefined, undefined, undefined, String(val))
+}
+
+// optimized shallow clone
+// used for static nodes and slot nodes because they may be reused across
+// multiple renders, cloning them avoids errors when DOM manipulations rely
+// on their elm reference.
+function cloneVNode (vnode) {
+  var cloned = new VNode(
+    vnode.tag,
+    vnode.data,
+    vnode.children,
+    vnode.text,
+    vnode.elm,
+    vnode.context,
+    vnode.componentOptions
+  );
+  cloned.ns = vnode.ns;
+  cloned.isStatic = vnode.isStatic;
+  cloned.key = vnode.key;
+  cloned.isCloned = true;
+  return cloned
+}
+
+function cloneVNodes (vnodes) {
+  var len = vnodes.length;
+  var res = new Array(len);
+  for (var i = 0; i < len; i++) {
+    res[i] = cloneVNode(vnodes[i]);
+  }
+  return res
+}
+
+/*  */
+
+var normalizeEvent = cached(function (name) {
+  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
+  name = once$$1 ? name.slice(1) : name;
+  var capture = name.charAt(0) === '!';
+  name = capture ? name.slice(1) : name;
+  return {
+    name: name,
+    once: once$$1,
+    capture: capture
+  }
+});
+
+function createFnInvoker (fns) {
+  function invoker () {
+    var arguments$1 = arguments;
+
+    var fns = invoker.fns;
+    if (Array.isArray(fns)) {
+      for (var i = 0; i < fns.length; i++) {
+        fns[i].apply(null, arguments$1);
+      }
+    } else {
+      // return handler return value for single handlers
+      return fns.apply(null, arguments)
+    }
+  }
+  invoker.fns = fns;
+  return invoker
+}
+
+function updateListeners (
+  on,
+  oldOn,
+  add,
+  remove$$1,
+  vm
+) {
+  var name, cur, old, event;
+  for (name in on) {
+    cur = on[name];
+    old = oldOn[name];
+    event = normalizeEvent(name);
+    if (!cur) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
+        vm
+      );
+    } else if (!old) {
+      if (!cur.fns) {
+        cur = on[name] = createFnInvoker(cur);
+      }
+      add(event.name, cur, event.once, event.capture);
+    } else if (cur !== old) {
+      old.fns = cur;
+      on[name] = old;
+    }
+  }
+  for (name in oldOn) {
+    if (!on[name]) {
+      event = normalizeEvent(name);
+      remove$$1(event.name, oldOn[name], event.capture);
+    }
+  }
+}
+
+/*  */
+
+function mergeVNodeHook (def, hookKey, hook) {
+  var invoker;
+  var oldHook = def[hookKey];
+
+  function wrappedHook () {
+    hook.apply(this, arguments);
+    // important: remove merged hook to ensure it's called only once
+    // and prevent memory leak
+    remove(invoker.fns, wrappedHook);
+  }
+
+  if (!oldHook) {
+    // no existing hook
+    invoker = createFnInvoker([wrappedHook]);
+  } else {
+    /* istanbul ignore if */
+    if (oldHook.fns && oldHook.merged) {
+      // already a merged invoker
+      invoker = oldHook;
+      invoker.fns.push(wrappedHook);
+    } else {
+      // existing plain hook
+      invoker = createFnInvoker([oldHook, wrappedHook]);
+    }
+  }
+
+  invoker.merged = true;
+  def[hookKey] = invoker;
+}
+
+/*  */
+
+// The template compiler attempts to minimize the need for normalization by
+// statically analyzing the template at compile time.
+//
+// For plain HTML markup, normalization can be completely skipped because the
+// generated render function is guaranteed to return Array<VNode>. There are
+// two cases where extra normalization is needed:
+
+// 1. When the children contains components - because a functional component
+// may return an Array instead of a single root. In this case, just a simple
+// normalization is needed - if any child is an Array, we flatten the whole
+// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
+// because functional components already normalize their own children.
+function simpleNormalizeChildren (children) {
+  for (var i = 0; i < children.length; i++) {
+    if (Array.isArray(children[i])) {
+      return Array.prototype.concat.apply([], children)
+    }
+  }
+  return children
+}
+
+// 2. When the children contains constructs that always generated nested Arrays,
+// e.g. <template>, <slot>, v-for, or when the children is provided by user
+// with hand-written render functions / JSX. In such cases a full normalization
+// is needed to cater to all possible types of children values.
+function normalizeChildren (children) {
+  return isPrimitive(children)
+    ? [createTextVNode(children)]
+    : Array.isArray(children)
+      ? normalizeArrayChildren(children)
+      : undefined
+}
+
+function normalizeArrayChildren (children, nestedIndex) {
+  var res = [];
+  var i, c, last;
+  for (i = 0; i < children.length; i++) {
+    c = children[i];
+    if (c == null || typeof c === 'boolean') { continue }
+    last = res[res.length - 1];
+    //  nested
+    if (Array.isArray(c)) {
+      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
+    } else if (isPrimitive(c)) {
+      if (last && last.text) {
+        last.text += String(c);
+      } else if (c !== '') {
+        // convert primitive to vnode
+        res.push(createTextVNode(c));
+      }
+    } else {
+      if (c.text && last && last.text) {
+        res[res.length - 1] = createTextVNode(last.text + c.text);
+      } else {
+        // default key for nested array children (likely generated by v-for)
+        if (c.tag && c.key == null && nestedIndex != null) {
+          c.key = "__vlist" + nestedIndex + "_" + i + "__";
+        }
+        res.push(c);
+      }
+    }
+  }
+  return res
+}
+
+/*  */
+
+function getFirstComponentChild (children) {
+  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
+}
+
+/*  */
+
+function initEvents (vm) {
+  vm._events = Object.create(null);
+  vm._hasHookEvent = false;
+  // init parent attached events
+  var listeners = vm.$options._parentListeners;
+  if (listeners) {
+    updateComponentListeners(vm, listeners);
+  }
+}
+
+var target;
+
+function add (event, fn, once$$1) {
+  if (once$$1) {
+    target.$once(event, fn);
+  } else {
+    target.$on(event, fn);
+  }
+}
+
+function remove$1 (event, fn) {
+  target.$off(event, fn);
+}
+
+function updateComponentListeners (
+  vm,
+  listeners,
+  oldListeners
+) {
+  target = vm;
+  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
+}
+
+function eventsMixin (Vue) {
+  var hookRE = /^hook:/;
+  Vue.prototype.$on = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    if (Array.isArray(event)) {
+      for (var i = 0, l = event.length; i < l; i++) {
+        this$1.$on(event[i], fn);
+      }
+    } else {
+      (vm._events[event] || (vm._events[event] = [])).push(fn);
+      // optimize hook:event cost by using a boolean flag marked at registration
+      // instead of a hash lookup
+      if (hookRE.test(event)) {
+        vm._hasHookEvent = true;
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$once = function (event, fn) {
+    var vm = this;
+    function on () {
+      vm.$off(event, on);
+      fn.apply(vm, arguments);
+    }
+    on.fn = fn;
+    vm.$on(event, on);
+    return vm
+  };
+
+  Vue.prototype.$off = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    // all
+    if (!arguments.length) {
+      vm._events = Object.create(null);
+      return vm
+    }
+    // array of events
+    if (Array.isArray(event)) {
+      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
+        this$1.$off(event[i$1], fn);
+      }
+      return vm
+    }
+    // specific event
+    var cbs = vm._events[event];
+    if (!cbs) {
+      return vm
+    }
+    if (arguments.length === 1) {
+      vm._events[event] = null;
+      return vm
+    }
+    // specific handler
+    var cb;
+    var i = cbs.length;
+    while (i--) {
+      cb = cbs[i];
+      if (cb === fn || cb.fn === fn) {
+        cbs.splice(i, 1);
+        break
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$emit = function (event) {
+    var vm = this;
+    var cbs = vm._events[event];
+    if (cbs) {
+      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
+      var args = toArray(arguments, 1);
+      for (var i = 0, l = cbs.length; i < l; i++) {
+        cbs[i].apply(vm, args);
+      }
+    }
+    return vm
+  };
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving raw children VNodes into a slot object.
+ */
+function resolveSlots (
+  children,
+  context
+) {
+  var slots = {};
+  if (!children) {
+    return slots
+  }
+  var defaultSlot = [];
+  var name, child;
+  for (var i = 0, l = children.length; i < l; i++) {
+    child = children[i];
+    // named slots should only be respected if the vnode was rendered in the
+    // same context.
+    if ((child.context === context || child.functionalContext === context) &&
+        child.data && (name = child.data.slot)) {
+      var slot = (slots[name] || (slots[name] = []));
+      if (child.tag === 'template') {
+        slot.push.apply(slot, child.children);
+      } else {
+        slot.push(child);
+      }
+    } else {
+      defaultSlot.push(child);
+    }
+  }
+  // ignore whitespace
+  if (!defaultSlot.every(isWhitespace)) {
+    slots.default = defaultSlot;
+  }
+  return slots
+}
+
+function isWhitespace (node) {
+  return node.isComment || node.text === ' '
+}
+
+function resolveScopedSlots (
+  fns
+) {
+  var res = {};
+  for (var i = 0; i < fns.length; i++) {
+    res[fns[i][0]] = fns[i][1];
+  }
+  return res
+}
+
+/*  */
+
+var activeInstance = null;
+
+function initLifecycle (vm) {
+  var options = vm.$options;
+
+  // locate first non-abstract parent
+  var parent = options.parent;
+  if (parent && !options.abstract) {
+    while (parent.$options.abstract && parent.$parent) {
+      parent = parent.$parent;
+    }
+    parent.$children.push(vm);
+  }
+
+  vm.$parent = parent;
+  vm.$root = parent ? parent.$root : vm;
+
+  vm.$children = [];
+  vm.$refs = {};
+
+  vm._watcher = null;
+  vm._inactive = null;
+  vm._directInactive = false;
+  vm._isMounted = false;
+  vm._isDestroyed = false;
+  vm._isBeingDestroyed = false;
+}
+
+function lifecycleMixin (Vue) {
+  Vue.prototype._update = function (vnode, hydrating) {
+    var vm = this;
+    if (vm._isMounted) {
+      callHook(vm, 'beforeUpdate');
+    }
+    var prevEl = vm.$el;
+    var prevVnode = vm._vnode;
+    var prevActiveInstance = activeInstance;
+    activeInstance = vm;
+    vm._vnode = vnode;
+    // Vue.prototype.__patch__ is injected in entry points
+    // based on the rendering backend used.
+    if (!prevVnode) {
+      // initial render
+      vm.$el = vm.__patch__(
+        vm.$el, vnode, hydrating, false /* removeOnly */,
+        vm.$options._parentElm,
+        vm.$options._refElm
+      );
+    } else {
+      // updates
+      vm.$el = vm.__patch__(prevVnode, vnode);
+    }
+    activeInstance = prevActiveInstance;
+    // update __vue__ reference
+    if (prevEl) {
+      prevEl.__vue__ = null;
+    }
+    if (vm.$el) {
+      vm.$el.__vue__ = vm;
+    }
+    // if parent is an HOC, update its $el as well
+    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
+      vm.$parent.$el = vm.$el;
+    }
+    // updated hook is called by the scheduler to ensure that children are
+    // updated in a parent's updated hook.
+  };
+
+  Vue.prototype.$forceUpdate = function () {
+    var vm = this;
+    if (vm._watcher) {
+      vm._watcher.update();
+    }
+  };
+
+  Vue.prototype.$destroy = function () {
+    var vm = this;
+    if (vm._isBeingDestroyed) {
+      return
+    }
+    callHook(vm, 'beforeDestroy');
+    vm._isBeingDestroyed = true;
+    // remove self from parent
+    var parent = vm.$parent;
+    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
+      remove(parent.$children, vm);
+    }
+    // teardown watchers
+    if (vm._watcher) {
+      vm._watcher.teardown();
+    }
+    var i = vm._watchers.length;
+    while (i--) {
+      vm._watchers[i].teardown();
+    }
+    // remove reference from data ob
+    // frozen object may not have observer.
+    if (vm._data.__ob__) {
+      vm._data.__ob__.vmCount--;
+    }
+    // call the last hook...
+    vm._isDestroyed = true;
+    callHook(vm, 'destroyed');
+    // turn off all instance listeners.
+    vm.$off();
+    // remove __vue__ reference
+    if (vm.$el) {
+      vm.$el.__vue__ = null;
+    }
+    // invoke destroy hooks on current rendered tree
+    vm.__patch__(vm._vnode, null);
+  };
+}
+
+function mountComponent (
+  vm,
+  el,
+  hydrating
+) {
+  vm.$el = el;
+  if (!vm.$options.render) {
+    vm.$options.render = createEmptyVNode;
+    if (process.env.NODE_ENV !== 'production') {
+      /* istanbul ignore if */
+      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
+        vm.$options.el || el) {
+        warn(
+          'You are using the runtime-only build of Vue where the template ' +
+          'compiler is not available. Either pre-compile the templates into ' +
+          'render functions, or use the compiler-included build.',
+          vm
+        );
+      } else {
+        warn(
+          'Failed to mount component: template or render function not defined.',
+          vm
+        );
+      }
+    }
+  }
+  callHook(vm, 'beforeMount');
+
+  var updateComponent;
+  /* istanbul ignore if */
+  if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+    updateComponent = function () {
+      var name = vm._name;
+      var startTag = "start " + name;
+      var endTag = "end " + name;
+      perf.mark(startTag);
+      var vnode = vm._render();
+      perf.mark(endTag);
+      perf.measure((name + " render"), startTag, endTag);
+      perf.mark(startTag);
+      vm._update(vnode, hydrating);
+      perf.mark(endTag);
+      perf.measure((name + " patch"), startTag, endTag);
+    };
+  } else {
+    updateComponent = function () {
+      vm._update(vm._render(), hydrating);
+    };
+  }
+
+  vm._watcher = new Watcher(vm, updateComponent, noop);
+  hydrating = false;
+
+  // manually mounted instance, call mounted on self
+  // mounted is called for render-created child components in its inserted hook
+  if (vm.$vnode == null) {
+    vm._isMounted = true;
+    callHook(vm, 'mounted');
+  }
+  return vm
+}
+
+function updateChildComponent (
+  vm,
+  propsData,
+  listeners,
+  parentVnode,
+  renderChildren
+) {
+  // determine whether component has slot children
+  // we need to do this before overwriting $options._renderChildren
+  var hasChildren = !!(
+    renderChildren ||               // has new static slots
+    vm.$options._renderChildren ||  // has old static slots
+    parentVnode.data.scopedSlots || // has new scoped slots
+    vm.$scopedSlots !== emptyObject // has old scoped slots
+  );
+
+  vm.$options._parentVnode = parentVnode;
+  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
+  if (vm._vnode) { // update child tree's parent
+    vm._vnode.parent = parentVnode;
+  }
+  vm.$options._renderChildren = renderChildren;
+
+  // update props
+  if (propsData && vm.$options.props) {
+    observerState.shouldConvert = false;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = true;
+    }
+    var props = vm._props;
+    var propKeys = vm.$options._propKeys || [];
+    for (var i = 0; i < propKeys.length; i++) {
+      var key = propKeys[i];
+      props[key] = validateProp(key, vm.$options.props, propsData, vm);
+    }
+    observerState.shouldConvert = true;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = false;
+    }
+    // keep a copy of raw propsData
+    vm.$options.propsData = propsData;
+  }
+  // update listeners
+  if (listeners) {
+    var oldListeners = vm.$options._parentListeners;
+    vm.$options._parentListeners = listeners;
+    updateComponentListeners(vm, listeners, oldListeners);
+  }
+  // resolve slots + force update if has children
+  if (hasChildren) {
+    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
+    vm.$forceUpdate();
+  }
+}
+
+function isInInactiveTree (vm) {
+  while (vm && (vm = vm.$parent)) {
+    if (vm._inactive) { return true }
+  }
+  return false
+}
+
+function activateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = false;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  } else if (vm._directInactive) {
+    return
+  }
+  if (vm._inactive || vm._inactive == null) {
+    vm._inactive = false;
+    for (var i = 0; i < vm.$children.length; i++) {
+      activateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'activated');
+  }
+}
+
+function deactivateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = true;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  }
+  if (!vm._inactive) {
+    vm._inactive = true;
+    for (var i = 0; i < vm.$children.length; i++) {
+      deactivateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'deactivated');
+  }
+}
+
+function callHook (vm, hook) {
+  var handlers = vm.$options[hook];
+  if (handlers) {
+    for (var i = 0, j = handlers.length; i < j; i++) {
+      try {
+        handlers[i].call(vm);
+      } catch (e) {
+        handleError(e, vm, (hook + " hook"));
+      }
+    }
+  }
+  if (vm._hasHookEvent) {
+    vm.$emit('hook:' + hook);
+  }
+}
+
+/*  */
+
+
+var queue = [];
+var has = {};
+var circular = {};
+var waiting = false;
+var flushing = false;
+var index = 0;
+
+/**
+ * Reset the scheduler's state.
+ */
+function resetSchedulerState () {
+  queue.length = 0;
+  has = {};
+  if (process.env.NODE_ENV !== 'production') {
+    circular = {};
+  }
+  waiting = flushing = false;
+}
+
+/**
+ * Flush both queues and run the watchers.
+ */
+function flushSchedulerQueue () {
+  flushing = true;
+  var watcher, id, vm;
+
+  // Sort queue before flush.
+  // This ensures that:
+  // 1. Components are updated from parent to child. (because parent is always
+  //    created before the child)
+  // 2. A component's user watchers are run before its render watcher (because
+  //    user watchers are created before the render watcher)
+  // 3. If a component is destroyed during a parent component's watcher run,
+  //    its watchers can be skipped.
+  queue.sort(function (a, b) { return a.id - b.id; });
+
+  // do not cache length because more watchers might be pushed
+  // as we run existing watchers
+  for (index = 0; index < queue.length; index++) {
+    watcher = queue[index];
+    id = watcher.id;
+    has[id] = null;
+    watcher.run();
+    // in dev build, check and stop circular updates.
+    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
+      circular[id] = (circular[id] || 0) + 1;
+      if (circular[id] > config._maxUpdateCount) {
+        warn(
+          'You may have an infinite update loop ' + (
+            watcher.user
+              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
+              : "in a component render function."
+          ),
+          watcher.vm
+        );
+        break
+      }
+    }
+  }
+
+  // call updated hooks
+  index = queue.length;
+  while (index--) {
+    watcher = queue[index];
+    vm = watcher.vm;
+    if (vm._watcher === watcher && vm._isMounted) {
+      callHook(vm, 'updated');
+    }
+  }
+
+  // devtool hook
+  /* istanbul ignore if */
+  if (devtools && config.devtools) {
+    devtools.emit('flush');
+  }
+
+  resetSchedulerState();
+}
+
+/**
+ * Push a watcher into the watcher queue.
+ * Jobs with duplicate IDs will be skipped unless it's
+ * pushed when the queue is being flushed.
+ */
+function queueWatcher (watcher) {
+  var id = watcher.id;
+  if (has[id] == null) {
+    has[id] = true;
+    if (!flushing) {
+      queue.push(watcher);
+    } else {
+      // if already flushing, splice the watcher based on its id
+      // if already past its id, it will be run next immediately.
+      var i = queue.length - 1;
+      while (i >= 0 && queue[i].id > watcher.id) {
+        i--;
+      }
+      queue.splice(Math.max(i, index) + 1, 0, watcher);
+    }
+    // queue the flush
+    if (!waiting) {
+      waiting = true;
+      nextTick(flushSchedulerQueue);
+    }
+  }
+}
+
+/*  */
+
+var uid$2 = 0;
+
+/**
+ * A watcher parses an expression, collects dependencies,
+ * and fires callback when the expression value changes.
+ * This is used for both the $watch() api and directives.
+ */
+var Watcher = function Watcher (
+  vm,
+  expOrFn,
+  cb,
+  options
+) {
+  this.vm = vm;
+  vm._watchers.push(this);
+  // options
+  if (options) {
+    this.deep = !!options.deep;
+    this.user = !!options.user;
+    this.lazy = !!options.lazy;
+    this.sync = !!options.sync;
+  } else {
+    this.deep = this.user = this.lazy = this.sync = false;
+  }
+  this.cb = cb;
+  this.id = ++uid$2; // uid for batching
+  this.active = true;
+  this.dirty = this.lazy; // for lazy watchers
+  this.deps = [];
+  this.newDeps = [];
+  this.depIds = new _Set();
+  this.newDepIds = new _Set();
+  this.expression = process.env.NODE_ENV !== 'production'
+    ? expOrFn.toString()
+    : '';
+  // parse expression for getter
+  if (typeof expOrFn === 'function') {
+    this.getter = expOrFn;
+  } else {
+    this.getter = parsePath(expOrFn);
+    if (!this.getter) {
+      this.getter = function () {};
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed watching path: \"" + expOrFn + "\" " +
+        'Watcher only accepts simple dot-delimited paths. ' +
+        'For full control, use a function instead.',
+        vm
+      );
+    }
+  }
+  this.value = this.lazy
+    ? undefined
+    : this.get();
+};
+
+/**
+ * Evaluate the getter, and re-collect dependencies.
+ */
+Watcher.prototype.get = function get () {
+  pushTarget(this);
+  var value;
+  var vm = this.vm;
+  if (this.user) {
+    try {
+      value = this.getter.call(vm, vm);
+    } catch (e) {
+      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
+    }
+  } else {
+    value = this.getter.call(vm, vm);
+  }
+  // "touch" every property so they are all tracked as
+  // dependencies for deep watching
+  if (this.deep) {
+    traverse(value);
+  }
+  popTarget();
+  this.cleanupDeps();
+  return value
+};
+
+/**
+ * Add a dependency to this directive.
+ */
+Watcher.prototype.addDep = function addDep (dep) {
+  var id = dep.id;
+  if (!this.newDepIds.has(id)) {
+    this.newDepIds.add(id);
+    this.newDeps.push(dep);
+    if (!this.depIds.has(id)) {
+      dep.addSub(this);
+    }
+  }
+};
+
+/**
+ * Clean up for dependency collection.
+ */
+Watcher.prototype.cleanupDeps = function cleanupDeps () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    var dep = this$1.deps[i];
+    if (!this$1.newDepIds.has(dep.id)) {
+      dep.removeSub(this$1);
+    }
+  }
+  var tmp = this.depIds;
+  this.depIds = this.newDepIds;
+  this.newDepIds = tmp;
+  this.newDepIds.clear();
+  tmp = this.deps;
+  this.deps = this.newDeps;
+  this.newDeps = tmp;
+  this.newDeps.length = 0;
+};
+
+/**
+ * Subscriber interface.
+ * Will be called when a dependency changes.
+ */
+Watcher.prototype.update = function update () {
+  /* istanbul ignore else */
+  if (this.lazy) {
+    this.dirty = true;
+  } else if (this.sync) {
+    this.run();
+  } else {
+    queueWatcher(this);
+  }
+};
+
+/**
+ * Scheduler job interface.
+ * Will be called by the scheduler.
+ */
+Watcher.prototype.run = function run () {
+  if (this.active) {
+    var value = this.get();
+    if (
+      value !== this.value ||
+      // Deep watchers and watchers on Object/Arrays should fire even
+      // when the value is the same, because the value may
+      // have mutated.
+      isObject(value) ||
+      this.deep
+    ) {
+      // set new value
+      var oldValue = this.value;
+      this.value = value;
+      if (this.user) {
+        try {
+          this.cb.call(this.vm, value, oldValue);
+        } catch (e) {
+          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
+        }
+      } else {
+        this.cb.call(this.vm, value, oldValue);
+      }
+    }
+  }
+};
+
+/**
+ * Evaluate the value of the watcher.
+ * This only gets called for lazy watchers.
+ */
+Watcher.prototype.evaluate = function evaluate () {
+  this.value = this.get();
+  this.dirty = false;
+};
+
+/**
+ * Depend on all deps collected by this watcher.
+ */
+Watcher.prototype.depend = function depend () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    this$1.deps[i].depend();
+  }
+};
+
+/**
+ * Remove self from all dependencies' subscriber list.
+ */
+Watcher.prototype.teardown = function teardown () {
+    var this$1 = this;
+
+  if (this.active) {
+    // remove self from vm's watcher list
+    // this is a somewhat expensive operation so we skip it
+    // if the vm is being destroyed.
+    if (!this.vm._isBeingDestroyed) {
+      remove(this.vm._watchers, this);
+    }
+    var i = this.deps.length;
+    while (i--) {
+      this$1.deps[i].removeSub(this$1);
+    }
+    this.active = false;
+  }
+};
+
+/**
+ * Recursively traverse an object to evoke all converted
+ * getters, so that every nested property inside the object
+ * is collected as a "deep" dependency.
+ */
+var seenObjects = new _Set();
+function traverse (val) {
+  seenObjects.clear();
+  _traverse(val, seenObjects);
+}
+
+function _traverse (val, seen) {
+  var i, keys;
+  var isA = Array.isArray(val);
+  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
+    return
+  }
+  if (val.__ob__) {
+    var depId = val.__ob__.dep.id;
+    if (seen.has(depId)) {
+      return
+    }
+    seen.add(depId);
+  }
+  if (isA) {
+    i = val.length;
+    while (i--) { _traverse(val[i], seen); }
+  } else {
+    keys = Object.keys(val);
+    i = keys.length;
+    while (i--) { _traverse(val[keys[i]], seen); }
+  }
+}
+
+/*  */
+
+var sharedPropertyDefinition = {
+  enumerable: true,
+  configurable: true,
+  get: noop,
+  set: noop
+};
+
+function proxy (target, sourceKey, key) {
+  sharedPropertyDefinition.get = function proxyGetter () {
+    return this[sourceKey][key]
+  };
+  sharedPropertyDefinition.set = function proxySetter (val) {
+    this[sourceKey][key] = val;
+  };
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function initState (vm) {
+  vm._watchers = [];
+  var opts = vm.$options;
+  if (opts.props) { initProps(vm, opts.props); }
+  if (opts.methods) { initMethods(vm, opts.methods); }
+  if (opts.data) {
+    initData(vm);
+  } else {
+    observe(vm._data = {}, true /* asRootData */);
+  }
+  if (opts.computed) { initComputed(vm, opts.computed); }
+  if (opts.watch) { initWatch(vm, opts.watch); }
+}
+
+var isReservedProp = { key: 1, ref: 1, slot: 1 };
+
+function initProps (vm, propsOptions) {
+  var propsData = vm.$options.propsData || {};
+  var props = vm._props = {};
+  // cache prop keys so that future props updates can iterate using Array
+  // instead of dynamic object key enumeration.
+  var keys = vm.$options._propKeys = [];
+  var isRoot = !vm.$parent;
+  // root instance props should be converted
+  observerState.shouldConvert = isRoot;
+  var loop = function ( key ) {
+    keys.push(key);
+    var value = validateProp(key, propsOptions, propsData, vm);
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      if (isReservedProp[key]) {
+        warn(
+          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
+          vm
+        );
+      }
+      defineReactive$$1(props, key, value, function () {
+        if (vm.$parent && !observerState.isSettingProps) {
+          warn(
+            "Avoid mutating a prop directly since the value will be " +
+            "overwritten whenever the parent component re-renders. " +
+            "Instead, use a data or computed property based on the prop's " +
+            "value. Prop being mutated: \"" + key + "\"",
+            vm
+          );
+        }
+      });
+    } else {
+      defineReactive$$1(props, key, value);
+    }
+    // static props are already proxied on the component's prototype
+    // during Vue.extend(). We only need to proxy props defined at
+    // instantiation here.
+    if (!(key in vm)) {
+      proxy(vm, "_props", key);
+    }
+  };
+
+  for (var key in propsOptions) loop( key );
+  observerState.shouldConvert = true;
+}
+
+function initData (vm) {
+  var data = vm.$options.data;
+  data = vm._data = typeof data === 'function'
+    ? data.call(vm)
+    : data || {};
+  if (!isPlainObject(data)) {
+    data = {};
+    process.env.NODE_ENV !== 'production' && warn(
+      'data functions should return an object:\n' +
+      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
+      vm
+    );
+  }
+  // proxy data on instance
+  var keys = Object.keys(data);
+  var props = vm.$options.props;
+  var i = keys.length;
+  while (i--) {
+    if (props && hasOwn(props, keys[i])) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
+        "Use prop default value instead.",
+        vm
+      );
+    } else if (!isReserved(keys[i])) {
+      proxy(vm, "_data", keys[i]);
+    }
+  }
+  // observe data
+  observe(data, true /* asRootData */);
+}
+
+var computedWatcherOptions = { lazy: true };
+
+function initComputed (vm, computed) {
+  var watchers = vm._computedWatchers = Object.create(null);
+
+  for (var key in computed) {
+    var userDef = computed[key];
+    var getter = typeof userDef === 'function' ? userDef : userDef.get;
+    // create internal watcher for the computed property.
+    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);
+
+    // component-defined computed properties are already defined on the
+    // component prototype. We only need to define computed properties defined
+    // at instantiation here.
+    if (!(key in vm)) {
+      defineComputed(vm, key, userDef);
+    }
+  }
+}
+
+function defineComputed (target, key, userDef) {
+  if (typeof userDef === 'function') {
+    sharedPropertyDefinition.get = createComputedGetter(key);
+    sharedPropertyDefinition.set = noop;
+  } else {
+    sharedPropertyDefinition.get = userDef.get
+      ? userDef.cache !== false
+        ? createComputedGetter(key)
+        : userDef.get
+      : noop;
+    sharedPropertyDefinition.set = userDef.set
+      ? userDef.set
+      : noop;
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function createComputedGetter (key) {
+  return function computedGetter () {
+    var watcher = this._computedWatchers && this._computedWatchers[key];
+    if (watcher) {
+      if (watcher.dirty) {
+        watcher.evaluate();
+      }
+      if (Dep.target) {
+        watcher.depend();
+      }
+      return watcher.value
+    }
+  }
+}
+
+function initMethods (vm, methods) {
+  var props = vm.$options.props;
+  for (var key in methods) {
+    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
+    if (process.env.NODE_ENV !== 'production') {
+      if (methods[key] == null) {
+        warn(
+          "method \"" + key + "\" has an undefined value in the component definition. " +
+          "Did you reference the function correctly?",
+          vm
+        );
+      }
+      if (props && hasOwn(props, key)) {
+        warn(
+          ("method \"" + key + "\" has already been defined as a prop."),
+          vm
+        );
+      }
+    }
+  }
+}
+
+function initWatch (vm, watch) {
+  for (var key in watch) {
+    var handler = watch[key];
+    if (Array.isArray(handler)) {
+      for (var i = 0; i < handler.length; i++) {
+        createWatcher(vm, key, handler[i]);
+      }
+    } else {
+      createWatcher(vm, key, handler);
+    }
+  }
+}
+
+function createWatcher (vm, key, handler) {
+  var options;
+  if (isPlainObject(handler)) {
+    options = handler;
+    handler = handler.handler;
+  }
+  if (typeof handler === 'string') {
+    handler = vm[handler];
+  }
+  vm.$watch(key, handler, options);
+}
+
+function stateMixin (Vue) {
+  // flow somehow has problems with directly declared definition object
+  // when using Object.defineProperty, so we have to procedurally build up
+  // the object here.
+  var dataDef = {};
+  dataDef.get = function () { return this._data };
+  var propsDef = {};
+  propsDef.get = function () { return this._props };
+  if (process.env.NODE_ENV !== 'production') {
+    dataDef.set = function (newData) {
+      warn(
+        'Avoid replacing instance root $data. ' +
+        'Use nested data properties instead.',
+        this
+      );
+    };
+    propsDef.set = function () {
+      warn("$props is readonly.", this);
+    };
+  }
+  Object.defineProperty(Vue.prototype, '$data', dataDef);
+  Object.defineProperty(Vue.prototype, '$props', propsDef);
+
+  Vue.prototype.$set = set;
+  Vue.prototype.$delete = del;
+
+  Vue.prototype.$watch = function (
+    expOrFn,
+    cb,
+    options
+  ) {
+    var vm = this;
+    options = options || {};
+    options.user = true;
+    var watcher = new Watcher(vm, expOrFn, cb, options);
+    if (options.immediate) {
+      cb.call(vm, watcher.value);
+    }
+    return function unwatchFn () {
+      watcher.teardown();
+    }
+  };
+}
+
+/*  */
+
+var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy };
+var hooksToMerge = Object.keys(hooks);
+
+function createComponent (
+  Ctor,
+  data,
+  context,
+  children,
+  tag
+) {
+  if (!Ctor) {
+    return
+  }
+
+  var baseCtor = context.$options._base;
+  if (isObject(Ctor)) {
+    Ctor = baseCtor.extend(Ctor);
+  }
+
+  if (typeof Ctor !== 'function') {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Invalid Component definition: " + (String(Ctor))), context);
+    }
+    return
+  }
+
+  // async component
+  if (!Ctor.cid) {
+    if (Ctor.resolved) {
+      Ctor = Ctor.resolved;
+    } else {
+      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
+        // it's ok to queue this on every render because
+        // $forceUpdate is buffered by the scheduler.
+        context.$forceUpdate();
+      });
+      if (!Ctor) {
+        // return nothing if this is indeed an async component
+        // wait for the callback to trigger parent update.
+        return
+      }
+    }
+  }
+
+  // resolve constructor options in case global mixins are applied after
+  // component constructor creation
+  resolveConstructorOptions(Ctor);
+
+  data = data || {};
+
+  // transform component v-model data into props & events
+  if (data.model) {
+    transformModel(Ctor.options, data);
+  }
+
+  // extract props
+  var propsData = extractProps(data, Ctor);
+
+  // functional component
+  if (Ctor.options.functional) {
+    return createFunctionalComponent(Ctor, propsData, data, context, children)
+  }
+
+  // extract listeners, since these needs to be treated as
+  // child component listeners instead of DOM listeners
+  var listeners = data.on;
+  // replace with listeners with .native modifier
+  data.on = data.nativeOn;
+
+  if (Ctor.options.abstract) {
+    // abstract components do not keep anything
+    // other than props & listeners
+    data = {};
+  }
+
+  // merge component management hooks onto the placeholder node
+  mergeHooks(data);
+
+  // return a placeholder vnode
+  var name = Ctor.options.name || tag;
+  var vnode = new VNode(
+    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
+    data, undefined, undefined, undefined, context,
+    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
+  );
+  return vnode
+}
+
+function createFunctionalComponent (
+  Ctor,
+  propsData,
+  data,
+  context,
+  children
+) {
+  var props = {};
+  var propOptions = Ctor.options.props;
+  if (propOptions) {
+    for (var key in propOptions) {
+      props[key] = validateProp(key, propOptions, propsData);
+    }
+  }
+  // ensure the createElement function in functional components
+  // gets a unique context - this is necessary for correct named slot check
+  var _context = Object.create(context);
+  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
+  var vnode = Ctor.options.render.call(null, h, {
+    props: props,
+    data: data,
+    parent: context,
+    children: children,
+    slots: function () { return resolveSlots(children, context); }
+  });
+  if (vnode instanceof VNode) {
+    vnode.functionalContext = context;
+    if (data.slot) {
+      (vnode.data || (vnode.data = {})).slot = data.slot;
+    }
+  }
+  return vnode
+}
+
+function createComponentInstanceForVnode (
+  vnode, // we know it's MountedComponentVNode but flow doesn't
+  parent, // activeInstance in lifecycle state
+  parentElm,
+  refElm
+) {
+  var vnodeComponentOptions = vnode.componentOptions;
+  var options = {
+    _isComponent: true,
+    parent: parent,
+    propsData: vnodeComponentOptions.propsData,
+    _componentTag: vnodeComponentOptions.tag,
+    _parentVnode: vnode,
+    _parentListeners: vnodeComponentOptions.listeners,
+    _renderChildren: vnodeComponentOptions.children,
+    _parentElm: parentElm || null,
+    _refElm: refElm || null
+  };
+  // check inline-template render functions
+  var inlineTemplate = vnode.data.inlineTemplate;
+  if (inlineTemplate) {
+    options.render = inlineTemplate.render;
+    options.staticRenderFns = inlineTemplate.staticRenderFns;
+  }
+  return new vnodeComponentOptions.Ctor(options)
+}
+
+function init (
+  vnode,
+  hydrating,
+  parentElm,
+  refElm
+) {
+  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
+    var child = vnode.componentInstance = createComponentInstanceForVnode(
+      vnode,
+      activeInstance,
+      parentElm,
+      refElm
+    );
+    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
+  } else if (vnode.data.keepAlive) {
+    // kept-alive components, treat as a patch
+    var mountedNode = vnode; // work around flow
+    prepatch(mountedNode, mountedNode);
+  }
+}
+
+function prepatch (
+  oldVnode,
+  vnode
+) {
+  var options = vnode.componentOptions;
+  var child = vnode.componentInstance = oldVnode.componentInstance;
+  updateChildComponent(
+    child,
+    options.propsData, // updated props
+    options.listeners, // updated listeners
+    vnode, // new parent vnode
+    options.children // new children
+  );
+}
+
+function insert (vnode) {
+  if (!vnode.componentInstance._isMounted) {
+    vnode.componentInstance._isMounted = true;
+    callHook(vnode.componentInstance, 'mounted');
+  }
+  if (vnode.data.keepAlive) {
+    activateChildComponent(vnode.componentInstance, true /* direct */);
+  }
+}
+
+function destroy (vnode) {
+  if (!vnode.componentInstance._isDestroyed) {
+    if (!vnode.data.keepAlive) {
+      vnode.componentInstance.$destroy();
+    } else {
+      deactivateChildComponent(vnode.componentInstance, true /* direct */);
+    }
+  }
+}
+
+function resolveAsyncComponent (
+  factory,
+  baseCtor,
+  cb
+) {
+  if (factory.requested) {
+    // pool callbacks
+    factory.pendingCallbacks.push(cb);
+  } else {
+    factory.requested = true;
+    var cbs = factory.pendingCallbacks = [cb];
+    var sync = true;
+
+    var resolve = function (res) {
+      if (isObject(res)) {
+        res = baseCtor.extend(res);
+      }
+      // cache resolved
+      factory.resolved = res;
+      // invoke callbacks only if this is not a synchronous resolve
+      // (async resolves are shimmed as synchronous during SSR)
+      if (!sync) {
+        for (var i = 0, l = cbs.length; i < l; i++) {
+          cbs[i](res);
+        }
+      }
+    };
+
+    var reject = function (reason) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed to resolve async component: " + (String(factory)) +
+        (reason ? ("\nReason: " + reason) : '')
+      );
+    };
+
+    var res = factory(resolve, reject);
+
+    // handle promise
+    if (res && typeof res.then === 'function' && !factory.resolved) {
+      res.then(resolve, reject);
+    }
+
+    sync = false;
+    // return in case resolved synchronously
+    return factory.resolved
+  }
+}
+
+function extractProps (data, Ctor) {
+  // we are only extracting raw values here.
+  // validation and default values are handled in the child
+  // component itself.
+  var propOptions = Ctor.options.props;
+  if (!propOptions) {
+    return
+  }
+  var res = {};
+  var attrs = data.attrs;
+  var props = data.props;
+  var domProps = data.domProps;
+  if (attrs || props || domProps) {
+    for (var key in propOptions) {
+      var altKey = hyphenate(key);
+      checkProp(res, props, key, altKey, true) ||
+      checkProp(res, attrs, key, altKey) ||
+      checkProp(res, domProps, key, altKey);
+    }
+  }
+  return res
+}
+
+function checkProp (
+  res,
+  hash,
+  key,
+  altKey,
+  preserve
+) {
+  if (hash) {
+    if (hasOwn(hash, key)) {
+      res[key] = hash[key];
+      if (!preserve) {
+        delete hash[key];
+      }
+      return true
+    } else if (hasOwn(hash, altKey)) {
+      res[key] = hash[altKey];
+      if (!preserve) {
+        delete hash[altKey];
+      }
+      return true
+    }
+  }
+  return false
+}
+
+function mergeHooks (data) {
+  if (!data.hook) {
+    data.hook = {};
+  }
+  for (var i = 0; i < hooksToMerge.length; i++) {
+    var key = hooksToMerge[i];
+    var fromParent = data.hook[key];
+    var ours = hooks[key];
+    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
+  }
+}
+
+function mergeHook$1 (one, two) {
+  return function (a, b, c, d) {
+    one(a, b, c, d);
+    two(a, b, c, d);
+  }
+}
+
+// transform component v-model info (value and callback) into
+// prop and event handler respectively.
+function transformModel (options, data) {
+  var prop = (options.model && options.model.prop) || 'value';
+  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
+  var on = data.on || (data.on = {});
+  if (on[event]) {
+    on[event] = [data.model.callback].concat(on[event]);
+  } else {
+    on[event] = data.model.callback;
+  }
+}
+
+/*  */
+
+var SIMPLE_NORMALIZE = 1;
+var ALWAYS_NORMALIZE = 2;
+
+// wrapper function for providing a more flexible interface
+// without getting yelled at by flow
+function createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType,
+  alwaysNormalize
+) {
+  if (Array.isArray(data) || isPrimitive(data)) {
+    normalizationType = children;
+    children = data;
+    data = undefined;
+  }
+  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
+  return _createElement(context, tag, data, children, normalizationType)
+}
+
+function _createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType
+) {
+  if (data && data.__ob__) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
+      'Always create fresh vnode data objects in each render!',
+      context
+    );
+    return createEmptyVNode()
+  }
+  if (!tag) {
+    // in case of component :is set to falsy value
+    return createEmptyVNode()
+  }
+  // support single function children as default scoped slot
+  if (Array.isArray(children) &&
+      typeof children[0] === 'function') {
+    data = data || {};
+    data.scopedSlots = { default: children[0] };
+    children.length = 0;
+  }
+  if (normalizationType === ALWAYS_NORMALIZE) {
+    children = normalizeChildren(children);
+  } else if (normalizationType === SIMPLE_NORMALIZE) {
+    children = simpleNormalizeChildren(children);
+  }
+  var vnode, ns;
+  if (typeof tag === 'string') {
+    var Ctor;
+    ns = config.getTagNamespace(tag);
+    if (config.isReservedTag(tag)) {
+      // platform built-in elements
+      vnode = new VNode(
+        config.parsePlatformTagName(tag), data, children,
+        undefined, undefined, context
+      );
+    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
+      // component
+      vnode = createComponent(Ctor, data, context, children, tag);
+    } else {
+      // unknown or unlisted namespaced elements
+      // check at runtime because it may get assigned a namespace when its
+      // parent normalizes children
+      vnode = new VNode(
+        tag, data, children,
+        undefined, undefined, context
+      );
+    }
+  } else {
+    // direct component options / constructor
+    vnode = createComponent(tag, data, context, children);
+  }
+  if (vnode) {
+    if (ns) { applyNS(vnode, ns); }
+    return vnode
+  } else {
+    return createEmptyVNode()
+  }
+}
+
+function applyNS (vnode, ns) {
+  vnode.ns = ns;
+  if (vnode.tag === 'foreignObject') {
+    // use default namespace inside foreignObject
+    return
+  }
+  if (vnode.children) {
+    for (var i = 0, l = vnode.children.length; i < l; i++) {
+      var child = vnode.children[i];
+      if (child.tag && !child.ns) {
+        applyNS(child, ns);
+      }
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering v-for lists.
+ */
+function renderList (
+  val,
+  render
+) {
+  var ret, i, l, keys, key;
+  if (Array.isArray(val) || typeof val === 'string') {
+    ret = new Array(val.length);
+    for (i = 0, l = val.length; i < l; i++) {
+      ret[i] = render(val[i], i);
+    }
+  } else if (typeof val === 'number') {
+    ret = new Array(val);
+    for (i = 0; i < val; i++) {
+      ret[i] = render(i + 1, i);
+    }
+  } else if (isObject(val)) {
+    keys = Object.keys(val);
+    ret = new Array(keys.length);
+    for (i = 0, l = keys.length; i < l; i++) {
+      key = keys[i];
+      ret[i] = render(val[key], key, i);
+    }
+  }
+  return ret
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering <slot>
+ */
+function renderSlot (
+  name,
+  fallback,
+  props,
+  bindObject
+) {
+  var scopedSlotFn = this.$scopedSlots[name];
+  if (scopedSlotFn) { // scoped slot
+    props = props || {};
+    if (bindObject) {
+      extend(props, bindObject);
+    }
+    return scopedSlotFn(props) || fallback
+  } else {
+    var slotNodes = this.$slots[name];
+    // warn duplicate slot usage
+    if (slotNodes && process.env.NODE_ENV !== 'production') {
+      slotNodes._rendered && warn(
+        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
+        "- this will likely cause render errors.",
+        this
+      );
+      slotNodes._rendered = true;
+    }
+    return slotNodes || fallback
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving filters
+ */
+function resolveFilter (id) {
+  return resolveAsset(this.$options, 'filters', id, true) || identity
+}
+
+/*  */
+
+/**
+ * Runtime helper for checking keyCodes from config.
+ */
+function checkKeyCodes (
+  eventKeyCode,
+  key,
+  builtInAlias
+) {
+  var keyCodes = config.keyCodes[key] || builtInAlias;
+  if (Array.isArray(keyCodes)) {
+    return keyCodes.indexOf(eventKeyCode) === -1
+  } else {
+    return keyCodes !== eventKeyCode
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for merging v-bind="object" into a VNode's data.
+ */
+function bindObjectProps (
+  data,
+  tag,
+  value,
+  asProp
+) {
+  if (value) {
+    if (!isObject(value)) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'v-bind without argument expects an Object or Array value',
+        this
+      );
+    } else {
+      if (Array.isArray(value)) {
+        value = toObject(value);
+      }
+      for (var key in value) {
+        if (key === 'class' || key === 'style') {
+          data[key] = value[key];
+        } else {
+          var type = data.attrs && data.attrs.type;
+          var hash = asProp || config.mustUseProp(tag, type, key)
+            ? data.domProps || (data.domProps = {})
+            : data.attrs || (data.attrs = {});
+          hash[key] = value[key];
+        }
+      }
+    }
+  }
+  return data
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering static trees.
+ */
+function renderStatic (
+  index,
+  isInFor
+) {
+  var tree = this._staticTrees[index];
+  // if has already-rendered static tree and not inside v-for,
+  // we can reuse the same tree by doing a shallow clone.
+  if (tree && !isInFor) {
+    return Array.isArray(tree)
+      ? cloneVNodes(tree)
+      : cloneVNode(tree)
+  }
+  // otherwise, render a fresh tree.
+  tree = this._staticTrees[index] =
+    this.$options.staticRenderFns[index].call(this._renderProxy);
+  markStatic(tree, ("__static__" + index), false);
+  return tree
+}
+
+/**
+ * Runtime helper for v-once.
+ * Effectively it means marking the node as static with a unique key.
+ */
+function markOnce (
+  tree,
+  index,
+  key
+) {
+  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
+  return tree
+}
+
+function markStatic (
+  tree,
+  key,
+  isOnce
+) {
+  if (Array.isArray(tree)) {
+    for (var i = 0; i < tree.length; i++) {
+      if (tree[i] && typeof tree[i] !== 'string') {
+        markStaticNode(tree[i], (key + "_" + i), isOnce);
+      }
+    }
+  } else {
+    markStaticNode(tree, key, isOnce);
+  }
+}
+
+function markStaticNode (node, key, isOnce) {
+  node.isStatic = true;
+  node.key = key;
+  node.isOnce = isOnce;
+}
+
+/*  */
+
+function initRender (vm) {
+  vm.$vnode = null; // the placeholder node in parent tree
+  vm._vnode = null; // the root of the child tree
+  vm._staticTrees = null;
+  var parentVnode = vm.$options._parentVnode;
+  var renderContext = parentVnode && parentVnode.context;
+  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
+  vm.$scopedSlots = emptyObject;
+  // bind the createElement fn to this instance
+  // so that we get proper render context inside it.
+  // args order: tag, data, children, normalizationType, alwaysNormalize
+  // internal version is used by render functions compiled from templates
+  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
+  // normalization is always applied for the public version, used in
+  // user-written render functions.
+  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
+}
+
+function renderMixin (Vue) {
+  Vue.prototype.$nextTick = function (fn) {
+    return nextTick(fn, this)
+  };
+
+  Vue.prototype._render = function () {
+    var vm = this;
+    var ref = vm.$options;
+    var render = ref.render;
+    var staticRenderFns = ref.staticRenderFns;
+    var _parentVnode = ref._parentVnode;
+
+    if (vm._isMounted) {
+      // clone slot nodes on re-renders
+      for (var key in vm.$slots) {
+        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
+      }
+    }
+
+    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;
+
+    if (staticRenderFns && !vm._staticTrees) {
+      vm._staticTrees = [];
+    }
+    // set parent vnode. this allows render functions to have access
+    // to the data on the placeholder node.
+    vm.$vnode = _parentVnode;
+    // render self
+    var vnode;
+    try {
+      vnode = render.call(vm._renderProxy, vm.$createElement);
+    } catch (e) {
+      handleError(e, vm, "render function");
+      // return error render result,
+      // or previous vnode to prevent render error causing blank component
+      /* istanbul ignore else */
+      if (process.env.NODE_ENV !== 'production') {
+        vnode = vm.$options.renderError
+          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
+          : vm._vnode;
+      } else {
+        vnode = vm._vnode;
+      }
+    }
+    // return empty vnode in case the render function errored out
+    if (!(vnode instanceof VNode)) {
+      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
+        warn(
+          'Multiple root nodes returned from render function. Render function ' +
+          'should return a single root node.',
+          vm
+        );
+      }
+      vnode = createEmptyVNode();
+    }
+    // set parent
+    vnode.parent = _parentVnode;
+    return vnode
+  };
+
+  // internal render helpers.
+  // these are exposed on the instance prototype to reduce generated render
+  // code size.
+  Vue.prototype._o = markOnce;
+  Vue.prototype._n = toNumber;
+  Vue.prototype._s = _toString;
+  Vue.prototype._l = renderList;
+  Vue.prototype._t = renderSlot;
+  Vue.prototype._q = looseEqual;
+  Vue.prototype._i = looseIndexOf;
+  Vue.prototype._m = renderStatic;
+  Vue.prototype._f = resolveFilter;
+  Vue.prototype._k = checkKeyCodes;
+  Vue.prototype._b = bindObjectProps;
+  Vue.prototype._v = createTextVNode;
+  Vue.prototype._e = createEmptyVNode;
+  Vue.prototype._u = resolveScopedSlots;
+}
+
+/*  */
+
+function initProvide (vm) {
+  var provide = vm.$options.provide;
+  if (provide) {
+    vm._provided = typeof provide === 'function'
+      ? provide.call(vm)
+      : provide;
+  }
+}
+
+function initInjections (vm) {
+  var inject = vm.$options.inject;
+  if (inject) {
+    // inject is :any because flow is not smart enough to figure out cached
+    // isArray here
+    var isArray = Array.isArray(inject);
+    var keys = isArray
+      ? inject
+      : hasSymbol
+        ? Reflect.ownKeys(inject)
+        : Object.keys(inject);
+
+    for (var i = 0; i < keys.length; i++) {
+      var key = keys[i];
+      var provideKey = isArray ? key : inject[key];
+      var source = vm;
+      while (source) {
+        if (source._provided && provideKey in source._provided) {
+          vm[key] = source._provided[provideKey];
+          break
+        }
+        source = source.$parent;
+      }
+    }
+  }
+}
+
+/*  */
+
+var uid = 0;
+
+function initMixin (Vue) {
+  Vue.prototype._init = function (options) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      perf.mark('init');
+    }
+
+    var vm = this;
+    // a uid
+    vm._uid = uid++;
+    // a flag to avoid this being observed
+    vm._isVue = true;
+    // merge options
+    if (options && options._isComponent) {
+      // optimize internal component instantiation
+      // since dynamic options merging is pretty slow, and none of the
+      // internal component options needs special treatment.
+      initInternalComponent(vm, options);
+    } else {
+      vm.$options = mergeOptions(
+        resolveConstructorOptions(vm.constructor),
+        options || {},
+        vm
+      );
+    }
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      initProxy(vm);
+    } else {
+      vm._renderProxy = vm;
+    }
+    // expose real self
+    vm._self = vm;
+    initLifecycle(vm);
+    initEvents(vm);
+    initRender(vm);
+    callHook(vm, 'beforeCreate');
+    initInjections(vm); // resolve injections before data/props
+    initState(vm);
+    initProvide(vm); // resolve provide after data/props
+    callHook(vm, 'created');
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      vm._name = formatComponentName(vm, false);
+      perf.mark('init end');
+      perf.measure(((vm._name) + " init"), 'init', 'init end');
+    }
+
+    if (vm.$options.el) {
+      vm.$mount(vm.$options.el);
+    }
+  };
+}
+
+function initInternalComponent (vm, options) {
+  var opts = vm.$options = Object.create(vm.constructor.options);
+  // doing this because it's faster than dynamic enumeration.
+  opts.parent = options.parent;
+  opts.propsData = options.propsData;
+  opts._parentVnode = options._parentVnode;
+  opts._parentListeners = options._parentListeners;
+  opts._renderChildren = options._renderChildren;
+  opts._componentTag = options._componentTag;
+  opts._parentElm = options._parentElm;
+  opts._refElm = options._refElm;
+  if (options.render) {
+    opts.render = options.render;
+    opts.staticRenderFns = options.staticRenderFns;
+  }
+}
+
+function resolveConstructorOptions (Ctor) {
+  var options = Ctor.options;
+  if (Ctor.super) {
+    var superOptions = resolveConstructorOptions(Ctor.super);
+    var cachedSuperOptions = Ctor.superOptions;
+    if (superOptions !== cachedSuperOptions) {
+      // super option changed,
+      // need to resolve new options.
+      Ctor.superOptions = superOptions;
+      // check if there are any late-modified/attached options (#4976)
+      var modifiedOptions = resolveModifiedOptions(Ctor);
+      // update base extend options
+      if (modifiedOptions) {
+        extend(Ctor.extendOptions, modifiedOptions);
+      }
+      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
+      if (options.name) {
+        options.components[options.name] = Ctor;
+      }
+    }
+  }
+  return options
+}
+
+function resolveModifiedOptions (Ctor) {
+  var modified;
+  var latest = Ctor.options;
+  var sealed = Ctor.sealedOptions;
+  for (var key in latest) {
+    if (latest[key] !== sealed[key]) {
+      if (!modified) { modified = {}; }
+      modified[key] = dedupe(latest[key], sealed[key]);
+    }
+  }
+  return modified
+}
+
+function dedupe (latest, sealed) {
+  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
+  // between merges
+  if (Array.isArray(latest)) {
+    var res = [];
+    sealed = Array.isArray(sealed) ? sealed : [sealed];
+    for (var i = 0; i < latest.length; i++) {
+      if (sealed.indexOf(latest[i]) < 0) {
+        res.push(latest[i]);
+      }
+    }
+    return res
+  } else {
+    return latest
+  }
+}
+
+function Vue$2 (options) {
+  if (process.env.NODE_ENV !== 'production' &&
+    !(this instanceof Vue$2)) {
+    warn('Vue is a constructor and should be called with the `new` keyword');
+  }
+  this._init(options);
+}
+
+initMixin(Vue$2);
+stateMixin(Vue$2);
+eventsMixin(Vue$2);
+lifecycleMixin(Vue$2);
+renderMixin(Vue$2);
+
+/*  */
+
+function initUse (Vue) {
+  Vue.use = function (plugin) {
+    /* istanbul ignore if */
+    if (plugin.installed) {
+      return
+    }
+    // additional parameters
+    var args = toArray(arguments, 1);
+    args.unshift(this);
+    if (typeof plugin.install === 'function') {
+      plugin.install.apply(plugin, args);
+    } else if (typeof plugin === 'function') {
+      plugin.apply(null, args);
+    }
+    plugin.installed = true;
+    return this
+  };
+}
+
+/*  */
+
+function initMixin$1 (Vue) {
+  Vue.mixin = function (mixin) {
+    this.options = mergeOptions(this.options, mixin);
+  };
+}
+
+/*  */
+
+function initExtend (Vue) {
+  /**
+   * Each instance constructor, including Vue, has a unique
+   * cid. This enables us to create wrapped "child
+   * constructors" for prototypal inheritance and cache them.
+   */
+  Vue.cid = 0;
+  var cid = 1;
+
+  /**
+   * Class inheritance
+   */
+  Vue.extend = function (extendOptions) {
+    extendOptions = extendOptions || {};
+    var Super = this;
+    var SuperId = Super.cid;
+    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
+    if (cachedCtors[SuperId]) {
+      return cachedCtors[SuperId]
+    }
+
+    var name = extendOptions.name || Super.options.name;
+    if (process.env.NODE_ENV !== 'production') {
+      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+        warn(
+          'Invalid component name: "' + name + '". Component names ' +
+          'can only contain alphanumeric characters and the hyphen, ' +
+          'and must start with a letter.'
+        );
+      }
+    }
+
+    var Sub = function VueComponent (options) {
+      this._init(options);
+    };
+    Sub.prototype = Object.create(Super.prototype);
+    Sub.prototype.constructor = Sub;
+    Sub.cid = cid++;
+    Sub.options = mergeOptions(
+      Super.options,
+      extendOptions
+    );
+    Sub['super'] = Super;
+
+    // For props and computed properties, we define the proxy getters on
+    // the Vue instances at extension time, on the extended prototype. This
+    // avoids Object.defineProperty calls for each instance created.
+    if (Sub.options.props) {
+      initProps$1(Sub);
+    }
+    if (Sub.options.computed) {
+      initComputed$1(Sub);
+    }
+
+    // allow further extension/mixin/plugin usage
+    Sub.extend = Super.extend;
+    Sub.mixin = Super.mixin;
+    Sub.use = Super.use;
+
+    // create asset registers, so extended classes
+    // can have their private assets too.
+    config._assetTypes.forEach(function (type) {
+      Sub[type] = Super[type];
+    });
+    // enable recursive self-lookup
+    if (name) {
+      Sub.options.components[name] = Sub;
+    }
+
+    // keep a reference to the super options at extension time.
+    // later at instantiation we can check if Super's options have
+    // been updated.
+    Sub.superOptions = Super.options;
+    Sub.extendOptions = extendOptions;
+    Sub.sealedOptions = extend({}, Sub.options);
+
+    // cache constructor
+    cachedCtors[SuperId] = Sub;
+    return Sub
+  };
+}
+
+function initProps$1 (Comp) {
+  var props = Comp.options.props;
+  for (var key in props) {
+    proxy(Comp.prototype, "_props", key);
+  }
+}
+
+function initComputed$1 (Comp) {
+  var computed = Comp.options.computed;
+  for (var key in computed) {
+    defineComputed(Comp.prototype, key, computed[key]);
+  }
+}
+
+/*  */
+
+function initAssetRegisters (Vue) {
+  /**
+   * Create asset registration methods.
+   */
+  config._assetTypes.forEach(function (type) {
+    Vue[type] = function (
+      id,
+      definition
+    ) {
+      if (!definition) {
+        return this.options[type + 's'][id]
+      } else {
+        /* istanbul ignore if */
+        if (process.env.NODE_ENV !== 'production') {
+          if (type === 'component' && config.isReservedTag(id)) {
+            warn(
+              'Do not use built-in or reserved HTML elements as component ' +
+              'id: ' + id
+            );
+          }
+        }
+        if (type === 'component' && isPlainObject(definition)) {
+          definition.name = definition.name || id;
+          definition = this.options._base.extend(definition);
+        }
+        if (type === 'directive' && typeof definition === 'function') {
+          definition = { bind: definition, update: definition };
+        }
+        this.options[type + 's'][id] = definition;
+        return definition
+      }
+    };
+  });
+}
+
+/*  */
+
+var patternTypes = [String, RegExp];
+
+function getComponentName (opts) {
+  return opts && (opts.Ctor.options.name || opts.tag)
+}
+
+function matches (pattern, name) {
+  if (typeof pattern === 'string') {
+    return pattern.split(',').indexOf(name) > -1
+  } else if (pattern instanceof RegExp) {
+    return pattern.test(name)
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function pruneCache (cache, filter) {
+  for (var key in cache) {
+    var cachedNode = cache[key];
+    if (cachedNode) {
+      var name = getComponentName(cachedNode.componentOptions);
+      if (name && !filter(name)) {
+        pruneCacheEntry(cachedNode);
+        cache[key] = null;
+      }
+    }
+  }
+}
+
+function pruneCacheEntry (vnode) {
+  if (vnode) {
+    if (!vnode.componentInstance._inactive) {
+      callHook(vnode.componentInstance, 'deactivated');
+    }
+    vnode.componentInstance.$destroy();
+  }
+}
+
+var KeepAlive = {
+  name: 'keep-alive',
+  abstract: true,
+
+  props: {
+    include: patternTypes,
+    exclude: patternTypes
+  },
+
+  created: function created () {
+    this.cache = Object.create(null);
+  },
+
+  destroyed: function destroyed () {
+    var this$1 = this;
+
+    for (var key in this$1.cache) {
+      pruneCacheEntry(this$1.cache[key]);
+    }
+  },
+
+  watch: {
+    include: function include (val) {
+      pruneCache(this.cache, function (name) { return matches(val, name); });
+    },
+    exclude: function exclude (val) {
+      pruneCache(this.cache, function (name) { return !matches(val, name); });
+    }
+  },
+
+  render: function render () {
+    var vnode = getFirstComponentChild(this.$slots.default);
+    var componentOptions = vnode && vnode.componentOptions;
+    if (componentOptions) {
+      // check pattern
+      var name = getComponentName(componentOptions);
+      if (name && (
+        (this.include && !matches(this.include, name)) ||
+        (this.exclude && matches(this.exclude, name))
+      )) {
+        return vnode
+      }
+      var key = vnode.key == null
+        // same constructor may get registered as different local components
+        // so cid alone is not enough (#3269)
+        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
+        : vnode.key;
+      if (this.cache[key]) {
+        vnode.componentInstance = this.cache[key].componentInstance;
+      } else {
+        this.cache[key] = vnode;
+      }
+      vnode.data.keepAlive = true;
+    }
+    return vnode
+  }
+};
+
+var builtInComponents = {
+  KeepAlive: KeepAlive
+};
+
+/*  */
+
+function initGlobalAPI (Vue) {
+  // config
+  var configDef = {};
+  configDef.get = function () { return config; };
+  if (process.env.NODE_ENV !== 'production') {
+    configDef.set = function () {
+      warn(
+        'Do not replace the Vue.config object, set individual fields instead.'
+      );
+    };
+  }
+  Object.defineProperty(Vue, 'config', configDef);
+
+  // exposed util methods.
+  // NOTE: these are not considered part of the public API - avoid relying on
+  // them unless you are aware of the risk.
+  Vue.util = {
+    warn: warn,
+    extend: extend,
+    mergeOptions: mergeOptions,
+    defineReactive: defineReactive$$1
+  };
+
+  Vue.set = set;
+  Vue.delete = del;
+  Vue.nextTick = nextTick;
+
+  Vue.options = Object.create(null);
+  config._assetTypes.forEach(function (type) {
+    Vue.options[type + 's'] = Object.create(null);
+  });
+
+  // this is used to identify the "base" constructor to extend all plain-object
+  // components with in Weex's multi-instance scenarios.
+  Vue.options._base = Vue;
+
+  extend(Vue.options.components, builtInComponents);
+
+  initUse(Vue);
+  initMixin$1(Vue);
+  initExtend(Vue);
+  initAssetRegisters(Vue);
+}
+
+initGlobalAPI(Vue$2);
+
+Object.defineProperty(Vue$2.prototype, '$isServer', {
+  get: isServerRendering
+});
+
+Vue$2.version = '2.2.2';
+
+/*  */
+
+// attributes that should be using props for binding
+var acceptValue = makeMap('input,textarea,option,select');
+var mustUseProp = function (tag, type, attr) {
+  return (
+    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
+    (attr === 'selected' && tag === 'option') ||
+    (attr === 'checked' && tag === 'input') ||
+    (attr === 'muted' && tag === 'video')
+  )
+};
+
+var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
+
+var isBooleanAttr = makeMap(
+  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
+  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
+  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
+  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
+  'required,reversed,scoped,seamless,selected,sortable,translate,' +
+  'truespeed,typemustmatch,visible'
+);
+
+var xlinkNS = 'http://www.w3.org/1999/xlink';
+
+var isXlink = function (name) {
+  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
+};
+
+var getXlinkProp = function (name) {
+  return isXlink(name) ? name.slice(6, name.length) : ''
+};
+
+var isFalsyAttrValue = function (val) {
+  return val == null || val === false
+};
+
+/*  */
+
+function genClassForVnode (vnode) {
+  var data = vnode.data;
+  var parentNode = vnode;
+  var childNode = vnode;
+  while (childNode.componentInstance) {
+    childNode = childNode.componentInstance._vnode;
+    if (childNode.data) {
+      data = mergeClassData(childNode.data, data);
+    }
+  }
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data) {
+      data = mergeClassData(data, parentNode.data);
+    }
+  }
+  return genClassFromData(data)
+}
+
+function mergeClassData (child, parent) {
+  return {
+    staticClass: concat(child.staticClass, parent.staticClass),
+    class: child.class
+      ? [child.class, parent.class]
+      : parent.class
+  }
+}
+
+function genClassFromData (data) {
+  var dynamicClass = data.class;
+  var staticClass = data.staticClass;
+  if (staticClass || dynamicClass) {
+    return concat(staticClass, stringifyClass(dynamicClass))
+  }
+  /* istanbul ignore next */
+  return ''
+}
+
+function concat (a, b) {
+  return a ? b ? (a + ' ' + b) : a : (b || '')
+}
+
+function stringifyClass (value) {
+  var res = '';
+  if (!value) {
+    return res
+  }
+  if (typeof value === 'string') {
+    return value
+  }
+  if (Array.isArray(value)) {
+    var stringified;
+    for (var i = 0, l = value.length; i < l; i++) {
+      if (value[i]) {
+        if ((stringified = stringifyClass(value[i]))) {
+          res += stringified + ' ';
+        }
+      }
+    }
+    return res.slice(0, -1)
+  }
+  if (isObject(value)) {
+    for (var key in value) {
+      if (value[key]) { res += key + ' '; }
+    }
+    return res.slice(0, -1)
+  }
+  /* istanbul ignore next */
+  return res
+}
+
+/*  */
+
+var namespaceMap = {
+  svg: 'http://www.w3.org/2000/svg',
+  math: 'http://www.w3.org/1998/Math/MathML'
+};
+
+var isHTMLTag = makeMap(
+  'html,body,base,head,link,meta,style,title,' +
+  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
+  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
+  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
+  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
+  'embed,object,param,source,canvas,script,noscript,del,ins,' +
+  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
+  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
+  'output,progress,select,textarea,' +
+  'details,dialog,menu,menuitem,summary,' +
+  'content,element,shadow,template'
+);
+
+// this map is intentionally selective, only covering SVG elements that may
+// contain child elements.
+var isSVG = makeMap(
+  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
+  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
+  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
+  true
+);
+
+
+
+var isReservedTag = function (tag) {
+  return isHTMLTag(tag) || isSVG(tag)
+};
+
+function getTagNamespace (tag) {
+  if (isSVG(tag)) {
+    return 'svg'
+  }
+  // basic support for MathML
+  // note it doesn't support other MathML elements being component roots
+  if (tag === 'math') {
+    return 'math'
+  }
+}
+
+var unknownElementCache = Object.create(null);
+function isUnknownElement (tag) {
+  /* istanbul ignore if */
+  if (!inBrowser) {
+    return true
+  }
+  if (isReservedTag(tag)) {
+    return false
+  }
+  tag = tag.toLowerCase();
+  /* istanbul ignore if */
+  if (unknownElementCache[tag] != null) {
+    return unknownElementCache[tag]
+  }
+  var el = document.createElement(tag);
+  if (tag.indexOf('-') > -1) {
+    // http://stackoverflow.com/a/28210364/1070244
+    return (unknownElementCache[tag] = (
+      el.constructor === window.HTMLUnknownElement ||
+      el.constructor === window.HTMLElement
+    ))
+  } else {
+    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
+  }
+}
+
+/*  */
+
+/**
+ * Query an element selector if it's not an element already.
+ */
+function query (el) {
+  if (typeof el === 'string') {
+    var selected = document.querySelector(el);
+    if (!selected) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'Cannot find element: ' + el
+      );
+      return document.createElement('div')
+    }
+    return selected
+  } else {
+    return el
+  }
+}
+
+/*  */
+
+function createElement$1 (tagName, vnode) {
+  var elm = document.createElement(tagName);
+  if (tagName !== 'select') {
+    return elm
+  }
+  // false or null will remove the attribute but undefined will not
+  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
+    elm.setAttribute('multiple', 'multiple');
+  }
+  return elm
+}
+
+function createElementNS (namespace, tagName) {
+  return document.createElementNS(namespaceMap[namespace], tagName)
+}
+
+function createTextNode (text) {
+  return document.createTextNode(text)
+}
+
+function createComment (text) {
+  return document.createComment(text)
+}
+
+function insertBefore (parentNode, newNode, referenceNode) {
+  parentNode.insertBefore(newNode, referenceNode);
+}
+
+function removeChild (node, child) {
+  node.removeChild(child);
+}
+
+function appendChild (node, child) {
+  node.appendChild(child);
+}
+
+function parentNode (node) {
+  return node.parentNode
+}
+
+function nextSibling (node) {
+  return node.nextSibling
+}
+
+function tagName (node) {
+  return node.tagName
+}
+
+function setTextContent (node, text) {
+  node.textContent = text;
+}
+
+function setAttribute (node, key, val) {
+  node.setAttribute(key, val);
+}
+
+
+var nodeOps = Object.freeze({
+	createElement: createElement$1,
+	createElementNS: createElementNS,
+	createTextNode: createTextNode,
+	createComment: createComment,
+	insertBefore: insertBefore,
+	removeChild: removeChild,
+	appendChild: appendChild,
+	parentNode: parentNode,
+	nextSibling: nextSibling,
+	tagName: tagName,
+	setTextContent: setTextContent,
+	setAttribute: setAttribute
+});
+
+/*  */
+
+var ref = {
+  create: function create (_, vnode) {
+    registerRef(vnode);
+  },
+  update: function update (oldVnode, vnode) {
+    if (oldVnode.data.ref !== vnode.data.ref) {
+      registerRef(oldVnode, true);
+      registerRef(vnode);
+    }
+  },
+  destroy: function destroy (vnode) {
+    registerRef(vnode, true);
+  }
+};
+
+function registerRef (vnode, isRemoval) {
+  var key = vnode.data.ref;
+  if (!key) { return }
+
+  var vm = vnode.context;
+  var ref = vnode.componentInstance || vnode.elm;
+  var refs = vm.$refs;
+  if (isRemoval) {
+    if (Array.isArray(refs[key])) {
+      remove(refs[key], ref);
+    } else if (refs[key] === ref) {
+      refs[key] = undefined;
+    }
+  } else {
+    if (vnode.data.refInFor) {
+      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
+        refs[key].push(ref);
+      } else {
+        refs[key] = [ref];
+      }
+    } else {
+      refs[key] = ref;
+    }
+  }
+}
+
+/**
+ * Virtual DOM patching algorithm based on Snabbdom by
+ * Simon Friis Vindum (@paldepind)
+ * Licensed under the MIT License
+ * https://github.com/paldepind/snabbdom/blob/master/LICENSE
+ *
+ * modified by Evan You (@yyx990803)
+ *
+
+/*
+ * Not type-checking this because this file is perf-critical and the cost
+ * of making flow understand it is not worth it.
+ */
+
+var emptyNode = new VNode('', {}, []);
+
+var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];
+
+function isUndef (s) {
+  return s == null
+}
+
+function isDef (s) {
+  return s != null
+}
+
+function sameVnode (vnode1, vnode2) {
+  return (
+    vnode1.key === vnode2.key &&
+    vnode1.tag === vnode2.tag &&
+    vnode1.isComment === vnode2.isComment &&
+    !vnode1.data === !vnode2.data
+  )
+}
+
+function createKeyToOldIdx (children, beginIdx, endIdx) {
+  var i, key;
+  var map = {};
+  for (i = beginIdx; i <= endIdx; ++i) {
+    key = children[i].key;
+    if (isDef(key)) { map[key] = i; }
+  }
+  return map
+}
+
+function createPatchFunction (backend) {
+  var i, j;
+  var cbs = {};
+
+  var modules = backend.modules;
+  var nodeOps = backend.nodeOps;
+
+  for (i = 0; i < hooks$1.length; ++i) {
+    cbs[hooks$1[i]] = [];
+    for (j = 0; j < modules.length; ++j) {
+      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
+    }
+  }
+
+  function emptyNodeAt (elm) {
+    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
+  }
+
+  function createRmCb (childElm, listeners) {
+    function remove$$1 () {
+      if (--remove$$1.listeners === 0) {
+        removeNode(childElm);
+      }
+    }
+    remove$$1.listeners = listeners;
+    return remove$$1
+  }
+
+  function removeNode (el) {
+    var parent = nodeOps.parentNode(el);
+    // element may have already been removed due to v-html / v-text
+    if (parent) {
+      nodeOps.removeChild(parent, el);
+    }
+  }
+
+  var inPre = 0;
+  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
+    vnode.isRootInsert = !nested; // for transition enter check
+    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
+      return
+    }
+
+    var data = vnode.data;
+    var children = vnode.children;
+    var tag = vnode.tag;
+    if (isDef(tag)) {
+      if (process.env.NODE_ENV !== 'production') {
+        if (data && data.pre) {
+          inPre++;
+        }
+        if (
+          !inPre &&
+          !vnode.ns &&
+          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
+          config.isUnknownElement(tag)
+        ) {
+          warn(
+            'Unknown custom element: <' + tag + '> - did you ' +
+            'register the component correctly? For recursive components, ' +
+            'make sure to provide the "name" option.',
+            vnode.context
+          );
+        }
+      }
+      vnode.elm = vnode.ns
+        ? nodeOps.createElementNS(vnode.ns, tag)
+        : nodeOps.createElement(tag, vnode);
+      setScope(vnode);
+
+      /* istanbul ignore if */
+      {
+        createChildren(vnode, children, insertedVnodeQueue);
+        if (isDef(data)) {
+          invokeCreateHooks(vnode, insertedVnodeQueue);
+        }
+        insert(parentElm, vnode.elm, refElm);
+      }
+
+      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
+        inPre--;
+      }
+    } else if (vnode.isComment) {
+      vnode.elm = nodeOps.createComment(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    } else {
+      vnode.elm = nodeOps.createTextNode(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    }
+  }
+
+  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i = vnode.data;
+    if (isDef(i)) {
+      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
+      if (isDef(i = i.hook) && isDef(i = i.init)) {
+        i(vnode, false /* hydrating */, parentElm, refElm);
+      }
+      // after calling the init hook, if the vnode is a child component
+      // it should've created a child instance and mounted it. the child
+      // component also has set the placeholder vnode's elm.
+      // in that case we can just return the element and be done.
+      if (isDef(vnode.componentInstance)) {
+        initComponent(vnode, insertedVnodeQueue);
+        if (isReactivated) {
+          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
+        }
+        return true
+      }
+    }
+  }
+
+  function initComponent (vnode, insertedVnodeQueue) {
+    if (vnode.data.pendingInsert) {
+      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
+    }
+    vnode.elm = vnode.componentInstance.$el;
+    if (isPatchable(vnode)) {
+      invokeCreateHooks(vnode, insertedVnodeQueue);
+      setScope(vnode);
+    } else {
+      // empty component root.
+      // skip all element-related modules except for ref (#3455)
+      registerRef(vnode);
+      // make sure to invoke the insert hook
+      insertedVnodeQueue.push(vnode);
+    }
+  }
+
+  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i;
+    // hack for #4339: a reactivated component with inner transition
+    // does not trigger because the inner node's created hooks are not called
+    // again. It's not ideal to involve module-specific logic in here but
+    // there doesn't seem to be a better way to do it.
+    var innerNode = vnode;
+    while (innerNode.componentInstance) {
+      innerNode = innerNode.componentInstance._vnode;
+      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
+        for (i = 0; i < cbs.activate.length; ++i) {
+          cbs.activate[i](emptyNode, innerNode);
+        }
+        insertedVnodeQueue.push(innerNode);
+        break
+      }
+    }
+    // unlike a newly created component,
+    // a reactivated keep-alive component doesn't insert itself
+    insert(parentElm, vnode.elm, refElm);
+  }
+
+  function insert (parent, elm, ref) {
+    if (parent) {
+      if (ref) {
+        nodeOps.insertBefore(parent, elm, ref);
+      } else {
+        nodeOps.appendChild(parent, elm);
+      }
+    }
+  }
+
+  function createChildren (vnode, children, insertedVnodeQueue) {
+    if (Array.isArray(children)) {
+      for (var i = 0; i < children.length; ++i) {
+        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
+      }
+    } else if (isPrimitive(vnode.text)) {
+      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
+    }
+  }
+
+  function isPatchable (vnode) {
+    while (vnode.componentInstance) {
+      vnode = vnode.componentInstance._vnode;
+    }
+    return isDef(vnode.tag)
+  }
+
+  function invokeCreateHooks (vnode, insertedVnodeQueue) {
+    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
+      cbs.create[i$1](emptyNode, vnode);
+    }
+    i = vnode.data.hook; // Reuse variable
+    if (isDef(i)) {
+      if (i.create) { i.create(emptyNode, vnode); }
+      if (i.insert) { insertedVnodeQueue.push(vnode); }
+    }
+  }
+
+  // set scope id attribute for scoped CSS.
+  // this is implemented as a special case to avoid the overhead
+  // of going through the normal attribute patching process.
+  function setScope (vnode) {
+    var i;
+    var ancestor = vnode;
+    while (ancestor) {
+      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
+        nodeOps.setAttribute(vnode.elm, i, '');
+      }
+      ancestor = ancestor.parent;
+    }
+    // for slot content they should also get the scopeId from the host instance.
+    if (isDef(i = activeInstance) &&
+        i !== vnode.context &&
+        isDef(i = i.$options._scopeId)) {
+      nodeOps.setAttribute(vnode.elm, i, '');
+    }
+  }
+
+  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
+    }
+  }
+
+  function invokeDestroyHook (vnode) {
+    var i, j;
+    var data = vnode.data;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
+      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
+    }
+    if (isDef(i = vnode.children)) {
+      for (j = 0; j < vnode.children.length; ++j) {
+        invokeDestroyHook(vnode.children[j]);
+      }
+    }
+  }
+
+  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      var ch = vnodes[startIdx];
+      if (isDef(ch)) {
+        if (isDef(ch.tag)) {
+          removeAndInvokeRemoveHook(ch);
+          invokeDestroyHook(ch);
+        } else { // Text node
+          removeNode(ch.elm);
+        }
+      }
+    }
+  }
+
+  function removeAndInvokeRemoveHook (vnode, rm) {
+    if (rm || isDef(vnode.data)) {
+      var listeners = cbs.remove.length + 1;
+      if (!rm) {
+        // directly removing
+        rm = createRmCb(vnode.elm, listeners);
+      } else {
+        // we have a recursively passed down rm callback
+        // increase the listeners count
+        rm.listeners += listeners;
+      }
+      // recursively invoke hooks on child component root node
+      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
+        removeAndInvokeRemoveHook(i, rm);
+      }
+      for (i = 0; i < cbs.remove.length; ++i) {
+        cbs.remove[i](vnode, rm);
+      }
+      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
+        i(vnode, rm);
+      } else {
+        rm();
+      }
+    } else {
+      removeNode(vnode.elm);
+    }
+  }
+
+  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
+    var oldStartIdx = 0;
+    var newStartIdx = 0;
+    var oldEndIdx = oldCh.length - 1;
+    var oldStartVnode = oldCh[0];
+    var oldEndVnode = oldCh[oldEndIdx];
+    var newEndIdx = newCh.length - 1;
+    var newStartVnode = newCh[0];
+    var newEndVnode = newCh[newEndIdx];
+    var oldKeyToIdx, idxInOld, elmToMove, refElm;
+
+    // removeOnly is a special flag used only by <transition-group>
+    // to ensure removed elements stay in correct relative positions
+    // during leaving transitions
+    var canMove = !removeOnly;
+
+    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
+      if (isUndef(oldStartVnode)) {
+        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
+      } else if (isUndef(oldEndVnode)) {
+        oldEndVnode = oldCh[--oldEndIdx];
+      } else if (sameVnode(oldStartVnode, newStartVnode)) {
+        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
+        oldStartVnode = oldCh[++oldStartIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else if (sameVnode(oldEndVnode, newEndVnode)) {
+        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
+        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
+        oldStartVnode = oldCh[++oldStartIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
+        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else {
+        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
+        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
+        if (isUndef(idxInOld)) { // New element
+          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+          newStartVnode = newCh[++newStartIdx];
+        } else {
+          elmToMove = oldCh[idxInOld];
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
+            warn(
+              'It seems there are duplicate keys that is causing an update error. ' +
+              'Make sure each v-for item has a unique key.'
+            );
+          }
+          if (sameVnode(elmToMove, newStartVnode)) {
+            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
+            oldCh[idxInOld] = undefined;
+            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          } else {
+            // same key but different element. treat as new element
+            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          }
+        }
+      }
+    }
+    if (oldStartIdx > oldEndIdx) {
+      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
+      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
+    } else if (newStartIdx > newEndIdx) {
+      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
+    }
+  }
+
+  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
+    if (oldVnode === vnode) {
+      return
+    }
+    // reuse element for static trees.
+    // note we only do this if the vnode is cloned -
+    // if the new node is not cloned it means the render functions have been
+    // reset by the hot-reload-api and we need to do a proper re-render.
+    if (vnode.isStatic &&
+        oldVnode.isStatic &&
+        vnode.key === oldVnode.key &&
+        (vnode.isCloned || vnode.isOnce)) {
+      vnode.elm = oldVnode.elm;
+      vnode.componentInstance = oldVnode.componentInstance;
+      return
+    }
+    var i;
+    var data = vnode.data;
+    var hasData = isDef(data);
+    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
+      i(oldVnode, vnode);
+    }
+    var elm = vnode.elm = oldVnode.elm;
+    var oldCh = oldVnode.children;
+    var ch = vnode.children;
+    if (hasData && isPatchable(vnode)) {
+      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
+      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
+    }
+    if (isUndef(vnode.text)) {
+      if (isDef(oldCh) && isDef(ch)) {
+        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
+      } else if (isDef(ch)) {
+        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
+        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
+      } else if (isDef(oldCh)) {
+        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
+      } else if (isDef(oldVnode.text)) {
+        nodeOps.setTextContent(elm, '');
+      }
+    } else if (oldVnode.text !== vnode.text) {
+      nodeOps.setTextContent(elm, vnode.text);
+    }
+    if (hasData) {
+      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
+    }
+  }
+
+  function invokeInsertHook (vnode, queue, initial) {
+    // delay insert hooks for component root nodes, invoke them after the
+    // element is really inserted
+    if (initial && vnode.parent) {
+      vnode.parent.data.pendingInsert = queue;
+    } else {
+      for (var i = 0; i < queue.length; ++i) {
+        queue[i].data.hook.insert(queue[i]);
+      }
+    }
+  }
+
+  var bailed = false;
+  // list of modules that can skip create hook during hydration because they
+  // are already rendered on the client or has no need for initialization
+  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
+
+  // Note: this is a browser-only function so we can assume elms are DOM nodes.
+  function hydrate (elm, vnode, insertedVnodeQueue) {
+    if (process.env.NODE_ENV !== 'production') {
+      if (!assertNodeMatch(elm, vnode)) {
+        return false
+      }
+    }
+    vnode.elm = elm;
+    var tag = vnode.tag;
+    var data = vnode.data;
+    var children = vnode.children;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
+      if (isDef(i = vnode.componentInstance)) {
+        // child component. it should have hydrated its own tree.
+        initComponent(vnode, insertedVnodeQueue);
+        return true
+      }
+    }
+    if (isDef(tag)) {
+      if (isDef(children)) {
+        // empty element, allow client to pick up and populate children
+        if (!elm.hasChildNodes()) {
+          createChildren(vnode, children, insertedVnodeQueue);
+        } else {
+          var childrenMatch = true;
+          var childNode = elm.firstChild;
+          for (var i$1 = 0; i$1 < children.length; i$1++) {
+            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
+              childrenMatch = false;
+              break
+            }
+            childNode = childNode.nextSibling;
+          }
+          // if childNode is not null, it means the actual childNodes list is
+          // longer than the virtual children list.
+          if (!childrenMatch || childNode) {
+            if (process.env.NODE_ENV !== 'production' &&
+                typeof console !== 'undefined' &&
+                !bailed) {
+              bailed = true;
+              console.warn('Parent: ', elm);
+              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
+            }
+            return false
+          }
+        }
+      }
+      if (isDef(data)) {
+        for (var key in data) {
+          if (!isRenderedModule(key)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue);
+            break
+          }
+        }
+      }
+    } else if (elm.data !== vnode.text) {
+      elm.data = vnode.text;
+    }
+    return true
+  }
+
+  function assertNodeMatch (node, vnode) {
+    if (vnode.tag) {
+      return (
+        vnode.tag.indexOf('vue-component') === 0 ||
+        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
+      )
+    } else {
+      return node.nodeType === (vnode.isComment ? 8 : 3)
+    }
+  }
+
+  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
+    if (!vnode) {
+      if (oldVnode) { invokeDestroyHook(oldVnode); }
+      return
+    }
+
+    var isInitialPatch = false;
+    var insertedVnodeQueue = [];
+
+    if (!oldVnode) {
+      // empty mount (likely as component), create new root element
+      isInitialPatch = true;
+      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
+    } else {
+      var isRealElement = isDef(oldVnode.nodeType);
+      if (!isRealElement && sameVnode(oldVnode, vnode)) {
+        // patch existing root node
+        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
+      } else {
+        if (isRealElement) {
+          // mounting to a real element
+          // check if this is server-rendered content and if we can perform
+          // a successful hydration.
+          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
+            oldVnode.removeAttribute('server-rendered');
+            hydrating = true;
+          }
+          if (hydrating) {
+            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
+              invokeInsertHook(vnode, insertedVnodeQueue, true);
+              return oldVnode
+            } else if (process.env.NODE_ENV !== 'production') {
+              warn(
+                'The client-side rendered virtual DOM tree is not matching ' +
+                'server-rendered content. This is likely caused by incorrect ' +
+                'HTML markup, for example nesting block-level elements inside ' +
+                '<p>, or missing <tbody>. Bailing hydration and performing ' +
+                'full client-side render.'
+              );
+            }
+          }
+          // either not server-rendered, or hydration failed.
+          // create an empty node and replace it
+          oldVnode = emptyNodeAt(oldVnode);
+        }
+        // replacing existing element
+        var oldElm = oldVnode.elm;
+        var parentElm$1 = nodeOps.parentNode(oldElm);
+        createElm(
+          vnode,
+          insertedVnodeQueue,
+          // extremely rare edge case: do not insert if old element is in a
+          // leaving transition. Only happens when combining transition +
+          // keep-alive + HOCs. (#4590)
+          oldElm._leaveCb ? null : parentElm$1,
+          nodeOps.nextSibling(oldElm)
+        );
+
+        if (vnode.parent) {
+          // component root element replaced.
+          // update parent placeholder node element, recursively
+          var ancestor = vnode.parent;
+          while (ancestor) {
+            ancestor.elm = vnode.elm;
+            ancestor = ancestor.parent;
+          }
+          if (isPatchable(vnode)) {
+            for (var i = 0; i < cbs.create.length; ++i) {
+              cbs.create[i](emptyNode, vnode.parent);
+            }
+          }
+        }
+
+        if (parentElm$1 !== null) {
+          removeVnodes(parentElm$1, [oldVnode], 0, 0);
+        } else if (isDef(oldVnode.tag)) {
+          invokeDestroyHook(oldVnode);
+        }
+      }
+    }
+
+    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
+    return vnode.elm
+  }
+}
+
+/*  */
+
+var directives = {
+  create: updateDirectives,
+  update: updateDirectives,
+  destroy: function unbindDirectives (vnode) {
+    updateDirectives(vnode, emptyNode);
+  }
+};
+
+function updateDirectives (oldVnode, vnode) {
+  if (oldVnode.data.directives || vnode.data.directives) {
+    _update(oldVnode, vnode);
+  }
+}
+
+function _update (oldVnode, vnode) {
+  var isCreate = oldVnode === emptyNode;
+  var isDestroy = vnode === emptyNode;
+  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
+  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
+
+  var dirsWithInsert = [];
+  var dirsWithPostpatch = [];
+
+  var key, oldDir, dir;
+  for (key in newDirs) {
+    oldDir = oldDirs[key];
+    dir = newDirs[key];
+    if (!oldDir) {
+      // new directive, bind
+      callHook$1(dir, 'bind', vnode, oldVnode);
+      if (dir.def && dir.def.inserted) {
+        dirsWithInsert.push(dir);
+      }
+    } else {
+      // existing directive, update
+      dir.oldValue = oldDir.value;
+      callHook$1(dir, 'update', vnode, oldVnode);
+      if (dir.def && dir.def.componentUpdated) {
+        dirsWithPostpatch.push(dir);
+      }
+    }
+  }
+
+  if (dirsWithInsert.length) {
+    var callInsert = function () {
+      for (var i = 0; i < dirsWithInsert.length; i++) {
+        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
+      }
+    };
+    if (isCreate) {
+      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
+    } else {
+      callInsert();
+    }
+  }
+
+  if (dirsWithPostpatch.length) {
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
+      for (var i = 0; i < dirsWithPostpatch.length; i++) {
+        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
+      }
+    });
+  }
+
+  if (!isCreate) {
+    for (key in oldDirs) {
+      if (!newDirs[key]) {
+        // no longer present, unbind
+        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
+      }
+    }
+  }
+}
+
+var emptyModifiers = Object.create(null);
+
+function normalizeDirectives$1 (
+  dirs,
+  vm
+) {
+  var res = Object.create(null);
+  if (!dirs) {
+    return res
+  }
+  var i, dir;
+  for (i = 0; i < dirs.length; i++) {
+    dir = dirs[i];
+    if (!dir.modifiers) {
+      dir.modifiers = emptyModifiers;
+    }
+    res[getRawDirName(dir)] = dir;
+    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
+  }
+  return res
+}
+
+function getRawDirName (dir) {
+  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
+}
+
+function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
+  var fn = dir.def && dir.def[hook];
+  if (fn) {
+    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
+  }
+}
+
+var baseModules = [
+  ref,
+  directives
+];
+
+/*  */
+
+function updateAttrs (oldVnode, vnode) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  var key, cur, old;
+  var elm = vnode.elm;
+  var oldAttrs = oldVnode.data.attrs || {};
+  var attrs = vnode.data.attrs || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs);
+  }
+
+  for (key in attrs) {
+    cur = attrs[key];
+    old = oldAttrs[key];
+    if (old !== cur) {
+      setAttr(elm, key, cur);
+    }
+  }
+  // #4391: in IE9, setting type can reset value for input[type=radio]
+  /* istanbul ignore if */
+  if (isIE9 && attrs.value !== oldAttrs.value) {
+    setAttr(elm, 'value', attrs.value);
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      if (isXlink(key)) {
+        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
+      } else if (!isEnumeratedAttr(key)) {
+        elm.removeAttribute(key);
+      }
+    }
+  }
+}
+
+function setAttr (el, key, value) {
+  if (isBooleanAttr(key)) {
+    // set attribute for blank value
+    // e.g. <option disabled>Select one</option>
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, key);
+    }
+  } else if (isEnumeratedAttr(key)) {
+    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
+  } else if (isXlink(key)) {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
+    } else {
+      el.setAttributeNS(xlinkNS, key, value);
+    }
+  } else {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, value);
+    }
+  }
+}
+
+var attrs = {
+  create: updateAttrs,
+  update: updateAttrs
+};
+
+/*  */
+
+function updateClass (oldVnode, vnode) {
+  var el = vnode.elm;
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  var cls = genClassForVnode(vnode);
+
+  // handle transition classes
+  var transitionClass = el._transitionClasses;
+  if (transitionClass) {
+    cls = concat(cls, stringifyClass(transitionClass));
+  }
+
+  // set the class
+  if (cls !== el._prevClass) {
+    el.setAttribute('class', cls);
+    el._prevClass = cls;
+  }
+}
+
+var klass = {
+  create: updateClass,
+  update: updateClass
+};
+
+/*  */
+
+var validDivisionCharRE = /[\w).+\-_$\]]/;
+
+
+
+function wrapFilter (exp, filter) {
+  var i = filter.indexOf('(');
+  if (i < 0) {
+    // _f: resolveFilter
+    return ("_f(\"" + filter + "\")(" + exp + ")")
+  } else {
+    var name = filter.slice(0, i);
+    var args = filter.slice(i + 1);
+    return ("_f(\"" + name + "\")(" + exp + "," + args)
+  }
+}
+
+/*  */
+
+/*  */
+
+/**
+ * Cross-platform code generation for component v-model
+ */
+
+
+/**
+ * Cross-platform codegen helper for generating v-model value assignment code.
+ */
+
+
+/**
+ * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
+ *
+ * for loop possible cases:
+ *
+ * - test
+ * - test[idx]
+ * - test[test1[idx]]
+ * - test["a"][idx]
+ * - xxx.test[a[a].test1[idx]]
+ * - test.xxx.a["asa"][test1[idx]]
+ *
+ */
+
+var str;
+var index$1;
+
+/*  */
+
+// in some cases, the event used has to be determined at runtime
+// so we used some reserved tokens during compile.
+var RANGE_TOKEN = '__r';
+var CHECKBOX_RADIO_TOKEN = '__c';
+
+/*  */
+
+// normalize v-model event tokens that can only be determined at runtime.
+// it's important to place the event as the first in the array because
+// the whole point is ensuring the v-model callback gets called before
+// user-attached handlers.
+function normalizeEvents (on) {
+  var event;
+  /* istanbul ignore if */
+  if (on[RANGE_TOKEN]) {
+    // IE input[type=range] only supports `change` event
+    event = isIE ? 'change' : 'input';
+    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
+    delete on[RANGE_TOKEN];
+  }
+  if (on[CHECKBOX_RADIO_TOKEN]) {
+    // Chrome fires microtasks in between click/change, leads to #4521
+    event = isChrome ? 'click' : 'change';
+    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
+    delete on[CHECKBOX_RADIO_TOKEN];
+  }
+}
+
+var target$1;
+
+function add$1 (
+  event,
+  handler,
+  once,
+  capture
+) {
+  if (once) {
+    var oldHandler = handler;
+    var _target = target$1; // save current target element in closure
+    handler = function (ev) {
+      var res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments);
+      if (res !== null) {
+        remove$2(event, handler, capture, _target);
+      }
+    };
+  }
+  target$1.addEventListener(event, handler, capture);
+}
+
+function remove$2 (
+  event,
+  handler,
+  capture,
+  _target
+) {
+  (_target || target$1).removeEventListener(event, handler, capture);
+}
+
+function updateDOMListeners (oldVnode, vnode) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  var on = vnode.data.on || {};
+  var oldOn = oldVnode.data.on || {};
+  target$1 = vnode.elm;
+  normalizeEvents(on);
+  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
+}
+
+var events = {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+};
+
+/*  */
+
+function updateDOMProps (oldVnode, vnode) {
+  if (!oldVnode.data.domProps && !vnode.data.domProps) {
+    return
+  }
+  var key, cur;
+  var elm = vnode.elm;
+  var oldProps = oldVnode.data.domProps || {};
+  var props = vnode.data.domProps || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (props.__ob__) {
+    props = vnode.data.domProps = extend({}, props);
+  }
+
+  for (key in oldProps) {
+    if (props[key] == null) {
+      elm[key] = '';
+    }
+  }
+  for (key in props) {
+    cur = props[key];
+    // ignore children if the node has textContent or innerHTML,
+    // as these will throw away existing DOM nodes and cause removal errors
+    // on subsequent patches (#3360)
+    if (key === 'textContent' || key === 'innerHTML') {
+      if (vnode.children) { vnode.children.length = 0; }
+      if (cur === oldProps[key]) { continue }
+    }
+
+    if (key === 'value') {
+      // store value as _value as well since
+      // non-string values will be stringified
+      elm._value = cur;
+      // avoid resetting cursor position when value is the same
+      var strCur = cur == null ? '' : String(cur);
+      if (shouldUpdateValue(elm, vnode, strCur)) {
+        elm.value = strCur;
+      }
+    } else {
+      elm[key] = cur;
+    }
+  }
+}
+
+// check platforms/web/util/attrs.js acceptValue
+
+
+function shouldUpdateValue (
+  elm,
+  vnode,
+  checkVal
+) {
+  return (!elm.composing && (
+    vnode.tag === 'option' ||
+    isDirty(elm, checkVal) ||
+    isInputChanged(elm, checkVal)
+  ))
+}
+
+function isDirty (elm, checkVal) {
+  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
+  return document.activeElement !== elm && elm.value !== checkVal
+}
+
+function isInputChanged (elm, newVal) {
+  var value = elm.value;
+  var modifiers = elm._vModifiers; // injected by v-model runtime
+  if ((modifiers && modifiers.number) || elm.type === 'number') {
+    return toNumber(value) !== toNumber(newVal)
+  }
+  if (modifiers && modifiers.trim) {
+    return value.trim() !== newVal.trim()
+  }
+  return value !== newVal
+}
+
+var domProps = {
+  create: updateDOMProps,
+  update: updateDOMProps
+};
+
+/*  */
+
+var parseStyleText = cached(function (cssText) {
+  var res = {};
+  var listDelimiter = /;(?![^(]*\))/g;
+  var propertyDelimiter = /:(.+)/;
+  cssText.split(listDelimiter).forEach(function (item) {
+    if (item) {
+      var tmp = item.split(propertyDelimiter);
+      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
+    }
+  });
+  return res
+});
+
+// merge static and dynamic style data on the same vnode
+function normalizeStyleData (data) {
+  var style = normalizeStyleBinding(data.style);
+  // static style is pre-processed into an object during compilation
+  // and is always a fresh object, so it's safe to merge into it
+  return data.staticStyle
+    ? extend(data.staticStyle, style)
+    : style
+}
+
+// normalize possible array / string values into Object
+function normalizeStyleBinding (bindingStyle) {
+  if (Array.isArray(bindingStyle)) {
+    return toObject(bindingStyle)
+  }
+  if (typeof bindingStyle === 'string') {
+    return parseStyleText(bindingStyle)
+  }
+  return bindingStyle
+}
+
+/**
+ * parent component style should be after child's
+ * so that parent component's style could override it
+ */
+function getStyle (vnode, checkChild) {
+  var res = {};
+  var styleData;
+
+  if (checkChild) {
+    var childNode = vnode;
+    while (childNode.componentInstance) {
+      childNode = childNode.componentInstance._vnode;
+      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
+        extend(res, styleData);
+      }
+    }
+  }
+
+  if ((styleData = normalizeStyleData(vnode.data))) {
+    extend(res, styleData);
+  }
+
+  var parentNode = vnode;
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
+      extend(res, styleData);
+    }
+  }
+  return res
+}
+
+/*  */
+
+var cssVarRE = /^--/;
+var importantRE = /\s*!important$/;
+var setProp = function (el, name, val) {
+  /* istanbul ignore if */
+  if (cssVarRE.test(name)) {
+    el.style.setProperty(name, val);
+  } else if (importantRE.test(val)) {
+    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
+  } else {
+    el.style[normalize(name)] = val;
+  }
+};
+
+var prefixes = ['Webkit', 'Moz', 'ms'];
+
+var testEl;
+var normalize = cached(function (prop) {
+  testEl = testEl || document.createElement('div');
+  prop = camelize(prop);
+  if (prop !== 'filter' && (prop in testEl.style)) {
+    return prop
+  }
+  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
+  for (var i = 0; i < prefixes.length; i++) {
+    var prefixed = prefixes[i] + upper;
+    if (prefixed in testEl.style) {
+      return prefixed
+    }
+  }
+});
+
+function updateStyle (oldVnode, vnode) {
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+
+  if (!data.staticStyle && !data.style &&
+      !oldData.staticStyle && !oldData.style) {
+    return
+  }
+
+  var cur, name;
+  var el = vnode.elm;
+  var oldStaticStyle = oldVnode.data.staticStyle;
+  var oldStyleBinding = oldVnode.data.style || {};
+
+  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
+  var oldStyle = oldStaticStyle || oldStyleBinding;
+
+  var style = normalizeStyleBinding(vnode.data.style) || {};
+
+  vnode.data.style = style.__ob__ ? extend({}, style) : style;
+
+  var newStyle = getStyle(vnode, true);
+
+  for (name in oldStyle) {
+    if (newStyle[name] == null) {
+      setProp(el, name, '');
+    }
+  }
+  for (name in newStyle) {
+    cur = newStyle[name];
+    if (cur !== oldStyle[name]) {
+      // ie9 setting to null has no effect, must use empty string
+      setProp(el, name, cur == null ? '' : cur);
+    }
+  }
+}
+
+var style = {
+  create: updateStyle,
+  update: updateStyle
+};
+
+/*  */
+
+/**
+ * Add class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function addClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
+    } else {
+      el.classList.add(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    if (cur.indexOf(' ' + cls + ' ') < 0) {
+      el.setAttribute('class', (cur + cls).trim());
+    }
+  }
+}
+
+/**
+ * Remove class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function removeClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
+    } else {
+      el.classList.remove(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    var tar = ' ' + cls + ' ';
+    while (cur.indexOf(tar) >= 0) {
+      cur = cur.replace(tar, ' ');
+    }
+    el.setAttribute('class', cur.trim());
+  }
+}
+
+/*  */
+
+function resolveTransition (def$$1) {
+  if (!def$$1) {
+    return
+  }
+  /* istanbul ignore else */
+  if (typeof def$$1 === 'object') {
+    var res = {};
+    if (def$$1.css !== false) {
+      extend(res, autoCssTransition(def$$1.name || 'v'));
+    }
+    extend(res, def$$1);
+    return res
+  } else if (typeof def$$1 === 'string') {
+    return autoCssTransition(def$$1)
+  }
+}
+
+var autoCssTransition = cached(function (name) {
+  return {
+    enterClass: (name + "-enter"),
+    enterToClass: (name + "-enter-to"),
+    enterActiveClass: (name + "-enter-active"),
+    leaveClass: (name + "-leave"),
+    leaveToClass: (name + "-leave-to"),
+    leaveActiveClass: (name + "-leave-active")
+  }
+});
+
+var hasTransition = inBrowser && !isIE9;
+var TRANSITION = 'transition';
+var ANIMATION = 'animation';
+
+// Transition property/event sniffing
+var transitionProp = 'transition';
+var transitionEndEvent = 'transitionend';
+var animationProp = 'animation';
+var animationEndEvent = 'animationend';
+if (hasTransition) {
+  /* istanbul ignore if */
+  if (window.ontransitionend === undefined &&
+    window.onwebkittransitionend !== undefined) {
+    transitionProp = 'WebkitTransition';
+    transitionEndEvent = 'webkitTransitionEnd';
+  }
+  if (window.onanimationend === undefined &&
+    window.onwebkitanimationend !== undefined) {
+    animationProp = 'WebkitAnimation';
+    animationEndEvent = 'webkitAnimationEnd';
+  }
+}
+
+// binding to window is necessary to make hot reload work in IE in strict mode
+var raf = inBrowser && window.requestAnimationFrame
+  ? window.requestAnimationFrame.bind(window)
+  : setTimeout;
+
+function nextFrame (fn) {
+  raf(function () {
+    raf(fn);
+  });
+}
+
+function addTransitionClass (el, cls) {
+  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
+  addClass(el, cls);
+}
+
+function removeTransitionClass (el, cls) {
+  if (el._transitionClasses) {
+    remove(el._transitionClasses, cls);
+  }
+  removeClass(el, cls);
+}
+
+function whenTransitionEnds (
+  el,
+  expectedType,
+  cb
+) {
+  var ref = getTransitionInfo(el, expectedType);
+  var type = ref.type;
+  var timeout = ref.timeout;
+  var propCount = ref.propCount;
+  if (!type) { return cb() }
+  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
+  var ended = 0;
+  var end = function () {
+    el.removeEventListener(event, onEnd);
+    cb();
+  };
+  var onEnd = function (e) {
+    if (e.target === el) {
+      if (++ended >= propCount) {
+        end();
+      }
+    }
+  };
+  setTimeout(function () {
+    if (ended < propCount) {
+      end();
+    }
+  }, timeout + 1);
+  el.addEventListener(event, onEnd);
+}
+
+var transformRE = /\b(transform|all)(,|$)/;
+
+function getTransitionInfo (el, expectedType) {
+  var styles = window.getComputedStyle(el);
+  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
+  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
+  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
+  var animationDelays = styles[animationProp + 'Delay'].split(', ');
+  var animationDurations = styles[animationProp + 'Duration'].split(', ');
+  var animationTimeout = getTimeout(animationDelays, animationDurations);
+
+  var type;
+  var timeout = 0;
+  var propCount = 0;
+  /* istanbul ignore if */
+  if (expectedType === TRANSITION) {
+    if (transitionTimeout > 0) {
+      type = TRANSITION;
+      timeout = transitionTimeout;
+      propCount = transitionDurations.length;
+    }
+  } else if (expectedType === ANIMATION) {
+    if (animationTimeout > 0) {
+      type = ANIMATION;
+      timeout = animationTimeout;
+      propCount = animationDurations.length;
+    }
+  } else {
+    timeout = Math.max(transitionTimeout, animationTimeout);
+    type = timeout > 0
+      ? transitionTimeout > animationTimeout
+        ? TRANSITION
+        : ANIMATION
+      : null;
+    propCount = type
+      ? type === TRANSITION
+        ? transitionDurations.length
+        : animationDurations.length
+      : 0;
+  }
+  var hasTransform =
+    type === TRANSITION &&
+    transformRE.test(styles[transitionProp + 'Property']);
+  return {
+    type: type,
+    timeout: timeout,
+    propCount: propCount,
+    hasTransform: hasTransform
+  }
+}
+
+function getTimeout (delays, durations) {
+  /* istanbul ignore next */
+  while (delays.length < durations.length) {
+    delays = delays.concat(delays);
+  }
+
+  return Math.max.apply(null, durations.map(function (d, i) {
+    return toMs(d) + toMs(delays[i])
+  }))
+}
+
+function toMs (s) {
+  return Number(s.slice(0, -1)) * 1000
+}
+
+/*  */
+
+function enter (vnode, toggleDisplay) {
+  var el = vnode.elm;
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true;
+    el._leaveCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var enterClass = data.enterClass;
+  var enterToClass = data.enterToClass;
+  var enterActiveClass = data.enterActiveClass;
+  var appearClass = data.appearClass;
+  var appearToClass = data.appearToClass;
+  var appearActiveClass = data.appearActiveClass;
+  var beforeEnter = data.beforeEnter;
+  var enter = data.enter;
+  var afterEnter = data.afterEnter;
+  var enterCancelled = data.enterCancelled;
+  var beforeAppear = data.beforeAppear;
+  var appear = data.appear;
+  var afterAppear = data.afterAppear;
+  var appearCancelled = data.appearCancelled;
+  var duration = data.duration;
+
+  // activeInstance will always be the <transition> component managing this
+  // transition. One edge case to check is when the <transition> is placed
+  // as the root node of a child component. In that case we need to check
+  // <transition>'s parent for appear check.
+  var context = activeInstance;
+  var transitionNode = activeInstance.$vnode;
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent;
+    context = transitionNode.context;
+  }
+
+  var isAppear = !context._isMounted || !vnode.isRootInsert;
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  var startClass = isAppear && appearClass
+    ? appearClass
+    : enterClass;
+  var activeClass = isAppear && appearActiveClass
+    ? appearActiveClass
+    : enterActiveClass;
+  var toClass = isAppear && appearToClass
+    ? appearToClass
+    : enterToClass;
+
+  var beforeEnterHook = isAppear
+    ? (beforeAppear || beforeEnter)
+    : beforeEnter;
+  var enterHook = isAppear
+    ? (typeof appear === 'function' ? appear : enter)
+    : enter;
+  var afterEnterHook = isAppear
+    ? (afterAppear || afterEnter)
+    : afterEnter;
+  var enterCancelledHook = isAppear
+    ? (appearCancelled || enterCancelled)
+    : enterCancelled;
+
+  var explicitEnterDuration = toNumber(
+    isObject(duration)
+      ? duration.enter
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
+    checkDuration(explicitEnterDuration, 'enter', vnode);
+  }
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(enterHook);
+
+  var cb = el._enterCb = once(function () {
+    if (expectsCSS) {
+      removeTransitionClass(el, toClass);
+      removeTransitionClass(el, activeClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, startClass);
+      }
+      enterCancelledHook && enterCancelledHook(el);
+    } else {
+      afterEnterHook && afterEnterHook(el);
+    }
+    el._enterCb = null;
+  });
+
+  if (!vnode.data.show) {
+    // remove pending leave element on enter by injecting an insert hook
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
+      var parent = el.parentNode;
+      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
+      if (pendingNode &&
+          pendingNode.tag === vnode.tag &&
+          pendingNode.elm._leaveCb) {
+        pendingNode.elm._leaveCb();
+      }
+      enterHook && enterHook(el, cb);
+    });
+  }
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el);
+  if (expectsCSS) {
+    addTransitionClass(el, startClass);
+    addTransitionClass(el, activeClass);
+    nextFrame(function () {
+      addTransitionClass(el, toClass);
+      removeTransitionClass(el, startClass);
+      if (!cb.cancelled && !userWantsControl) {
+        if (isValidDuration(explicitEnterDuration)) {
+          setTimeout(cb, explicitEnterDuration);
+        } else {
+          whenTransitionEnds(el, type, cb);
+        }
+      }
+    });
+  }
+
+  if (vnode.data.show) {
+    toggleDisplay && toggleDisplay();
+    enterHook && enterHook(el, cb);
+  }
+
+  if (!expectsCSS && !userWantsControl) {
+    cb();
+  }
+}
+
+function leave (vnode, rm) {
+  var el = vnode.elm;
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true;
+    el._enterCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return rm()
+  }
+
+  /* istanbul ignore if */
+  if (el._leaveCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var leaveClass = data.leaveClass;
+  var leaveToClass = data.leaveToClass;
+  var leaveActiveClass = data.leaveActiveClass;
+  var beforeLeave = data.beforeLeave;
+  var leave = data.leave;
+  var afterLeave = data.afterLeave;
+  var leaveCancelled = data.leaveCancelled;
+  var delayLeave = data.delayLeave;
+  var duration = data.duration;
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(leave);
+
+  var explicitLeaveDuration = toNumber(
+    isObject(duration)
+      ? duration.leave
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
+    checkDuration(explicitLeaveDuration, 'leave', vnode);
+  }
+
+  var cb = el._leaveCb = once(function () {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null;
+    }
+    if (expectsCSS) {
+      removeTransitionClass(el, leaveToClass);
+      removeTransitionClass(el, leaveActiveClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, leaveClass);
+      }
+      leaveCancelled && leaveCancelled(el);
+    } else {
+      rm();
+      afterLeave && afterLeave(el);
+    }
+    el._leaveCb = null;
+  });
+
+  if (delayLeave) {
+    delayLeave(performLeave);
+  } else {
+    performLeave();
+  }
+
+  function performLeave () {
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
+    }
+    beforeLeave && beforeLeave(el);
+    if (expectsCSS) {
+      addTransitionClass(el, leaveClass);
+      addTransitionClass(el, leaveActiveClass);
+      nextFrame(function () {
+        addTransitionClass(el, leaveToClass);
+        removeTransitionClass(el, leaveClass);
+        if (!cb.cancelled && !userWantsControl) {
+          if (isValidDuration(explicitLeaveDuration)) {
+            setTimeout(cb, explicitLeaveDuration);
+          } else {
+            whenTransitionEnds(el, type, cb);
+          }
+        }
+      });
+    }
+    leave && leave(el, cb);
+    if (!expectsCSS && !userWantsControl) {
+      cb();
+    }
+  }
+}
+
+// only used in dev mode
+function checkDuration (val, name, vnode) {
+  if (typeof val !== 'number') {
+    warn(
+      "<transition> explicit " + name + " duration is not a valid number - " +
+      "got " + (JSON.stringify(val)) + ".",
+      vnode.context
+    );
+  } else if (isNaN(val)) {
+    warn(
+      "<transition> explicit " + name + " duration is NaN - " +
+      'the duration expression might be incorrect.',
+      vnode.context
+    );
+  }
+}
+
+function isValidDuration (val) {
+  return typeof val === 'number' && !isNaN(val)
+}
+
+/**
+ * Normalize a transition hook's argument length. The hook may be:
+ * - a merged hook (invoker) with the original in .fns
+ * - a wrapped component method (check ._length)
+ * - a plain function (.length)
+ */
+function getHookArgumentsLength (fn) {
+  if (!fn) { return false }
+  var invokerFns = fn.fns;
+  if (invokerFns) {
+    // invoker
+    return getHookArgumentsLength(
+      Array.isArray(invokerFns)
+        ? invokerFns[0]
+        : invokerFns
+    )
+  } else {
+    return (fn._length || fn.length) > 1
+  }
+}
+
+function _enter (_, vnode) {
+  if (!vnode.data.show) {
+    enter(vnode);
+  }
+}
+
+var transition = inBrowser ? {
+  create: _enter,
+  activate: _enter,
+  remove: function remove$$1 (vnode, rm) {
+    /* istanbul ignore else */
+    if (!vnode.data.show) {
+      leave(vnode, rm);
+    } else {
+      rm();
+    }
+  }
+} : {};
+
+var platformModules = [
+  attrs,
+  klass,
+  events,
+  domProps,
+  style,
+  transition
+];
+
+/*  */
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+var modules = platformModules.concat(baseModules);
+
+var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
+
+/**
+ * Not type checking this file because flow doesn't like attaching
+ * properties to Elements.
+ */
+
+/* istanbul ignore if */
+if (isIE9) {
+  // http://www.matts411.com/post/internet-explorer-9-oninput/
+  document.addEventListener('selectionchange', function () {
+    var el = document.activeElement;
+    if (el && el.vmodel) {
+      trigger(el, 'input');
+    }
+  });
+}
+
+var model$1 = {
+  inserted: function inserted (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      var cb = function () {
+        setSelected(el, binding, vnode.context);
+      };
+      cb();
+      /* istanbul ignore if */
+      if (isIE || isEdge) {
+        setTimeout(cb, 0);
+      }
+    } else if (vnode.tag === 'textarea' || el.type === 'text') {
+      el._vModifiers = binding.modifiers;
+      if (!binding.modifiers.lazy) {
+        if (!isAndroid) {
+          el.addEventListener('compositionstart', onCompositionStart);
+          el.addEventListener('compositionend', onCompositionEnd);
+        }
+        /* istanbul ignore if */
+        if (isIE9) {
+          el.vmodel = true;
+        }
+      }
+    }
+  },
+  componentUpdated: function componentUpdated (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      setSelected(el, binding, vnode.context);
+      // in case the options rendered by v-for have changed,
+      // it's possible that the value is out-of-sync with the rendered options.
+      // detect such cases and filter out values that no longer has a matching
+      // option in the DOM.
+      var needReset = el.multiple
+        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
+        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
+      if (needReset) {
+        trigger(el, 'change');
+      }
+    }
+  }
+};
+
+function setSelected (el, binding, vm) {
+  var value = binding.value;
+  var isMultiple = el.multiple;
+  if (isMultiple && !Array.isArray(value)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
+      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
+      vm
+    );
+    return
+  }
+  var selected, option;
+  for (var i = 0, l = el.options.length; i < l; i++) {
+    option = el.options[i];
+    if (isMultiple) {
+      selected = looseIndexOf(value, getValue(option)) > -1;
+      if (option.selected !== selected) {
+        option.selected = selected;
+      }
+    } else {
+      if (looseEqual(getValue(option), value)) {
+        if (el.selectedIndex !== i) {
+          el.selectedIndex = i;
+        }
+        return
+      }
+    }
+  }
+  if (!isMultiple) {
+    el.selectedIndex = -1;
+  }
+}
+
+function hasNoMatchingOption (value, options) {
+  for (var i = 0, l = options.length; i < l; i++) {
+    if (looseEqual(getValue(options[i]), value)) {
+      return false
+    }
+  }
+  return true
+}
+
+function getValue (option) {
+  return '_value' in option
+    ? option._value
+    : option.value
+}
+
+function onCompositionStart (e) {
+  e.target.composing = true;
+}
+
+function onCompositionEnd (e) {
+  e.target.composing = false;
+  trigger(e.target, 'input');
+}
+
+function trigger (el, type) {
+  var e = document.createEvent('HTMLEvents');
+  e.initEvent(type, true, true);
+  el.dispatchEvent(e);
+}
+
+/*  */
+
+// recursively search for possible transition defined inside the component root
+function locateNode (vnode) {
+  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
+    ? locateNode(vnode.componentInstance._vnode)
+    : vnode
+}
+
+var show = {
+  bind: function bind (el, ref, vnode) {
+    var value = ref.value;
+
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    var originalDisplay = el.__vOriginalDisplay =
+      el.style.display === 'none' ? '' : el.style.display;
+    if (value && transition && !isIE9) {
+      vnode.data.show = true;
+      enter(vnode, function () {
+        el.style.display = originalDisplay;
+      });
+    } else {
+      el.style.display = value ? originalDisplay : 'none';
+    }
+  },
+
+  update: function update (el, ref, vnode) {
+    var value = ref.value;
+    var oldValue = ref.oldValue;
+
+    /* istanbul ignore if */
+    if (value === oldValue) { return }
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    if (transition && !isIE9) {
+      vnode.data.show = true;
+      if (value) {
+        enter(vnode, function () {
+          el.style.display = el.__vOriginalDisplay;
+        });
+      } else {
+        leave(vnode, function () {
+          el.style.display = 'none';
+        });
+      }
+    } else {
+      el.style.display = value ? el.__vOriginalDisplay : 'none';
+    }
+  },
+
+  unbind: function unbind (
+    el,
+    binding,
+    vnode,
+    oldVnode,
+    isDestroy
+  ) {
+    if (!isDestroy) {
+      el.style.display = el.__vOriginalDisplay;
+    }
+  }
+};
+
+var platformDirectives = {
+  model: model$1,
+  show: show
+};
+
+/*  */
+
+// Provides transition support for a single element/component.
+// supports transition mode (out-in / in-out)
+
+var transitionProps = {
+  name: String,
+  appear: Boolean,
+  css: Boolean,
+  mode: String,
+  type: String,
+  enterClass: String,
+  leaveClass: String,
+  enterToClass: String,
+  leaveToClass: String,
+  enterActiveClass: String,
+  leaveActiveClass: String,
+  appearClass: String,
+  appearActiveClass: String,
+  appearToClass: String,
+  duration: [Number, String, Object]
+};
+
+// in case the child is also an abstract component, e.g. <keep-alive>
+// we want to recursively retrieve the real component to be rendered
+function getRealChild (vnode) {
+  var compOptions = vnode && vnode.componentOptions;
+  if (compOptions && compOptions.Ctor.options.abstract) {
+    return getRealChild(getFirstComponentChild(compOptions.children))
+  } else {
+    return vnode
+  }
+}
+
+function extractTransitionData (comp) {
+  var data = {};
+  var options = comp.$options;
+  // props
+  for (var key in options.propsData) {
+    data[key] = comp[key];
+  }
+  // events.
+  // extract listeners and pass them directly to the transition methods
+  var listeners = options._parentListeners;
+  for (var key$1 in listeners) {
+    data[camelize(key$1)] = listeners[key$1];
+  }
+  return data
+}
+
+function placeholder (h, rawChild) {
+  return /\d-keep-alive$/.test(rawChild.tag)
+    ? h('keep-alive')
+    : null
+}
+
+function hasParentTransition (vnode) {
+  while ((vnode = vnode.parent)) {
+    if (vnode.data.transition) {
+      return true
+    }
+  }
+}
+
+function isSameChild (child, oldChild) {
+  return oldChild.key === child.key && oldChild.tag === child.tag
+}
+
+var Transition = {
+  name: 'transition',
+  props: transitionProps,
+  abstract: true,
+
+  render: function render (h) {
+    var this$1 = this;
+
+    var children = this.$slots.default;
+    if (!children) {
+      return
+    }
+
+    // filter out text nodes (possible whitespaces)
+    children = children.filter(function (c) { return c.tag; });
+    /* istanbul ignore if */
+    if (!children.length) {
+      return
+    }
+
+    // warn multiple elements
+    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
+      warn(
+        '<transition> can only be used on a single element. Use ' +
+        '<transition-group> for lists.',
+        this.$parent
+      );
+    }
+
+    var mode = this.mode;
+
+    // warn invalid mode
+    if (process.env.NODE_ENV !== 'production' &&
+        mode && mode !== 'in-out' && mode !== 'out-in') {
+      warn(
+        'invalid <transition> mode: ' + mode,
+        this.$parent
+      );
+    }
+
+    var rawChild = children[0];
+
+    // if this is a component root node and the component's
+    // parent container node also has transition, skip.
+    if (hasParentTransition(this.$vnode)) {
+      return rawChild
+    }
+
+    // apply transition data to child
+    // use getRealChild() to ignore abstract components e.g. keep-alive
+    var child = getRealChild(rawChild);
+    /* istanbul ignore if */
+    if (!child) {
+      return rawChild
+    }
+
+    if (this._leaving) {
+      return placeholder(h, rawChild)
+    }
+
+    // ensure a key that is unique to the vnode type and to this transition
+    // component instance. This key will be used to remove pending leaving nodes
+    // during entering.
+    var id = "__transition-" + (this._uid) + "-";
+    child.key = child.key == null
+      ? id + child.tag
+      : isPrimitive(child.key)
+        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
+        : child.key;
+
+    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
+    var oldRawChild = this._vnode;
+    var oldChild = getRealChild(oldRawChild);
+
+    // mark v-show
+    // so that the transition module can hand over the control to the directive
+    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
+      child.data.show = true;
+    }
+
+    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
+      // replace old child transition data with fresh one
+      // important for dynamic transitions!
+      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
+      // handle transition mode
+      if (mode === 'out-in') {
+        // return placeholder node and queue update when leave finishes
+        this._leaving = true;
+        mergeVNodeHook(oldData, 'afterLeave', function () {
+          this$1._leaving = false;
+          this$1.$forceUpdate();
+        });
+        return placeholder(h, rawChild)
+      } else if (mode === 'in-out') {
+        var delayedLeave;
+        var performLeave = function () { delayedLeave(); };
+        mergeVNodeHook(data, 'afterEnter', performLeave);
+        mergeVNodeHook(data, 'enterCancelled', performLeave);
+        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
+      }
+    }
+
+    return rawChild
+  }
+};
+
+/*  */
+
+// Provides transition support for list items.
+// supports move transitions using the FLIP technique.
+
+// Because the vdom's children update algorithm is "unstable" - i.e.
+// it doesn't guarantee the relative positioning of removed elements,
+// we force transition-group to update its children into two passes:
+// in the first pass, we remove all nodes that need to be removed,
+// triggering their leaving transition; in the second pass, we insert/move
+// into the final desired state. This way in the second pass removed
+// nodes will remain where they should be.
+
+var props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps);
+
+delete props.mode;
+
+var TransitionGroup = {
+  props: props,
+
+  render: function render (h) {
+    var tag = this.tag || this.$vnode.data.tag || 'span';
+    var map = Object.create(null);
+    var prevChildren = this.prevChildren = this.children;
+    var rawChildren = this.$slots.default || [];
+    var children = this.children = [];
+    var transitionData = extractTransitionData(this);
+
+    for (var i = 0; i < rawChildren.length; i++) {
+      var c = rawChildren[i];
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c);
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData;
+        } else if (process.env.NODE_ENV !== 'production') {
+          var opts = c.componentOptions;
+          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
+          warn(("<transition-group> children must be keyed: <" + name + ">"));
+        }
+      }
+    }
+
+    if (prevChildren) {
+      var kept = [];
+      var removed = [];
+      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
+        var c$1 = prevChildren[i$1];
+        c$1.data.transition = transitionData;
+        c$1.data.pos = c$1.elm.getBoundingClientRect();
+        if (map[c$1.key]) {
+          kept.push(c$1);
+        } else {
+          removed.push(c$1);
+        }
+      }
+      this.kept = h(tag, null, kept);
+      this.removed = removed;
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate: function beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    );
+    this._vnode = this.kept;
+  },
+
+  updated: function updated () {
+    var children = this.prevChildren;
+    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
+    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
+      return
+    }
+
+    // we divide the work into three loops to avoid mixing DOM reads and writes
+    // in each iteration - which helps prevent layout thrashing.
+    children.forEach(callPendingCbs);
+    children.forEach(recordPosition);
+    children.forEach(applyTranslation);
+
+    // force reflow to put everything in position
+    var body = document.body;
+    var f = body.offsetHeight; // eslint-disable-line
+
+    children.forEach(function (c) {
+      if (c.data.moved) {
+        var el = c.elm;
+        var s = el.style;
+        addTransitionClass(el, moveClass);
+        s.transform = s.WebkitTransform = s.transitionDuration = '';
+        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
+          if (!e || /transform$/.test(e.propertyName)) {
+            el.removeEventListener(transitionEndEvent, cb);
+            el._moveCb = null;
+            removeTransitionClass(el, moveClass);
+          }
+        });
+      }
+    });
+  },
+
+  methods: {
+    hasMove: function hasMove (el, moveClass) {
+      /* istanbul ignore if */
+      if (!hasTransition) {
+        return false
+      }
+      if (this._hasMove != null) {
+        return this._hasMove
+      }
+      // Detect whether an element with the move class applied has
+      // CSS transitions. Since the element may be inside an entering
+      // transition at this very moment, we make a clone of it and remove
+      // all other transition classes applied to ensure only the move class
+      // is applied.
+      var clone = el.cloneNode();
+      if (el._transitionClasses) {
+        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
+      }
+      addClass(clone, moveClass);
+      clone.style.display = 'none';
+      this.$el.appendChild(clone);
+      var info = getTransitionInfo(clone);
+      this.$el.removeChild(clone);
+      return (this._hasMove = info.hasTransform)
+    }
+  }
+};
+
+function callPendingCbs (c) {
+  /* istanbul ignore if */
+  if (c.elm._moveCb) {
+    c.elm._moveCb();
+  }
+  /* istanbul ignore if */
+  if (c.elm._enterCb) {
+    c.elm._enterCb();
+  }
+}
+
+function recordPosition (c) {
+  c.data.newPos = c.elm.getBoundingClientRect();
+}
+
+function applyTranslation (c) {
+  var oldPos = c.data.pos;
+  var newPos = c.data.newPos;
+  var dx = oldPos.left - newPos.left;
+  var dy = oldPos.top - newPos.top;
+  if (dx || dy) {
+    c.data.moved = true;
+    var s = c.elm.style;
+    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
+    s.transitionDuration = '0s';
+  }
+}
+
+var platformComponents = {
+  Transition: Transition,
+  TransitionGroup: TransitionGroup
+};
+
+/*  */
+
+// install platform specific utils
+Vue$2.config.mustUseProp = mustUseProp;
+Vue$2.config.isReservedTag = isReservedTag;
+Vue$2.config.getTagNamespace = getTagNamespace;
+Vue$2.config.isUnknownElement = isUnknownElement;
+
+// install platform runtime directives & components
+extend(Vue$2.options.directives, platformDirectives);
+extend(Vue$2.options.components, platformComponents);
+
+// install platform patch function
+Vue$2.prototype.__patch__ = inBrowser ? patch : noop;
+
+// public mount method
+Vue$2.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && inBrowser ? query(el) : undefined;
+  return mountComponent(this, el, hydrating)
+};
+
+// devtools global hook
+/* istanbul ignore next */
+setTimeout(function () {
+  if (config.devtools) {
+    if (devtools) {
+      devtools.emit('init', Vue$2);
+    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
+      console[console.info ? 'info' : 'log'](
+        'Download the Vue Devtools extension for a better development experience:\n' +
+        'https://github.com/vuejs/vue-devtools'
+      );
+    }
+  }
+  if (process.env.NODE_ENV !== 'production' &&
+      config.productionTip !== false &&
+      inBrowser && typeof console !== 'undefined') {
+    console[console.info ? 'info' : 'log'](
+      "You are running Vue in development mode.\n" +
+      "Make sure to turn on production mode when deploying for production.\n" +
+      "See more tips at https://vuejs.org/guide/deployment.html"
+    );
+  }
+}, 0);
+
+export default Vue$2;
Index: public/node_modules/vue-resource/test/promise.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/promise.js	(revision )
+++ public/node_modules/vue-resource/test/promise.js	(revision )
@@ -0,0 +1,125 @@
+import Promise from '../src/promise';
+
+describe('Vue.promise ' + (window.Promise !== undefined ? '(native)' : '(polyfill)'), function () {
+
+    it('then fulfill', function (done) {
+
+        Promise.resolve(1).then(function (value) {
+            expect(value).toBe(1);
+            done();
+        });
+
+    });
+
+    it('then reject', function (done) {
+
+        Promise.reject(1).then(undefined, function (value) {
+            expect(value).toBe(1);
+            done();
+        });
+
+    });
+
+    it('catch', function (done) {
+
+        Promise.reject(1).catch(function (value) {
+            expect(value).toBe(1);
+            done();
+        });
+
+    });
+
+    it('finally fulfill', function (done) {
+
+        Promise.resolve(1).finally(function (arg) {
+            expect(arg).toBe(undefined);
+        }).then(function (arg) {
+            expect(arg).toBe(1);
+            done();
+        });
+
+    });
+
+    it('finally reject', function (done) {
+
+        Promise.reject(1).finally(function (arg) {
+            expect(arg).toBe(undefined);
+        }).catch(function (arg) {
+            expect(arg).toBe(1);
+            done();
+        });
+
+    });
+
+    it('all', function (done) {
+
+        Promise.all([
+
+            Promise.resolve(1),
+            Promise.resolve(2)
+
+        ]).then(function (values) {
+            expect(values[0]).toBe(1);
+            expect(values[1]).toBe(2);
+            done();
+        });
+
+    });
+
+    it('duplicate', function (done) {
+
+        Promise.all([
+
+            Promise.resolve(1).then(function (value) {
+                expect(value).toBe(1);
+            }),
+
+            Promise.resolve(2).then(function (value) {
+                expect(value).toBe(2);
+            })
+
+        ]).then(done);
+
+    });
+
+    it('context', function (done) {
+
+        var context = {foo: 'bar'};
+
+        Promise.resolve().bind(context).then(function () {
+            expect(this).toBe(context);
+            done();
+        });
+
+    });
+
+    it('context chain fulfill', function (done) {
+
+        var context = {foo: 'bar'};
+
+        Promise.resolve().bind(context).catch(undefined).finally(function () {
+            expect(this).toBe(context);
+        }).then(function () {
+            expect(this).toBe(context);
+            done();
+        });
+
+    });
+
+    it('context chain reject', function (done) {
+
+        var context = {foo: 'bar'};
+
+        Promise.reject().bind(context).catch(function () {
+            expect(this).toBe(context);
+            return Promise.reject();
+        }).finally(function () {
+            expect(this).toBe(context);
+        }).catch(function () {
+            expect(this).toBe(context);
+            done();
+        });
+
+    });
+
+});
Index: public/node_modules/vue-select2/.coveralls.yml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/.coveralls.yml	(revision )
+++ public/node_modules/vue-select2/.coveralls.yml	(revision )
@@ -0,0 +1,1 @@
+repo_token: fv7fpdRYNi8lFMhWQ9Ce9chRxyMrNa1ey
\ No newline at end of file
Index: public/node_modules/vue/src/core/instance/state.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/state.js	(revision )
+++ public/node_modules/vue/src/core/instance/state.js	(revision )
@@ -0,0 +1,274 @@
+/* @flow */
+
+import Dep from '../observer/dep'
+import Watcher from '../observer/watcher'
+
+import {
+  set,
+  del,
+  observe,
+  defineReactive,
+  observerState
+} from '../observer/index'
+
+import {
+  warn,
+  hasOwn,
+  isReserved,
+  isPlainObject,
+  bind,
+  validateProp,
+  noop
+} from '../util/index'
+
+const sharedPropertyDefinition = {
+  enumerable: true,
+  configurable: true,
+  get: noop,
+  set: noop
+}
+
+export function proxy (target: Object, sourceKey: string, key: string) {
+  sharedPropertyDefinition.get = function proxyGetter () {
+    return this[sourceKey][key]
+  }
+  sharedPropertyDefinition.set = function proxySetter (val) {
+    this[sourceKey][key] = val
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition)
+}
+
+export function initState (vm: Component) {
+  vm._watchers = []
+  const opts = vm.$options
+  if (opts.props) initProps(vm, opts.props)
+  if (opts.methods) initMethods(vm, opts.methods)
+  if (opts.data) {
+    initData(vm)
+  } else {
+    observe(vm._data = {}, true /* asRootData */)
+  }
+  if (opts.computed) initComputed(vm, opts.computed)
+  if (opts.watch) initWatch(vm, opts.watch)
+}
+
+const isReservedProp = { key: 1, ref: 1, slot: 1 }
+
+function initProps (vm: Component, propsOptions: Object) {
+  const propsData = vm.$options.propsData || {}
+  const props = vm._props = {}
+  // cache prop keys so that future props updates can iterate using Array
+  // instead of dynamic object key enumeration.
+  const keys = vm.$options._propKeys = []
+  const isRoot = !vm.$parent
+  // root instance props should be converted
+  observerState.shouldConvert = isRoot
+  for (const key in propsOptions) {
+    keys.push(key)
+    const value = validateProp(key, propsOptions, propsData, vm)
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      if (isReservedProp[key]) {
+        warn(
+          `"${key}" is a reserved attribute and cannot be used as component prop.`,
+          vm
+        )
+      }
+      defineReactive(props, key, value, () => {
+        if (vm.$parent && !observerState.isSettingProps) {
+          warn(
+            `Avoid mutating a prop directly since the value will be ` +
+            `overwritten whenever the parent component re-renders. ` +
+            `Instead, use a data or computed property based on the prop's ` +
+            `value. Prop being mutated: "${key}"`,
+            vm
+          )
+        }
+      })
+    } else {
+      defineReactive(props, key, value)
+    }
+    // static props are already proxied on the component's prototype
+    // during Vue.extend(). We only need to proxy props defined at
+    // instantiation here.
+    if (!(key in vm)) {
+      proxy(vm, `_props`, key)
+    }
+  }
+  observerState.shouldConvert = true
+}
+
+function initData (vm: Component) {
+  let data = vm.$options.data
+  data = vm._data = typeof data === 'function'
+    ? data.call(vm)
+    : data || {}
+  if (!isPlainObject(data)) {
+    data = {}
+    process.env.NODE_ENV !== 'production' && warn(
+      'data functions should return an object:\n' +
+      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
+      vm
+    )
+  }
+  // proxy data on instance
+  const keys = Object.keys(data)
+  const props = vm.$options.props
+  let i = keys.length
+  while (i--) {
+    if (props && hasOwn(props, keys[i])) {
+      process.env.NODE_ENV !== 'production' && warn(
+        `The data property "${keys[i]}" is already declared as a prop. ` +
+        `Use prop default value instead.`,
+        vm
+      )
+    } else if (!isReserved(keys[i])) {
+      proxy(vm, `_data`, keys[i])
+    }
+  }
+  // observe data
+  observe(data, true /* asRootData */)
+}
+
+const computedWatcherOptions = { lazy: true }
+
+function initComputed (vm: Component, computed: Object) {
+  const watchers = vm._computedWatchers = Object.create(null)
+
+  for (const key in computed) {
+    const userDef = computed[key]
+    const getter = typeof userDef === 'function' ? userDef : userDef.get
+    // create internal watcher for the computed property.
+    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions)
+
+    // component-defined computed properties are already defined on the
+    // component prototype. We only need to define computed properties defined
+    // at instantiation here.
+    if (!(key in vm)) {
+      defineComputed(vm, key, userDef)
+    }
+  }
+}
+
+export function defineComputed (target: any, key: string, userDef: Object | Function) {
+  if (typeof userDef === 'function') {
+    sharedPropertyDefinition.get = createComputedGetter(key)
+    sharedPropertyDefinition.set = noop
+  } else {
+    sharedPropertyDefinition.get = userDef.get
+      ? userDef.cache !== false
+        ? createComputedGetter(key)
+        : userDef.get
+      : noop
+    sharedPropertyDefinition.set = userDef.set
+      ? userDef.set
+      : noop
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition)
+}
+
+function createComputedGetter (key) {
+  return function computedGetter () {
+    const watcher = this._computedWatchers && this._computedWatchers[key]
+    if (watcher) {
+      if (watcher.dirty) {
+        watcher.evaluate()
+      }
+      if (Dep.target) {
+        watcher.depend()
+      }
+      return watcher.value
+    }
+  }
+}
+
+function initMethods (vm: Component, methods: Object) {
+  const props = vm.$options.props
+  for (const key in methods) {
+    vm[key] = methods[key] == null ? noop : bind(methods[key], vm)
+    if (process.env.NODE_ENV !== 'production') {
+      if (methods[key] == null) {
+        warn(
+          `method "${key}" has an undefined value in the component definition. ` +
+          `Did you reference the function correctly?`,
+          vm
+        )
+      }
+      if (props && hasOwn(props, key)) {
+        warn(
+          `method "${key}" has already been defined as a prop.`,
+          vm
+        )
+      }
+    }
+  }
+}
+
+function initWatch (vm: Component, watch: Object) {
+  for (const key in watch) {
+    const handler = watch[key]
+    if (Array.isArray(handler)) {
+      for (let i = 0; i < handler.length; i++) {
+        createWatcher(vm, key, handler[i])
+      }
+    } else {
+      createWatcher(vm, key, handler)
+    }
+  }
+}
+
+function createWatcher (vm: Component, key: string, handler: any) {
+  let options
+  if (isPlainObject(handler)) {
+    options = handler
+    handler = handler.handler
+  }
+  if (typeof handler === 'string') {
+    handler = vm[handler]
+  }
+  vm.$watch(key, handler, options)
+}
+
+export function stateMixin (Vue: Class<Component>) {
+  // flow somehow has problems with directly declared definition object
+  // when using Object.defineProperty, so we have to procedurally build up
+  // the object here.
+  const dataDef = {}
+  dataDef.get = function () { return this._data }
+  const propsDef = {}
+  propsDef.get = function () { return this._props }
+  if (process.env.NODE_ENV !== 'production') {
+    dataDef.set = function (newData: Object) {
+      warn(
+        'Avoid replacing instance root $data. ' +
+        'Use nested data properties instead.',
+        this
+      )
+    }
+    propsDef.set = function () {
+      warn(`$props is readonly.`, this)
+    }
+  }
+  Object.defineProperty(Vue.prototype, '$data', dataDef)
+  Object.defineProperty(Vue.prototype, '$props', propsDef)
+
+  Vue.prototype.$set = set
+  Vue.prototype.$delete = del
+
+  Vue.prototype.$watch = function (
+    expOrFn: string | Function,
+    cb: Function,
+    options?: Object
+  ): Function {
+    const vm: Component = this
+    options = options || {}
+    options.user = true
+    const watcher = new Watcher(vm, expOrFn, cb, options)
+    if (options.immediate) {
+      cb.call(vm, watcher.value)
+    }
+    return function unwatchFn () {
+      watcher.teardown()
+    }
+  }
+}
Index: public/node_modules/vue/dist/vue.runtime.common.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.runtime.common.js	(revision )
+++ public/node_modules/vue/dist/vue.runtime.common.js	(revision )
@@ -0,0 +1,6723 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+'use strict';
+
+/*  */
+
+/**
+ * Convert a value to a string that is actually rendered.
+ */
+function _toString (val) {
+  return val == null
+    ? ''
+    : typeof val === 'object'
+      ? JSON.stringify(val, null, 2)
+      : String(val)
+}
+
+/**
+ * Convert a input value to a number for persistence.
+ * If the conversion fails, return original string.
+ */
+function toNumber (val) {
+  var n = parseFloat(val);
+  return isNaN(n) ? val : n
+}
+
+/**
+ * Make a map and return a function for checking if a key
+ * is in that map.
+ */
+function makeMap (
+  str,
+  expectsLowerCase
+) {
+  var map = Object.create(null);
+  var list = str.split(',');
+  for (var i = 0; i < list.length; i++) {
+    map[list[i]] = true;
+  }
+  return expectsLowerCase
+    ? function (val) { return map[val.toLowerCase()]; }
+    : function (val) { return map[val]; }
+}
+
+/**
+ * Check if a tag is a built-in tag.
+ */
+var isBuiltInTag = makeMap('slot,component', true);
+
+/**
+ * Remove an item from an array
+ */
+function remove (arr, item) {
+  if (arr.length) {
+    var index = arr.indexOf(item);
+    if (index > -1) {
+      return arr.splice(index, 1)
+    }
+  }
+}
+
+/**
+ * Check whether the object has the property.
+ */
+var hasOwnProperty = Object.prototype.hasOwnProperty;
+function hasOwn (obj, key) {
+  return hasOwnProperty.call(obj, key)
+}
+
+/**
+ * Check if value is primitive
+ */
+function isPrimitive (value) {
+  return typeof value === 'string' || typeof value === 'number'
+}
+
+/**
+ * Create a cached version of a pure function.
+ */
+function cached (fn) {
+  var cache = Object.create(null);
+  return (function cachedFn (str) {
+    var hit = cache[str];
+    return hit || (cache[str] = fn(str))
+  })
+}
+
+/**
+ * Camelize a hyphen-delimited string.
+ */
+var camelizeRE = /-(\w)/g;
+var camelize = cached(function (str) {
+  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
+});
+
+/**
+ * Capitalize a string.
+ */
+var capitalize = cached(function (str) {
+  return str.charAt(0).toUpperCase() + str.slice(1)
+});
+
+/**
+ * Hyphenate a camelCase string.
+ */
+var hyphenateRE = /([^-])([A-Z])/g;
+var hyphenate = cached(function (str) {
+  return str
+    .replace(hyphenateRE, '$1-$2')
+    .replace(hyphenateRE, '$1-$2')
+    .toLowerCase()
+});
+
+/**
+ * Simple bind, faster than native
+ */
+function bind (fn, ctx) {
+  function boundFn (a) {
+    var l = arguments.length;
+    return l
+      ? l > 1
+        ? fn.apply(ctx, arguments)
+        : fn.call(ctx, a)
+      : fn.call(ctx)
+  }
+  // record original fn length
+  boundFn._length = fn.length;
+  return boundFn
+}
+
+/**
+ * Convert an Array-like object to a real Array.
+ */
+function toArray (list, start) {
+  start = start || 0;
+  var i = list.length - start;
+  var ret = new Array(i);
+  while (i--) {
+    ret[i] = list[i + start];
+  }
+  return ret
+}
+
+/**
+ * Mix properties into target object.
+ */
+function extend (to, _from) {
+  for (var key in _from) {
+    to[key] = _from[key];
+  }
+  return to
+}
+
+/**
+ * Quick object check - this is primarily used to tell
+ * Objects from primitive values when we know the value
+ * is a JSON-compliant type.
+ */
+function isObject (obj) {
+  return obj !== null && typeof obj === 'object'
+}
+
+/**
+ * Strict object type check. Only returns true
+ * for plain JavaScript objects.
+ */
+var toString = Object.prototype.toString;
+var OBJECT_STRING = '[object Object]';
+function isPlainObject (obj) {
+  return toString.call(obj) === OBJECT_STRING
+}
+
+/**
+ * Merge an Array of Objects into a single Object.
+ */
+function toObject (arr) {
+  var res = {};
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i]);
+    }
+  }
+  return res
+}
+
+/**
+ * Perform no operation.
+ */
+function noop () {}
+
+/**
+ * Always return false.
+ */
+var no = function () { return false; };
+
+/**
+ * Return same value
+ */
+var identity = function (_) { return _; };
+
+/**
+ * Generate a static keys string from compiler modules.
+ */
+
+
+/**
+ * Check if two values are loosely equal - that is,
+ * if they are plain objects, do they have the same shape?
+ */
+function looseEqual (a, b) {
+  var isObjectA = isObject(a);
+  var isObjectB = isObject(b);
+  if (isObjectA && isObjectB) {
+    try {
+      return JSON.stringify(a) === JSON.stringify(b)
+    } catch (e) {
+      // possible circular reference
+      return a === b
+    }
+  } else if (!isObjectA && !isObjectB) {
+    return String(a) === String(b)
+  } else {
+    return false
+  }
+}
+
+function looseIndexOf (arr, val) {
+  for (var i = 0; i < arr.length; i++) {
+    if (looseEqual(arr[i], val)) { return i }
+  }
+  return -1
+}
+
+/**
+ * Ensure a function is called only once.
+ */
+function once (fn) {
+  var called = false;
+  return function () {
+    if (!called) {
+      called = true;
+      fn();
+    }
+  }
+}
+
+/*  */
+
+var config = {
+  /**
+   * Option merge strategies (used in core/util/options)
+   */
+  optionMergeStrategies: Object.create(null),
+
+  /**
+   * Whether to suppress warnings.
+   */
+  silent: false,
+
+  /**
+   * Show production mode tip message on boot?
+   */
+  productionTip: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to enable devtools
+   */
+  devtools: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Whether to record perf
+   */
+  performance: process.env.NODE_ENV !== 'production',
+
+  /**
+   * Error handler for watcher errors
+   */
+  errorHandler: null,
+
+  /**
+   * Ignore certain custom elements
+   */
+  ignoredElements: [],
+
+  /**
+   * Custom user key aliases for v-on
+   */
+  keyCodes: Object.create(null),
+
+  /**
+   * Check if a tag is reserved so that it cannot be registered as a
+   * component. This is platform-dependent and may be overwritten.
+   */
+  isReservedTag: no,
+
+  /**
+   * Check if a tag is an unknown element.
+   * Platform-dependent.
+   */
+  isUnknownElement: no,
+
+  /**
+   * Get the namespace of an element
+   */
+  getTagNamespace: noop,
+
+  /**
+   * Parse the real tag name for the specific platform.
+   */
+  parsePlatformTagName: identity,
+
+  /**
+   * Check if an attribute must be bound using property, e.g. value
+   * Platform-dependent.
+   */
+  mustUseProp: no,
+
+  /**
+   * List of asset types that a component can own.
+   */
+  _assetTypes: [
+    'component',
+    'directive',
+    'filter'
+  ],
+
+  /**
+   * List of lifecycle hooks.
+   */
+  _lifecycleHooks: [
+    'beforeCreate',
+    'created',
+    'beforeMount',
+    'mounted',
+    'beforeUpdate',
+    'updated',
+    'beforeDestroy',
+    'destroyed',
+    'activated',
+    'deactivated'
+  ],
+
+  /**
+   * Max circular updates allowed in a scheduler flush cycle.
+   */
+  _maxUpdateCount: 100
+};
+
+/*  */
+/* globals MutationObserver */
+
+// can we use __proto__?
+var hasProto = '__proto__' in {};
+
+// Browser environment sniffing
+var inBrowser = typeof window !== 'undefined';
+var UA = inBrowser && window.navigator.userAgent.toLowerCase();
+var isIE = UA && /msie|trident/.test(UA);
+var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
+var isEdge = UA && UA.indexOf('edge/') > 0;
+var isAndroid = UA && UA.indexOf('android') > 0;
+var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);
+var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
+
+// this needs to be lazy-evaled because vue may be required before
+// vue-server-renderer can set VUE_ENV
+var _isServer;
+var isServerRendering = function () {
+  if (_isServer === undefined) {
+    /* istanbul ignore if */
+    if (!inBrowser && typeof global !== 'undefined') {
+      // detect presence of vue-server-renderer and avoid
+      // Webpack shimming the process
+      _isServer = global['process'].env.VUE_ENV === 'server';
+    } else {
+      _isServer = false;
+    }
+  }
+  return _isServer
+};
+
+// detect devtools
+var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
+
+/* istanbul ignore next */
+function isNative (Ctor) {
+  return /native code/.test(Ctor.toString())
+}
+
+var hasSymbol =
+  typeof Symbol !== 'undefined' && isNative(Symbol) &&
+  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);
+
+/**
+ * Defer a task to execute it asynchronously.
+ */
+var nextTick = (function () {
+  var callbacks = [];
+  var pending = false;
+  var timerFunc;
+
+  function nextTickHandler () {
+    pending = false;
+    var copies = callbacks.slice(0);
+    callbacks.length = 0;
+    for (var i = 0; i < copies.length; i++) {
+      copies[i]();
+    }
+  }
+
+  // the nextTick behavior leverages the microtask queue, which can be accessed
+  // via either native Promise.then or MutationObserver.
+  // MutationObserver has wider support, however it is seriously bugged in
+  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
+  // completely stops working after triggering a few times... so, if native
+  // Promise is available, we will use it:
+  /* istanbul ignore if */
+  if (typeof Promise !== 'undefined' && isNative(Promise)) {
+    var p = Promise.resolve();
+    var logError = function (err) { console.error(err); };
+    timerFunc = function () {
+      p.then(nextTickHandler).catch(logError);
+      // in problematic UIWebViews, Promise.then doesn't completely break, but
+      // it can get stuck in a weird state where callbacks are pushed into the
+      // microtask queue but the queue isn't being flushed, until the browser
+      // needs to do some other work, e.g. handle a timer. Therefore we can
+      // "force" the microtask queue to be flushed by adding an empty timer.
+      if (isIOS) { setTimeout(noop); }
+    };
+  } else if (typeof MutationObserver !== 'undefined' && (
+    isNative(MutationObserver) ||
+    // PhantomJS and iOS 7.x
+    MutationObserver.toString() === '[object MutationObserverConstructor]'
+  )) {
+    // use MutationObserver where native Promise is not available,
+    // e.g. PhantomJS IE11, iOS7, Android 4.4
+    var counter = 1;
+    var observer = new MutationObserver(nextTickHandler);
+    var textNode = document.createTextNode(String(counter));
+    observer.observe(textNode, {
+      characterData: true
+    });
+    timerFunc = function () {
+      counter = (counter + 1) % 2;
+      textNode.data = String(counter);
+    };
+  } else {
+    // fallback to setTimeout
+    /* istanbul ignore next */
+    timerFunc = function () {
+      setTimeout(nextTickHandler, 0);
+    };
+  }
+
+  return function queueNextTick (cb, ctx) {
+    var _resolve;
+    callbacks.push(function () {
+      if (cb) { cb.call(ctx); }
+      if (_resolve) { _resolve(ctx); }
+    });
+    if (!pending) {
+      pending = true;
+      timerFunc();
+    }
+    if (!cb && typeof Promise !== 'undefined') {
+      return new Promise(function (resolve) {
+        _resolve = resolve;
+      })
+    }
+  }
+})();
+
+var _Set;
+/* istanbul ignore if */
+if (typeof Set !== 'undefined' && isNative(Set)) {
+  // use native Set when available.
+  _Set = Set;
+} else {
+  // a non-standard Set polyfill that only works with primitive keys.
+  _Set = (function () {
+    function Set () {
+      this.set = Object.create(null);
+    }
+    Set.prototype.has = function has (key) {
+      return this.set[key] === true
+    };
+    Set.prototype.add = function add (key) {
+      this.set[key] = true;
+    };
+    Set.prototype.clear = function clear () {
+      this.set = Object.create(null);
+    };
+
+    return Set;
+  }());
+}
+
+var perf;
+
+if (process.env.NODE_ENV !== 'production') {
+  perf = inBrowser && window.performance;
+  if (perf && (!perf.mark || !perf.measure)) {
+    perf = undefined;
+  }
+}
+
+/*  */
+
+var emptyObject = Object.freeze({});
+
+/**
+ * Check if a string starts with $ or _
+ */
+function isReserved (str) {
+  var c = (str + '').charCodeAt(0);
+  return c === 0x24 || c === 0x5F
+}
+
+/**
+ * Define a property.
+ */
+function def (obj, key, val, enumerable) {
+  Object.defineProperty(obj, key, {
+    value: val,
+    enumerable: !!enumerable,
+    writable: true,
+    configurable: true
+  });
+}
+
+/**
+ * Parse simple path.
+ */
+var bailRE = /[^\w.$]/;
+function parsePath (path) {
+  if (bailRE.test(path)) {
+    return
+  }
+  var segments = path.split('.');
+  return function (obj) {
+    for (var i = 0; i < segments.length; i++) {
+      if (!obj) { return }
+      obj = obj[segments[i]];
+    }
+    return obj
+  }
+}
+
+var warn = noop;
+var tip = noop;
+var formatComponentName;
+
+if (process.env.NODE_ENV !== 'production') {
+  var hasConsole = typeof console !== 'undefined';
+  var classifyRE = /(?:^|[-_])(\w)/g;
+  var classify = function (str) { return str
+    .replace(classifyRE, function (c) { return c.toUpperCase(); })
+    .replace(/[-_]/g, ''); };
+
+  warn = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.error("[Vue warn]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  tip = function (msg, vm) {
+    if (hasConsole && (!config.silent)) {
+      console.warn("[Vue tip]: " + msg + " " + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ));
+    }
+  };
+
+  formatComponentName = function (vm, includeFile) {
+    if (vm.$root === vm) {
+      return '<Root>'
+    }
+    var name = vm._isVue
+      ? vm.$options.name || vm.$options._componentTag
+      : vm.name;
+
+    var file = vm._isVue && vm.$options.__file;
+    if (!name && file) {
+      var match = file.match(/([^/\\]+)\.vue$/);
+      name = match && match[1];
+    }
+
+    return (
+      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
+      (file && includeFile !== false ? (" at " + file) : '')
+    )
+  };
+
+  var formatLocation = function (str) {
+    if (str === "<Anonymous>") {
+      str += " - use the \"name\" option for better debugging messages.";
+    }
+    return ("\n(found in " + str + ")")
+  };
+}
+
+/*  */
+
+
+var uid$1 = 0;
+
+/**
+ * A dep is an observable that can have multiple
+ * directives subscribing to it.
+ */
+var Dep = function Dep () {
+  this.id = uid$1++;
+  this.subs = [];
+};
+
+Dep.prototype.addSub = function addSub (sub) {
+  this.subs.push(sub);
+};
+
+Dep.prototype.removeSub = function removeSub (sub) {
+  remove(this.subs, sub);
+};
+
+Dep.prototype.depend = function depend () {
+  if (Dep.target) {
+    Dep.target.addDep(this);
+  }
+};
+
+Dep.prototype.notify = function notify () {
+  // stabilize the subscriber list first
+  var subs = this.subs.slice();
+  for (var i = 0, l = subs.length; i < l; i++) {
+    subs[i].update();
+  }
+};
+
+// the current target watcher being evaluated.
+// this is globally unique because there could be only one
+// watcher being evaluated at any time.
+Dep.target = null;
+var targetStack = [];
+
+function pushTarget (_target) {
+  if (Dep.target) { targetStack.push(Dep.target); }
+  Dep.target = _target;
+}
+
+function popTarget () {
+  Dep.target = targetStack.pop();
+}
+
+/*
+ * not type checking this file because flow doesn't play well with
+ * dynamically accessing methods on Array prototype
+ */
+
+var arrayProto = Array.prototype;
+var arrayMethods = Object.create(arrayProto);[
+  'push',
+  'pop',
+  'shift',
+  'unshift',
+  'splice',
+  'sort',
+  'reverse'
+]
+.forEach(function (method) {
+  // cache original method
+  var original = arrayProto[method];
+  def(arrayMethods, method, function mutator () {
+    var arguments$1 = arguments;
+
+    // avoid leaking arguments:
+    // http://jsperf.com/closure-with-arguments
+    var i = arguments.length;
+    var args = new Array(i);
+    while (i--) {
+      args[i] = arguments$1[i];
+    }
+    var result = original.apply(this, args);
+    var ob = this.__ob__;
+    var inserted;
+    switch (method) {
+      case 'push':
+        inserted = args;
+        break
+      case 'unshift':
+        inserted = args;
+        break
+      case 'splice':
+        inserted = args.slice(2);
+        break
+    }
+    if (inserted) { ob.observeArray(inserted); }
+    // notify change
+    ob.dep.notify();
+    return result
+  });
+});
+
+/*  */
+
+var arrayKeys = Object.getOwnPropertyNames(arrayMethods);
+
+/**
+ * By default, when a reactive property is set, the new value is
+ * also converted to become reactive. However when passing down props,
+ * we don't want to force conversion because the value may be a nested value
+ * under a frozen data structure. Converting it would defeat the optimization.
+ */
+var observerState = {
+  shouldConvert: true,
+  isSettingProps: false
+};
+
+/**
+ * Observer class that are attached to each observed
+ * object. Once attached, the observer converts target
+ * object's property keys into getter/setters that
+ * collect dependencies and dispatches updates.
+ */
+var Observer = function Observer (value) {
+  this.value = value;
+  this.dep = new Dep();
+  this.vmCount = 0;
+  def(value, '__ob__', this);
+  if (Array.isArray(value)) {
+    var augment = hasProto
+      ? protoAugment
+      : copyAugment;
+    augment(value, arrayMethods, arrayKeys);
+    this.observeArray(value);
+  } else {
+    this.walk(value);
+  }
+};
+
+/**
+ * Walk through each property and convert them into
+ * getter/setters. This method should only be called when
+ * value type is Object.
+ */
+Observer.prototype.walk = function walk (obj) {
+  var keys = Object.keys(obj);
+  for (var i = 0; i < keys.length; i++) {
+    defineReactive$$1(obj, keys[i], obj[keys[i]]);
+  }
+};
+
+/**
+ * Observe a list of Array items.
+ */
+Observer.prototype.observeArray = function observeArray (items) {
+  for (var i = 0, l = items.length; i < l; i++) {
+    observe(items[i]);
+  }
+};
+
+// helpers
+
+/**
+ * Augment an target Object or Array by intercepting
+ * the prototype chain using __proto__
+ */
+function protoAugment (target, src) {
+  /* eslint-disable no-proto */
+  target.__proto__ = src;
+  /* eslint-enable no-proto */
+}
+
+/**
+ * Augment an target Object or Array by defining
+ * hidden properties.
+ */
+/* istanbul ignore next */
+function copyAugment (target, src, keys) {
+  for (var i = 0, l = keys.length; i < l; i++) {
+    var key = keys[i];
+    def(target, key, src[key]);
+  }
+}
+
+/**
+ * Attempt to create an observer instance for a value,
+ * returns the new observer if successfully observed,
+ * or the existing observer if the value already has one.
+ */
+function observe (value, asRootData) {
+  if (!isObject(value)) {
+    return
+  }
+  var ob;
+  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
+    ob = value.__ob__;
+  } else if (
+    observerState.shouldConvert &&
+    !isServerRendering() &&
+    (Array.isArray(value) || isPlainObject(value)) &&
+    Object.isExtensible(value) &&
+    !value._isVue
+  ) {
+    ob = new Observer(value);
+  }
+  if (asRootData && ob) {
+    ob.vmCount++;
+  }
+  return ob
+}
+
+/**
+ * Define a reactive property on an Object.
+ */
+function defineReactive$$1 (
+  obj,
+  key,
+  val,
+  customSetter
+) {
+  var dep = new Dep();
+
+  var property = Object.getOwnPropertyDescriptor(obj, key);
+  if (property && property.configurable === false) {
+    return
+  }
+
+  // cater for pre-defined getter/setters
+  var getter = property && property.get;
+  var setter = property && property.set;
+
+  var childOb = observe(val);
+  Object.defineProperty(obj, key, {
+    enumerable: true,
+    configurable: true,
+    get: function reactiveGetter () {
+      var value = getter ? getter.call(obj) : val;
+      if (Dep.target) {
+        dep.depend();
+        if (childOb) {
+          childOb.dep.depend();
+        }
+        if (Array.isArray(value)) {
+          dependArray(value);
+        }
+      }
+      return value
+    },
+    set: function reactiveSetter (newVal) {
+      var value = getter ? getter.call(obj) : val;
+      /* eslint-disable no-self-compare */
+      if (newVal === value || (newVal !== newVal && value !== value)) {
+        return
+      }
+      /* eslint-enable no-self-compare */
+      if (process.env.NODE_ENV !== 'production' && customSetter) {
+        customSetter();
+      }
+      if (setter) {
+        setter.call(obj, newVal);
+      } else {
+        val = newVal;
+      }
+      childOb = observe(newVal);
+      dep.notify();
+    }
+  });
+}
+
+/**
+ * Set a property on an object. Adds the new property and
+ * triggers change notification if the property doesn't
+ * already exist.
+ */
+function set (target, key, val) {
+  if (Array.isArray(target)) {
+    target.length = Math.max(target.length, key);
+    target.splice(key, 1, val);
+    return val
+  }
+  if (hasOwn(target, key)) {
+    target[key] = val;
+    return val
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid adding reactive properties to a Vue instance or its root $data ' +
+      'at runtime - declare it upfront in the data option.'
+    );
+    return val
+  }
+  if (!ob) {
+    target[key] = val;
+    return val
+  }
+  defineReactive$$1(ob.value, key, val);
+  ob.dep.notify();
+  return val
+}
+
+/**
+ * Delete a property and trigger change if necessary.
+ */
+function del (target, key) {
+  if (Array.isArray(target)) {
+    target.splice(key, 1);
+    return
+  }
+  var ob = target.__ob__;
+  if (target._isVue || (ob && ob.vmCount)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      'Avoid deleting properties on a Vue instance or its root $data ' +
+      '- just set it to null.'
+    );
+    return
+  }
+  if (!hasOwn(target, key)) {
+    return
+  }
+  delete target[key];
+  if (!ob) {
+    return
+  }
+  ob.dep.notify();
+}
+
+/**
+ * Collect dependencies on array elements when the array is touched, since
+ * we cannot intercept array element access like property getters.
+ */
+function dependArray (value) {
+  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
+    e = value[i];
+    e && e.__ob__ && e.__ob__.dep.depend();
+    if (Array.isArray(e)) {
+      dependArray(e);
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Option overwriting strategies are functions that handle
+ * how to merge a parent option value and a child option
+ * value into the final value.
+ */
+var strats = config.optionMergeStrategies;
+
+/**
+ * Options with restrictions
+ */
+if (process.env.NODE_ENV !== 'production') {
+  strats.el = strats.propsData = function (parent, child, vm, key) {
+    if (!vm) {
+      warn(
+        "option \"" + key + "\" can only be used during instance " +
+        'creation with the `new` keyword.'
+      );
+    }
+    return defaultStrat(parent, child)
+  };
+}
+
+/**
+ * Helper that recursively merges two data objects together.
+ */
+function mergeData (to, from) {
+  if (!from) { return to }
+  var key, toVal, fromVal;
+  var keys = Object.keys(from);
+  for (var i = 0; i < keys.length; i++) {
+    key = keys[i];
+    toVal = to[key];
+    fromVal = from[key];
+    if (!hasOwn(to, key)) {
+      set(to, key, fromVal);
+    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
+      mergeData(toVal, fromVal);
+    }
+  }
+  return to
+}
+
+/**
+ * Data
+ */
+strats.data = function (
+  parentVal,
+  childVal,
+  vm
+) {
+  if (!vm) {
+    // in a Vue.extend merge, both should be functions
+    if (!childVal) {
+      return parentVal
+    }
+    if (typeof childVal !== 'function') {
+      process.env.NODE_ENV !== 'production' && warn(
+        'The "data" option should be a function ' +
+        'that returns a per-instance value in component ' +
+        'definitions.',
+        vm
+      );
+      return parentVal
+    }
+    if (!parentVal) {
+      return childVal
+    }
+    // when parentVal & childVal are both present,
+    // we need to return a function that returns the
+    // merged result of both functions... no need to
+    // check if parentVal is a function here because
+    // it has to be a function to pass previous merges.
+    return function mergedDataFn () {
+      return mergeData(
+        childVal.call(this),
+        parentVal.call(this)
+      )
+    }
+  } else if (parentVal || childVal) {
+    return function mergedInstanceDataFn () {
+      // instance merge
+      var instanceData = typeof childVal === 'function'
+        ? childVal.call(vm)
+        : childVal;
+      var defaultData = typeof parentVal === 'function'
+        ? parentVal.call(vm)
+        : undefined;
+      if (instanceData) {
+        return mergeData(instanceData, defaultData)
+      } else {
+        return defaultData
+      }
+    }
+  }
+};
+
+/**
+ * Hooks and props are merged as arrays.
+ */
+function mergeHook (
+  parentVal,
+  childVal
+) {
+  return childVal
+    ? parentVal
+      ? parentVal.concat(childVal)
+      : Array.isArray(childVal)
+        ? childVal
+        : [childVal]
+    : parentVal
+}
+
+config._lifecycleHooks.forEach(function (hook) {
+  strats[hook] = mergeHook;
+});
+
+/**
+ * Assets
+ *
+ * When a vm is present (instance creation), we need to do
+ * a three-way merge between constructor options, instance
+ * options and parent options.
+ */
+function mergeAssets (parentVal, childVal) {
+  var res = Object.create(parentVal || null);
+  return childVal
+    ? extend(res, childVal)
+    : res
+}
+
+config._assetTypes.forEach(function (type) {
+  strats[type + 's'] = mergeAssets;
+});
+
+/**
+ * Watchers.
+ *
+ * Watchers hashes should not overwrite one
+ * another, so we merge them as arrays.
+ */
+strats.watch = function (parentVal, childVal) {
+  /* istanbul ignore if */
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = {};
+  extend(ret, parentVal);
+  for (var key in childVal) {
+    var parent = ret[key];
+    var child = childVal[key];
+    if (parent && !Array.isArray(parent)) {
+      parent = [parent];
+    }
+    ret[key] = parent
+      ? parent.concat(child)
+      : [child];
+  }
+  return ret
+};
+
+/**
+ * Other object hashes.
+ */
+strats.props =
+strats.methods =
+strats.computed = function (parentVal, childVal) {
+  if (!childVal) { return Object.create(parentVal || null) }
+  if (!parentVal) { return childVal }
+  var ret = Object.create(null);
+  extend(ret, parentVal);
+  extend(ret, childVal);
+  return ret
+};
+
+/**
+ * Default strategy.
+ */
+var defaultStrat = function (parentVal, childVal) {
+  return childVal === undefined
+    ? parentVal
+    : childVal
+};
+
+/**
+ * Validate component names
+ */
+function checkComponents (options) {
+  for (var key in options.components) {
+    var lower = key.toLowerCase();
+    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
+      warn(
+        'Do not use built-in or reserved HTML elements as component ' +
+        'id: ' + key
+      );
+    }
+  }
+}
+
+/**
+ * Ensure all props option syntax are normalized into the
+ * Object-based format.
+ */
+function normalizeProps (options) {
+  var props = options.props;
+  if (!props) { return }
+  var res = {};
+  var i, val, name;
+  if (Array.isArray(props)) {
+    i = props.length;
+    while (i--) {
+      val = props[i];
+      if (typeof val === 'string') {
+        name = camelize(val);
+        res[name] = { type: null };
+      } else if (process.env.NODE_ENV !== 'production') {
+        warn('props must be strings when using array syntax.');
+      }
+    }
+  } else if (isPlainObject(props)) {
+    for (var key in props) {
+      val = props[key];
+      name = camelize(key);
+      res[name] = isPlainObject(val)
+        ? val
+        : { type: val };
+    }
+  }
+  options.props = res;
+}
+
+/**
+ * Normalize raw function directives into object format.
+ */
+function normalizeDirectives (options) {
+  var dirs = options.directives;
+  if (dirs) {
+    for (var key in dirs) {
+      var def = dirs[key];
+      if (typeof def === 'function') {
+        dirs[key] = { bind: def, update: def };
+      }
+    }
+  }
+}
+
+/**
+ * Merge two option objects into a new one.
+ * Core utility used in both instantiation and inheritance.
+ */
+function mergeOptions (
+  parent,
+  child,
+  vm
+) {
+  if (process.env.NODE_ENV !== 'production') {
+    checkComponents(child);
+  }
+  normalizeProps(child);
+  normalizeDirectives(child);
+  var extendsFrom = child.extends;
+  if (extendsFrom) {
+    parent = typeof extendsFrom === 'function'
+      ? mergeOptions(parent, extendsFrom.options, vm)
+      : mergeOptions(parent, extendsFrom, vm);
+  }
+  if (child.mixins) {
+    for (var i = 0, l = child.mixins.length; i < l; i++) {
+      var mixin = child.mixins[i];
+      if (mixin.prototype instanceof Vue$2) {
+        mixin = mixin.options;
+      }
+      parent = mergeOptions(parent, mixin, vm);
+    }
+  }
+  var options = {};
+  var key;
+  for (key in parent) {
+    mergeField(key);
+  }
+  for (key in child) {
+    if (!hasOwn(parent, key)) {
+      mergeField(key);
+    }
+  }
+  function mergeField (key) {
+    var strat = strats[key] || defaultStrat;
+    options[key] = strat(parent[key], child[key], vm, key);
+  }
+  return options
+}
+
+/**
+ * Resolve an asset.
+ * This function is used because child instances need access
+ * to assets defined in its ancestor chain.
+ */
+function resolveAsset (
+  options,
+  type,
+  id,
+  warnMissing
+) {
+  /* istanbul ignore if */
+  if (typeof id !== 'string') {
+    return
+  }
+  var assets = options[type];
+  // check local registration variations first
+  if (hasOwn(assets, id)) { return assets[id] }
+  var camelizedId = camelize(id);
+  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
+  var PascalCaseId = capitalize(camelizedId);
+  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
+  // fallback to prototype chain
+  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
+  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
+    warn(
+      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
+      options
+    );
+  }
+  return res
+}
+
+/*  */
+
+function validateProp (
+  key,
+  propOptions,
+  propsData,
+  vm
+) {
+  var prop = propOptions[key];
+  var absent = !hasOwn(propsData, key);
+  var value = propsData[key];
+  // handle boolean props
+  if (isType(Boolean, prop.type)) {
+    if (absent && !hasOwn(prop, 'default')) {
+      value = false;
+    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
+      value = true;
+    }
+  }
+  // check default value
+  if (value === undefined) {
+    value = getPropDefaultValue(vm, prop, key);
+    // since the default value is a fresh copy,
+    // make sure to observe it.
+    var prevShouldConvert = observerState.shouldConvert;
+    observerState.shouldConvert = true;
+    observe(value);
+    observerState.shouldConvert = prevShouldConvert;
+  }
+  if (process.env.NODE_ENV !== 'production') {
+    assertProp(prop, key, value, vm, absent);
+  }
+  return value
+}
+
+/**
+ * Get the default value of a prop.
+ */
+function getPropDefaultValue (vm, prop, key) {
+  // no default, return undefined
+  if (!hasOwn(prop, 'default')) {
+    return undefined
+  }
+  var def = prop.default;
+  // warn against non-factory defaults for Object & Array
+  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
+    warn(
+      'Invalid default value for prop "' + key + '": ' +
+      'Props with type Object/Array must use a factory function ' +
+      'to return the default value.',
+      vm
+    );
+  }
+  // the raw prop value was also undefined from previous render,
+  // return previous default value to avoid unnecessary watcher trigger
+  if (vm && vm.$options.propsData &&
+    vm.$options.propsData[key] === undefined &&
+    vm._props[key] !== undefined) {
+    return vm._props[key]
+  }
+  // call factory function for non-Function types
+  // a value is Function if its prototype is function even across different execution context
+  return typeof def === 'function' && getType(prop.type) !== 'Function'
+    ? def.call(vm)
+    : def
+}
+
+/**
+ * Assert whether a prop is valid.
+ */
+function assertProp (
+  prop,
+  name,
+  value,
+  vm,
+  absent
+) {
+  if (prop.required && absent) {
+    warn(
+      'Missing required prop: "' + name + '"',
+      vm
+    );
+    return
+  }
+  if (value == null && !prop.required) {
+    return
+  }
+  var type = prop.type;
+  var valid = !type || type === true;
+  var expectedTypes = [];
+  if (type) {
+    if (!Array.isArray(type)) {
+      type = [type];
+    }
+    for (var i = 0; i < type.length && !valid; i++) {
+      var assertedType = assertType(value, type[i]);
+      expectedTypes.push(assertedType.expectedType || '');
+      valid = assertedType.valid;
+    }
+  }
+  if (!valid) {
+    warn(
+      'Invalid prop: type check failed for prop "' + name + '".' +
+      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
+      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
+      vm
+    );
+    return
+  }
+  var validator = prop.validator;
+  if (validator) {
+    if (!validator(value)) {
+      warn(
+        'Invalid prop: custom validator check failed for prop "' + name + '".',
+        vm
+      );
+    }
+  }
+}
+
+/**
+ * Assert the type of a value
+ */
+function assertType (value, type) {
+  var valid;
+  var expectedType = getType(type);
+  if (expectedType === 'String') {
+    valid = typeof value === (expectedType = 'string');
+  } else if (expectedType === 'Number') {
+    valid = typeof value === (expectedType = 'number');
+  } else if (expectedType === 'Boolean') {
+    valid = typeof value === (expectedType = 'boolean');
+  } else if (expectedType === 'Function') {
+    valid = typeof value === (expectedType = 'function');
+  } else if (expectedType === 'Object') {
+    valid = isPlainObject(value);
+  } else if (expectedType === 'Array') {
+    valid = Array.isArray(value);
+  } else {
+    valid = value instanceof type;
+  }
+  return {
+    valid: valid,
+    expectedType: expectedType
+  }
+}
+
+/**
+ * Use function string name to check built-in types,
+ * because a simple equality check will fail when running
+ * across different vms / iframes.
+ */
+function getType (fn) {
+  var match = fn && fn.toString().match(/^\s*function (\w+)/);
+  return match && match[1]
+}
+
+function isType (type, fn) {
+  if (!Array.isArray(fn)) {
+    return getType(fn) === getType(type)
+  }
+  for (var i = 0, len = fn.length; i < len; i++) {
+    if (getType(fn[i]) === getType(type)) {
+      return true
+    }
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function handleError (err, vm, info) {
+  if (config.errorHandler) {
+    config.errorHandler.call(null, err, vm, info);
+  } else {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Error in " + info + ":"), vm);
+    }
+    /* istanbul ignore else */
+    if (inBrowser && typeof console !== 'undefined') {
+      console.error(err);
+    } else {
+      throw err
+    }
+  }
+}
+
+/* not type checking this file because flow doesn't play well with Proxy */
+
+var initProxy;
+
+if (process.env.NODE_ENV !== 'production') {
+  var allowedGlobals = makeMap(
+    'Infinity,undefined,NaN,isFinite,isNaN,' +
+    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
+    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
+    'require' // for Webpack/Browserify
+  );
+
+  var warnNonPresent = function (target, key) {
+    warn(
+      "Property or method \"" + key + "\" is not defined on the instance but " +
+      "referenced during render. Make sure to declare reactive data " +
+      "properties in the data option.",
+      target
+    );
+  };
+
+  var hasProxy =
+    typeof Proxy !== 'undefined' &&
+    Proxy.toString().match(/native code/);
+
+  if (hasProxy) {
+    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');
+    config.keyCodes = new Proxy(config.keyCodes, {
+      set: function set (target, key, value) {
+        if (isBuiltInModifier(key)) {
+          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
+          return false
+        } else {
+          target[key] = value;
+          return true
+        }
+      }
+    });
+  }
+
+  var hasHandler = {
+    has: function has (target, key) {
+      var has = key in target;
+      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
+      if (!has && !isAllowed) {
+        warnNonPresent(target, key);
+      }
+      return has || !isAllowed
+    }
+  };
+
+  var getHandler = {
+    get: function get (target, key) {
+      if (typeof key === 'string' && !(key in target)) {
+        warnNonPresent(target, key);
+      }
+      return target[key]
+    }
+  };
+
+  initProxy = function initProxy (vm) {
+    if (hasProxy) {
+      // determine which proxy handler to use
+      var options = vm.$options;
+      var handlers = options.render && options.render._withStripped
+        ? getHandler
+        : hasHandler;
+      vm._renderProxy = new Proxy(vm, handlers);
+    } else {
+      vm._renderProxy = vm;
+    }
+  };
+}
+
+/*  */
+
+var VNode = function VNode (
+  tag,
+  data,
+  children,
+  text,
+  elm,
+  context,
+  componentOptions
+) {
+  this.tag = tag;
+  this.data = data;
+  this.children = children;
+  this.text = text;
+  this.elm = elm;
+  this.ns = undefined;
+  this.context = context;
+  this.functionalContext = undefined;
+  this.key = data && data.key;
+  this.componentOptions = componentOptions;
+  this.componentInstance = undefined;
+  this.parent = undefined;
+  this.raw = false;
+  this.isStatic = false;
+  this.isRootInsert = true;
+  this.isComment = false;
+  this.isCloned = false;
+  this.isOnce = false;
+};
+
+var prototypeAccessors = { child: {} };
+
+// DEPRECATED: alias for componentInstance for backwards compat.
+/* istanbul ignore next */
+prototypeAccessors.child.get = function () {
+  return this.componentInstance
+};
+
+Object.defineProperties( VNode.prototype, prototypeAccessors );
+
+var createEmptyVNode = function () {
+  var node = new VNode();
+  node.text = '';
+  node.isComment = true;
+  return node
+};
+
+function createTextVNode (val) {
+  return new VNode(undefined, undefined, undefined, String(val))
+}
+
+// optimized shallow clone
+// used for static nodes and slot nodes because they may be reused across
+// multiple renders, cloning them avoids errors when DOM manipulations rely
+// on their elm reference.
+function cloneVNode (vnode) {
+  var cloned = new VNode(
+    vnode.tag,
+    vnode.data,
+    vnode.children,
+    vnode.text,
+    vnode.elm,
+    vnode.context,
+    vnode.componentOptions
+  );
+  cloned.ns = vnode.ns;
+  cloned.isStatic = vnode.isStatic;
+  cloned.key = vnode.key;
+  cloned.isCloned = true;
+  return cloned
+}
+
+function cloneVNodes (vnodes) {
+  var len = vnodes.length;
+  var res = new Array(len);
+  for (var i = 0; i < len; i++) {
+    res[i] = cloneVNode(vnodes[i]);
+  }
+  return res
+}
+
+/*  */
+
+var normalizeEvent = cached(function (name) {
+  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
+  name = once$$1 ? name.slice(1) : name;
+  var capture = name.charAt(0) === '!';
+  name = capture ? name.slice(1) : name;
+  return {
+    name: name,
+    once: once$$1,
+    capture: capture
+  }
+});
+
+function createFnInvoker (fns) {
+  function invoker () {
+    var arguments$1 = arguments;
+
+    var fns = invoker.fns;
+    if (Array.isArray(fns)) {
+      for (var i = 0; i < fns.length; i++) {
+        fns[i].apply(null, arguments$1);
+      }
+    } else {
+      // return handler return value for single handlers
+      return fns.apply(null, arguments)
+    }
+  }
+  invoker.fns = fns;
+  return invoker
+}
+
+function updateListeners (
+  on,
+  oldOn,
+  add,
+  remove$$1,
+  vm
+) {
+  var name, cur, old, event;
+  for (name in on) {
+    cur = on[name];
+    old = oldOn[name];
+    event = normalizeEvent(name);
+    if (!cur) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
+        vm
+      );
+    } else if (!old) {
+      if (!cur.fns) {
+        cur = on[name] = createFnInvoker(cur);
+      }
+      add(event.name, cur, event.once, event.capture);
+    } else if (cur !== old) {
+      old.fns = cur;
+      on[name] = old;
+    }
+  }
+  for (name in oldOn) {
+    if (!on[name]) {
+      event = normalizeEvent(name);
+      remove$$1(event.name, oldOn[name], event.capture);
+    }
+  }
+}
+
+/*  */
+
+function mergeVNodeHook (def, hookKey, hook) {
+  var invoker;
+  var oldHook = def[hookKey];
+
+  function wrappedHook () {
+    hook.apply(this, arguments);
+    // important: remove merged hook to ensure it's called only once
+    // and prevent memory leak
+    remove(invoker.fns, wrappedHook);
+  }
+
+  if (!oldHook) {
+    // no existing hook
+    invoker = createFnInvoker([wrappedHook]);
+  } else {
+    /* istanbul ignore if */
+    if (oldHook.fns && oldHook.merged) {
+      // already a merged invoker
+      invoker = oldHook;
+      invoker.fns.push(wrappedHook);
+    } else {
+      // existing plain hook
+      invoker = createFnInvoker([oldHook, wrappedHook]);
+    }
+  }
+
+  invoker.merged = true;
+  def[hookKey] = invoker;
+}
+
+/*  */
+
+// The template compiler attempts to minimize the need for normalization by
+// statically analyzing the template at compile time.
+//
+// For plain HTML markup, normalization can be completely skipped because the
+// generated render function is guaranteed to return Array<VNode>. There are
+// two cases where extra normalization is needed:
+
+// 1. When the children contains components - because a functional component
+// may return an Array instead of a single root. In this case, just a simple
+// normalization is needed - if any child is an Array, we flatten the whole
+// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
+// because functional components already normalize their own children.
+function simpleNormalizeChildren (children) {
+  for (var i = 0; i < children.length; i++) {
+    if (Array.isArray(children[i])) {
+      return Array.prototype.concat.apply([], children)
+    }
+  }
+  return children
+}
+
+// 2. When the children contains constructs that always generated nested Arrays,
+// e.g. <template>, <slot>, v-for, or when the children is provided by user
+// with hand-written render functions / JSX. In such cases a full normalization
+// is needed to cater to all possible types of children values.
+function normalizeChildren (children) {
+  return isPrimitive(children)
+    ? [createTextVNode(children)]
+    : Array.isArray(children)
+      ? normalizeArrayChildren(children)
+      : undefined
+}
+
+function normalizeArrayChildren (children, nestedIndex) {
+  var res = [];
+  var i, c, last;
+  for (i = 0; i < children.length; i++) {
+    c = children[i];
+    if (c == null || typeof c === 'boolean') { continue }
+    last = res[res.length - 1];
+    //  nested
+    if (Array.isArray(c)) {
+      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i)));
+    } else if (isPrimitive(c)) {
+      if (last && last.text) {
+        last.text += String(c);
+      } else if (c !== '') {
+        // convert primitive to vnode
+        res.push(createTextVNode(c));
+      }
+    } else {
+      if (c.text && last && last.text) {
+        res[res.length - 1] = createTextVNode(last.text + c.text);
+      } else {
+        // default key for nested array children (likely generated by v-for)
+        if (c.tag && c.key == null && nestedIndex != null) {
+          c.key = "__vlist" + nestedIndex + "_" + i + "__";
+        }
+        res.push(c);
+      }
+    }
+  }
+  return res
+}
+
+/*  */
+
+function getFirstComponentChild (children) {
+  return children && children.filter(function (c) { return c && c.componentOptions; })[0]
+}
+
+/*  */
+
+function initEvents (vm) {
+  vm._events = Object.create(null);
+  vm._hasHookEvent = false;
+  // init parent attached events
+  var listeners = vm.$options._parentListeners;
+  if (listeners) {
+    updateComponentListeners(vm, listeners);
+  }
+}
+
+var target;
+
+function add (event, fn, once$$1) {
+  if (once$$1) {
+    target.$once(event, fn);
+  } else {
+    target.$on(event, fn);
+  }
+}
+
+function remove$1 (event, fn) {
+  target.$off(event, fn);
+}
+
+function updateComponentListeners (
+  vm,
+  listeners,
+  oldListeners
+) {
+  target = vm;
+  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
+}
+
+function eventsMixin (Vue) {
+  var hookRE = /^hook:/;
+  Vue.prototype.$on = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    if (Array.isArray(event)) {
+      for (var i = 0, l = event.length; i < l; i++) {
+        this$1.$on(event[i], fn);
+      }
+    } else {
+      (vm._events[event] || (vm._events[event] = [])).push(fn);
+      // optimize hook:event cost by using a boolean flag marked at registration
+      // instead of a hash lookup
+      if (hookRE.test(event)) {
+        vm._hasHookEvent = true;
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$once = function (event, fn) {
+    var vm = this;
+    function on () {
+      vm.$off(event, on);
+      fn.apply(vm, arguments);
+    }
+    on.fn = fn;
+    vm.$on(event, on);
+    return vm
+  };
+
+  Vue.prototype.$off = function (event, fn) {
+    var this$1 = this;
+
+    var vm = this;
+    // all
+    if (!arguments.length) {
+      vm._events = Object.create(null);
+      return vm
+    }
+    // array of events
+    if (Array.isArray(event)) {
+      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
+        this$1.$off(event[i$1], fn);
+      }
+      return vm
+    }
+    // specific event
+    var cbs = vm._events[event];
+    if (!cbs) {
+      return vm
+    }
+    if (arguments.length === 1) {
+      vm._events[event] = null;
+      return vm
+    }
+    // specific handler
+    var cb;
+    var i = cbs.length;
+    while (i--) {
+      cb = cbs[i];
+      if (cb === fn || cb.fn === fn) {
+        cbs.splice(i, 1);
+        break
+      }
+    }
+    return vm
+  };
+
+  Vue.prototype.$emit = function (event) {
+    var vm = this;
+    var cbs = vm._events[event];
+    if (cbs) {
+      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
+      var args = toArray(arguments, 1);
+      for (var i = 0, l = cbs.length; i < l; i++) {
+        cbs[i].apply(vm, args);
+      }
+    }
+    return vm
+  };
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving raw children VNodes into a slot object.
+ */
+function resolveSlots (
+  children,
+  context
+) {
+  var slots = {};
+  if (!children) {
+    return slots
+  }
+  var defaultSlot = [];
+  var name, child;
+  for (var i = 0, l = children.length; i < l; i++) {
+    child = children[i];
+    // named slots should only be respected if the vnode was rendered in the
+    // same context.
+    if ((child.context === context || child.functionalContext === context) &&
+        child.data && (name = child.data.slot)) {
+      var slot = (slots[name] || (slots[name] = []));
+      if (child.tag === 'template') {
+        slot.push.apply(slot, child.children);
+      } else {
+        slot.push(child);
+      }
+    } else {
+      defaultSlot.push(child);
+    }
+  }
+  // ignore whitespace
+  if (!defaultSlot.every(isWhitespace)) {
+    slots.default = defaultSlot;
+  }
+  return slots
+}
+
+function isWhitespace (node) {
+  return node.isComment || node.text === ' '
+}
+
+function resolveScopedSlots (
+  fns
+) {
+  var res = {};
+  for (var i = 0; i < fns.length; i++) {
+    res[fns[i][0]] = fns[i][1];
+  }
+  return res
+}
+
+/*  */
+
+var activeInstance = null;
+
+function initLifecycle (vm) {
+  var options = vm.$options;
+
+  // locate first non-abstract parent
+  var parent = options.parent;
+  if (parent && !options.abstract) {
+    while (parent.$options.abstract && parent.$parent) {
+      parent = parent.$parent;
+    }
+    parent.$children.push(vm);
+  }
+
+  vm.$parent = parent;
+  vm.$root = parent ? parent.$root : vm;
+
+  vm.$children = [];
+  vm.$refs = {};
+
+  vm._watcher = null;
+  vm._inactive = null;
+  vm._directInactive = false;
+  vm._isMounted = false;
+  vm._isDestroyed = false;
+  vm._isBeingDestroyed = false;
+}
+
+function lifecycleMixin (Vue) {
+  Vue.prototype._update = function (vnode, hydrating) {
+    var vm = this;
+    if (vm._isMounted) {
+      callHook(vm, 'beforeUpdate');
+    }
+    var prevEl = vm.$el;
+    var prevVnode = vm._vnode;
+    var prevActiveInstance = activeInstance;
+    activeInstance = vm;
+    vm._vnode = vnode;
+    // Vue.prototype.__patch__ is injected in entry points
+    // based on the rendering backend used.
+    if (!prevVnode) {
+      // initial render
+      vm.$el = vm.__patch__(
+        vm.$el, vnode, hydrating, false /* removeOnly */,
+        vm.$options._parentElm,
+        vm.$options._refElm
+      );
+    } else {
+      // updates
+      vm.$el = vm.__patch__(prevVnode, vnode);
+    }
+    activeInstance = prevActiveInstance;
+    // update __vue__ reference
+    if (prevEl) {
+      prevEl.__vue__ = null;
+    }
+    if (vm.$el) {
+      vm.$el.__vue__ = vm;
+    }
+    // if parent is an HOC, update its $el as well
+    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
+      vm.$parent.$el = vm.$el;
+    }
+    // updated hook is called by the scheduler to ensure that children are
+    // updated in a parent's updated hook.
+  };
+
+  Vue.prototype.$forceUpdate = function () {
+    var vm = this;
+    if (vm._watcher) {
+      vm._watcher.update();
+    }
+  };
+
+  Vue.prototype.$destroy = function () {
+    var vm = this;
+    if (vm._isBeingDestroyed) {
+      return
+    }
+    callHook(vm, 'beforeDestroy');
+    vm._isBeingDestroyed = true;
+    // remove self from parent
+    var parent = vm.$parent;
+    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
+      remove(parent.$children, vm);
+    }
+    // teardown watchers
+    if (vm._watcher) {
+      vm._watcher.teardown();
+    }
+    var i = vm._watchers.length;
+    while (i--) {
+      vm._watchers[i].teardown();
+    }
+    // remove reference from data ob
+    // frozen object may not have observer.
+    if (vm._data.__ob__) {
+      vm._data.__ob__.vmCount--;
+    }
+    // call the last hook...
+    vm._isDestroyed = true;
+    callHook(vm, 'destroyed');
+    // turn off all instance listeners.
+    vm.$off();
+    // remove __vue__ reference
+    if (vm.$el) {
+      vm.$el.__vue__ = null;
+    }
+    // invoke destroy hooks on current rendered tree
+    vm.__patch__(vm._vnode, null);
+  };
+}
+
+function mountComponent (
+  vm,
+  el,
+  hydrating
+) {
+  vm.$el = el;
+  if (!vm.$options.render) {
+    vm.$options.render = createEmptyVNode;
+    if (process.env.NODE_ENV !== 'production') {
+      /* istanbul ignore if */
+      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
+        vm.$options.el || el) {
+        warn(
+          'You are using the runtime-only build of Vue where the template ' +
+          'compiler is not available. Either pre-compile the templates into ' +
+          'render functions, or use the compiler-included build.',
+          vm
+        );
+      } else {
+        warn(
+          'Failed to mount component: template or render function not defined.',
+          vm
+        );
+      }
+    }
+  }
+  callHook(vm, 'beforeMount');
+
+  var updateComponent;
+  /* istanbul ignore if */
+  if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+    updateComponent = function () {
+      var name = vm._name;
+      var startTag = "start " + name;
+      var endTag = "end " + name;
+      perf.mark(startTag);
+      var vnode = vm._render();
+      perf.mark(endTag);
+      perf.measure((name + " render"), startTag, endTag);
+      perf.mark(startTag);
+      vm._update(vnode, hydrating);
+      perf.mark(endTag);
+      perf.measure((name + " patch"), startTag, endTag);
+    };
+  } else {
+    updateComponent = function () {
+      vm._update(vm._render(), hydrating);
+    };
+  }
+
+  vm._watcher = new Watcher(vm, updateComponent, noop);
+  hydrating = false;
+
+  // manually mounted instance, call mounted on self
+  // mounted is called for render-created child components in its inserted hook
+  if (vm.$vnode == null) {
+    vm._isMounted = true;
+    callHook(vm, 'mounted');
+  }
+  return vm
+}
+
+function updateChildComponent (
+  vm,
+  propsData,
+  listeners,
+  parentVnode,
+  renderChildren
+) {
+  // determine whether component has slot children
+  // we need to do this before overwriting $options._renderChildren
+  var hasChildren = !!(
+    renderChildren ||               // has new static slots
+    vm.$options._renderChildren ||  // has old static slots
+    parentVnode.data.scopedSlots || // has new scoped slots
+    vm.$scopedSlots !== emptyObject // has old scoped slots
+  );
+
+  vm.$options._parentVnode = parentVnode;
+  vm.$vnode = parentVnode; // update vm's placeholder node without re-render
+  if (vm._vnode) { // update child tree's parent
+    vm._vnode.parent = parentVnode;
+  }
+  vm.$options._renderChildren = renderChildren;
+
+  // update props
+  if (propsData && vm.$options.props) {
+    observerState.shouldConvert = false;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = true;
+    }
+    var props = vm._props;
+    var propKeys = vm.$options._propKeys || [];
+    for (var i = 0; i < propKeys.length; i++) {
+      var key = propKeys[i];
+      props[key] = validateProp(key, vm.$options.props, propsData, vm);
+    }
+    observerState.shouldConvert = true;
+    if (process.env.NODE_ENV !== 'production') {
+      observerState.isSettingProps = false;
+    }
+    // keep a copy of raw propsData
+    vm.$options.propsData = propsData;
+  }
+  // update listeners
+  if (listeners) {
+    var oldListeners = vm.$options._parentListeners;
+    vm.$options._parentListeners = listeners;
+    updateComponentListeners(vm, listeners, oldListeners);
+  }
+  // resolve slots + force update if has children
+  if (hasChildren) {
+    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
+    vm.$forceUpdate();
+  }
+}
+
+function isInInactiveTree (vm) {
+  while (vm && (vm = vm.$parent)) {
+    if (vm._inactive) { return true }
+  }
+  return false
+}
+
+function activateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = false;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  } else if (vm._directInactive) {
+    return
+  }
+  if (vm._inactive || vm._inactive == null) {
+    vm._inactive = false;
+    for (var i = 0; i < vm.$children.length; i++) {
+      activateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'activated');
+  }
+}
+
+function deactivateChildComponent (vm, direct) {
+  if (direct) {
+    vm._directInactive = true;
+    if (isInInactiveTree(vm)) {
+      return
+    }
+  }
+  if (!vm._inactive) {
+    vm._inactive = true;
+    for (var i = 0; i < vm.$children.length; i++) {
+      deactivateChildComponent(vm.$children[i]);
+    }
+    callHook(vm, 'deactivated');
+  }
+}
+
+function callHook (vm, hook) {
+  var handlers = vm.$options[hook];
+  if (handlers) {
+    for (var i = 0, j = handlers.length; i < j; i++) {
+      try {
+        handlers[i].call(vm);
+      } catch (e) {
+        handleError(e, vm, (hook + " hook"));
+      }
+    }
+  }
+  if (vm._hasHookEvent) {
+    vm.$emit('hook:' + hook);
+  }
+}
+
+/*  */
+
+
+var queue = [];
+var has = {};
+var circular = {};
+var waiting = false;
+var flushing = false;
+var index = 0;
+
+/**
+ * Reset the scheduler's state.
+ */
+function resetSchedulerState () {
+  queue.length = 0;
+  has = {};
+  if (process.env.NODE_ENV !== 'production') {
+    circular = {};
+  }
+  waiting = flushing = false;
+}
+
+/**
+ * Flush both queues and run the watchers.
+ */
+function flushSchedulerQueue () {
+  flushing = true;
+  var watcher, id, vm;
+
+  // Sort queue before flush.
+  // This ensures that:
+  // 1. Components are updated from parent to child. (because parent is always
+  //    created before the child)
+  // 2. A component's user watchers are run before its render watcher (because
+  //    user watchers are created before the render watcher)
+  // 3. If a component is destroyed during a parent component's watcher run,
+  //    its watchers can be skipped.
+  queue.sort(function (a, b) { return a.id - b.id; });
+
+  // do not cache length because more watchers might be pushed
+  // as we run existing watchers
+  for (index = 0; index < queue.length; index++) {
+    watcher = queue[index];
+    id = watcher.id;
+    has[id] = null;
+    watcher.run();
+    // in dev build, check and stop circular updates.
+    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
+      circular[id] = (circular[id] || 0) + 1;
+      if (circular[id] > config._maxUpdateCount) {
+        warn(
+          'You may have an infinite update loop ' + (
+            watcher.user
+              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
+              : "in a component render function."
+          ),
+          watcher.vm
+        );
+        break
+      }
+    }
+  }
+
+  // call updated hooks
+  index = queue.length;
+  while (index--) {
+    watcher = queue[index];
+    vm = watcher.vm;
+    if (vm._watcher === watcher && vm._isMounted) {
+      callHook(vm, 'updated');
+    }
+  }
+
+  // devtool hook
+  /* istanbul ignore if */
+  if (devtools && config.devtools) {
+    devtools.emit('flush');
+  }
+
+  resetSchedulerState();
+}
+
+/**
+ * Push a watcher into the watcher queue.
+ * Jobs with duplicate IDs will be skipped unless it's
+ * pushed when the queue is being flushed.
+ */
+function queueWatcher (watcher) {
+  var id = watcher.id;
+  if (has[id] == null) {
+    has[id] = true;
+    if (!flushing) {
+      queue.push(watcher);
+    } else {
+      // if already flushing, splice the watcher based on its id
+      // if already past its id, it will be run next immediately.
+      var i = queue.length - 1;
+      while (i >= 0 && queue[i].id > watcher.id) {
+        i--;
+      }
+      queue.splice(Math.max(i, index) + 1, 0, watcher);
+    }
+    // queue the flush
+    if (!waiting) {
+      waiting = true;
+      nextTick(flushSchedulerQueue);
+    }
+  }
+}
+
+/*  */
+
+var uid$2 = 0;
+
+/**
+ * A watcher parses an expression, collects dependencies,
+ * and fires callback when the expression value changes.
+ * This is used for both the $watch() api and directives.
+ */
+var Watcher = function Watcher (
+  vm,
+  expOrFn,
+  cb,
+  options
+) {
+  this.vm = vm;
+  vm._watchers.push(this);
+  // options
+  if (options) {
+    this.deep = !!options.deep;
+    this.user = !!options.user;
+    this.lazy = !!options.lazy;
+    this.sync = !!options.sync;
+  } else {
+    this.deep = this.user = this.lazy = this.sync = false;
+  }
+  this.cb = cb;
+  this.id = ++uid$2; // uid for batching
+  this.active = true;
+  this.dirty = this.lazy; // for lazy watchers
+  this.deps = [];
+  this.newDeps = [];
+  this.depIds = new _Set();
+  this.newDepIds = new _Set();
+  this.expression = process.env.NODE_ENV !== 'production'
+    ? expOrFn.toString()
+    : '';
+  // parse expression for getter
+  if (typeof expOrFn === 'function') {
+    this.getter = expOrFn;
+  } else {
+    this.getter = parsePath(expOrFn);
+    if (!this.getter) {
+      this.getter = function () {};
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed watching path: \"" + expOrFn + "\" " +
+        'Watcher only accepts simple dot-delimited paths. ' +
+        'For full control, use a function instead.',
+        vm
+      );
+    }
+  }
+  this.value = this.lazy
+    ? undefined
+    : this.get();
+};
+
+/**
+ * Evaluate the getter, and re-collect dependencies.
+ */
+Watcher.prototype.get = function get () {
+  pushTarget(this);
+  var value;
+  var vm = this.vm;
+  if (this.user) {
+    try {
+      value = this.getter.call(vm, vm);
+    } catch (e) {
+      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
+    }
+  } else {
+    value = this.getter.call(vm, vm);
+  }
+  // "touch" every property so they are all tracked as
+  // dependencies for deep watching
+  if (this.deep) {
+    traverse(value);
+  }
+  popTarget();
+  this.cleanupDeps();
+  return value
+};
+
+/**
+ * Add a dependency to this directive.
+ */
+Watcher.prototype.addDep = function addDep (dep) {
+  var id = dep.id;
+  if (!this.newDepIds.has(id)) {
+    this.newDepIds.add(id);
+    this.newDeps.push(dep);
+    if (!this.depIds.has(id)) {
+      dep.addSub(this);
+    }
+  }
+};
+
+/**
+ * Clean up for dependency collection.
+ */
+Watcher.prototype.cleanupDeps = function cleanupDeps () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    var dep = this$1.deps[i];
+    if (!this$1.newDepIds.has(dep.id)) {
+      dep.removeSub(this$1);
+    }
+  }
+  var tmp = this.depIds;
+  this.depIds = this.newDepIds;
+  this.newDepIds = tmp;
+  this.newDepIds.clear();
+  tmp = this.deps;
+  this.deps = this.newDeps;
+  this.newDeps = tmp;
+  this.newDeps.length = 0;
+};
+
+/**
+ * Subscriber interface.
+ * Will be called when a dependency changes.
+ */
+Watcher.prototype.update = function update () {
+  /* istanbul ignore else */
+  if (this.lazy) {
+    this.dirty = true;
+  } else if (this.sync) {
+    this.run();
+  } else {
+    queueWatcher(this);
+  }
+};
+
+/**
+ * Scheduler job interface.
+ * Will be called by the scheduler.
+ */
+Watcher.prototype.run = function run () {
+  if (this.active) {
+    var value = this.get();
+    if (
+      value !== this.value ||
+      // Deep watchers and watchers on Object/Arrays should fire even
+      // when the value is the same, because the value may
+      // have mutated.
+      isObject(value) ||
+      this.deep
+    ) {
+      // set new value
+      var oldValue = this.value;
+      this.value = value;
+      if (this.user) {
+        try {
+          this.cb.call(this.vm, value, oldValue);
+        } catch (e) {
+          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
+        }
+      } else {
+        this.cb.call(this.vm, value, oldValue);
+      }
+    }
+  }
+};
+
+/**
+ * Evaluate the value of the watcher.
+ * This only gets called for lazy watchers.
+ */
+Watcher.prototype.evaluate = function evaluate () {
+  this.value = this.get();
+  this.dirty = false;
+};
+
+/**
+ * Depend on all deps collected by this watcher.
+ */
+Watcher.prototype.depend = function depend () {
+    var this$1 = this;
+
+  var i = this.deps.length;
+  while (i--) {
+    this$1.deps[i].depend();
+  }
+};
+
+/**
+ * Remove self from all dependencies' subscriber list.
+ */
+Watcher.prototype.teardown = function teardown () {
+    var this$1 = this;
+
+  if (this.active) {
+    // remove self from vm's watcher list
+    // this is a somewhat expensive operation so we skip it
+    // if the vm is being destroyed.
+    if (!this.vm._isBeingDestroyed) {
+      remove(this.vm._watchers, this);
+    }
+    var i = this.deps.length;
+    while (i--) {
+      this$1.deps[i].removeSub(this$1);
+    }
+    this.active = false;
+  }
+};
+
+/**
+ * Recursively traverse an object to evoke all converted
+ * getters, so that every nested property inside the object
+ * is collected as a "deep" dependency.
+ */
+var seenObjects = new _Set();
+function traverse (val) {
+  seenObjects.clear();
+  _traverse(val, seenObjects);
+}
+
+function _traverse (val, seen) {
+  var i, keys;
+  var isA = Array.isArray(val);
+  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
+    return
+  }
+  if (val.__ob__) {
+    var depId = val.__ob__.dep.id;
+    if (seen.has(depId)) {
+      return
+    }
+    seen.add(depId);
+  }
+  if (isA) {
+    i = val.length;
+    while (i--) { _traverse(val[i], seen); }
+  } else {
+    keys = Object.keys(val);
+    i = keys.length;
+    while (i--) { _traverse(val[keys[i]], seen); }
+  }
+}
+
+/*  */
+
+var sharedPropertyDefinition = {
+  enumerable: true,
+  configurable: true,
+  get: noop,
+  set: noop
+};
+
+function proxy (target, sourceKey, key) {
+  sharedPropertyDefinition.get = function proxyGetter () {
+    return this[sourceKey][key]
+  };
+  sharedPropertyDefinition.set = function proxySetter (val) {
+    this[sourceKey][key] = val;
+  };
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function initState (vm) {
+  vm._watchers = [];
+  var opts = vm.$options;
+  if (opts.props) { initProps(vm, opts.props); }
+  if (opts.methods) { initMethods(vm, opts.methods); }
+  if (opts.data) {
+    initData(vm);
+  } else {
+    observe(vm._data = {}, true /* asRootData */);
+  }
+  if (opts.computed) { initComputed(vm, opts.computed); }
+  if (opts.watch) { initWatch(vm, opts.watch); }
+}
+
+var isReservedProp = { key: 1, ref: 1, slot: 1 };
+
+function initProps (vm, propsOptions) {
+  var propsData = vm.$options.propsData || {};
+  var props = vm._props = {};
+  // cache prop keys so that future props updates can iterate using Array
+  // instead of dynamic object key enumeration.
+  var keys = vm.$options._propKeys = [];
+  var isRoot = !vm.$parent;
+  // root instance props should be converted
+  observerState.shouldConvert = isRoot;
+  var loop = function ( key ) {
+    keys.push(key);
+    var value = validateProp(key, propsOptions, propsData, vm);
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      if (isReservedProp[key]) {
+        warn(
+          ("\"" + key + "\" is a reserved attribute and cannot be used as component prop."),
+          vm
+        );
+      }
+      defineReactive$$1(props, key, value, function () {
+        if (vm.$parent && !observerState.isSettingProps) {
+          warn(
+            "Avoid mutating a prop directly since the value will be " +
+            "overwritten whenever the parent component re-renders. " +
+            "Instead, use a data or computed property based on the prop's " +
+            "value. Prop being mutated: \"" + key + "\"",
+            vm
+          );
+        }
+      });
+    } else {
+      defineReactive$$1(props, key, value);
+    }
+    // static props are already proxied on the component's prototype
+    // during Vue.extend(). We only need to proxy props defined at
+    // instantiation here.
+    if (!(key in vm)) {
+      proxy(vm, "_props", key);
+    }
+  };
+
+  for (var key in propsOptions) loop( key );
+  observerState.shouldConvert = true;
+}
+
+function initData (vm) {
+  var data = vm.$options.data;
+  data = vm._data = typeof data === 'function'
+    ? data.call(vm)
+    : data || {};
+  if (!isPlainObject(data)) {
+    data = {};
+    process.env.NODE_ENV !== 'production' && warn(
+      'data functions should return an object:\n' +
+      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
+      vm
+    );
+  }
+  // proxy data on instance
+  var keys = Object.keys(data);
+  var props = vm.$options.props;
+  var i = keys.length;
+  while (i--) {
+    if (props && hasOwn(props, keys[i])) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "The data property \"" + (keys[i]) + "\" is already declared as a prop. " +
+        "Use prop default value instead.",
+        vm
+      );
+    } else if (!isReserved(keys[i])) {
+      proxy(vm, "_data", keys[i]);
+    }
+  }
+  // observe data
+  observe(data, true /* asRootData */);
+}
+
+var computedWatcherOptions = { lazy: true };
+
+function initComputed (vm, computed) {
+  var watchers = vm._computedWatchers = Object.create(null);
+
+  for (var key in computed) {
+    var userDef = computed[key];
+    var getter = typeof userDef === 'function' ? userDef : userDef.get;
+    // create internal watcher for the computed property.
+    watchers[key] = new Watcher(vm, getter, noop, computedWatcherOptions);
+
+    // component-defined computed properties are already defined on the
+    // component prototype. We only need to define computed properties defined
+    // at instantiation here.
+    if (!(key in vm)) {
+      defineComputed(vm, key, userDef);
+    }
+  }
+}
+
+function defineComputed (target, key, userDef) {
+  if (typeof userDef === 'function') {
+    sharedPropertyDefinition.get = createComputedGetter(key);
+    sharedPropertyDefinition.set = noop;
+  } else {
+    sharedPropertyDefinition.get = userDef.get
+      ? userDef.cache !== false
+        ? createComputedGetter(key)
+        : userDef.get
+      : noop;
+    sharedPropertyDefinition.set = userDef.set
+      ? userDef.set
+      : noop;
+  }
+  Object.defineProperty(target, key, sharedPropertyDefinition);
+}
+
+function createComputedGetter (key) {
+  return function computedGetter () {
+    var watcher = this._computedWatchers && this._computedWatchers[key];
+    if (watcher) {
+      if (watcher.dirty) {
+        watcher.evaluate();
+      }
+      if (Dep.target) {
+        watcher.depend();
+      }
+      return watcher.value
+    }
+  }
+}
+
+function initMethods (vm, methods) {
+  var props = vm.$options.props;
+  for (var key in methods) {
+    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
+    if (process.env.NODE_ENV !== 'production') {
+      if (methods[key] == null) {
+        warn(
+          "method \"" + key + "\" has an undefined value in the component definition. " +
+          "Did you reference the function correctly?",
+          vm
+        );
+      }
+      if (props && hasOwn(props, key)) {
+        warn(
+          ("method \"" + key + "\" has already been defined as a prop."),
+          vm
+        );
+      }
+    }
+  }
+}
+
+function initWatch (vm, watch) {
+  for (var key in watch) {
+    var handler = watch[key];
+    if (Array.isArray(handler)) {
+      for (var i = 0; i < handler.length; i++) {
+        createWatcher(vm, key, handler[i]);
+      }
+    } else {
+      createWatcher(vm, key, handler);
+    }
+  }
+}
+
+function createWatcher (vm, key, handler) {
+  var options;
+  if (isPlainObject(handler)) {
+    options = handler;
+    handler = handler.handler;
+  }
+  if (typeof handler === 'string') {
+    handler = vm[handler];
+  }
+  vm.$watch(key, handler, options);
+}
+
+function stateMixin (Vue) {
+  // flow somehow has problems with directly declared definition object
+  // when using Object.defineProperty, so we have to procedurally build up
+  // the object here.
+  var dataDef = {};
+  dataDef.get = function () { return this._data };
+  var propsDef = {};
+  propsDef.get = function () { return this._props };
+  if (process.env.NODE_ENV !== 'production') {
+    dataDef.set = function (newData) {
+      warn(
+        'Avoid replacing instance root $data. ' +
+        'Use nested data properties instead.',
+        this
+      );
+    };
+    propsDef.set = function () {
+      warn("$props is readonly.", this);
+    };
+  }
+  Object.defineProperty(Vue.prototype, '$data', dataDef);
+  Object.defineProperty(Vue.prototype, '$props', propsDef);
+
+  Vue.prototype.$set = set;
+  Vue.prototype.$delete = del;
+
+  Vue.prototype.$watch = function (
+    expOrFn,
+    cb,
+    options
+  ) {
+    var vm = this;
+    options = options || {};
+    options.user = true;
+    var watcher = new Watcher(vm, expOrFn, cb, options);
+    if (options.immediate) {
+      cb.call(vm, watcher.value);
+    }
+    return function unwatchFn () {
+      watcher.teardown();
+    }
+  };
+}
+
+/*  */
+
+var hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy };
+var hooksToMerge = Object.keys(hooks);
+
+function createComponent (
+  Ctor,
+  data,
+  context,
+  children,
+  tag
+) {
+  if (!Ctor) {
+    return
+  }
+
+  var baseCtor = context.$options._base;
+  if (isObject(Ctor)) {
+    Ctor = baseCtor.extend(Ctor);
+  }
+
+  if (typeof Ctor !== 'function') {
+    if (process.env.NODE_ENV !== 'production') {
+      warn(("Invalid Component definition: " + (String(Ctor))), context);
+    }
+    return
+  }
+
+  // async component
+  if (!Ctor.cid) {
+    if (Ctor.resolved) {
+      Ctor = Ctor.resolved;
+    } else {
+      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {
+        // it's ok to queue this on every render because
+        // $forceUpdate is buffered by the scheduler.
+        context.$forceUpdate();
+      });
+      if (!Ctor) {
+        // return nothing if this is indeed an async component
+        // wait for the callback to trigger parent update.
+        return
+      }
+    }
+  }
+
+  // resolve constructor options in case global mixins are applied after
+  // component constructor creation
+  resolveConstructorOptions(Ctor);
+
+  data = data || {};
+
+  // transform component v-model data into props & events
+  if (data.model) {
+    transformModel(Ctor.options, data);
+  }
+
+  // extract props
+  var propsData = extractProps(data, Ctor);
+
+  // functional component
+  if (Ctor.options.functional) {
+    return createFunctionalComponent(Ctor, propsData, data, context, children)
+  }
+
+  // extract listeners, since these needs to be treated as
+  // child component listeners instead of DOM listeners
+  var listeners = data.on;
+  // replace with listeners with .native modifier
+  data.on = data.nativeOn;
+
+  if (Ctor.options.abstract) {
+    // abstract components do not keep anything
+    // other than props & listeners
+    data = {};
+  }
+
+  // merge component management hooks onto the placeholder node
+  mergeHooks(data);
+
+  // return a placeholder vnode
+  var name = Ctor.options.name || tag;
+  var vnode = new VNode(
+    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
+    data, undefined, undefined, undefined, context,
+    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }
+  );
+  return vnode
+}
+
+function createFunctionalComponent (
+  Ctor,
+  propsData,
+  data,
+  context,
+  children
+) {
+  var props = {};
+  var propOptions = Ctor.options.props;
+  if (propOptions) {
+    for (var key in propOptions) {
+      props[key] = validateProp(key, propOptions, propsData);
+    }
+  }
+  // ensure the createElement function in functional components
+  // gets a unique context - this is necessary for correct named slot check
+  var _context = Object.create(context);
+  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };
+  var vnode = Ctor.options.render.call(null, h, {
+    props: props,
+    data: data,
+    parent: context,
+    children: children,
+    slots: function () { return resolveSlots(children, context); }
+  });
+  if (vnode instanceof VNode) {
+    vnode.functionalContext = context;
+    if (data.slot) {
+      (vnode.data || (vnode.data = {})).slot = data.slot;
+    }
+  }
+  return vnode
+}
+
+function createComponentInstanceForVnode (
+  vnode, // we know it's MountedComponentVNode but flow doesn't
+  parent, // activeInstance in lifecycle state
+  parentElm,
+  refElm
+) {
+  var vnodeComponentOptions = vnode.componentOptions;
+  var options = {
+    _isComponent: true,
+    parent: parent,
+    propsData: vnodeComponentOptions.propsData,
+    _componentTag: vnodeComponentOptions.tag,
+    _parentVnode: vnode,
+    _parentListeners: vnodeComponentOptions.listeners,
+    _renderChildren: vnodeComponentOptions.children,
+    _parentElm: parentElm || null,
+    _refElm: refElm || null
+  };
+  // check inline-template render functions
+  var inlineTemplate = vnode.data.inlineTemplate;
+  if (inlineTemplate) {
+    options.render = inlineTemplate.render;
+    options.staticRenderFns = inlineTemplate.staticRenderFns;
+  }
+  return new vnodeComponentOptions.Ctor(options)
+}
+
+function init (
+  vnode,
+  hydrating,
+  parentElm,
+  refElm
+) {
+  if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
+    var child = vnode.componentInstance = createComponentInstanceForVnode(
+      vnode,
+      activeInstance,
+      parentElm,
+      refElm
+    );
+    child.$mount(hydrating ? vnode.elm : undefined, hydrating);
+  } else if (vnode.data.keepAlive) {
+    // kept-alive components, treat as a patch
+    var mountedNode = vnode; // work around flow
+    prepatch(mountedNode, mountedNode);
+  }
+}
+
+function prepatch (
+  oldVnode,
+  vnode
+) {
+  var options = vnode.componentOptions;
+  var child = vnode.componentInstance = oldVnode.componentInstance;
+  updateChildComponent(
+    child,
+    options.propsData, // updated props
+    options.listeners, // updated listeners
+    vnode, // new parent vnode
+    options.children // new children
+  );
+}
+
+function insert (vnode) {
+  if (!vnode.componentInstance._isMounted) {
+    vnode.componentInstance._isMounted = true;
+    callHook(vnode.componentInstance, 'mounted');
+  }
+  if (vnode.data.keepAlive) {
+    activateChildComponent(vnode.componentInstance, true /* direct */);
+  }
+}
+
+function destroy (vnode) {
+  if (!vnode.componentInstance._isDestroyed) {
+    if (!vnode.data.keepAlive) {
+      vnode.componentInstance.$destroy();
+    } else {
+      deactivateChildComponent(vnode.componentInstance, true /* direct */);
+    }
+  }
+}
+
+function resolveAsyncComponent (
+  factory,
+  baseCtor,
+  cb
+) {
+  if (factory.requested) {
+    // pool callbacks
+    factory.pendingCallbacks.push(cb);
+  } else {
+    factory.requested = true;
+    var cbs = factory.pendingCallbacks = [cb];
+    var sync = true;
+
+    var resolve = function (res) {
+      if (isObject(res)) {
+        res = baseCtor.extend(res);
+      }
+      // cache resolved
+      factory.resolved = res;
+      // invoke callbacks only if this is not a synchronous resolve
+      // (async resolves are shimmed as synchronous during SSR)
+      if (!sync) {
+        for (var i = 0, l = cbs.length; i < l; i++) {
+          cbs[i](res);
+        }
+      }
+    };
+
+    var reject = function (reason) {
+      process.env.NODE_ENV !== 'production' && warn(
+        "Failed to resolve async component: " + (String(factory)) +
+        (reason ? ("\nReason: " + reason) : '')
+      );
+    };
+
+    var res = factory(resolve, reject);
+
+    // handle promise
+    if (res && typeof res.then === 'function' && !factory.resolved) {
+      res.then(resolve, reject);
+    }
+
+    sync = false;
+    // return in case resolved synchronously
+    return factory.resolved
+  }
+}
+
+function extractProps (data, Ctor) {
+  // we are only extracting raw values here.
+  // validation and default values are handled in the child
+  // component itself.
+  var propOptions = Ctor.options.props;
+  if (!propOptions) {
+    return
+  }
+  var res = {};
+  var attrs = data.attrs;
+  var props = data.props;
+  var domProps = data.domProps;
+  if (attrs || props || domProps) {
+    for (var key in propOptions) {
+      var altKey = hyphenate(key);
+      checkProp(res, props, key, altKey, true) ||
+      checkProp(res, attrs, key, altKey) ||
+      checkProp(res, domProps, key, altKey);
+    }
+  }
+  return res
+}
+
+function checkProp (
+  res,
+  hash,
+  key,
+  altKey,
+  preserve
+) {
+  if (hash) {
+    if (hasOwn(hash, key)) {
+      res[key] = hash[key];
+      if (!preserve) {
+        delete hash[key];
+      }
+      return true
+    } else if (hasOwn(hash, altKey)) {
+      res[key] = hash[altKey];
+      if (!preserve) {
+        delete hash[altKey];
+      }
+      return true
+    }
+  }
+  return false
+}
+
+function mergeHooks (data) {
+  if (!data.hook) {
+    data.hook = {};
+  }
+  for (var i = 0; i < hooksToMerge.length; i++) {
+    var key = hooksToMerge[i];
+    var fromParent = data.hook[key];
+    var ours = hooks[key];
+    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
+  }
+}
+
+function mergeHook$1 (one, two) {
+  return function (a, b, c, d) {
+    one(a, b, c, d);
+    two(a, b, c, d);
+  }
+}
+
+// transform component v-model info (value and callback) into
+// prop and event handler respectively.
+function transformModel (options, data) {
+  var prop = (options.model && options.model.prop) || 'value';
+  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
+  var on = data.on || (data.on = {});
+  if (on[event]) {
+    on[event] = [data.model.callback].concat(on[event]);
+  } else {
+    on[event] = data.model.callback;
+  }
+}
+
+/*  */
+
+var SIMPLE_NORMALIZE = 1;
+var ALWAYS_NORMALIZE = 2;
+
+// wrapper function for providing a more flexible interface
+// without getting yelled at by flow
+function createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType,
+  alwaysNormalize
+) {
+  if (Array.isArray(data) || isPrimitive(data)) {
+    normalizationType = children;
+    children = data;
+    data = undefined;
+  }
+  if (alwaysNormalize) { normalizationType = ALWAYS_NORMALIZE; }
+  return _createElement(context, tag, data, children, normalizationType)
+}
+
+function _createElement (
+  context,
+  tag,
+  data,
+  children,
+  normalizationType
+) {
+  if (data && data.__ob__) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
+      'Always create fresh vnode data objects in each render!',
+      context
+    );
+    return createEmptyVNode()
+  }
+  if (!tag) {
+    // in case of component :is set to falsy value
+    return createEmptyVNode()
+  }
+  // support single function children as default scoped slot
+  if (Array.isArray(children) &&
+      typeof children[0] === 'function') {
+    data = data || {};
+    data.scopedSlots = { default: children[0] };
+    children.length = 0;
+  }
+  if (normalizationType === ALWAYS_NORMALIZE) {
+    children = normalizeChildren(children);
+  } else if (normalizationType === SIMPLE_NORMALIZE) {
+    children = simpleNormalizeChildren(children);
+  }
+  var vnode, ns;
+  if (typeof tag === 'string') {
+    var Ctor;
+    ns = config.getTagNamespace(tag);
+    if (config.isReservedTag(tag)) {
+      // platform built-in elements
+      vnode = new VNode(
+        config.parsePlatformTagName(tag), data, children,
+        undefined, undefined, context
+      );
+    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {
+      // component
+      vnode = createComponent(Ctor, data, context, children, tag);
+    } else {
+      // unknown or unlisted namespaced elements
+      // check at runtime because it may get assigned a namespace when its
+      // parent normalizes children
+      vnode = new VNode(
+        tag, data, children,
+        undefined, undefined, context
+      );
+    }
+  } else {
+    // direct component options / constructor
+    vnode = createComponent(tag, data, context, children);
+  }
+  if (vnode) {
+    if (ns) { applyNS(vnode, ns); }
+    return vnode
+  } else {
+    return createEmptyVNode()
+  }
+}
+
+function applyNS (vnode, ns) {
+  vnode.ns = ns;
+  if (vnode.tag === 'foreignObject') {
+    // use default namespace inside foreignObject
+    return
+  }
+  if (vnode.children) {
+    for (var i = 0, l = vnode.children.length; i < l; i++) {
+      var child = vnode.children[i];
+      if (child.tag && !child.ns) {
+        applyNS(child, ns);
+      }
+    }
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering v-for lists.
+ */
+function renderList (
+  val,
+  render
+) {
+  var ret, i, l, keys, key;
+  if (Array.isArray(val) || typeof val === 'string') {
+    ret = new Array(val.length);
+    for (i = 0, l = val.length; i < l; i++) {
+      ret[i] = render(val[i], i);
+    }
+  } else if (typeof val === 'number') {
+    ret = new Array(val);
+    for (i = 0; i < val; i++) {
+      ret[i] = render(i + 1, i);
+    }
+  } else if (isObject(val)) {
+    keys = Object.keys(val);
+    ret = new Array(keys.length);
+    for (i = 0, l = keys.length; i < l; i++) {
+      key = keys[i];
+      ret[i] = render(val[key], key, i);
+    }
+  }
+  return ret
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering <slot>
+ */
+function renderSlot (
+  name,
+  fallback,
+  props,
+  bindObject
+) {
+  var scopedSlotFn = this.$scopedSlots[name];
+  if (scopedSlotFn) { // scoped slot
+    props = props || {};
+    if (bindObject) {
+      extend(props, bindObject);
+    }
+    return scopedSlotFn(props) || fallback
+  } else {
+    var slotNodes = this.$slots[name];
+    // warn duplicate slot usage
+    if (slotNodes && process.env.NODE_ENV !== 'production') {
+      slotNodes._rendered && warn(
+        "Duplicate presence of slot \"" + name + "\" found in the same render tree " +
+        "- this will likely cause render errors.",
+        this
+      );
+      slotNodes._rendered = true;
+    }
+    return slotNodes || fallback
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for resolving filters
+ */
+function resolveFilter (id) {
+  return resolveAsset(this.$options, 'filters', id, true) || identity
+}
+
+/*  */
+
+/**
+ * Runtime helper for checking keyCodes from config.
+ */
+function checkKeyCodes (
+  eventKeyCode,
+  key,
+  builtInAlias
+) {
+  var keyCodes = config.keyCodes[key] || builtInAlias;
+  if (Array.isArray(keyCodes)) {
+    return keyCodes.indexOf(eventKeyCode) === -1
+  } else {
+    return keyCodes !== eventKeyCode
+  }
+}
+
+/*  */
+
+/**
+ * Runtime helper for merging v-bind="object" into a VNode's data.
+ */
+function bindObjectProps (
+  data,
+  tag,
+  value,
+  asProp
+) {
+  if (value) {
+    if (!isObject(value)) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'v-bind without argument expects an Object or Array value',
+        this
+      );
+    } else {
+      if (Array.isArray(value)) {
+        value = toObject(value);
+      }
+      for (var key in value) {
+        if (key === 'class' || key === 'style') {
+          data[key] = value[key];
+        } else {
+          var type = data.attrs && data.attrs.type;
+          var hash = asProp || config.mustUseProp(tag, type, key)
+            ? data.domProps || (data.domProps = {})
+            : data.attrs || (data.attrs = {});
+          hash[key] = value[key];
+        }
+      }
+    }
+  }
+  return data
+}
+
+/*  */
+
+/**
+ * Runtime helper for rendering static trees.
+ */
+function renderStatic (
+  index,
+  isInFor
+) {
+  var tree = this._staticTrees[index];
+  // if has already-rendered static tree and not inside v-for,
+  // we can reuse the same tree by doing a shallow clone.
+  if (tree && !isInFor) {
+    return Array.isArray(tree)
+      ? cloneVNodes(tree)
+      : cloneVNode(tree)
+  }
+  // otherwise, render a fresh tree.
+  tree = this._staticTrees[index] =
+    this.$options.staticRenderFns[index].call(this._renderProxy);
+  markStatic(tree, ("__static__" + index), false);
+  return tree
+}
+
+/**
+ * Runtime helper for v-once.
+ * Effectively it means marking the node as static with a unique key.
+ */
+function markOnce (
+  tree,
+  index,
+  key
+) {
+  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
+  return tree
+}
+
+function markStatic (
+  tree,
+  key,
+  isOnce
+) {
+  if (Array.isArray(tree)) {
+    for (var i = 0; i < tree.length; i++) {
+      if (tree[i] && typeof tree[i] !== 'string') {
+        markStaticNode(tree[i], (key + "_" + i), isOnce);
+      }
+    }
+  } else {
+    markStaticNode(tree, key, isOnce);
+  }
+}
+
+function markStaticNode (node, key, isOnce) {
+  node.isStatic = true;
+  node.key = key;
+  node.isOnce = isOnce;
+}
+
+/*  */
+
+function initRender (vm) {
+  vm.$vnode = null; // the placeholder node in parent tree
+  vm._vnode = null; // the root of the child tree
+  vm._staticTrees = null;
+  var parentVnode = vm.$options._parentVnode;
+  var renderContext = parentVnode && parentVnode.context;
+  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);
+  vm.$scopedSlots = emptyObject;
+  // bind the createElement fn to this instance
+  // so that we get proper render context inside it.
+  // args order: tag, data, children, normalizationType, alwaysNormalize
+  // internal version is used by render functions compiled from templates
+  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
+  // normalization is always applied for the public version, used in
+  // user-written render functions.
+  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };
+}
+
+function renderMixin (Vue) {
+  Vue.prototype.$nextTick = function (fn) {
+    return nextTick(fn, this)
+  };
+
+  Vue.prototype._render = function () {
+    var vm = this;
+    var ref = vm.$options;
+    var render = ref.render;
+    var staticRenderFns = ref.staticRenderFns;
+    var _parentVnode = ref._parentVnode;
+
+    if (vm._isMounted) {
+      // clone slot nodes on re-renders
+      for (var key in vm.$slots) {
+        vm.$slots[key] = cloneVNodes(vm.$slots[key]);
+      }
+    }
+
+    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;
+
+    if (staticRenderFns && !vm._staticTrees) {
+      vm._staticTrees = [];
+    }
+    // set parent vnode. this allows render functions to have access
+    // to the data on the placeholder node.
+    vm.$vnode = _parentVnode;
+    // render self
+    var vnode;
+    try {
+      vnode = render.call(vm._renderProxy, vm.$createElement);
+    } catch (e) {
+      handleError(e, vm, "render function");
+      // return error render result,
+      // or previous vnode to prevent render error causing blank component
+      /* istanbul ignore else */
+      if (process.env.NODE_ENV !== 'production') {
+        vnode = vm.$options.renderError
+          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
+          : vm._vnode;
+      } else {
+        vnode = vm._vnode;
+      }
+    }
+    // return empty vnode in case the render function errored out
+    if (!(vnode instanceof VNode)) {
+      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
+        warn(
+          'Multiple root nodes returned from render function. Render function ' +
+          'should return a single root node.',
+          vm
+        );
+      }
+      vnode = createEmptyVNode();
+    }
+    // set parent
+    vnode.parent = _parentVnode;
+    return vnode
+  };
+
+  // internal render helpers.
+  // these are exposed on the instance prototype to reduce generated render
+  // code size.
+  Vue.prototype._o = markOnce;
+  Vue.prototype._n = toNumber;
+  Vue.prototype._s = _toString;
+  Vue.prototype._l = renderList;
+  Vue.prototype._t = renderSlot;
+  Vue.prototype._q = looseEqual;
+  Vue.prototype._i = looseIndexOf;
+  Vue.prototype._m = renderStatic;
+  Vue.prototype._f = resolveFilter;
+  Vue.prototype._k = checkKeyCodes;
+  Vue.prototype._b = bindObjectProps;
+  Vue.prototype._v = createTextVNode;
+  Vue.prototype._e = createEmptyVNode;
+  Vue.prototype._u = resolveScopedSlots;
+}
+
+/*  */
+
+function initProvide (vm) {
+  var provide = vm.$options.provide;
+  if (provide) {
+    vm._provided = typeof provide === 'function'
+      ? provide.call(vm)
+      : provide;
+  }
+}
+
+function initInjections (vm) {
+  var inject = vm.$options.inject;
+  if (inject) {
+    // inject is :any because flow is not smart enough to figure out cached
+    // isArray here
+    var isArray = Array.isArray(inject);
+    var keys = isArray
+      ? inject
+      : hasSymbol
+        ? Reflect.ownKeys(inject)
+        : Object.keys(inject);
+
+    for (var i = 0; i < keys.length; i++) {
+      var key = keys[i];
+      var provideKey = isArray ? key : inject[key];
+      var source = vm;
+      while (source) {
+        if (source._provided && provideKey in source._provided) {
+          vm[key] = source._provided[provideKey];
+          break
+        }
+        source = source.$parent;
+      }
+    }
+  }
+}
+
+/*  */
+
+var uid = 0;
+
+function initMixin (Vue) {
+  Vue.prototype._init = function (options) {
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      perf.mark('init');
+    }
+
+    var vm = this;
+    // a uid
+    vm._uid = uid++;
+    // a flag to avoid this being observed
+    vm._isVue = true;
+    // merge options
+    if (options && options._isComponent) {
+      // optimize internal component instantiation
+      // since dynamic options merging is pretty slow, and none of the
+      // internal component options needs special treatment.
+      initInternalComponent(vm, options);
+    } else {
+      vm.$options = mergeOptions(
+        resolveConstructorOptions(vm.constructor),
+        options || {},
+        vm
+      );
+    }
+    /* istanbul ignore else */
+    if (process.env.NODE_ENV !== 'production') {
+      initProxy(vm);
+    } else {
+      vm._renderProxy = vm;
+    }
+    // expose real self
+    vm._self = vm;
+    initLifecycle(vm);
+    initEvents(vm);
+    initRender(vm);
+    callHook(vm, 'beforeCreate');
+    initInjections(vm); // resolve injections before data/props
+    initState(vm);
+    initProvide(vm); // resolve provide after data/props
+    callHook(vm, 'created');
+
+    /* istanbul ignore if */
+    if (process.env.NODE_ENV !== 'production' && config.performance && perf) {
+      vm._name = formatComponentName(vm, false);
+      perf.mark('init end');
+      perf.measure(((vm._name) + " init"), 'init', 'init end');
+    }
+
+    if (vm.$options.el) {
+      vm.$mount(vm.$options.el);
+    }
+  };
+}
+
+function initInternalComponent (vm, options) {
+  var opts = vm.$options = Object.create(vm.constructor.options);
+  // doing this because it's faster than dynamic enumeration.
+  opts.parent = options.parent;
+  opts.propsData = options.propsData;
+  opts._parentVnode = options._parentVnode;
+  opts._parentListeners = options._parentListeners;
+  opts._renderChildren = options._renderChildren;
+  opts._componentTag = options._componentTag;
+  opts._parentElm = options._parentElm;
+  opts._refElm = options._refElm;
+  if (options.render) {
+    opts.render = options.render;
+    opts.staticRenderFns = options.staticRenderFns;
+  }
+}
+
+function resolveConstructorOptions (Ctor) {
+  var options = Ctor.options;
+  if (Ctor.super) {
+    var superOptions = resolveConstructorOptions(Ctor.super);
+    var cachedSuperOptions = Ctor.superOptions;
+    if (superOptions !== cachedSuperOptions) {
+      // super option changed,
+      // need to resolve new options.
+      Ctor.superOptions = superOptions;
+      // check if there are any late-modified/attached options (#4976)
+      var modifiedOptions = resolveModifiedOptions(Ctor);
+      // update base extend options
+      if (modifiedOptions) {
+        extend(Ctor.extendOptions, modifiedOptions);
+      }
+      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
+      if (options.name) {
+        options.components[options.name] = Ctor;
+      }
+    }
+  }
+  return options
+}
+
+function resolveModifiedOptions (Ctor) {
+  var modified;
+  var latest = Ctor.options;
+  var sealed = Ctor.sealedOptions;
+  for (var key in latest) {
+    if (latest[key] !== sealed[key]) {
+      if (!modified) { modified = {}; }
+      modified[key] = dedupe(latest[key], sealed[key]);
+    }
+  }
+  return modified
+}
+
+function dedupe (latest, sealed) {
+  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
+  // between merges
+  if (Array.isArray(latest)) {
+    var res = [];
+    sealed = Array.isArray(sealed) ? sealed : [sealed];
+    for (var i = 0; i < latest.length; i++) {
+      if (sealed.indexOf(latest[i]) < 0) {
+        res.push(latest[i]);
+      }
+    }
+    return res
+  } else {
+    return latest
+  }
+}
+
+function Vue$2 (options) {
+  if (process.env.NODE_ENV !== 'production' &&
+    !(this instanceof Vue$2)) {
+    warn('Vue is a constructor and should be called with the `new` keyword');
+  }
+  this._init(options);
+}
+
+initMixin(Vue$2);
+stateMixin(Vue$2);
+eventsMixin(Vue$2);
+lifecycleMixin(Vue$2);
+renderMixin(Vue$2);
+
+/*  */
+
+function initUse (Vue) {
+  Vue.use = function (plugin) {
+    /* istanbul ignore if */
+    if (plugin.installed) {
+      return
+    }
+    // additional parameters
+    var args = toArray(arguments, 1);
+    args.unshift(this);
+    if (typeof plugin.install === 'function') {
+      plugin.install.apply(plugin, args);
+    } else if (typeof plugin === 'function') {
+      plugin.apply(null, args);
+    }
+    plugin.installed = true;
+    return this
+  };
+}
+
+/*  */
+
+function initMixin$1 (Vue) {
+  Vue.mixin = function (mixin) {
+    this.options = mergeOptions(this.options, mixin);
+  };
+}
+
+/*  */
+
+function initExtend (Vue) {
+  /**
+   * Each instance constructor, including Vue, has a unique
+   * cid. This enables us to create wrapped "child
+   * constructors" for prototypal inheritance and cache them.
+   */
+  Vue.cid = 0;
+  var cid = 1;
+
+  /**
+   * Class inheritance
+   */
+  Vue.extend = function (extendOptions) {
+    extendOptions = extendOptions || {};
+    var Super = this;
+    var SuperId = Super.cid;
+    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
+    if (cachedCtors[SuperId]) {
+      return cachedCtors[SuperId]
+    }
+
+    var name = extendOptions.name || Super.options.name;
+    if (process.env.NODE_ENV !== 'production') {
+      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
+        warn(
+          'Invalid component name: "' + name + '". Component names ' +
+          'can only contain alphanumeric characters and the hyphen, ' +
+          'and must start with a letter.'
+        );
+      }
+    }
+
+    var Sub = function VueComponent (options) {
+      this._init(options);
+    };
+    Sub.prototype = Object.create(Super.prototype);
+    Sub.prototype.constructor = Sub;
+    Sub.cid = cid++;
+    Sub.options = mergeOptions(
+      Super.options,
+      extendOptions
+    );
+    Sub['super'] = Super;
+
+    // For props and computed properties, we define the proxy getters on
+    // the Vue instances at extension time, on the extended prototype. This
+    // avoids Object.defineProperty calls for each instance created.
+    if (Sub.options.props) {
+      initProps$1(Sub);
+    }
+    if (Sub.options.computed) {
+      initComputed$1(Sub);
+    }
+
+    // allow further extension/mixin/plugin usage
+    Sub.extend = Super.extend;
+    Sub.mixin = Super.mixin;
+    Sub.use = Super.use;
+
+    // create asset registers, so extended classes
+    // can have their private assets too.
+    config._assetTypes.forEach(function (type) {
+      Sub[type] = Super[type];
+    });
+    // enable recursive self-lookup
+    if (name) {
+      Sub.options.components[name] = Sub;
+    }
+
+    // keep a reference to the super options at extension time.
+    // later at instantiation we can check if Super's options have
+    // been updated.
+    Sub.superOptions = Super.options;
+    Sub.extendOptions = extendOptions;
+    Sub.sealedOptions = extend({}, Sub.options);
+
+    // cache constructor
+    cachedCtors[SuperId] = Sub;
+    return Sub
+  };
+}
+
+function initProps$1 (Comp) {
+  var props = Comp.options.props;
+  for (var key in props) {
+    proxy(Comp.prototype, "_props", key);
+  }
+}
+
+function initComputed$1 (Comp) {
+  var computed = Comp.options.computed;
+  for (var key in computed) {
+    defineComputed(Comp.prototype, key, computed[key]);
+  }
+}
+
+/*  */
+
+function initAssetRegisters (Vue) {
+  /**
+   * Create asset registration methods.
+   */
+  config._assetTypes.forEach(function (type) {
+    Vue[type] = function (
+      id,
+      definition
+    ) {
+      if (!definition) {
+        return this.options[type + 's'][id]
+      } else {
+        /* istanbul ignore if */
+        if (process.env.NODE_ENV !== 'production') {
+          if (type === 'component' && config.isReservedTag(id)) {
+            warn(
+              'Do not use built-in or reserved HTML elements as component ' +
+              'id: ' + id
+            );
+          }
+        }
+        if (type === 'component' && isPlainObject(definition)) {
+          definition.name = definition.name || id;
+          definition = this.options._base.extend(definition);
+        }
+        if (type === 'directive' && typeof definition === 'function') {
+          definition = { bind: definition, update: definition };
+        }
+        this.options[type + 's'][id] = definition;
+        return definition
+      }
+    };
+  });
+}
+
+/*  */
+
+var patternTypes = [String, RegExp];
+
+function getComponentName (opts) {
+  return opts && (opts.Ctor.options.name || opts.tag)
+}
+
+function matches (pattern, name) {
+  if (typeof pattern === 'string') {
+    return pattern.split(',').indexOf(name) > -1
+  } else if (pattern instanceof RegExp) {
+    return pattern.test(name)
+  }
+  /* istanbul ignore next */
+  return false
+}
+
+function pruneCache (cache, filter) {
+  for (var key in cache) {
+    var cachedNode = cache[key];
+    if (cachedNode) {
+      var name = getComponentName(cachedNode.componentOptions);
+      if (name && !filter(name)) {
+        pruneCacheEntry(cachedNode);
+        cache[key] = null;
+      }
+    }
+  }
+}
+
+function pruneCacheEntry (vnode) {
+  if (vnode) {
+    if (!vnode.componentInstance._inactive) {
+      callHook(vnode.componentInstance, 'deactivated');
+    }
+    vnode.componentInstance.$destroy();
+  }
+}
+
+var KeepAlive = {
+  name: 'keep-alive',
+  abstract: true,
+
+  props: {
+    include: patternTypes,
+    exclude: patternTypes
+  },
+
+  created: function created () {
+    this.cache = Object.create(null);
+  },
+
+  destroyed: function destroyed () {
+    var this$1 = this;
+
+    for (var key in this$1.cache) {
+      pruneCacheEntry(this$1.cache[key]);
+    }
+  },
+
+  watch: {
+    include: function include (val) {
+      pruneCache(this.cache, function (name) { return matches(val, name); });
+    },
+    exclude: function exclude (val) {
+      pruneCache(this.cache, function (name) { return !matches(val, name); });
+    }
+  },
+
+  render: function render () {
+    var vnode = getFirstComponentChild(this.$slots.default);
+    var componentOptions = vnode && vnode.componentOptions;
+    if (componentOptions) {
+      // check pattern
+      var name = getComponentName(componentOptions);
+      if (name && (
+        (this.include && !matches(this.include, name)) ||
+        (this.exclude && matches(this.exclude, name))
+      )) {
+        return vnode
+      }
+      var key = vnode.key == null
+        // same constructor may get registered as different local components
+        // so cid alone is not enough (#3269)
+        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
+        : vnode.key;
+      if (this.cache[key]) {
+        vnode.componentInstance = this.cache[key].componentInstance;
+      } else {
+        this.cache[key] = vnode;
+      }
+      vnode.data.keepAlive = true;
+    }
+    return vnode
+  }
+};
+
+var builtInComponents = {
+  KeepAlive: KeepAlive
+};
+
+/*  */
+
+function initGlobalAPI (Vue) {
+  // config
+  var configDef = {};
+  configDef.get = function () { return config; };
+  if (process.env.NODE_ENV !== 'production') {
+    configDef.set = function () {
+      warn(
+        'Do not replace the Vue.config object, set individual fields instead.'
+      );
+    };
+  }
+  Object.defineProperty(Vue, 'config', configDef);
+
+  // exposed util methods.
+  // NOTE: these are not considered part of the public API - avoid relying on
+  // them unless you are aware of the risk.
+  Vue.util = {
+    warn: warn,
+    extend: extend,
+    mergeOptions: mergeOptions,
+    defineReactive: defineReactive$$1
+  };
+
+  Vue.set = set;
+  Vue.delete = del;
+  Vue.nextTick = nextTick;
+
+  Vue.options = Object.create(null);
+  config._assetTypes.forEach(function (type) {
+    Vue.options[type + 's'] = Object.create(null);
+  });
+
+  // this is used to identify the "base" constructor to extend all plain-object
+  // components with in Weex's multi-instance scenarios.
+  Vue.options._base = Vue;
+
+  extend(Vue.options.components, builtInComponents);
+
+  initUse(Vue);
+  initMixin$1(Vue);
+  initExtend(Vue);
+  initAssetRegisters(Vue);
+}
+
+initGlobalAPI(Vue$2);
+
+Object.defineProperty(Vue$2.prototype, '$isServer', {
+  get: isServerRendering
+});
+
+Vue$2.version = '2.2.2';
+
+/*  */
+
+// attributes that should be using props for binding
+var acceptValue = makeMap('input,textarea,option,select');
+var mustUseProp = function (tag, type, attr) {
+  return (
+    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
+    (attr === 'selected' && tag === 'option') ||
+    (attr === 'checked' && tag === 'input') ||
+    (attr === 'muted' && tag === 'video')
+  )
+};
+
+var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');
+
+var isBooleanAttr = makeMap(
+  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
+  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
+  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
+  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
+  'required,reversed,scoped,seamless,selected,sortable,translate,' +
+  'truespeed,typemustmatch,visible'
+);
+
+var xlinkNS = 'http://www.w3.org/1999/xlink';
+
+var isXlink = function (name) {
+  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
+};
+
+var getXlinkProp = function (name) {
+  return isXlink(name) ? name.slice(6, name.length) : ''
+};
+
+var isFalsyAttrValue = function (val) {
+  return val == null || val === false
+};
+
+/*  */
+
+function genClassForVnode (vnode) {
+  var data = vnode.data;
+  var parentNode = vnode;
+  var childNode = vnode;
+  while (childNode.componentInstance) {
+    childNode = childNode.componentInstance._vnode;
+    if (childNode.data) {
+      data = mergeClassData(childNode.data, data);
+    }
+  }
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data) {
+      data = mergeClassData(data, parentNode.data);
+    }
+  }
+  return genClassFromData(data)
+}
+
+function mergeClassData (child, parent) {
+  return {
+    staticClass: concat(child.staticClass, parent.staticClass),
+    class: child.class
+      ? [child.class, parent.class]
+      : parent.class
+  }
+}
+
+function genClassFromData (data) {
+  var dynamicClass = data.class;
+  var staticClass = data.staticClass;
+  if (staticClass || dynamicClass) {
+    return concat(staticClass, stringifyClass(dynamicClass))
+  }
+  /* istanbul ignore next */
+  return ''
+}
+
+function concat (a, b) {
+  return a ? b ? (a + ' ' + b) : a : (b || '')
+}
+
+function stringifyClass (value) {
+  var res = '';
+  if (!value) {
+    return res
+  }
+  if (typeof value === 'string') {
+    return value
+  }
+  if (Array.isArray(value)) {
+    var stringified;
+    for (var i = 0, l = value.length; i < l; i++) {
+      if (value[i]) {
+        if ((stringified = stringifyClass(value[i]))) {
+          res += stringified + ' ';
+        }
+      }
+    }
+    return res.slice(0, -1)
+  }
+  if (isObject(value)) {
+    for (var key in value) {
+      if (value[key]) { res += key + ' '; }
+    }
+    return res.slice(0, -1)
+  }
+  /* istanbul ignore next */
+  return res
+}
+
+/*  */
+
+var namespaceMap = {
+  svg: 'http://www.w3.org/2000/svg',
+  math: 'http://www.w3.org/1998/Math/MathML'
+};
+
+var isHTMLTag = makeMap(
+  'html,body,base,head,link,meta,style,title,' +
+  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
+  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +
+  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
+  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
+  'embed,object,param,source,canvas,script,noscript,del,ins,' +
+  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
+  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
+  'output,progress,select,textarea,' +
+  'details,dialog,menu,menuitem,summary,' +
+  'content,element,shadow,template'
+);
+
+// this map is intentionally selective, only covering SVG elements that may
+// contain child elements.
+var isSVG = makeMap(
+  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
+  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
+  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
+  true
+);
+
+
+
+var isReservedTag = function (tag) {
+  return isHTMLTag(tag) || isSVG(tag)
+};
+
+function getTagNamespace (tag) {
+  if (isSVG(tag)) {
+    return 'svg'
+  }
+  // basic support for MathML
+  // note it doesn't support other MathML elements being component roots
+  if (tag === 'math') {
+    return 'math'
+  }
+}
+
+var unknownElementCache = Object.create(null);
+function isUnknownElement (tag) {
+  /* istanbul ignore if */
+  if (!inBrowser) {
+    return true
+  }
+  if (isReservedTag(tag)) {
+    return false
+  }
+  tag = tag.toLowerCase();
+  /* istanbul ignore if */
+  if (unknownElementCache[tag] != null) {
+    return unknownElementCache[tag]
+  }
+  var el = document.createElement(tag);
+  if (tag.indexOf('-') > -1) {
+    // http://stackoverflow.com/a/28210364/1070244
+    return (unknownElementCache[tag] = (
+      el.constructor === window.HTMLUnknownElement ||
+      el.constructor === window.HTMLElement
+    ))
+  } else {
+    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
+  }
+}
+
+/*  */
+
+/**
+ * Query an element selector if it's not an element already.
+ */
+function query (el) {
+  if (typeof el === 'string') {
+    var selected = document.querySelector(el);
+    if (!selected) {
+      process.env.NODE_ENV !== 'production' && warn(
+        'Cannot find element: ' + el
+      );
+      return document.createElement('div')
+    }
+    return selected
+  } else {
+    return el
+  }
+}
+
+/*  */
+
+function createElement$1 (tagName, vnode) {
+  var elm = document.createElement(tagName);
+  if (tagName !== 'select') {
+    return elm
+  }
+  // false or null will remove the attribute but undefined will not
+  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
+    elm.setAttribute('multiple', 'multiple');
+  }
+  return elm
+}
+
+function createElementNS (namespace, tagName) {
+  return document.createElementNS(namespaceMap[namespace], tagName)
+}
+
+function createTextNode (text) {
+  return document.createTextNode(text)
+}
+
+function createComment (text) {
+  return document.createComment(text)
+}
+
+function insertBefore (parentNode, newNode, referenceNode) {
+  parentNode.insertBefore(newNode, referenceNode);
+}
+
+function removeChild (node, child) {
+  node.removeChild(child);
+}
+
+function appendChild (node, child) {
+  node.appendChild(child);
+}
+
+function parentNode (node) {
+  return node.parentNode
+}
+
+function nextSibling (node) {
+  return node.nextSibling
+}
+
+function tagName (node) {
+  return node.tagName
+}
+
+function setTextContent (node, text) {
+  node.textContent = text;
+}
+
+function setAttribute (node, key, val) {
+  node.setAttribute(key, val);
+}
+
+
+var nodeOps = Object.freeze({
+	createElement: createElement$1,
+	createElementNS: createElementNS,
+	createTextNode: createTextNode,
+	createComment: createComment,
+	insertBefore: insertBefore,
+	removeChild: removeChild,
+	appendChild: appendChild,
+	parentNode: parentNode,
+	nextSibling: nextSibling,
+	tagName: tagName,
+	setTextContent: setTextContent,
+	setAttribute: setAttribute
+});
+
+/*  */
+
+var ref = {
+  create: function create (_, vnode) {
+    registerRef(vnode);
+  },
+  update: function update (oldVnode, vnode) {
+    if (oldVnode.data.ref !== vnode.data.ref) {
+      registerRef(oldVnode, true);
+      registerRef(vnode);
+    }
+  },
+  destroy: function destroy (vnode) {
+    registerRef(vnode, true);
+  }
+};
+
+function registerRef (vnode, isRemoval) {
+  var key = vnode.data.ref;
+  if (!key) { return }
+
+  var vm = vnode.context;
+  var ref = vnode.componentInstance || vnode.elm;
+  var refs = vm.$refs;
+  if (isRemoval) {
+    if (Array.isArray(refs[key])) {
+      remove(refs[key], ref);
+    } else if (refs[key] === ref) {
+      refs[key] = undefined;
+    }
+  } else {
+    if (vnode.data.refInFor) {
+      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {
+        refs[key].push(ref);
+      } else {
+        refs[key] = [ref];
+      }
+    } else {
+      refs[key] = ref;
+    }
+  }
+}
+
+/**
+ * Virtual DOM patching algorithm based on Snabbdom by
+ * Simon Friis Vindum (@paldepind)
+ * Licensed under the MIT License
+ * https://github.com/paldepind/snabbdom/blob/master/LICENSE
+ *
+ * modified by Evan You (@yyx990803)
+ *
+
+/*
+ * Not type-checking this because this file is perf-critical and the cost
+ * of making flow understand it is not worth it.
+ */
+
+var emptyNode = new VNode('', {}, []);
+
+var hooks$1 = ['create', 'activate', 'update', 'remove', 'destroy'];
+
+function isUndef (s) {
+  return s == null
+}
+
+function isDef (s) {
+  return s != null
+}
+
+function sameVnode (vnode1, vnode2) {
+  return (
+    vnode1.key === vnode2.key &&
+    vnode1.tag === vnode2.tag &&
+    vnode1.isComment === vnode2.isComment &&
+    !vnode1.data === !vnode2.data
+  )
+}
+
+function createKeyToOldIdx (children, beginIdx, endIdx) {
+  var i, key;
+  var map = {};
+  for (i = beginIdx; i <= endIdx; ++i) {
+    key = children[i].key;
+    if (isDef(key)) { map[key] = i; }
+  }
+  return map
+}
+
+function createPatchFunction (backend) {
+  var i, j;
+  var cbs = {};
+
+  var modules = backend.modules;
+  var nodeOps = backend.nodeOps;
+
+  for (i = 0; i < hooks$1.length; ++i) {
+    cbs[hooks$1[i]] = [];
+    for (j = 0; j < modules.length; ++j) {
+      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }
+    }
+  }
+
+  function emptyNodeAt (elm) {
+    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
+  }
+
+  function createRmCb (childElm, listeners) {
+    function remove$$1 () {
+      if (--remove$$1.listeners === 0) {
+        removeNode(childElm);
+      }
+    }
+    remove$$1.listeners = listeners;
+    return remove$$1
+  }
+
+  function removeNode (el) {
+    var parent = nodeOps.parentNode(el);
+    // element may have already been removed due to v-html / v-text
+    if (parent) {
+      nodeOps.removeChild(parent, el);
+    }
+  }
+
+  var inPre = 0;
+  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
+    vnode.isRootInsert = !nested; // for transition enter check
+    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
+      return
+    }
+
+    var data = vnode.data;
+    var children = vnode.children;
+    var tag = vnode.tag;
+    if (isDef(tag)) {
+      if (process.env.NODE_ENV !== 'production') {
+        if (data && data.pre) {
+          inPre++;
+        }
+        if (
+          !inPre &&
+          !vnode.ns &&
+          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
+          config.isUnknownElement(tag)
+        ) {
+          warn(
+            'Unknown custom element: <' + tag + '> - did you ' +
+            'register the component correctly? For recursive components, ' +
+            'make sure to provide the "name" option.',
+            vnode.context
+          );
+        }
+      }
+      vnode.elm = vnode.ns
+        ? nodeOps.createElementNS(vnode.ns, tag)
+        : nodeOps.createElement(tag, vnode);
+      setScope(vnode);
+
+      /* istanbul ignore if */
+      {
+        createChildren(vnode, children, insertedVnodeQueue);
+        if (isDef(data)) {
+          invokeCreateHooks(vnode, insertedVnodeQueue);
+        }
+        insert(parentElm, vnode.elm, refElm);
+      }
+
+      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
+        inPre--;
+      }
+    } else if (vnode.isComment) {
+      vnode.elm = nodeOps.createComment(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    } else {
+      vnode.elm = nodeOps.createTextNode(vnode.text);
+      insert(parentElm, vnode.elm, refElm);
+    }
+  }
+
+  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i = vnode.data;
+    if (isDef(i)) {
+      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
+      if (isDef(i = i.hook) && isDef(i = i.init)) {
+        i(vnode, false /* hydrating */, parentElm, refElm);
+      }
+      // after calling the init hook, if the vnode is a child component
+      // it should've created a child instance and mounted it. the child
+      // component also has set the placeholder vnode's elm.
+      // in that case we can just return the element and be done.
+      if (isDef(vnode.componentInstance)) {
+        initComponent(vnode, insertedVnodeQueue);
+        if (isReactivated) {
+          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
+        }
+        return true
+      }
+    }
+  }
+
+  function initComponent (vnode, insertedVnodeQueue) {
+    if (vnode.data.pendingInsert) {
+      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
+    }
+    vnode.elm = vnode.componentInstance.$el;
+    if (isPatchable(vnode)) {
+      invokeCreateHooks(vnode, insertedVnodeQueue);
+      setScope(vnode);
+    } else {
+      // empty component root.
+      // skip all element-related modules except for ref (#3455)
+      registerRef(vnode);
+      // make sure to invoke the insert hook
+      insertedVnodeQueue.push(vnode);
+    }
+  }
+
+  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    var i;
+    // hack for #4339: a reactivated component with inner transition
+    // does not trigger because the inner node's created hooks are not called
+    // again. It's not ideal to involve module-specific logic in here but
+    // there doesn't seem to be a better way to do it.
+    var innerNode = vnode;
+    while (innerNode.componentInstance) {
+      innerNode = innerNode.componentInstance._vnode;
+      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
+        for (i = 0; i < cbs.activate.length; ++i) {
+          cbs.activate[i](emptyNode, innerNode);
+        }
+        insertedVnodeQueue.push(innerNode);
+        break
+      }
+    }
+    // unlike a newly created component,
+    // a reactivated keep-alive component doesn't insert itself
+    insert(parentElm, vnode.elm, refElm);
+  }
+
+  function insert (parent, elm, ref) {
+    if (parent) {
+      if (ref) {
+        nodeOps.insertBefore(parent, elm, ref);
+      } else {
+        nodeOps.appendChild(parent, elm);
+      }
+    }
+  }
+
+  function createChildren (vnode, children, insertedVnodeQueue) {
+    if (Array.isArray(children)) {
+      for (var i = 0; i < children.length; ++i) {
+        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
+      }
+    } else if (isPrimitive(vnode.text)) {
+      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
+    }
+  }
+
+  function isPatchable (vnode) {
+    while (vnode.componentInstance) {
+      vnode = vnode.componentInstance._vnode;
+    }
+    return isDef(vnode.tag)
+  }
+
+  function invokeCreateHooks (vnode, insertedVnodeQueue) {
+    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
+      cbs.create[i$1](emptyNode, vnode);
+    }
+    i = vnode.data.hook; // Reuse variable
+    if (isDef(i)) {
+      if (i.create) { i.create(emptyNode, vnode); }
+      if (i.insert) { insertedVnodeQueue.push(vnode); }
+    }
+  }
+
+  // set scope id attribute for scoped CSS.
+  // this is implemented as a special case to avoid the overhead
+  // of going through the normal attribute patching process.
+  function setScope (vnode) {
+    var i;
+    var ancestor = vnode;
+    while (ancestor) {
+      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
+        nodeOps.setAttribute(vnode.elm, i, '');
+      }
+      ancestor = ancestor.parent;
+    }
+    // for slot content they should also get the scopeId from the host instance.
+    if (isDef(i = activeInstance) &&
+        i !== vnode.context &&
+        isDef(i = i.$options._scopeId)) {
+      nodeOps.setAttribute(vnode.elm, i, '');
+    }
+  }
+
+  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
+    }
+  }
+
+  function invokeDestroyHook (vnode) {
+    var i, j;
+    var data = vnode.data;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
+      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
+    }
+    if (isDef(i = vnode.children)) {
+      for (j = 0; j < vnode.children.length; ++j) {
+        invokeDestroyHook(vnode.children[j]);
+      }
+    }
+  }
+
+  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      var ch = vnodes[startIdx];
+      if (isDef(ch)) {
+        if (isDef(ch.tag)) {
+          removeAndInvokeRemoveHook(ch);
+          invokeDestroyHook(ch);
+        } else { // Text node
+          removeNode(ch.elm);
+        }
+      }
+    }
+  }
+
+  function removeAndInvokeRemoveHook (vnode, rm) {
+    if (rm || isDef(vnode.data)) {
+      var listeners = cbs.remove.length + 1;
+      if (!rm) {
+        // directly removing
+        rm = createRmCb(vnode.elm, listeners);
+      } else {
+        // we have a recursively passed down rm callback
+        // increase the listeners count
+        rm.listeners += listeners;
+      }
+      // recursively invoke hooks on child component root node
+      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
+        removeAndInvokeRemoveHook(i, rm);
+      }
+      for (i = 0; i < cbs.remove.length; ++i) {
+        cbs.remove[i](vnode, rm);
+      }
+      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
+        i(vnode, rm);
+      } else {
+        rm();
+      }
+    } else {
+      removeNode(vnode.elm);
+    }
+  }
+
+  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
+    var oldStartIdx = 0;
+    var newStartIdx = 0;
+    var oldEndIdx = oldCh.length - 1;
+    var oldStartVnode = oldCh[0];
+    var oldEndVnode = oldCh[oldEndIdx];
+    var newEndIdx = newCh.length - 1;
+    var newStartVnode = newCh[0];
+    var newEndVnode = newCh[newEndIdx];
+    var oldKeyToIdx, idxInOld, elmToMove, refElm;
+
+    // removeOnly is a special flag used only by <transition-group>
+    // to ensure removed elements stay in correct relative positions
+    // during leaving transitions
+    var canMove = !removeOnly;
+
+    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
+      if (isUndef(oldStartVnode)) {
+        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
+      } else if (isUndef(oldEndVnode)) {
+        oldEndVnode = oldCh[--oldEndIdx];
+      } else if (sameVnode(oldStartVnode, newStartVnode)) {
+        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
+        oldStartVnode = oldCh[++oldStartIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else if (sameVnode(oldEndVnode, newEndVnode)) {
+        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
+        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
+        oldStartVnode = oldCh[++oldStartIdx];
+        newEndVnode = newCh[--newEndIdx];
+      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
+        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
+        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
+        oldEndVnode = oldCh[--oldEndIdx];
+        newStartVnode = newCh[++newStartIdx];
+      } else {
+        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
+        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;
+        if (isUndef(idxInOld)) { // New element
+          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+          newStartVnode = newCh[++newStartIdx];
+        } else {
+          elmToMove = oldCh[idxInOld];
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
+            warn(
+              'It seems there are duplicate keys that is causing an update error. ' +
+              'Make sure each v-for item has a unique key.'
+            );
+          }
+          if (sameVnode(elmToMove, newStartVnode)) {
+            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
+            oldCh[idxInOld] = undefined;
+            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          } else {
+            // same key but different element. treat as new element
+            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
+            newStartVnode = newCh[++newStartIdx];
+          }
+        }
+      }
+    }
+    if (oldStartIdx > oldEndIdx) {
+      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
+      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
+    } else if (newStartIdx > newEndIdx) {
+      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
+    }
+  }
+
+  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
+    if (oldVnode === vnode) {
+      return
+    }
+    // reuse element for static trees.
+    // note we only do this if the vnode is cloned -
+    // if the new node is not cloned it means the render functions have been
+    // reset by the hot-reload-api and we need to do a proper re-render.
+    if (vnode.isStatic &&
+        oldVnode.isStatic &&
+        vnode.key === oldVnode.key &&
+        (vnode.isCloned || vnode.isOnce)) {
+      vnode.elm = oldVnode.elm;
+      vnode.componentInstance = oldVnode.componentInstance;
+      return
+    }
+    var i;
+    var data = vnode.data;
+    var hasData = isDef(data);
+    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
+      i(oldVnode, vnode);
+    }
+    var elm = vnode.elm = oldVnode.elm;
+    var oldCh = oldVnode.children;
+    var ch = vnode.children;
+    if (hasData && isPatchable(vnode)) {
+      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
+      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
+    }
+    if (isUndef(vnode.text)) {
+      if (isDef(oldCh) && isDef(ch)) {
+        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
+      } else if (isDef(ch)) {
+        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
+        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
+      } else if (isDef(oldCh)) {
+        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
+      } else if (isDef(oldVnode.text)) {
+        nodeOps.setTextContent(elm, '');
+      }
+    } else if (oldVnode.text !== vnode.text) {
+      nodeOps.setTextContent(elm, vnode.text);
+    }
+    if (hasData) {
+      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
+    }
+  }
+
+  function invokeInsertHook (vnode, queue, initial) {
+    // delay insert hooks for component root nodes, invoke them after the
+    // element is really inserted
+    if (initial && vnode.parent) {
+      vnode.parent.data.pendingInsert = queue;
+    } else {
+      for (var i = 0; i < queue.length; ++i) {
+        queue[i].data.hook.insert(queue[i]);
+      }
+    }
+  }
+
+  var bailed = false;
+  // list of modules that can skip create hook during hydration because they
+  // are already rendered on the client or has no need for initialization
+  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');
+
+  // Note: this is a browser-only function so we can assume elms are DOM nodes.
+  function hydrate (elm, vnode, insertedVnodeQueue) {
+    if (process.env.NODE_ENV !== 'production') {
+      if (!assertNodeMatch(elm, vnode)) {
+        return false
+      }
+    }
+    vnode.elm = elm;
+    var tag = vnode.tag;
+    var data = vnode.data;
+    var children = vnode.children;
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
+      if (isDef(i = vnode.componentInstance)) {
+        // child component. it should have hydrated its own tree.
+        initComponent(vnode, insertedVnodeQueue);
+        return true
+      }
+    }
+    if (isDef(tag)) {
+      if (isDef(children)) {
+        // empty element, allow client to pick up and populate children
+        if (!elm.hasChildNodes()) {
+          createChildren(vnode, children, insertedVnodeQueue);
+        } else {
+          var childrenMatch = true;
+          var childNode = elm.firstChild;
+          for (var i$1 = 0; i$1 < children.length; i$1++) {
+            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {
+              childrenMatch = false;
+              break
+            }
+            childNode = childNode.nextSibling;
+          }
+          // if childNode is not null, it means the actual childNodes list is
+          // longer than the virtual children list.
+          if (!childrenMatch || childNode) {
+            if (process.env.NODE_ENV !== 'production' &&
+                typeof console !== 'undefined' &&
+                !bailed) {
+              bailed = true;
+              console.warn('Parent: ', elm);
+              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
+            }
+            return false
+          }
+        }
+      }
+      if (isDef(data)) {
+        for (var key in data) {
+          if (!isRenderedModule(key)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue);
+            break
+          }
+        }
+      }
+    } else if (elm.data !== vnode.text) {
+      elm.data = vnode.text;
+    }
+    return true
+  }
+
+  function assertNodeMatch (node, vnode) {
+    if (vnode.tag) {
+      return (
+        vnode.tag.indexOf('vue-component') === 0 ||
+        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
+      )
+    } else {
+      return node.nodeType === (vnode.isComment ? 8 : 3)
+    }
+  }
+
+  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
+    if (!vnode) {
+      if (oldVnode) { invokeDestroyHook(oldVnode); }
+      return
+    }
+
+    var isInitialPatch = false;
+    var insertedVnodeQueue = [];
+
+    if (!oldVnode) {
+      // empty mount (likely as component), create new root element
+      isInitialPatch = true;
+      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
+    } else {
+      var isRealElement = isDef(oldVnode.nodeType);
+      if (!isRealElement && sameVnode(oldVnode, vnode)) {
+        // patch existing root node
+        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
+      } else {
+        if (isRealElement) {
+          // mounting to a real element
+          // check if this is server-rendered content and if we can perform
+          // a successful hydration.
+          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
+            oldVnode.removeAttribute('server-rendered');
+            hydrating = true;
+          }
+          if (hydrating) {
+            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
+              invokeInsertHook(vnode, insertedVnodeQueue, true);
+              return oldVnode
+            } else if (process.env.NODE_ENV !== 'production') {
+              warn(
+                'The client-side rendered virtual DOM tree is not matching ' +
+                'server-rendered content. This is likely caused by incorrect ' +
+                'HTML markup, for example nesting block-level elements inside ' +
+                '<p>, or missing <tbody>. Bailing hydration and performing ' +
+                'full client-side render.'
+              );
+            }
+          }
+          // either not server-rendered, or hydration failed.
+          // create an empty node and replace it
+          oldVnode = emptyNodeAt(oldVnode);
+        }
+        // replacing existing element
+        var oldElm = oldVnode.elm;
+        var parentElm$1 = nodeOps.parentNode(oldElm);
+        createElm(
+          vnode,
+          insertedVnodeQueue,
+          // extremely rare edge case: do not insert if old element is in a
+          // leaving transition. Only happens when combining transition +
+          // keep-alive + HOCs. (#4590)
+          oldElm._leaveCb ? null : parentElm$1,
+          nodeOps.nextSibling(oldElm)
+        );
+
+        if (vnode.parent) {
+          // component root element replaced.
+          // update parent placeholder node element, recursively
+          var ancestor = vnode.parent;
+          while (ancestor) {
+            ancestor.elm = vnode.elm;
+            ancestor = ancestor.parent;
+          }
+          if (isPatchable(vnode)) {
+            for (var i = 0; i < cbs.create.length; ++i) {
+              cbs.create[i](emptyNode, vnode.parent);
+            }
+          }
+        }
+
+        if (parentElm$1 !== null) {
+          removeVnodes(parentElm$1, [oldVnode], 0, 0);
+        } else if (isDef(oldVnode.tag)) {
+          invokeDestroyHook(oldVnode);
+        }
+      }
+    }
+
+    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
+    return vnode.elm
+  }
+}
+
+/*  */
+
+var directives = {
+  create: updateDirectives,
+  update: updateDirectives,
+  destroy: function unbindDirectives (vnode) {
+    updateDirectives(vnode, emptyNode);
+  }
+};
+
+function updateDirectives (oldVnode, vnode) {
+  if (oldVnode.data.directives || vnode.data.directives) {
+    _update(oldVnode, vnode);
+  }
+}
+
+function _update (oldVnode, vnode) {
+  var isCreate = oldVnode === emptyNode;
+  var isDestroy = vnode === emptyNode;
+  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
+  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);
+
+  var dirsWithInsert = [];
+  var dirsWithPostpatch = [];
+
+  var key, oldDir, dir;
+  for (key in newDirs) {
+    oldDir = oldDirs[key];
+    dir = newDirs[key];
+    if (!oldDir) {
+      // new directive, bind
+      callHook$1(dir, 'bind', vnode, oldVnode);
+      if (dir.def && dir.def.inserted) {
+        dirsWithInsert.push(dir);
+      }
+    } else {
+      // existing directive, update
+      dir.oldValue = oldDir.value;
+      callHook$1(dir, 'update', vnode, oldVnode);
+      if (dir.def && dir.def.componentUpdated) {
+        dirsWithPostpatch.push(dir);
+      }
+    }
+  }
+
+  if (dirsWithInsert.length) {
+    var callInsert = function () {
+      for (var i = 0; i < dirsWithInsert.length; i++) {
+        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
+      }
+    };
+    if (isCreate) {
+      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);
+    } else {
+      callInsert();
+    }
+  }
+
+  if (dirsWithPostpatch.length) {
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {
+      for (var i = 0; i < dirsWithPostpatch.length; i++) {
+        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
+      }
+    });
+  }
+
+  if (!isCreate) {
+    for (key in oldDirs) {
+      if (!newDirs[key]) {
+        // no longer present, unbind
+        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
+      }
+    }
+  }
+}
+
+var emptyModifiers = Object.create(null);
+
+function normalizeDirectives$1 (
+  dirs,
+  vm
+) {
+  var res = Object.create(null);
+  if (!dirs) {
+    return res
+  }
+  var i, dir;
+  for (i = 0; i < dirs.length; i++) {
+    dir = dirs[i];
+    if (!dir.modifiers) {
+      dir.modifiers = emptyModifiers;
+    }
+    res[getRawDirName(dir)] = dir;
+    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
+  }
+  return res
+}
+
+function getRawDirName (dir) {
+  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
+}
+
+function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
+  var fn = dir.def && dir.def[hook];
+  if (fn) {
+    fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
+  }
+}
+
+var baseModules = [
+  ref,
+  directives
+];
+
+/*  */
+
+function updateAttrs (oldVnode, vnode) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  var key, cur, old;
+  var elm = vnode.elm;
+  var oldAttrs = oldVnode.data.attrs || {};
+  var attrs = vnode.data.attrs || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs);
+  }
+
+  for (key in attrs) {
+    cur = attrs[key];
+    old = oldAttrs[key];
+    if (old !== cur) {
+      setAttr(elm, key, cur);
+    }
+  }
+  // #4391: in IE9, setting type can reset value for input[type=radio]
+  /* istanbul ignore if */
+  if (isIE9 && attrs.value !== oldAttrs.value) {
+    setAttr(elm, 'value', attrs.value);
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      if (isXlink(key)) {
+        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
+      } else if (!isEnumeratedAttr(key)) {
+        elm.removeAttribute(key);
+      }
+    }
+  }
+}
+
+function setAttr (el, key, value) {
+  if (isBooleanAttr(key)) {
+    // set attribute for blank value
+    // e.g. <option disabled>Select one</option>
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, key);
+    }
+  } else if (isEnumeratedAttr(key)) {
+    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
+  } else if (isXlink(key)) {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
+    } else {
+      el.setAttributeNS(xlinkNS, key, value);
+    }
+  } else {
+    if (isFalsyAttrValue(value)) {
+      el.removeAttribute(key);
+    } else {
+      el.setAttribute(key, value);
+    }
+  }
+}
+
+var attrs = {
+  create: updateAttrs,
+  update: updateAttrs
+};
+
+/*  */
+
+function updateClass (oldVnode, vnode) {
+  var el = vnode.elm;
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  var cls = genClassForVnode(vnode);
+
+  // handle transition classes
+  var transitionClass = el._transitionClasses;
+  if (transitionClass) {
+    cls = concat(cls, stringifyClass(transitionClass));
+  }
+
+  // set the class
+  if (cls !== el._prevClass) {
+    el.setAttribute('class', cls);
+    el._prevClass = cls;
+  }
+}
+
+var klass = {
+  create: updateClass,
+  update: updateClass
+};
+
+/*  */
+
+var validDivisionCharRE = /[\w).+\-_$\]]/;
+
+
+
+function wrapFilter (exp, filter) {
+  var i = filter.indexOf('(');
+  if (i < 0) {
+    // _f: resolveFilter
+    return ("_f(\"" + filter + "\")(" + exp + ")")
+  } else {
+    var name = filter.slice(0, i);
+    var args = filter.slice(i + 1);
+    return ("_f(\"" + name + "\")(" + exp + "," + args)
+  }
+}
+
+/*  */
+
+/*  */
+
+/**
+ * Cross-platform code generation for component v-model
+ */
+
+
+/**
+ * Cross-platform codegen helper for generating v-model value assignment code.
+ */
+
+
+/**
+ * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)
+ *
+ * for loop possible cases:
+ *
+ * - test
+ * - test[idx]
+ * - test[test1[idx]]
+ * - test["a"][idx]
+ * - xxx.test[a[a].test1[idx]]
+ * - test.xxx.a["asa"][test1[idx]]
+ *
+ */
+
+var str;
+var index$1;
+
+/*  */
+
+// in some cases, the event used has to be determined at runtime
+// so we used some reserved tokens during compile.
+var RANGE_TOKEN = '__r';
+var CHECKBOX_RADIO_TOKEN = '__c';
+
+/*  */
+
+// normalize v-model event tokens that can only be determined at runtime.
+// it's important to place the event as the first in the array because
+// the whole point is ensuring the v-model callback gets called before
+// user-attached handlers.
+function normalizeEvents (on) {
+  var event;
+  /* istanbul ignore if */
+  if (on[RANGE_TOKEN]) {
+    // IE input[type=range] only supports `change` event
+    event = isIE ? 'change' : 'input';
+    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
+    delete on[RANGE_TOKEN];
+  }
+  if (on[CHECKBOX_RADIO_TOKEN]) {
+    // Chrome fires microtasks in between click/change, leads to #4521
+    event = isChrome ? 'click' : 'change';
+    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);
+    delete on[CHECKBOX_RADIO_TOKEN];
+  }
+}
+
+var target$1;
+
+function add$1 (
+  event,
+  handler,
+  once,
+  capture
+) {
+  if (once) {
+    var oldHandler = handler;
+    var _target = target$1; // save current target element in closure
+    handler = function (ev) {
+      var res = arguments.length === 1
+        ? oldHandler(ev)
+        : oldHandler.apply(null, arguments);
+      if (res !== null) {
+        remove$2(event, handler, capture, _target);
+      }
+    };
+  }
+  target$1.addEventListener(event, handler, capture);
+}
+
+function remove$2 (
+  event,
+  handler,
+  capture,
+  _target
+) {
+  (_target || target$1).removeEventListener(event, handler, capture);
+}
+
+function updateDOMListeners (oldVnode, vnode) {
+  if (!oldVnode.data.on && !vnode.data.on) {
+    return
+  }
+  var on = vnode.data.on || {};
+  var oldOn = oldVnode.data.on || {};
+  target$1 = vnode.elm;
+  normalizeEvents(on);
+  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
+}
+
+var events = {
+  create: updateDOMListeners,
+  update: updateDOMListeners
+};
+
+/*  */
+
+function updateDOMProps (oldVnode, vnode) {
+  if (!oldVnode.data.domProps && !vnode.data.domProps) {
+    return
+  }
+  var key, cur;
+  var elm = vnode.elm;
+  var oldProps = oldVnode.data.domProps || {};
+  var props = vnode.data.domProps || {};
+  // clone observed objects, as the user probably wants to mutate it
+  if (props.__ob__) {
+    props = vnode.data.domProps = extend({}, props);
+  }
+
+  for (key in oldProps) {
+    if (props[key] == null) {
+      elm[key] = '';
+    }
+  }
+  for (key in props) {
+    cur = props[key];
+    // ignore children if the node has textContent or innerHTML,
+    // as these will throw away existing DOM nodes and cause removal errors
+    // on subsequent patches (#3360)
+    if (key === 'textContent' || key === 'innerHTML') {
+      if (vnode.children) { vnode.children.length = 0; }
+      if (cur === oldProps[key]) { continue }
+    }
+
+    if (key === 'value') {
+      // store value as _value as well since
+      // non-string values will be stringified
+      elm._value = cur;
+      // avoid resetting cursor position when value is the same
+      var strCur = cur == null ? '' : String(cur);
+      if (shouldUpdateValue(elm, vnode, strCur)) {
+        elm.value = strCur;
+      }
+    } else {
+      elm[key] = cur;
+    }
+  }
+}
+
+// check platforms/web/util/attrs.js acceptValue
+
+
+function shouldUpdateValue (
+  elm,
+  vnode,
+  checkVal
+) {
+  return (!elm.composing && (
+    vnode.tag === 'option' ||
+    isDirty(elm, checkVal) ||
+    isInputChanged(elm, checkVal)
+  ))
+}
+
+function isDirty (elm, checkVal) {
+  // return true when textbox (.number and .trim) loses focus and its value is not equal to the updated value
+  return document.activeElement !== elm && elm.value !== checkVal
+}
+
+function isInputChanged (elm, newVal) {
+  var value = elm.value;
+  var modifiers = elm._vModifiers; // injected by v-model runtime
+  if ((modifiers && modifiers.number) || elm.type === 'number') {
+    return toNumber(value) !== toNumber(newVal)
+  }
+  if (modifiers && modifiers.trim) {
+    return value.trim() !== newVal.trim()
+  }
+  return value !== newVal
+}
+
+var domProps = {
+  create: updateDOMProps,
+  update: updateDOMProps
+};
+
+/*  */
+
+var parseStyleText = cached(function (cssText) {
+  var res = {};
+  var listDelimiter = /;(?![^(]*\))/g;
+  var propertyDelimiter = /:(.+)/;
+  cssText.split(listDelimiter).forEach(function (item) {
+    if (item) {
+      var tmp = item.split(propertyDelimiter);
+      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
+    }
+  });
+  return res
+});
+
+// merge static and dynamic style data on the same vnode
+function normalizeStyleData (data) {
+  var style = normalizeStyleBinding(data.style);
+  // static style is pre-processed into an object during compilation
+  // and is always a fresh object, so it's safe to merge into it
+  return data.staticStyle
+    ? extend(data.staticStyle, style)
+    : style
+}
+
+// normalize possible array / string values into Object
+function normalizeStyleBinding (bindingStyle) {
+  if (Array.isArray(bindingStyle)) {
+    return toObject(bindingStyle)
+  }
+  if (typeof bindingStyle === 'string') {
+    return parseStyleText(bindingStyle)
+  }
+  return bindingStyle
+}
+
+/**
+ * parent component style should be after child's
+ * so that parent component's style could override it
+ */
+function getStyle (vnode, checkChild) {
+  var res = {};
+  var styleData;
+
+  if (checkChild) {
+    var childNode = vnode;
+    while (childNode.componentInstance) {
+      childNode = childNode.componentInstance._vnode;
+      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
+        extend(res, styleData);
+      }
+    }
+  }
+
+  if ((styleData = normalizeStyleData(vnode.data))) {
+    extend(res, styleData);
+  }
+
+  var parentNode = vnode;
+  while ((parentNode = parentNode.parent)) {
+    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
+      extend(res, styleData);
+    }
+  }
+  return res
+}
+
+/*  */
+
+var cssVarRE = /^--/;
+var importantRE = /\s*!important$/;
+var setProp = function (el, name, val) {
+  /* istanbul ignore if */
+  if (cssVarRE.test(name)) {
+    el.style.setProperty(name, val);
+  } else if (importantRE.test(val)) {
+    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
+  } else {
+    el.style[normalize(name)] = val;
+  }
+};
+
+var prefixes = ['Webkit', 'Moz', 'ms'];
+
+var testEl;
+var normalize = cached(function (prop) {
+  testEl = testEl || document.createElement('div');
+  prop = camelize(prop);
+  if (prop !== 'filter' && (prop in testEl.style)) {
+    return prop
+  }
+  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);
+  for (var i = 0; i < prefixes.length; i++) {
+    var prefixed = prefixes[i] + upper;
+    if (prefixed in testEl.style) {
+      return prefixed
+    }
+  }
+});
+
+function updateStyle (oldVnode, vnode) {
+  var data = vnode.data;
+  var oldData = oldVnode.data;
+
+  if (!data.staticStyle && !data.style &&
+      !oldData.staticStyle && !oldData.style) {
+    return
+  }
+
+  var cur, name;
+  var el = vnode.elm;
+  var oldStaticStyle = oldVnode.data.staticStyle;
+  var oldStyleBinding = oldVnode.data.style || {};
+
+  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
+  var oldStyle = oldStaticStyle || oldStyleBinding;
+
+  var style = normalizeStyleBinding(vnode.data.style) || {};
+
+  vnode.data.style = style.__ob__ ? extend({}, style) : style;
+
+  var newStyle = getStyle(vnode, true);
+
+  for (name in oldStyle) {
+    if (newStyle[name] == null) {
+      setProp(el, name, '');
+    }
+  }
+  for (name in newStyle) {
+    cur = newStyle[name];
+    if (cur !== oldStyle[name]) {
+      // ie9 setting to null has no effect, must use empty string
+      setProp(el, name, cur == null ? '' : cur);
+    }
+  }
+}
+
+var style = {
+  create: updateStyle,
+  update: updateStyle
+};
+
+/*  */
+
+/**
+ * Add class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function addClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.add(c); });
+    } else {
+      el.classList.add(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    if (cur.indexOf(' ' + cls + ' ') < 0) {
+      el.setAttribute('class', (cur + cls).trim());
+    }
+  }
+}
+
+/**
+ * Remove class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+function removeClass (el, cls) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(function (c) { return el.classList.remove(c); });
+    } else {
+      el.classList.remove(cls);
+    }
+  } else {
+    var cur = " " + (el.getAttribute('class') || '') + " ";
+    var tar = ' ' + cls + ' ';
+    while (cur.indexOf(tar) >= 0) {
+      cur = cur.replace(tar, ' ');
+    }
+    el.setAttribute('class', cur.trim());
+  }
+}
+
+/*  */
+
+function resolveTransition (def$$1) {
+  if (!def$$1) {
+    return
+  }
+  /* istanbul ignore else */
+  if (typeof def$$1 === 'object') {
+    var res = {};
+    if (def$$1.css !== false) {
+      extend(res, autoCssTransition(def$$1.name || 'v'));
+    }
+    extend(res, def$$1);
+    return res
+  } else if (typeof def$$1 === 'string') {
+    return autoCssTransition(def$$1)
+  }
+}
+
+var autoCssTransition = cached(function (name) {
+  return {
+    enterClass: (name + "-enter"),
+    enterToClass: (name + "-enter-to"),
+    enterActiveClass: (name + "-enter-active"),
+    leaveClass: (name + "-leave"),
+    leaveToClass: (name + "-leave-to"),
+    leaveActiveClass: (name + "-leave-active")
+  }
+});
+
+var hasTransition = inBrowser && !isIE9;
+var TRANSITION = 'transition';
+var ANIMATION = 'animation';
+
+// Transition property/event sniffing
+var transitionProp = 'transition';
+var transitionEndEvent = 'transitionend';
+var animationProp = 'animation';
+var animationEndEvent = 'animationend';
+if (hasTransition) {
+  /* istanbul ignore if */
+  if (window.ontransitionend === undefined &&
+    window.onwebkittransitionend !== undefined) {
+    transitionProp = 'WebkitTransition';
+    transitionEndEvent = 'webkitTransitionEnd';
+  }
+  if (window.onanimationend === undefined &&
+    window.onwebkitanimationend !== undefined) {
+    animationProp = 'WebkitAnimation';
+    animationEndEvent = 'webkitAnimationEnd';
+  }
+}
+
+// binding to window is necessary to make hot reload work in IE in strict mode
+var raf = inBrowser && window.requestAnimationFrame
+  ? window.requestAnimationFrame.bind(window)
+  : setTimeout;
+
+function nextFrame (fn) {
+  raf(function () {
+    raf(fn);
+  });
+}
+
+function addTransitionClass (el, cls) {
+  (el._transitionClasses || (el._transitionClasses = [])).push(cls);
+  addClass(el, cls);
+}
+
+function removeTransitionClass (el, cls) {
+  if (el._transitionClasses) {
+    remove(el._transitionClasses, cls);
+  }
+  removeClass(el, cls);
+}
+
+function whenTransitionEnds (
+  el,
+  expectedType,
+  cb
+) {
+  var ref = getTransitionInfo(el, expectedType);
+  var type = ref.type;
+  var timeout = ref.timeout;
+  var propCount = ref.propCount;
+  if (!type) { return cb() }
+  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
+  var ended = 0;
+  var end = function () {
+    el.removeEventListener(event, onEnd);
+    cb();
+  };
+  var onEnd = function (e) {
+    if (e.target === el) {
+      if (++ended >= propCount) {
+        end();
+      }
+    }
+  };
+  setTimeout(function () {
+    if (ended < propCount) {
+      end();
+    }
+  }, timeout + 1);
+  el.addEventListener(event, onEnd);
+}
+
+var transformRE = /\b(transform|all)(,|$)/;
+
+function getTransitionInfo (el, expectedType) {
+  var styles = window.getComputedStyle(el);
+  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
+  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
+  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
+  var animationDelays = styles[animationProp + 'Delay'].split(', ');
+  var animationDurations = styles[animationProp + 'Duration'].split(', ');
+  var animationTimeout = getTimeout(animationDelays, animationDurations);
+
+  var type;
+  var timeout = 0;
+  var propCount = 0;
+  /* istanbul ignore if */
+  if (expectedType === TRANSITION) {
+    if (transitionTimeout > 0) {
+      type = TRANSITION;
+      timeout = transitionTimeout;
+      propCount = transitionDurations.length;
+    }
+  } else if (expectedType === ANIMATION) {
+    if (animationTimeout > 0) {
+      type = ANIMATION;
+      timeout = animationTimeout;
+      propCount = animationDurations.length;
+    }
+  } else {
+    timeout = Math.max(transitionTimeout, animationTimeout);
+    type = timeout > 0
+      ? transitionTimeout > animationTimeout
+        ? TRANSITION
+        : ANIMATION
+      : null;
+    propCount = type
+      ? type === TRANSITION
+        ? transitionDurations.length
+        : animationDurations.length
+      : 0;
+  }
+  var hasTransform =
+    type === TRANSITION &&
+    transformRE.test(styles[transitionProp + 'Property']);
+  return {
+    type: type,
+    timeout: timeout,
+    propCount: propCount,
+    hasTransform: hasTransform
+  }
+}
+
+function getTimeout (delays, durations) {
+  /* istanbul ignore next */
+  while (delays.length < durations.length) {
+    delays = delays.concat(delays);
+  }
+
+  return Math.max.apply(null, durations.map(function (d, i) {
+    return toMs(d) + toMs(delays[i])
+  }))
+}
+
+function toMs (s) {
+  return Number(s.slice(0, -1)) * 1000
+}
+
+/*  */
+
+function enter (vnode, toggleDisplay) {
+  var el = vnode.elm;
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true;
+    el._leaveCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var enterClass = data.enterClass;
+  var enterToClass = data.enterToClass;
+  var enterActiveClass = data.enterActiveClass;
+  var appearClass = data.appearClass;
+  var appearToClass = data.appearToClass;
+  var appearActiveClass = data.appearActiveClass;
+  var beforeEnter = data.beforeEnter;
+  var enter = data.enter;
+  var afterEnter = data.afterEnter;
+  var enterCancelled = data.enterCancelled;
+  var beforeAppear = data.beforeAppear;
+  var appear = data.appear;
+  var afterAppear = data.afterAppear;
+  var appearCancelled = data.appearCancelled;
+  var duration = data.duration;
+
+  // activeInstance will always be the <transition> component managing this
+  // transition. One edge case to check is when the <transition> is placed
+  // as the root node of a child component. In that case we need to check
+  // <transition>'s parent for appear check.
+  var context = activeInstance;
+  var transitionNode = activeInstance.$vnode;
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent;
+    context = transitionNode.context;
+  }
+
+  var isAppear = !context._isMounted || !vnode.isRootInsert;
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  var startClass = isAppear && appearClass
+    ? appearClass
+    : enterClass;
+  var activeClass = isAppear && appearActiveClass
+    ? appearActiveClass
+    : enterActiveClass;
+  var toClass = isAppear && appearToClass
+    ? appearToClass
+    : enterToClass;
+
+  var beforeEnterHook = isAppear
+    ? (beforeAppear || beforeEnter)
+    : beforeEnter;
+  var enterHook = isAppear
+    ? (typeof appear === 'function' ? appear : enter)
+    : enter;
+  var afterEnterHook = isAppear
+    ? (afterAppear || afterEnter)
+    : afterEnter;
+  var enterCancelledHook = isAppear
+    ? (appearCancelled || enterCancelled)
+    : enterCancelled;
+
+  var explicitEnterDuration = toNumber(
+    isObject(duration)
+      ? duration.enter
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {
+    checkDuration(explicitEnterDuration, 'enter', vnode);
+  }
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(enterHook);
+
+  var cb = el._enterCb = once(function () {
+    if (expectsCSS) {
+      removeTransitionClass(el, toClass);
+      removeTransitionClass(el, activeClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, startClass);
+      }
+      enterCancelledHook && enterCancelledHook(el);
+    } else {
+      afterEnterHook && afterEnterHook(el);
+    }
+    el._enterCb = null;
+  });
+
+  if (!vnode.data.show) {
+    // remove pending leave element on enter by injecting an insert hook
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {
+      var parent = el.parentNode;
+      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
+      if (pendingNode &&
+          pendingNode.tag === vnode.tag &&
+          pendingNode.elm._leaveCb) {
+        pendingNode.elm._leaveCb();
+      }
+      enterHook && enterHook(el, cb);
+    });
+  }
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el);
+  if (expectsCSS) {
+    addTransitionClass(el, startClass);
+    addTransitionClass(el, activeClass);
+    nextFrame(function () {
+      addTransitionClass(el, toClass);
+      removeTransitionClass(el, startClass);
+      if (!cb.cancelled && !userWantsControl) {
+        if (isValidDuration(explicitEnterDuration)) {
+          setTimeout(cb, explicitEnterDuration);
+        } else {
+          whenTransitionEnds(el, type, cb);
+        }
+      }
+    });
+  }
+
+  if (vnode.data.show) {
+    toggleDisplay && toggleDisplay();
+    enterHook && enterHook(el, cb);
+  }
+
+  if (!expectsCSS && !userWantsControl) {
+    cb();
+  }
+}
+
+function leave (vnode, rm) {
+  var el = vnode.elm;
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true;
+    el._enterCb();
+  }
+
+  var data = resolveTransition(vnode.data.transition);
+  if (!data) {
+    return rm()
+  }
+
+  /* istanbul ignore if */
+  if (el._leaveCb || el.nodeType !== 1) {
+    return
+  }
+
+  var css = data.css;
+  var type = data.type;
+  var leaveClass = data.leaveClass;
+  var leaveToClass = data.leaveToClass;
+  var leaveActiveClass = data.leaveActiveClass;
+  var beforeLeave = data.beforeLeave;
+  var leave = data.leave;
+  var afterLeave = data.afterLeave;
+  var leaveCancelled = data.leaveCancelled;
+  var delayLeave = data.delayLeave;
+  var duration = data.duration;
+
+  var expectsCSS = css !== false && !isIE9;
+  var userWantsControl = getHookArgumentsLength(leave);
+
+  var explicitLeaveDuration = toNumber(
+    isObject(duration)
+      ? duration.leave
+      : duration
+  );
+
+  if (process.env.NODE_ENV !== 'production' && explicitLeaveDuration != null) {
+    checkDuration(explicitLeaveDuration, 'leave', vnode);
+  }
+
+  var cb = el._leaveCb = once(function () {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null;
+    }
+    if (expectsCSS) {
+      removeTransitionClass(el, leaveToClass);
+      removeTransitionClass(el, leaveActiveClass);
+    }
+    if (cb.cancelled) {
+      if (expectsCSS) {
+        removeTransitionClass(el, leaveClass);
+      }
+      leaveCancelled && leaveCancelled(el);
+    } else {
+      rm();
+      afterLeave && afterLeave(el);
+    }
+    el._leaveCb = null;
+  });
+
+  if (delayLeave) {
+    delayLeave(performLeave);
+  } else {
+    performLeave();
+  }
+
+  function performLeave () {
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
+    }
+    beforeLeave && beforeLeave(el);
+    if (expectsCSS) {
+      addTransitionClass(el, leaveClass);
+      addTransitionClass(el, leaveActiveClass);
+      nextFrame(function () {
+        addTransitionClass(el, leaveToClass);
+        removeTransitionClass(el, leaveClass);
+        if (!cb.cancelled && !userWantsControl) {
+          if (isValidDuration(explicitLeaveDuration)) {
+            setTimeout(cb, explicitLeaveDuration);
+          } else {
+            whenTransitionEnds(el, type, cb);
+          }
+        }
+      });
+    }
+    leave && leave(el, cb);
+    if (!expectsCSS && !userWantsControl) {
+      cb();
+    }
+  }
+}
+
+// only used in dev mode
+function checkDuration (val, name, vnode) {
+  if (typeof val !== 'number') {
+    warn(
+      "<transition> explicit " + name + " duration is not a valid number - " +
+      "got " + (JSON.stringify(val)) + ".",
+      vnode.context
+    );
+  } else if (isNaN(val)) {
+    warn(
+      "<transition> explicit " + name + " duration is NaN - " +
+      'the duration expression might be incorrect.',
+      vnode.context
+    );
+  }
+}
+
+function isValidDuration (val) {
+  return typeof val === 'number' && !isNaN(val)
+}
+
+/**
+ * Normalize a transition hook's argument length. The hook may be:
+ * - a merged hook (invoker) with the original in .fns
+ * - a wrapped component method (check ._length)
+ * - a plain function (.length)
+ */
+function getHookArgumentsLength (fn) {
+  if (!fn) { return false }
+  var invokerFns = fn.fns;
+  if (invokerFns) {
+    // invoker
+    return getHookArgumentsLength(
+      Array.isArray(invokerFns)
+        ? invokerFns[0]
+        : invokerFns
+    )
+  } else {
+    return (fn._length || fn.length) > 1
+  }
+}
+
+function _enter (_, vnode) {
+  if (!vnode.data.show) {
+    enter(vnode);
+  }
+}
+
+var transition = inBrowser ? {
+  create: _enter,
+  activate: _enter,
+  remove: function remove$$1 (vnode, rm) {
+    /* istanbul ignore else */
+    if (!vnode.data.show) {
+      leave(vnode, rm);
+    } else {
+      rm();
+    }
+  }
+} : {};
+
+var platformModules = [
+  attrs,
+  klass,
+  events,
+  domProps,
+  style,
+  transition
+];
+
+/*  */
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+var modules = platformModules.concat(baseModules);
+
+var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });
+
+/**
+ * Not type checking this file because flow doesn't like attaching
+ * properties to Elements.
+ */
+
+/* istanbul ignore if */
+if (isIE9) {
+  // http://www.matts411.com/post/internet-explorer-9-oninput/
+  document.addEventListener('selectionchange', function () {
+    var el = document.activeElement;
+    if (el && el.vmodel) {
+      trigger(el, 'input');
+    }
+  });
+}
+
+var model$1 = {
+  inserted: function inserted (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      var cb = function () {
+        setSelected(el, binding, vnode.context);
+      };
+      cb();
+      /* istanbul ignore if */
+      if (isIE || isEdge) {
+        setTimeout(cb, 0);
+      }
+    } else if (vnode.tag === 'textarea' || el.type === 'text') {
+      el._vModifiers = binding.modifiers;
+      if (!binding.modifiers.lazy) {
+        if (!isAndroid) {
+          el.addEventListener('compositionstart', onCompositionStart);
+          el.addEventListener('compositionend', onCompositionEnd);
+        }
+        /* istanbul ignore if */
+        if (isIE9) {
+          el.vmodel = true;
+        }
+      }
+    }
+  },
+  componentUpdated: function componentUpdated (el, binding, vnode) {
+    if (vnode.tag === 'select') {
+      setSelected(el, binding, vnode.context);
+      // in case the options rendered by v-for have changed,
+      // it's possible that the value is out-of-sync with the rendered options.
+      // detect such cases and filter out values that no longer has a matching
+      // option in the DOM.
+      var needReset = el.multiple
+        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })
+        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);
+      if (needReset) {
+        trigger(el, 'change');
+      }
+    }
+  }
+};
+
+function setSelected (el, binding, vm) {
+  var value = binding.value;
+  var isMultiple = el.multiple;
+  if (isMultiple && !Array.isArray(value)) {
+    process.env.NODE_ENV !== 'production' && warn(
+      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
+      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
+      vm
+    );
+    return
+  }
+  var selected, option;
+  for (var i = 0, l = el.options.length; i < l; i++) {
+    option = el.options[i];
+    if (isMultiple) {
+      selected = looseIndexOf(value, getValue(option)) > -1;
+      if (option.selected !== selected) {
+        option.selected = selected;
+      }
+    } else {
+      if (looseEqual(getValue(option), value)) {
+        if (el.selectedIndex !== i) {
+          el.selectedIndex = i;
+        }
+        return
+      }
+    }
+  }
+  if (!isMultiple) {
+    el.selectedIndex = -1;
+  }
+}
+
+function hasNoMatchingOption (value, options) {
+  for (var i = 0, l = options.length; i < l; i++) {
+    if (looseEqual(getValue(options[i]), value)) {
+      return false
+    }
+  }
+  return true
+}
+
+function getValue (option) {
+  return '_value' in option
+    ? option._value
+    : option.value
+}
+
+function onCompositionStart (e) {
+  e.target.composing = true;
+}
+
+function onCompositionEnd (e) {
+  e.target.composing = false;
+  trigger(e.target, 'input');
+}
+
+function trigger (el, type) {
+  var e = document.createEvent('HTMLEvents');
+  e.initEvent(type, true, true);
+  el.dispatchEvent(e);
+}
+
+/*  */
+
+// recursively search for possible transition defined inside the component root
+function locateNode (vnode) {
+  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
+    ? locateNode(vnode.componentInstance._vnode)
+    : vnode
+}
+
+var show = {
+  bind: function bind (el, ref, vnode) {
+    var value = ref.value;
+
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    var originalDisplay = el.__vOriginalDisplay =
+      el.style.display === 'none' ? '' : el.style.display;
+    if (value && transition && !isIE9) {
+      vnode.data.show = true;
+      enter(vnode, function () {
+        el.style.display = originalDisplay;
+      });
+    } else {
+      el.style.display = value ? originalDisplay : 'none';
+    }
+  },
+
+  update: function update (el, ref, vnode) {
+    var value = ref.value;
+    var oldValue = ref.oldValue;
+
+    /* istanbul ignore if */
+    if (value === oldValue) { return }
+    vnode = locateNode(vnode);
+    var transition = vnode.data && vnode.data.transition;
+    if (transition && !isIE9) {
+      vnode.data.show = true;
+      if (value) {
+        enter(vnode, function () {
+          el.style.display = el.__vOriginalDisplay;
+        });
+      } else {
+        leave(vnode, function () {
+          el.style.display = 'none';
+        });
+      }
+    } else {
+      el.style.display = value ? el.__vOriginalDisplay : 'none';
+    }
+  },
+
+  unbind: function unbind (
+    el,
+    binding,
+    vnode,
+    oldVnode,
+    isDestroy
+  ) {
+    if (!isDestroy) {
+      el.style.display = el.__vOriginalDisplay;
+    }
+  }
+};
+
+var platformDirectives = {
+  model: model$1,
+  show: show
+};
+
+/*  */
+
+// Provides transition support for a single element/component.
+// supports transition mode (out-in / in-out)
+
+var transitionProps = {
+  name: String,
+  appear: Boolean,
+  css: Boolean,
+  mode: String,
+  type: String,
+  enterClass: String,
+  leaveClass: String,
+  enterToClass: String,
+  leaveToClass: String,
+  enterActiveClass: String,
+  leaveActiveClass: String,
+  appearClass: String,
+  appearActiveClass: String,
+  appearToClass: String,
+  duration: [Number, String, Object]
+};
+
+// in case the child is also an abstract component, e.g. <keep-alive>
+// we want to recursively retrieve the real component to be rendered
+function getRealChild (vnode) {
+  var compOptions = vnode && vnode.componentOptions;
+  if (compOptions && compOptions.Ctor.options.abstract) {
+    return getRealChild(getFirstComponentChild(compOptions.children))
+  } else {
+    return vnode
+  }
+}
+
+function extractTransitionData (comp) {
+  var data = {};
+  var options = comp.$options;
+  // props
+  for (var key in options.propsData) {
+    data[key] = comp[key];
+  }
+  // events.
+  // extract listeners and pass them directly to the transition methods
+  var listeners = options._parentListeners;
+  for (var key$1 in listeners) {
+    data[camelize(key$1)] = listeners[key$1];
+  }
+  return data
+}
+
+function placeholder (h, rawChild) {
+  return /\d-keep-alive$/.test(rawChild.tag)
+    ? h('keep-alive')
+    : null
+}
+
+function hasParentTransition (vnode) {
+  while ((vnode = vnode.parent)) {
+    if (vnode.data.transition) {
+      return true
+    }
+  }
+}
+
+function isSameChild (child, oldChild) {
+  return oldChild.key === child.key && oldChild.tag === child.tag
+}
+
+var Transition = {
+  name: 'transition',
+  props: transitionProps,
+  abstract: true,
+
+  render: function render (h) {
+    var this$1 = this;
+
+    var children = this.$slots.default;
+    if (!children) {
+      return
+    }
+
+    // filter out text nodes (possible whitespaces)
+    children = children.filter(function (c) { return c.tag; });
+    /* istanbul ignore if */
+    if (!children.length) {
+      return
+    }
+
+    // warn multiple elements
+    if (process.env.NODE_ENV !== 'production' && children.length > 1) {
+      warn(
+        '<transition> can only be used on a single element. Use ' +
+        '<transition-group> for lists.',
+        this.$parent
+      );
+    }
+
+    var mode = this.mode;
+
+    // warn invalid mode
+    if (process.env.NODE_ENV !== 'production' &&
+        mode && mode !== 'in-out' && mode !== 'out-in') {
+      warn(
+        'invalid <transition> mode: ' + mode,
+        this.$parent
+      );
+    }
+
+    var rawChild = children[0];
+
+    // if this is a component root node and the component's
+    // parent container node also has transition, skip.
+    if (hasParentTransition(this.$vnode)) {
+      return rawChild
+    }
+
+    // apply transition data to child
+    // use getRealChild() to ignore abstract components e.g. keep-alive
+    var child = getRealChild(rawChild);
+    /* istanbul ignore if */
+    if (!child) {
+      return rawChild
+    }
+
+    if (this._leaving) {
+      return placeholder(h, rawChild)
+    }
+
+    // ensure a key that is unique to the vnode type and to this transition
+    // component instance. This key will be used to remove pending leaving nodes
+    // during entering.
+    var id = "__transition-" + (this._uid) + "-";
+    child.key = child.key == null
+      ? id + child.tag
+      : isPrimitive(child.key)
+        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
+        : child.key;
+
+    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
+    var oldRawChild = this._vnode;
+    var oldChild = getRealChild(oldRawChild);
+
+    // mark v-show
+    // so that the transition module can hand over the control to the directive
+    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {
+      child.data.show = true;
+    }
+
+    if (oldChild && oldChild.data && !isSameChild(child, oldChild)) {
+      // replace old child transition data with fresh one
+      // important for dynamic transitions!
+      var oldData = oldChild && (oldChild.data.transition = extend({}, data));
+      // handle transition mode
+      if (mode === 'out-in') {
+        // return placeholder node and queue update when leave finishes
+        this._leaving = true;
+        mergeVNodeHook(oldData, 'afterLeave', function () {
+          this$1._leaving = false;
+          this$1.$forceUpdate();
+        });
+        return placeholder(h, rawChild)
+      } else if (mode === 'in-out') {
+        var delayedLeave;
+        var performLeave = function () { delayedLeave(); };
+        mergeVNodeHook(data, 'afterEnter', performLeave);
+        mergeVNodeHook(data, 'enterCancelled', performLeave);
+        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
+      }
+    }
+
+    return rawChild
+  }
+};
+
+/*  */
+
+// Provides transition support for list items.
+// supports move transitions using the FLIP technique.
+
+// Because the vdom's children update algorithm is "unstable" - i.e.
+// it doesn't guarantee the relative positioning of removed elements,
+// we force transition-group to update its children into two passes:
+// in the first pass, we remove all nodes that need to be removed,
+// triggering their leaving transition; in the second pass, we insert/move
+// into the final desired state. This way in the second pass removed
+// nodes will remain where they should be.
+
+var props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps);
+
+delete props.mode;
+
+var TransitionGroup = {
+  props: props,
+
+  render: function render (h) {
+    var tag = this.tag || this.$vnode.data.tag || 'span';
+    var map = Object.create(null);
+    var prevChildren = this.prevChildren = this.children;
+    var rawChildren = this.$slots.default || [];
+    var children = this.children = [];
+    var transitionData = extractTransitionData(this);
+
+    for (var i = 0; i < rawChildren.length; i++) {
+      var c = rawChildren[i];
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c);
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData;
+        } else if (process.env.NODE_ENV !== 'production') {
+          var opts = c.componentOptions;
+          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
+          warn(("<transition-group> children must be keyed: <" + name + ">"));
+        }
+      }
+    }
+
+    if (prevChildren) {
+      var kept = [];
+      var removed = [];
+      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
+        var c$1 = prevChildren[i$1];
+        c$1.data.transition = transitionData;
+        c$1.data.pos = c$1.elm.getBoundingClientRect();
+        if (map[c$1.key]) {
+          kept.push(c$1);
+        } else {
+          removed.push(c$1);
+        }
+      }
+      this.kept = h(tag, null, kept);
+      this.removed = removed;
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate: function beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    );
+    this._vnode = this.kept;
+  },
+
+  updated: function updated () {
+    var children = this.prevChildren;
+    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
+    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
+      return
+    }
+
+    // we divide the work into three loops to avoid mixing DOM reads and writes
+    // in each iteration - which helps prevent layout thrashing.
+    children.forEach(callPendingCbs);
+    children.forEach(recordPosition);
+    children.forEach(applyTranslation);
+
+    // force reflow to put everything in position
+    var body = document.body;
+    var f = body.offsetHeight; // eslint-disable-line
+
+    children.forEach(function (c) {
+      if (c.data.moved) {
+        var el = c.elm;
+        var s = el.style;
+        addTransitionClass(el, moveClass);
+        s.transform = s.WebkitTransform = s.transitionDuration = '';
+        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
+          if (!e || /transform$/.test(e.propertyName)) {
+            el.removeEventListener(transitionEndEvent, cb);
+            el._moveCb = null;
+            removeTransitionClass(el, moveClass);
+          }
+        });
+      }
+    });
+  },
+
+  methods: {
+    hasMove: function hasMove (el, moveClass) {
+      /* istanbul ignore if */
+      if (!hasTransition) {
+        return false
+      }
+      if (this._hasMove != null) {
+        return this._hasMove
+      }
+      // Detect whether an element with the move class applied has
+      // CSS transitions. Since the element may be inside an entering
+      // transition at this very moment, we make a clone of it and remove
+      // all other transition classes applied to ensure only the move class
+      // is applied.
+      var clone = el.cloneNode();
+      if (el._transitionClasses) {
+        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
+      }
+      addClass(clone, moveClass);
+      clone.style.display = 'none';
+      this.$el.appendChild(clone);
+      var info = getTransitionInfo(clone);
+      this.$el.removeChild(clone);
+      return (this._hasMove = info.hasTransform)
+    }
+  }
+};
+
+function callPendingCbs (c) {
+  /* istanbul ignore if */
+  if (c.elm._moveCb) {
+    c.elm._moveCb();
+  }
+  /* istanbul ignore if */
+  if (c.elm._enterCb) {
+    c.elm._enterCb();
+  }
+}
+
+function recordPosition (c) {
+  c.data.newPos = c.elm.getBoundingClientRect();
+}
+
+function applyTranslation (c) {
+  var oldPos = c.data.pos;
+  var newPos = c.data.newPos;
+  var dx = oldPos.left - newPos.left;
+  var dy = oldPos.top - newPos.top;
+  if (dx || dy) {
+    c.data.moved = true;
+    var s = c.elm.style;
+    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
+    s.transitionDuration = '0s';
+  }
+}
+
+var platformComponents = {
+  Transition: Transition,
+  TransitionGroup: TransitionGroup
+};
+
+/*  */
+
+// install platform specific utils
+Vue$2.config.mustUseProp = mustUseProp;
+Vue$2.config.isReservedTag = isReservedTag;
+Vue$2.config.getTagNamespace = getTagNamespace;
+Vue$2.config.isUnknownElement = isUnknownElement;
+
+// install platform runtime directives & components
+extend(Vue$2.options.directives, platformDirectives);
+extend(Vue$2.options.components, platformComponents);
+
+// install platform patch function
+Vue$2.prototype.__patch__ = inBrowser ? patch : noop;
+
+// public mount method
+Vue$2.prototype.$mount = function (
+  el,
+  hydrating
+) {
+  el = el && inBrowser ? query(el) : undefined;
+  return mountComponent(this, el, hydrating)
+};
+
+// devtools global hook
+/* istanbul ignore next */
+setTimeout(function () {
+  if (config.devtools) {
+    if (devtools) {
+      devtools.emit('init', Vue$2);
+    } else if (process.env.NODE_ENV !== 'production' && isChrome) {
+      console[console.info ? 'info' : 'log'](
+        'Download the Vue Devtools extension for a better development experience:\n' +
+        'https://github.com/vuejs/vue-devtools'
+      );
+    }
+  }
+  if (process.env.NODE_ENV !== 'production' &&
+      config.productionTip !== false &&
+      inBrowser && typeof console !== 'undefined') {
+    console[console.info ? 'info' : 'log'](
+      "You are running Vue in development mode.\n" +
+      "Make sure to turn on production mode when deploying for production.\n" +
+      "See more tips at https://vuejs.org/guide/deployment.html"
+    );
+  }
+}, 0);
+
+module.exports = Vue$2;
Index: public/node_modules/vue/src/platforms/web/util/compat.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/util/compat.js	(revision )
+++ public/node_modules/vue/src/platforms/web/util/compat.js	(revision )
@@ -0,0 +1,14 @@
+/* @flow */
+
+import { inBrowser } from 'core/util/index'
+
+// check whether current browser encodes a char inside attribute values
+function shouldDecode (content: string, encoded: string): boolean {
+  const div = document.createElement('div')
+  div.innerHTML = `<div a="${content}">`
+  return div.innerHTML.indexOf(encoded) > 0
+}
+
+// #3663
+// IE encodes newlines inside attribute values while other browsers don't
+export const shouldDecodeNewlines = inBrowser ? shouldDecode('\n', '&#10;') : false
Index: public/node_modules/vue/src/platforms/weex/compiler/directives/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/directives/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/directives/index.js	(revision )
@@ -0,0 +1,5 @@
+import model from './model'
+
+export default {
+  model
+}
Index: public/node_modules/vue/src/platforms/web/compiler/modules/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/compiler/modules/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/compiler/modules/index.js	(revision )
@@ -0,0 +1,7 @@
+import klass from './class'
+import style from './style'
+
+export default [
+  klass,
+  style
+]
Index: public/node_modules/vue-resource/node_modules/got/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/readme.md	(revision )
@@ -0,0 +1,335 @@
+<h1 align="center">
+	<br>
+	<img width="360" src="https://rawgit.com/sindresorhus/got/master/media/logo.svg" alt="got">
+	<br>
+	<br>
+	<br>
+</h1>
+
+> Simplified HTTP requests
+
+[![Build Status](https://travis-ci.org/sindresorhus/got.svg?branch=master)](https://travis-ci.org/sindresorhus/got) [![Coverage Status](https://coveralls.io/repos/github/sindresorhus/got/badge.svg?branch=master)](https://coveralls.io/github/sindresorhus/got?branch=master) [![Downloads](https://img.shields.io/npm/dm/got.svg)](https://npmjs.com/got)
+
+A nicer interface to the built-in [`http`](http://nodejs.org/api/http.html) module.
+
+It supports following redirects, promises, streams, retries, automagically handling gzip/deflate and some convenience options.
+
+Created because [`request`](https://github.com/request/request) is bloated *(several megabytes!)*.
+
+
+## Install
+
+**WARNING: Node.js 4 or higher is required for got@6 and above.** For older Node.js versions use [got@5](https://github.com/sindresorhus/got/tree/v5.x).
+
+```
+$ npm install --save got
+```
+
+
+## Usage
+
+```js
+const fs = require('fs');
+const got = require('got');
+
+got('todomvc.com')
+	.then(response => {
+		console.log(response.body);
+		//=> '<!doctype html> ...'
+	})
+	.catch(error => {
+		console.log(error.response.body);
+		//=> 'Internal server error ...'
+	});
+
+// Streams
+got.stream('todomvc.com').pipe(fs.createWriteStream('index.html'));
+
+// For POST, PUT and PATCH methods got.stream returns a WritableStream
+fs.createReadStream('index.html').pipe(got.stream.post('todomvc.com'));
+```
+
+
+### API
+
+It's a `GET` request by default, but can be changed in `options`.
+
+#### got(url, [options])
+
+Returns a Promise for a `response` object with a `body` property, a `url` property with the request URL or the final URL after redirects, and a `requestUrl` property with the original request URL.
+
+##### url
+
+Type: `string`, `object`
+
+The URL to request or a [`http.request` options](https://nodejs.org/api/http.html#http_http_request_options_callback) object.
+
+Properties from `options` will override properties in the parsed `url`.
+
+##### options
+
+Type: `object`
+
+Any of the [`http.request`](http://nodejs.org/api/http.html#http_http_request_options_callback) options.
+
+###### body
+
+Type: `string`, `buffer`, `readableStream`, `object`
+
+*This is mutually exclusive with stream mode.*
+
+Body that will be sent with a `POST` request.
+
+If present in `options` and `options.method` is not set, `options.method` will be set to `POST`.
+
+If `content-length` or `transfer-encoding` is not set in `options.headers` and `body` is a string or buffer, `content-length` will be set to the body length.
+
+If `body` is a plain object, it will be stringified with [`querystring.stringify`](https://nodejs.org/api/querystring.html#querystring_querystring_stringify_obj_sep_eq_options) and sent as `application/x-www-form-urlencoded`.
+
+###### encoding
+
+Type: `string`, `null`<br>
+Default: `'utf8'`
+
+Encoding to be used on `setEncoding` of the response data. If `null`, the body is returned as a Buffer.
+
+###### json
+
+Type: `boolean`<br>
+Default: `false`
+
+*This is mutually exclusive with stream mode.*
+
+Parse response body with `JSON.parse` and set `accept` header to `application/json`.
+
+###### query
+
+Type: `string`, `object`<br>
+
+Query string object that will be added to the request URL. This will override the query string in `url`.
+
+###### timeout
+
+Type: `number`, `object`
+
+Milliseconds to wait for a server to send response headers before aborting request with `ETIMEDOUT` error.
+
+Option accepts `object` with separate `connect` and `socket` fields for connection and socket inactivity timeouts.
+
+###### retries
+
+Type: `number`, `function`<br>
+Default: `5`
+
+Number of request retries when network errors happens. Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 0).
+
+Option accepts `function` with `retry` and `error` arguments. Function must return delay in milliseconds (`0` return value cancels retry).
+
+**Note:** if `retries` is `number`, `ENOTFOUND` and `ENETUNREACH` error will not be retried (see full list in [`is-retry-allowed`](https://github.com/floatdrop/is-retry-allowed/blob/master/index.js#L12) module).
+
+###### followRedirect
+
+Type: `boolean`<br>
+Default: `true`
+
+Defines if redirect responses should be followed automatically.
+
+
+#### Streams
+
+#### got.stream(url, [options])
+
+`stream` method will return Duplex stream with additional events:
+
+##### .on('request', request)
+
+`request` event to get the request object of the request.
+
+**Tip**: You can use `request` event to abort request:
+
+```js
+got.stream('github.com')
+	.on('request', req => setTimeout(() => req.abort(), 50));
+```
+
+##### .on('response', response)
+
+`response` event to get the response object of the final request.
+
+##### .on('redirect', response, nextOptions)
+
+`redirect` event to get the response object of a redirect. The second argument is options for the next request to the redirect location.
+
+##### .on('error', error, body, response)
+
+`error` event emitted in case of protocol error (like `ENOTFOUND` etc.) or status error (4xx or 5xx). The second argument is the body of the server response in case of status error. The third argument is response object.
+
+#### got.get(url, [options])
+#### got.post(url, [options])
+#### got.put(url, [options])
+#### got.patch(url, [options])
+#### got.head(url, [options])
+#### got.delete(url, [options])
+
+Sets `options.method` to the method name and makes a request.
+
+
+## Errors
+
+Each error contains (if available) `statusCode`, `statusMessage`, `host`, `hostname`, `method` and `path` properties to make debugging easier.
+
+In Promise mode, the `response` is attached to the error.
+
+#### got.RequestError
+
+When a request fails. Contains a `code` property with error class code, like `ECONNREFUSED`.
+
+#### got.ReadError
+
+When reading from response stream fails.
+
+#### got.ParseError
+
+When `json` option is enabled and `JSON.parse` fails.
+
+#### got.HTTPError
+
+When server response code is not 2xx. Contains `statusCode` and `statusMessage`.
+
+#### got.MaxRedirectsError
+
+When server redirects you more than 10 times.
+
+
+## Proxies
+
+You can use the [`tunnel`](https://github.com/koichik/node-tunnel) module with the `agent` option to work with proxies:
+
+```js
+const got = require('got');
+const tunnel = require('tunnel');
+
+got('todomvc.com', {
+	agent: tunnel.httpOverHttp({
+		proxy: {
+			host: 'localhost'
+		}
+	})
+});
+```
+
+
+## Cookies
+
+You can use the [`cookie`](https://github.com/jshttp/cookie) module to include cookies in a request:
+
+```js
+const got = require('got');
+const cookie = require('cookie');
+
+got('google.com', {
+	headers: {
+		cookie: cookie.serialize('foo', 'bar')
+	}
+});
+```
+
+
+## Form data
+
+You can use the [`form-data`](https://github.com/form-data/form-data) module to create POST request with form data:
+
+```js
+const fs = require('fs');
+const got = require('got');
+const FormData = require('form-data');
+const form = new FormData();
+
+form.append('my_file', fs.createReadStream('/foo/bar.jpg'));
+
+got.post('google.com', {
+	body: form
+});
+```
+
+
+## OAuth
+
+You can use the [`oauth-1.0a`](https://github.com/ddo/oauth-1.0a) module to create a signed OAuth request:
+
+```js
+const got = require('got');
+const crypto  = require('crypto');
+const OAuth = require('oauth-1.0a');
+
+const oauth = OAuth({
+	consumer: {
+		key: process.env.CONSUMER_KEY,
+		secret: process.env.CONSUMER_SECRET
+	},
+	signature_method: 'HMAC-SHA1',
+	hash_function: (baseString, key) => crypto.createHmac('sha1', key).update(baseString).digest('base64')
+});
+
+const token = {
+	key: process.env.ACCESS_TOKEN,
+	secret: process.env.ACCESS_TOKEN_SECRET
+};
+
+const url = 'https://api.twitter.com/1.1/statuses/home_timeline.json';
+
+got(url, {
+	headers: oauth.toHeader(oauth.authorize({url, method: 'GET'}, token)),
+	json: true
+});
+```
+
+
+## Unix Domain Sockets
+
+Requests can also be sent via [unix domain sockets](http://serverfault.com/questions/124517/whats-the-difference-between-unix-socket-and-tcp-ip-socket). Use the following URL scheme: `PROTOCOL://unix:SOCKET:PATH`.
+
+- `PROTOCOL` - `http` or `https` *(optional)*
+- `SOCKET` - absolute path to a unix domain socket, e.g. `/var/run/docker.sock`
+- `PATH` - request path, e.g. `/v2/keys`
+
+```js
+got('http://unix:/var/run/docker.sock:/containers/json');
+
+// or without protocol (http by default)
+got('unix:/var/run/docker.sock:/containers/json');
+```
+
+
+## Tip
+
+It's a good idea to set the `'user-agent'` header so the provider can more easily see how their resource is used. By default, it's the URL to this repo.
+
+```js
+const got = require('got');
+const pkg = require('./package.json');
+
+got('todomvc.com', {
+	headers: {
+		'user-agent': `my-module/${pkg.version} (https://github.com/username/my-module)`
+	}
+});
+```
+
+
+## Related
+
+- [gh-got](https://github.com/sindresorhus/gh-got) - Convenience wrapper for interacting with the GitHub API
+- [travis-got](https://github.com/samverschueren/travis-got) - Convenience wrapper for interacting with the Travis API
+
+
+## Created by
+
+[![Sindre Sorhus](https://avatars.githubusercontent.com/u/170270?v=3&s=100)](https://sindresorhus.com) | [![Vsevolod Strukchinsky](https://avatars.githubusercontent.com/u/365089?v=3&s=100)](https://github.com/floatdrop)
+---|---
+[Sindre Sorhus](https://sindresorhus.com) | [Vsevolod Strukchinsky](https://github.com/floatdrop)
+
+
+## License
+
+MIT  [Sindre Sorhus](https://sindresorhus.com)
Index: public/node_modules/vue/src/core/global-api/mixin.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/global-api/mixin.js	(revision )
+++ public/node_modules/vue/src/core/global-api/mixin.js	(revision )
@@ -0,0 +1,9 @@
+/* @flow */
+
+import { mergeOptions } from '../util/index'
+
+export function initMixin (Vue: GlobalAPI) {
+  Vue.mixin = function (mixin: Object) {
+    this.options = mergeOptions(this.options, mixin)
+  }
+}
Index: public/node_modules/vue/src/core/vdom/modules/directives.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/modules/directives.js	(revision )
+++ public/node_modules/vue/src/core/vdom/modules/directives.js	(revision )
@@ -0,0 +1,112 @@
+/* @flow */
+
+import { emptyNode } from 'core/vdom/patch'
+import { resolveAsset } from 'core/util/options'
+import { mergeVNodeHook } from 'core/vdom/helpers/index'
+
+export default {
+  create: updateDirectives,
+  update: updateDirectives,
+  destroy: function unbindDirectives (vnode: VNodeWithData) {
+    updateDirectives(vnode, emptyNode)
+  }
+}
+
+function updateDirectives (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (oldVnode.data.directives || vnode.data.directives) {
+    _update(oldVnode, vnode)
+  }
+}
+
+function _update (oldVnode, vnode) {
+  const isCreate = oldVnode === emptyNode
+  const isDestroy = vnode === emptyNode
+  const oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context)
+  const newDirs = normalizeDirectives(vnode.data.directives, vnode.context)
+
+  const dirsWithInsert = []
+  const dirsWithPostpatch = []
+
+  let key, oldDir, dir
+  for (key in newDirs) {
+    oldDir = oldDirs[key]
+    dir = newDirs[key]
+    if (!oldDir) {
+      // new directive, bind
+      callHook(dir, 'bind', vnode, oldVnode)
+      if (dir.def && dir.def.inserted) {
+        dirsWithInsert.push(dir)
+      }
+    } else {
+      // existing directive, update
+      dir.oldValue = oldDir.value
+      callHook(dir, 'update', vnode, oldVnode)
+      if (dir.def && dir.def.componentUpdated) {
+        dirsWithPostpatch.push(dir)
+      }
+    }
+  }
+
+  if (dirsWithInsert.length) {
+    const callInsert = () => {
+      for (let i = 0; i < dirsWithInsert.length; i++) {
+        callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode)
+      }
+    }
+    if (isCreate) {
+      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert)
+    } else {
+      callInsert()
+    }
+  }
+
+  if (dirsWithPostpatch.length) {
+    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', () => {
+      for (let i = 0; i < dirsWithPostpatch.length; i++) {
+        callHook(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode)
+      }
+    })
+  }
+
+  if (!isCreate) {
+    for (key in oldDirs) {
+      if (!newDirs[key]) {
+        // no longer present, unbind
+        callHook(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy)
+      }
+    }
+  }
+}
+
+const emptyModifiers = Object.create(null)
+
+function normalizeDirectives (
+  dirs: ?Array<VNodeDirective>,
+  vm: Component
+): { [key: string]: VNodeDirective } {
+  const res = Object.create(null)
+  if (!dirs) {
+    return res
+  }
+  let i, dir
+  for (i = 0; i < dirs.length; i++) {
+    dir = dirs[i]
+    if (!dir.modifiers) {
+      dir.modifiers = emptyModifiers
+    }
+    res[getRawDirName(dir)] = dir
+    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true)
+  }
+  return res
+}
+
+function getRawDirName (dir: VNodeDirective): string {
+  return dir.rawName || `${dir.name}.${Object.keys(dir.modifiers || {}).join('.')}`
+}
+
+function callHook (dir, hook, vnode, oldVnode, isDestroy) {
+  const fn = dir.def && dir.def[hook]
+  if (fn) {
+    fn(vnode.elm, dir, vnode, oldVnode, isDestroy)
+  }
+}
Index: public/node_modules/vue/src/platforms/web/runtime/node-ops.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/node-ops.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/node-ops.js	(revision )
@@ -0,0 +1,59 @@
+/* @flow */
+
+import { namespaceMap } from 'web/util/index'
+
+export function createElement (tagName: string, vnode: VNode): Element {
+  const elm = document.createElement(tagName)
+  if (tagName !== 'select') {
+    return elm
+  }
+  // false or null will remove the attribute but undefined will not
+  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
+    elm.setAttribute('multiple', 'multiple')
+  }
+  return elm
+}
+
+export function createElementNS (namespace: string, tagName: string): Element {
+  return document.createElementNS(namespaceMap[namespace], tagName)
+}
+
+export function createTextNode (text: string): Text {
+  return document.createTextNode(text)
+}
+
+export function createComment (text: string): Comment {
+  return document.createComment(text)
+}
+
+export function insertBefore (parentNode: Node, newNode: Node, referenceNode: Node) {
+  parentNode.insertBefore(newNode, referenceNode)
+}
+
+export function removeChild (node: Node, child: Node) {
+  node.removeChild(child)
+}
+
+export function appendChild (node: Node, child: Node) {
+  node.appendChild(child)
+}
+
+export function parentNode (node: Node): ?Node {
+  return node.parentNode
+}
+
+export function nextSibling (node: Node): ?Node {
+  return node.nextSibling
+}
+
+export function tagName (node: Element): string {
+  return node.tagName
+}
+
+export function setTextContent (node: Node, text: string) {
+  node.textContent = text
+}
+
+export function setAttribute (node: Element, key: string, val: string) {
+  node.setAttribute(key, val)
+}
Index: public/node_modules/vue-resource/src/util.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/util.js	(revision )
+++ public/node_modules/vue-resource/src/util.js	(revision )
@@ -0,0 +1,170 @@
+/**
+ * Utility functions.
+ */
+
+import Promise from './promise';
+
+var {hasOwnProperty} = {}, {slice} = [], debug = false, ntick;
+
+export const inBrowser = typeof window !== 'undefined';
+
+export default function ({config, nextTick}) {
+    ntick = nextTick;
+    debug = config.debug || !config.silent;
+}
+
+export function warn(msg) {
+    if (typeof console !== 'undefined' && debug) {
+        console.warn('[VueResource warn]: ' + msg);
+    }
+}
+
+export function error(msg) {
+    if (typeof console !== 'undefined') {
+        console.error(msg);
+    }
+}
+
+export function nextTick(cb, ctx) {
+    return ntick(cb, ctx);
+}
+
+export function trim(str) {
+    return str ? str.replace(/^\s*|\s*$/g, '') : '';
+}
+
+export function toLower(str) {
+    return str ? str.toLowerCase() : '';
+}
+
+export function toUpper(str) {
+    return str ? str.toUpperCase() : '';
+}
+
+export const isArray = Array.isArray;
+
+export function isString(val) {
+    return typeof val === 'string';
+}
+
+export function isBoolean(val) {
+    return val === true || val === false;
+}
+
+export function isFunction(val) {
+    return typeof val === 'function';
+}
+
+export function isObject(obj) {
+    return obj !== null && typeof obj === 'object';
+}
+
+export function isPlainObject(obj) {
+    return isObject(obj) && Object.getPrototypeOf(obj) == Object.prototype;
+}
+
+export function isBlob(obj) {
+    return typeof Blob !== 'undefined' && obj instanceof Blob;
+}
+
+export function isFormData(obj) {
+    return typeof FormData !== 'undefined' && obj instanceof FormData;
+}
+
+export function when(value, fulfilled, rejected) {
+
+    var promise = Promise.resolve(value);
+
+    if (arguments.length < 2) {
+        return promise;
+    }
+
+    return promise.then(fulfilled, rejected);
+}
+
+export function options(fn, obj, opts) {
+
+    opts = opts || {};
+
+    if (isFunction(opts)) {
+        opts = opts.call(obj);
+    }
+
+    return merge(fn.bind({$vm: obj, $options: opts}), fn, {$options: opts});
+}
+
+export function each(obj, iterator) {
+
+    var i, key;
+
+    if (isArray(obj)) {
+        for (i = 0; i < obj.length; i++) {
+            iterator.call(obj[i], obj[i], i);
+        }
+    } else if (isObject(obj)) {
+        for (key in obj) {
+            if (hasOwnProperty.call(obj, key)) {
+                iterator.call(obj[key], obj[key], key);
+            }
+        }
+    }
+
+    return obj;
+}
+
+export const assign = Object.assign || _assign;
+
+export function merge(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(source => {
+        _merge(target, source, true);
+    });
+
+    return target;
+}
+
+export function defaults(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(source => {
+
+        for (var key in source) {
+            if (target[key] === undefined) {
+                target[key] = source[key];
+            }
+        }
+
+    });
+
+    return target;
+}
+
+function _assign(target) {
+
+    var args = slice.call(arguments, 1);
+
+    args.forEach(source => {
+        _merge(target, source);
+    });
+
+    return target;
+}
+
+function _merge(target, source, deep) {
+    for (var key in source) {
+        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
+            if (isPlainObject(source[key]) && !isPlainObject(target[key])) {
+                target[key] = {};
+            }
+            if (isArray(source[key]) && !isArray(target[key])) {
+                target[key] = [];
+            }
+            _merge(target[key], source[key], deep);
+        } else if (source[key] !== undefined) {
+            target[key] = source[key];
+        }
+    }
+}
Index: public/node_modules/vue/src/core/util/options.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/options.js	(revision )
+++ public/node_modules/vue/src/core/util/options.js	(revision )
@@ -0,0 +1,337 @@
+/* @flow */
+
+import Vue from '../instance/index'
+import config from '../config'
+import { warn } from './debug'
+import { set } from '../observer/index'
+import {
+  extend,
+  isPlainObject,
+  hasOwn,
+  camelize,
+  capitalize,
+  isBuiltInTag
+} from 'shared/util'
+
+/**
+ * Option overwriting strategies are functions that handle
+ * how to merge a parent option value and a child option
+ * value into the final value.
+ */
+const strats = config.optionMergeStrategies
+
+/**
+ * Options with restrictions
+ */
+if (process.env.NODE_ENV !== 'production') {
+  strats.el = strats.propsData = function (parent, child, vm, key) {
+    if (!vm) {
+      warn(
+        `option "${key}" can only be used during instance ` +
+        'creation with the `new` keyword.'
+      )
+    }
+    return defaultStrat(parent, child)
+  }
+}
+
+/**
+ * Helper that recursively merges two data objects together.
+ */
+function mergeData (to: Object, from: ?Object): Object {
+  if (!from) return to
+  let key, toVal, fromVal
+  const keys = Object.keys(from)
+  for (let i = 0; i < keys.length; i++) {
+    key = keys[i]
+    toVal = to[key]
+    fromVal = from[key]
+    if (!hasOwn(to, key)) {
+      set(to, key, fromVal)
+    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
+      mergeData(toVal, fromVal)
+    }
+  }
+  return to
+}
+
+/**
+ * Data
+ */
+strats.data = function (
+  parentVal: any,
+  childVal: any,
+  vm?: Component
+): ?Function {
+  if (!vm) {
+    // in a Vue.extend merge, both should be functions
+    if (!childVal) {
+      return parentVal
+    }
+    if (typeof childVal !== 'function') {
+      process.env.NODE_ENV !== 'production' && warn(
+        'The "data" option should be a function ' +
+        'that returns a per-instance value in component ' +
+        'definitions.',
+        vm
+      )
+      return parentVal
+    }
+    if (!parentVal) {
+      return childVal
+    }
+    // when parentVal & childVal are both present,
+    // we need to return a function that returns the
+    // merged result of both functions... no need to
+    // check if parentVal is a function here because
+    // it has to be a function to pass previous merges.
+    return function mergedDataFn () {
+      return mergeData(
+        childVal.call(this),
+        parentVal.call(this)
+      )
+    }
+  } else if (parentVal || childVal) {
+    return function mergedInstanceDataFn () {
+      // instance merge
+      const instanceData = typeof childVal === 'function'
+        ? childVal.call(vm)
+        : childVal
+      const defaultData = typeof parentVal === 'function'
+        ? parentVal.call(vm)
+        : undefined
+      if (instanceData) {
+        return mergeData(instanceData, defaultData)
+      } else {
+        return defaultData
+      }
+    }
+  }
+}
+
+/**
+ * Hooks and props are merged as arrays.
+ */
+function mergeHook (
+  parentVal: ?Array<Function>,
+  childVal: ?Function | ?Array<Function>
+): ?Array<Function> {
+  return childVal
+    ? parentVal
+      ? parentVal.concat(childVal)
+      : Array.isArray(childVal)
+        ? childVal
+        : [childVal]
+    : parentVal
+}
+
+config._lifecycleHooks.forEach(hook => {
+  strats[hook] = mergeHook
+})
+
+/**
+ * Assets
+ *
+ * When a vm is present (instance creation), we need to do
+ * a three-way merge between constructor options, instance
+ * options and parent options.
+ */
+function mergeAssets (parentVal: ?Object, childVal: ?Object): Object {
+  const res = Object.create(parentVal || null)
+  return childVal
+    ? extend(res, childVal)
+    : res
+}
+
+config._assetTypes.forEach(function (type) {
+  strats[type + 's'] = mergeAssets
+})
+
+/**
+ * Watchers.
+ *
+ * Watchers hashes should not overwrite one
+ * another, so we merge them as arrays.
+ */
+strats.watch = function (parentVal: ?Object, childVal: ?Object): ?Object {
+  /* istanbul ignore if */
+  if (!childVal) return Object.create(parentVal || null)
+  if (!parentVal) return childVal
+  const ret = {}
+  extend(ret, parentVal)
+  for (const key in childVal) {
+    let parent = ret[key]
+    const child = childVal[key]
+    if (parent && !Array.isArray(parent)) {
+      parent = [parent]
+    }
+    ret[key] = parent
+      ? parent.concat(child)
+      : [child]
+  }
+  return ret
+}
+
+/**
+ * Other object hashes.
+ */
+strats.props =
+strats.methods =
+strats.computed = function (parentVal: ?Object, childVal: ?Object): ?Object {
+  if (!childVal) return Object.create(parentVal || null)
+  if (!parentVal) return childVal
+  const ret = Object.create(null)
+  extend(ret, parentVal)
+  extend(ret, childVal)
+  return ret
+}
+
+/**
+ * Default strategy.
+ */
+const defaultStrat = function (parentVal: any, childVal: any): any {
+  return childVal === undefined
+    ? parentVal
+    : childVal
+}
+
+/**
+ * Validate component names
+ */
+function checkComponents (options: Object) {
+  for (const key in options.components) {
+    const lower = key.toLowerCase()
+    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
+      warn(
+        'Do not use built-in or reserved HTML elements as component ' +
+        'id: ' + key
+      )
+    }
+  }
+}
+
+/**
+ * Ensure all props option syntax are normalized into the
+ * Object-based format.
+ */
+function normalizeProps (options: Object) {
+  const props = options.props
+  if (!props) return
+  const res = {}
+  let i, val, name
+  if (Array.isArray(props)) {
+    i = props.length
+    while (i--) {
+      val = props[i]
+      if (typeof val === 'string') {
+        name = camelize(val)
+        res[name] = { type: null }
+      } else if (process.env.NODE_ENV !== 'production') {
+        warn('props must be strings when using array syntax.')
+      }
+    }
+  } else if (isPlainObject(props)) {
+    for (const key in props) {
+      val = props[key]
+      name = camelize(key)
+      res[name] = isPlainObject(val)
+        ? val
+        : { type: val }
+    }
+  }
+  options.props = res
+}
+
+/**
+ * Normalize raw function directives into object format.
+ */
+function normalizeDirectives (options: Object) {
+  const dirs = options.directives
+  if (dirs) {
+    for (const key in dirs) {
+      const def = dirs[key]
+      if (typeof def === 'function') {
+        dirs[key] = { bind: def, update: def }
+      }
+    }
+  }
+}
+
+/**
+ * Merge two option objects into a new one.
+ * Core utility used in both instantiation and inheritance.
+ */
+export function mergeOptions (
+  parent: Object,
+  child: Object,
+  vm?: Component
+): Object {
+  if (process.env.NODE_ENV !== 'production') {
+    checkComponents(child)
+  }
+  normalizeProps(child)
+  normalizeDirectives(child)
+  const extendsFrom = child.extends
+  if (extendsFrom) {
+    parent = typeof extendsFrom === 'function'
+      ? mergeOptions(parent, extendsFrom.options, vm)
+      : mergeOptions(parent, extendsFrom, vm)
+  }
+  if (child.mixins) {
+    for (let i = 0, l = child.mixins.length; i < l; i++) {
+      let mixin = child.mixins[i]
+      if (mixin.prototype instanceof Vue) {
+        mixin = mixin.options
+      }
+      parent = mergeOptions(parent, mixin, vm)
+    }
+  }
+  const options = {}
+  let key
+  for (key in parent) {
+    mergeField(key)
+  }
+  for (key in child) {
+    if (!hasOwn(parent, key)) {
+      mergeField(key)
+    }
+  }
+  function mergeField (key) {
+    const strat = strats[key] || defaultStrat
+    options[key] = strat(parent[key], child[key], vm, key)
+  }
+  return options
+}
+
+/**
+ * Resolve an asset.
+ * This function is used because child instances need access
+ * to assets defined in its ancestor chain.
+ */
+export function resolveAsset (
+  options: Object,
+  type: string,
+  id: string,
+  warnMissing?: boolean
+): any {
+  /* istanbul ignore if */
+  if (typeof id !== 'string') {
+    return
+  }
+  const assets = options[type]
+  // check local registration variations first
+  if (hasOwn(assets, id)) return assets[id]
+  const camelizedId = camelize(id)
+  if (hasOwn(assets, camelizedId)) return assets[camelizedId]
+  const PascalCaseId = capitalize(camelizedId)
+  if (hasOwn(assets, PascalCaseId)) return assets[PascalCaseId]
+  // fallback to prototype chain
+  const res = assets[id] || assets[camelizedId] || assets[PascalCaseId]
+  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {
+    warn(
+      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
+      options
+    )
+  }
+  return res
+}
Index: public/node_modules/vue/src/platforms/weex/runtime/components/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/components/index.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/components/index.js	(revision )
@@ -0,0 +1,7 @@
+import Transition from './transition'
+import TransitionGroup from './transition-group'
+
+export default {
+  Transition,
+  TransitionGroup
+}
Index: public/node_modules/vue/src/platforms/weex/compiler/modules/props.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/compiler/modules/props.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/compiler/modules/props.js	(revision )
@@ -0,0 +1,32 @@
+/* @flow */
+
+import { cached, camelize } from 'shared/util'
+
+const normalize = cached(camelize)
+
+function normalizeKeyName (str: string) : string {
+  if (str.match(/^v\-/)) {
+    return str.replace(/(v-[a-z\-]+\:)([a-z\-]+)$/i, ($, directive, prop) => {
+      return directive + normalize(prop)
+    })
+  }
+  return normalize(str)
+}
+
+function transformNode (el: ASTElement, options: CompilerOptions) {
+  if (Array.isArray(el.attrsList)) {
+    el.attrsList.forEach(attr => {
+      if (attr.name && attr.name.match(/\-/)) {
+        const realName = normalizeKeyName(attr.name)
+        if (el.attrsMap) {
+          el.attrsMap[realName] = el.attrsMap[attr.name]
+          delete el.attrsMap[attr.name]
+        }
+        attr.name = realName
+      }
+    })
+  }
+}
+export default {
+  transformNode
+}
Index: public/node_modules/vue/src/platforms/web/runtime/components/transition-group.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/components/transition-group.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/components/transition-group.js	(revision )
@@ -0,0 +1,178 @@
+/* @flow */
+
+// Provides transition support for list items.
+// supports move transitions using the FLIP technique.
+
+// Because the vdom's children update algorithm is "unstable" - i.e.
+// it doesn't guarantee the relative positioning of removed elements,
+// we force transition-group to update its children into two passes:
+// in the first pass, we remove all nodes that need to be removed,
+// triggering their leaving transition; in the second pass, we insert/move
+// into the final desired state. This way in the second pass removed
+// nodes will remain where they should be.
+
+import { warn, extend } from 'core/util/index'
+import { addClass, removeClass } from '../class-util'
+import { transitionProps, extractTransitionData } from './transition'
+
+import {
+  hasTransition,
+  getTransitionInfo,
+  transitionEndEvent,
+  addTransitionClass,
+  removeTransitionClass
+} from '../transition-util'
+
+const props = extend({
+  tag: String,
+  moveClass: String
+}, transitionProps)
+
+delete props.mode
+
+export default {
+  props,
+
+  render (h: Function) {
+    const tag: string = this.tag || this.$vnode.data.tag || 'span'
+    const map: Object = Object.create(null)
+    const prevChildren: Array<VNode> = this.prevChildren = this.children
+    const rawChildren: Array<VNode> = this.$slots.default || []
+    const children: Array<VNode> = this.children = []
+    const transitionData: Object = extractTransitionData(this)
+
+    for (let i = 0; i < rawChildren.length; i++) {
+      const c: VNode = rawChildren[i]
+      if (c.tag) {
+        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
+          children.push(c)
+          map[c.key] = c
+          ;(c.data || (c.data = {})).transition = transitionData
+        } else if (process.env.NODE_ENV !== 'production') {
+          const opts: ?VNodeComponentOptions = c.componentOptions
+          const name: string = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag
+          warn(`<transition-group> children must be keyed: <${name}>`)
+        }
+      }
+    }
+
+    if (prevChildren) {
+      const kept: Array<VNode> = []
+      const removed: Array<VNode> = []
+      for (let i = 0; i < prevChildren.length; i++) {
+        const c: VNode = prevChildren[i]
+        c.data.transition = transitionData
+        c.data.pos = c.elm.getBoundingClientRect()
+        if (map[c.key]) {
+          kept.push(c)
+        } else {
+          removed.push(c)
+        }
+      }
+      this.kept = h(tag, null, kept)
+      this.removed = removed
+    }
+
+    return h(tag, null, children)
+  },
+
+  beforeUpdate () {
+    // force removing pass
+    this.__patch__(
+      this._vnode,
+      this.kept,
+      false, // hydrating
+      true // removeOnly (!important, avoids unnecessary moves)
+    )
+    this._vnode = this.kept
+  },
+
+  updated () {
+    const children: Array<VNode> = this.prevChildren
+    const moveClass: string = this.moveClass || ((this.name || 'v') + '-move')
+    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
+      return
+    }
+
+    // we divide the work into three loops to avoid mixing DOM reads and writes
+    // in each iteration - which helps prevent layout thrashing.
+    children.forEach(callPendingCbs)
+    children.forEach(recordPosition)
+    children.forEach(applyTranslation)
+
+    // force reflow to put everything in position
+    const body: any = document.body
+    const f: number = body.offsetHeight // eslint-disable-line
+
+    children.forEach((c: VNode) => {
+      if (c.data.moved) {
+        var el: any = c.elm
+        var s: any = el.style
+        addTransitionClass(el, moveClass)
+        s.transform = s.WebkitTransform = s.transitionDuration = ''
+        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
+          if (!e || /transform$/.test(e.propertyName)) {
+            el.removeEventListener(transitionEndEvent, cb)
+            el._moveCb = null
+            removeTransitionClass(el, moveClass)
+          }
+        })
+      }
+    })
+  },
+
+  methods: {
+    hasMove (el: any, moveClass: string): boolean {
+      /* istanbul ignore if */
+      if (!hasTransition) {
+        return false
+      }
+      if (this._hasMove != null) {
+        return this._hasMove
+      }
+      // Detect whether an element with the move class applied has
+      // CSS transitions. Since the element may be inside an entering
+      // transition at this very moment, we make a clone of it and remove
+      // all other transition classes applied to ensure only the move class
+      // is applied.
+      const clone: HTMLElement = el.cloneNode()
+      if (el._transitionClasses) {
+        el._transitionClasses.forEach((cls: string) => { removeClass(clone, cls) })
+      }
+      addClass(clone, moveClass)
+      clone.style.display = 'none'
+      this.$el.appendChild(clone)
+      const info: Object = getTransitionInfo(clone)
+      this.$el.removeChild(clone)
+      return (this._hasMove = info.hasTransform)
+    }
+  }
+}
+
+function callPendingCbs (c: VNode) {
+  /* istanbul ignore if */
+  if (c.elm._moveCb) {
+    c.elm._moveCb()
+  }
+  /* istanbul ignore if */
+  if (c.elm._enterCb) {
+    c.elm._enterCb()
+  }
+}
+
+function recordPosition (c: VNode) {
+  c.data.newPos = c.elm.getBoundingClientRect()
+}
+
+function applyTranslation (c: VNode) {
+  const oldPos = c.data.pos
+  const newPos = c.data.newPos
+  const dx = oldPos.left - newPos.left
+  const dy = oldPos.top - newPos.top
+  if (dx || dy) {
+    c.data.moved = true
+    const s = c.elm.style
+    s.transform = s.WebkitTransform = `translate(${dx}px,${dy}px)`
+    s.transitionDuration = '0s'
+  }
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/readme.md	(revision )
@@ -0,0 +1,28 @@
+# is-redirect [![Build Status](https://travis-ci.org/sindresorhus/is-redirect.svg?branch=master)](https://travis-ci.org/sindresorhus/is-redirect)
+
+> Check if a number is a [redirect HTTP status code](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection)
+
+
+## Install
+
+```
+$ npm install --save is-redirect
+```
+
+
+## Usage
+
+```js
+var isRedirect = require('is-redirect');
+
+isRedirect(302);
+//=> true
+
+isRedirect(200);
+//=> false
+```
+
+
+## License
+
+MIT  [Sindre Sorhus](http://sindresorhus.com)
Index: public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/url-parse-lax/package.json	(revision )
@@ -0,0 +1,55 @@
+{
+  "name": "url-parse-lax",
+  "version": "1.0.0",
+  "description": "url.parse() with support for protocol-less URLs & IPs",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/url-parse-lax"
+  },
+  "author": {
+    "name": "Sindre Sorhus",
+    "email": "sindresorhus@gmail.com",
+    "url": "sindresorhus.com"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "node test.js"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "url",
+    "uri",
+    "parse",
+    "parser",
+    "loose",
+    "lax",
+    "protocol",
+    "less",
+    "protocol-less",
+    "ip",
+    "ipv4",
+    "ipv6"
+  ],
+  "dependencies": {
+    "prepend-http": "^1.0.1"
+  },
+  "devDependencies": {
+    "ava": "0.0.4"
+  },
+  "readme": "# url-parse-lax [![Build Status](https://travis-ci.org/sindresorhus/url-parse-lax.svg?branch=master)](https://travis-ci.org/sindresorhus/url-parse-lax)\n\n> [`url.parse()`](https://nodejs.org/docs/latest/api/url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost) with support for protocol-less URLs & IPs\n\n\n## Install\n\n```\n$ npm install --save url-parse-lax\n```\n\n\n## Usage\n\n```js\nvar urlParseLax = require('url-parse-lax');\n\nurlParseLax('sindresorhus.com');\n/*\n{\n\tprotocol: null,\n\tslashes: true,\n\tauth: null,\n\thost: 'sindresorhus.com',\n\tport: null,\n\thostname: 'sindresorhus.com',\n\thash: null,\n\tsearch: null,\n\tquery: null,\n\tpathname: '/',\n\tpath: '/',\n\thref: 'http://sindresorhus.com/'\n}\n*/\n\nurlParseLax('[2001:db8::]:8000');\n/*\n{\n\tprotocol: null,\n\tslashes: true,\n\tauth: null,\n\thost: '[2001:db8::]:8000',\n\tport: '8000',\n\thostname: '2001:db8::',\n\thash: null,\n\tsearch: null,\n\tquery: null,\n\tpathname: '/',\n\tpath: '/',\n\thref: 'http://[2001:db8::]:8000/'\n}\n*/\n```\n\nAnd with the built-in `url.parse()`:\n\n```js\nvar url = require('url');\n\nurl.parse('sindresorhus.com');\n/*\n{\n\tprotocol: null,\n\tslashes: null,\n\tauth: null,\n\thost: null,\n\tport: null,\n\thostname: null,\n\thash: null,\n\tsearch: null,\n\tquery: null,\n\tpathname: 'sindresorhus',\n\tpath: 'sindresorhus',\n\thref: 'sindresorhus'\n}\n*/\n\nurl.parse('[2001:db8::]:8000');\n/*\n{\n\tprotocol: null,\n\tslashes: null,\n\tauth: null,\n\thost: null,\n\tport: null,\n\thostname: null,\n\thash: null,\n\tsearch: null,\n\tquery: null,\n\tpathname: '[2001:db8::]:8000',\n\tpath: '[2001:db8::]:8000',\n\thref: '[2001:db8::]:8000'\n}\n*/\n```\n\n\n## License\n\nMIT  [Sindre Sorhus](http://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/url-parse-lax/issues"
+  },
+  "_id": "url-parse-lax@1.0.0",
+  "dist": {
+    "shasum": "41dc75a3015f91d6df11b11cba18b6b5b397ccf3"
+  },
+  "_from": "url-parse-lax@^1.0.0",
+  "_resolved": "https://registry.npmjs.org/url-parse-lax/-/url-parse-lax-1.0.0.tgz"
+}
Index: public/node_modules/vue/src/platforms/weex/runtime/modules/attrs.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/modules/attrs.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/modules/attrs.js	(revision )
@@ -0,0 +1,35 @@
+/* @flow */
+
+import { extend } from 'shared/util'
+
+function updateAttrs (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (!oldVnode.data.attrs && !vnode.data.attrs) {
+    return
+  }
+  let key, cur, old
+  const elm = vnode.elm
+  const oldAttrs = oldVnode.data.attrs || {}
+  let attrs = vnode.data.attrs || {}
+  // clone observed objects, as the user probably wants to mutate it
+  if (attrs.__ob__) {
+    attrs = vnode.data.attrs = extend({}, attrs)
+  }
+
+  for (key in attrs) {
+    cur = attrs[key]
+    old = oldAttrs[key]
+    if (old !== cur) {
+      elm.setAttr(key, cur)
+    }
+  }
+  for (key in oldAttrs) {
+    if (attrs[key] == null) {
+      elm.setAttr(key)
+    }
+  }
+}
+
+export default {
+  create: updateAttrs,
+  update: updateAttrs
+}
Index: public/node_modules/vue-resource/src/url/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/url/index.js	(revision )
+++ public/node_modules/vue-resource/src/url/index.js	(revision )
@@ -0,0 +1,126 @@
+/**
+ * Service for URL templating.
+ */
+
+import root from './root';
+import query from './query';
+import template from './template';
+import { each, merge, isArray, isFunction, isObject, isPlainObject, isString } from '../util';
+
+export default function Url(url, params) {
+
+    var self = this || {}, options = url, transform;
+
+    if (isString(url)) {
+        options = {url, params};
+    }
+
+    options = merge({}, Url.options, self.$options, options);
+
+    Url.transforms.forEach(handler => {
+        transform = factory(handler, transform, self.$vm);
+    });
+
+    return transform(options);
+}
+
+/**
+ * Url options.
+ */
+
+Url.options = {
+    url: '',
+    root: null,
+    params: {}
+};
+
+/**
+ * Url transforms.
+ */
+
+Url.transforms = [template, query, root];
+
+/**
+ * Encodes a Url parameter string.
+ *
+ * @param {Object} obj
+ */
+
+Url.params = function (obj) {
+
+    var params = [], escape = encodeURIComponent;
+
+    params.add = function (key, value) {
+
+        if (isFunction(value)) {
+            value = value();
+        }
+
+        if (value === null) {
+            value = '';
+        }
+
+        this.push(escape(key) + '=' + escape(value));
+    };
+
+    serialize(params, obj);
+
+    return params.join('&').replace(/%20/g, '+');
+};
+
+/**
+ * Parse a URL and return its components.
+ *
+ * @param {String} url
+ */
+
+Url.parse = function (url) {
+
+    var el = document.createElement('a');
+
+    if (document.documentMode) {
+        el.href = url;
+        url = el.href;
+    }
+
+    el.href = url;
+
+    return {
+        href: el.href,
+        protocol: el.protocol ? el.protocol.replace(/:$/, '') : '',
+        port: el.port,
+        host: el.host,
+        hostname: el.hostname,
+        pathname: el.pathname.charAt(0) === '/' ? el.pathname : '/' + el.pathname,
+        search: el.search ? el.search.replace(/^\?/, '') : '',
+        hash: el.hash ? el.hash.replace(/^#/, '') : ''
+    };
+};
+
+function factory(handler, next, vm) {
+    return (options) => {
+        return handler.call(vm, options, next);
+    };
+}
+
+function serialize(params, obj, scope) {
+
+    var array = isArray(obj), plain = isPlainObject(obj), hash;
+
+    each(obj, (value, key) => {
+
+        hash = isObject(value) || isArray(value);
+
+        if (scope) {
+            key = scope + '[' + (plain || hash ? key : '') + ']';
+        }
+
+        if (!scope && array) {
+            params.add(value.name, value.value);
+        } else if (hash) {
+            serialize(params, value, key);
+        } else {
+            params.add(key, value);
+        }
+    });
+}
Index: public/node_modules/vue-select2/src/vue-select.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/src/vue-select.js	(revision )
+++ public/node_modules/vue-select2/src/vue-select.js	(revision )
@@ -0,0 +1,256 @@
+/**
+ * The default language used by this component.
+ */
+var DEFAULT_LANGUAGE = "en-US";
+
+/**
+ * A bootstrap style selection (combobox) control using the select2 plugin.
+ *
+ * @param options
+ *    the array of options of the selection control. It could be an array of
+ *    strings, e.g., "['opt1', 'opt2']"; or an array of objects specifying
+ *    the text and value of each option, e.g.,
+ *    "[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]";
+ *    or it could be an array of objects specifying the option group, e.g.
+ *    "[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},
+ *      {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]".
+ * @param model
+ *    the model bind to the control, which must be a two way binding variable.
+ * @param searchable
+ *    the optional flag indicates whether to show the search box. Default value
+ *    is false.
+ * @param matchValue
+ *    the optional flag indicates whether the searching should match both the
+ *    texts and values of options. Default value is true.
+ * @param language
+ *    the optional code of language used by the select2 plugin. If it is not set,
+ *    and the [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin is used,
+ *    the component will use the language code `$language` provided by the
+ *    [vue-i18n](https://github.com/Haixing-Hu/vue-i18n) plugin; otherwise, the
+ *    component will use the default value "en-US".
+ * @param theme
+ *    the optional name of the theme of the select2. Default value is "bootstrap".
+ * @param name
+ *    the optional name of the selection control.
+ * @author Haixing Hu
+ */
+module.exports = {
+  replace: true,
+  inherit: false,
+  template: "<select class='form-control' v-model='model' :name='name' style='width: 100%'>"
+          +   "<option v-if='optionsType === \"values\"' v-for='val in options' :value='val'>{{val}}</option>"
+          +   "<option v-if='optionsType === \"options\"' v-for='opt in options' :value='opt.value'>{{opt.text}}</option>"
+          +   "<optgroup v-if='optionsType === \"groups\"' v-for='group in options' :label='group.label'>"
+          +     "<option v-for='opt in group.options' :value='opt.value'>{{opt.text}}</option>"
+          +   "</optgroup>"
+          + "</select>",
+  props: {
+    options: {
+      type: Array,
+      required: true
+    },
+    model: {
+      required: true,
+      twoWay: true
+    },
+    searchable: {
+      type: Boolean,
+      required: false,
+      default: false
+    },
+    matchValue: {
+      type: Boolean,
+      required: false,
+      default: true
+    },
+    name: {
+      type: String,
+      required: false,
+      default: ""
+    },
+    language: {
+      type: String,
+      required: false,
+      default: ""
+    },
+    theme: {
+      type: String,
+      required: false,
+      default: "bootstrap"
+    }
+  },
+  data: function() {
+    return {
+      optionsType: "unknown"
+    }
+  },
+  beforeCompile: function() {
+    this.isChanging = false;
+    this.control = null;
+    this.optionsType = this.getOptionsType();
+  },
+  watch: {
+    "options": function(val, oldVal) {
+      //console.debug("options.change");
+      this.optionsType = this.getOptionsType();
+      var found = this.inOptions(this.model);
+      var newValue = (found ? this.model : null);
+      this.control.removeData("data");  // remove the cached options data
+      // note that setting the model will automatically changed in the "change"
+      // event of the select2 control
+      this.control.val(newValue).trigger("change");
+    },
+    "model": function(val, oldVal) {
+      //console.debug("model.change");
+      if (! this.isChanging) {
+        this.isChanging = true;
+        this.control.val(val).trigger("change");
+        this.isChanging = false;
+      }
+    }
+  },
+  ready: function() {
+    var language = this.language;
+    if (language === null || language === "") {
+      if (this.$language) {
+        language = this.$language;
+      } else {
+        language = DEFAULT_LANGUAGE;
+      }
+    }
+    var args = {
+      theme: this.theme,
+      language: this.getLanguageCode(language)
+    };
+    if (! this.searchable) {
+      args.minimumResultsForSearch = Infinity;  // hide the search box
+    } else {
+      if (this.matchValue) {
+        args.matcher = require("./value-text-matcher.js");
+      }
+    }
+    this.control = $(this.$el);
+    this.control.select2(args);
+    var me = this;
+    this.control.on("change", function(e) {
+      //console.debug("control.change");
+      if (! me.isChanging) {
+        me.isChanging = true;
+        me.model = me.control.val();
+        me.$nextTick(function () {
+          me.isChanging = false;
+        });
+      }
+    });
+  },
+  methods: {
+
+    /**
+     * Gets the type of the `options` property of this component.
+     *
+     * The `options` property of this component may have the following types:
+     * - "values": the `options` is an array of strings, e.g., `[value1, value2, value3]`;
+     * - "options": the `options` is an array of options, e.g., `[{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]`;
+     * - "groups": the `options` is an array of option groups, e.g.,
+     *   `[{label: 'group1', options: [{text: 'name1', value: 'val1'}, {text: 'name2', value: 'val2'}]},
+     *     {label: 'group2', options: [{text: 'name3', value: 'val3'}, {text: 'name4', value: 'val4'}]}]`;
+     *
+     * @param options
+     *    the new options.
+     * @return
+     *    the string representing the type of the `options` property of this
+     *    component.
+     */
+    getOptionsType: function() {
+      if (this.options.length === 0) {
+        return "values";
+      }
+      var el = this.options[0];
+      if (typeof el == "string" || el instanceof String) {
+        return "values";
+      } else if (typeof el.text !== "undefined") {
+        return "options";
+      } else if (typeof el.label !== "undefined") {
+        return "groups";
+      } else {
+        return "unknown";
+      }
+    },
+
+    /**
+     * Tests whether a specified value exists in the options.
+     *
+     * @param value
+     *    the value to test.
+     * @return
+     *    true if the specified value exists in the options; false otherwise.
+     */
+    inOptions: function(value) {
+      var type = this.getOptionsType();
+      var list = this.options;
+      var i, j;
+      switch (type) {
+      case "values":
+        for (i = 0; i < list.length; ++i) {
+          if (value === list[i]) {
+            return true;
+          }
+        }
+        break;
+      case "options":
+        for (i = 0; i < list.length; ++i) {
+          if (value === list[i].value) {
+            return true;
+          }
+        }
+        break;
+      case "groups":
+        for (i = 0; i < list.length; ++i) {
+          var options = list[i].options;
+          for (j = 0; j < options.length; ++j) {
+            if (value === options[j].value) {
+              return true;
+            }
+          }
+        }
+        break;
+      default:
+        break;
+      }
+      return false;
+    },
+
+    /**
+     * Gets the language code from the "language-country" locale code.
+     *
+     * The function will strip the language code before the first "-" of a
+     * locale code. For example, pass "en-US" will returns "en". But for some
+     * special locales, the function reserves the locale code. For example,
+     * the "zh-CN" for the simplified Chinese and the "zh-TW" for the
+     * traditional Chinese.
+     *
+     * @param locale
+     *    A locale code.
+     * @return
+     *    the language code of the locale.
+     */
+    getLanguageCode: function(locale) {
+      if (locale === null || locale.length === 0) {
+        return "en";
+      }
+      if (locale.length <= 2) {
+        return locale;
+      } else {
+        switch (locale) {
+          case "pt-BR":
+          case "zh-CN":
+          case "zh-TW":
+            return locale;
+          default:
+            // reserve only the first two letters language code
+            return locale.substr(0, 2);
+        }
+      }
+    }
+  }
+};
Index: public/node_modules/vue/src/platforms/web/runtime/class-util.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/class-util.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/class-util.js	(revision )
@@ -0,0 +1,53 @@
+/* @flow */
+
+/**
+ * Add class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+export function addClass (el: HTMLElement, cls: ?string) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(c => el.classList.add(c))
+    } else {
+      el.classList.add(cls)
+    }
+  } else {
+    const cur = ` ${el.getAttribute('class') || ''} `
+    if (cur.indexOf(' ' + cls + ' ') < 0) {
+      el.setAttribute('class', (cur + cls).trim())
+    }
+  }
+}
+
+/**
+ * Remove class with compatibility for SVG since classList is not supported on
+ * SVG elements in IE
+ */
+export function removeClass (el: HTMLElement, cls: ?string) {
+  /* istanbul ignore if */
+  if (!cls || !(cls = cls.trim())) {
+    return
+  }
+
+  /* istanbul ignore else */
+  if (el.classList) {
+    if (cls.indexOf(' ') > -1) {
+      cls.split(/\s+/).forEach(c => el.classList.remove(c))
+    } else {
+      el.classList.remove(cls)
+    }
+  } else {
+    let cur = ` ${el.getAttribute('class') || ''} `
+    const tar = ' ' + cls + ' '
+    while (cur.indexOf(tar) >= 0) {
+      cur = cur.replace(tar, ' ')
+    }
+    el.setAttribute('class', cur.trim())
+  }
+}
Index: public/node_modules/vue-select2/src/value-text-matcher.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/src/value-text-matcher.js	(revision )
+++ public/node_modules/vue-select2/src/value-text-matcher.js	(revision )
@@ -0,0 +1,906 @@
+
+var DIACRITICS = {
+  '\u24B6': 'A',
+  '\uFF21': 'A',
+  '\u00C0': 'A',
+  '\u00C1': 'A',
+  '\u00C2': 'A',
+  '\u1EA6': 'A',
+  '\u1EA4': 'A',
+  '\u1EAA': 'A',
+  '\u1EA8': 'A',
+  '\u00C3': 'A',
+  '\u0100': 'A',
+  '\u0102': 'A',
+  '\u1EB0': 'A',
+  '\u1EAE': 'A',
+  '\u1EB4': 'A',
+  '\u1EB2': 'A',
+  '\u0226': 'A',
+  '\u01E0': 'A',
+  '\u00C4': 'A',
+  '\u01DE': 'A',
+  '\u1EA2': 'A',
+  '\u00C5': 'A',
+  '\u01FA': 'A',
+  '\u01CD': 'A',
+  '\u0200': 'A',
+  '\u0202': 'A',
+  '\u1EA0': 'A',
+  '\u1EAC': 'A',
+  '\u1EB6': 'A',
+  '\u1E00': 'A',
+  '\u0104': 'A',
+  '\u023A': 'A',
+  '\u2C6F': 'A',
+  '\uA732': 'AA',
+  '\u00C6': 'AE',
+  '\u01FC': 'AE',
+  '\u01E2': 'AE',
+  '\uA734': 'AO',
+  '\uA736': 'AU',
+  '\uA738': 'AV',
+  '\uA73A': 'AV',
+  '\uA73C': 'AY',
+  '\u24B7': 'B',
+  '\uFF22': 'B',
+  '\u1E02': 'B',
+  '\u1E04': 'B',
+  '\u1E06': 'B',
+  '\u0243': 'B',
+  '\u0182': 'B',
+  '\u0181': 'B',
+  '\u24B8': 'C',
+  '\uFF23': 'C',
+  '\u0106': 'C',
+  '\u0108': 'C',
+  '\u010A': 'C',
+  '\u010C': 'C',
+  '\u00C7': 'C',
+  '\u1E08': 'C',
+  '\u0187': 'C',
+  '\u023B': 'C',
+  '\uA73E': 'C',
+  '\u24B9': 'D',
+  '\uFF24': 'D',
+  '\u1E0A': 'D',
+  '\u010E': 'D',
+  '\u1E0C': 'D',
+  '\u1E10': 'D',
+  '\u1E12': 'D',
+  '\u1E0E': 'D',
+  '\u0110': 'D',
+  '\u018B': 'D',
+  '\u018A': 'D',
+  '\u0189': 'D',
+  '\uA779': 'D',
+  '\u01F1': 'DZ',
+  '\u01C4': 'DZ',
+  '\u01F2': 'Dz',
+  '\u01C5': 'Dz',
+  '\u24BA': 'E',
+  '\uFF25': 'E',
+  '\u00C8': 'E',
+  '\u00C9': 'E',
+  '\u00CA': 'E',
+  '\u1EC0': 'E',
+  '\u1EBE': 'E',
+  '\u1EC4': 'E',
+  '\u1EC2': 'E',
+  '\u1EBC': 'E',
+  '\u0112': 'E',
+  '\u1E14': 'E',
+  '\u1E16': 'E',
+  '\u0114': 'E',
+  '\u0116': 'E',
+  '\u00CB': 'E',
+  '\u1EBA': 'E',
+  '\u011A': 'E',
+  '\u0204': 'E',
+  '\u0206': 'E',
+  '\u1EB8': 'E',
+  '\u1EC6': 'E',
+  '\u0228': 'E',
+  '\u1E1C': 'E',
+  '\u0118': 'E',
+  '\u1E18': 'E',
+  '\u1E1A': 'E',
+  '\u0190': 'E',
+  '\u018E': 'E',
+  '\u24BB': 'F',
+  '\uFF26': 'F',
+  '\u1E1E': 'F',
+  '\u0191': 'F',
+  '\uA77B': 'F',
+  '\u24BC': 'G',
+  '\uFF27': 'G',
+  '\u01F4': 'G',
+  '\u011C': 'G',
+  '\u1E20': 'G',
+  '\u011E': 'G',
+  '\u0120': 'G',
+  '\u01E6': 'G',
+  '\u0122': 'G',
+  '\u01E4': 'G',
+  '\u0193': 'G',
+  '\uA7A0': 'G',
+  '\uA77D': 'G',
+  '\uA77E': 'G',
+  '\u24BD': 'H',
+  '\uFF28': 'H',
+  '\u0124': 'H',
+  '\u1E22': 'H',
+  '\u1E26': 'H',
+  '\u021E': 'H',
+  '\u1E24': 'H',
+  '\u1E28': 'H',
+  '\u1E2A': 'H',
+  '\u0126': 'H',
+  '\u2C67': 'H',
+  '\u2C75': 'H',
+  '\uA78D': 'H',
+  '\u24BE': 'I',
+  '\uFF29': 'I',
+  '\u00CC': 'I',
+  '\u00CD': 'I',
+  '\u00CE': 'I',
+  '\u0128': 'I',
+  '\u012A': 'I',
+  '\u012C': 'I',
+  '\u0130': 'I',
+  '\u00CF': 'I',
+  '\u1E2E': 'I',
+  '\u1EC8': 'I',
+  '\u01CF': 'I',
+  '\u0208': 'I',
+  '\u020A': 'I',
+  '\u1ECA': 'I',
+  '\u012E': 'I',
+  '\u1E2C': 'I',
+  '\u0197': 'I',
+  '\u24BF': 'J',
+  '\uFF2A': 'J',
+  '\u0134': 'J',
+  '\u0248': 'J',
+  '\u24C0': 'K',
+  '\uFF2B': 'K',
+  '\u1E30': 'K',
+  '\u01E8': 'K',
+  '\u1E32': 'K',
+  '\u0136': 'K',
+  '\u1E34': 'K',
+  '\u0198': 'K',
+  '\u2C69': 'K',
+  '\uA740': 'K',
+  '\uA742': 'K',
+  '\uA744': 'K',
+  '\uA7A2': 'K',
+  '\u24C1': 'L',
+  '\uFF2C': 'L',
+  '\u013F': 'L',
+  '\u0139': 'L',
+  '\u013D': 'L',
+  '\u1E36': 'L',
+  '\u1E38': 'L',
+  '\u013B': 'L',
+  '\u1E3C': 'L',
+  '\u1E3A': 'L',
+  '\u0141': 'L',
+  '\u023D': 'L',
+  '\u2C62': 'L',
+  '\u2C60': 'L',
+  '\uA748': 'L',
+  '\uA746': 'L',
+  '\uA780': 'L',
+  '\u01C7': 'LJ',
+  '\u01C8': 'Lj',
+  '\u24C2': 'M',
+  '\uFF2D': 'M',
+  '\u1E3E': 'M',
+  '\u1E40': 'M',
+  '\u1E42': 'M',
+  '\u2C6E': 'M',
+  '\u019C': 'M',
+  '\u24C3': 'N',
+  '\uFF2E': 'N',
+  '\u01F8': 'N',
+  '\u0143': 'N',
+  '\u00D1': 'N',
+  '\u1E44': 'N',
+  '\u0147': 'N',
+  '\u1E46': 'N',
+  '\u0145': 'N',
+  '\u1E4A': 'N',
+  '\u1E48': 'N',
+  '\u0220': 'N',
+  '\u019D': 'N',
+  '\uA790': 'N',
+  '\uA7A4': 'N',
+  '\u01CA': 'NJ',
+  '\u01CB': 'Nj',
+  '\u24C4': 'O',
+  '\uFF2F': 'O',
+  '\u00D2': 'O',
+  '\u00D3': 'O',
+  '\u00D4': 'O',
+  '\u1ED2': 'O',
+  '\u1ED0': 'O',
+  '\u1ED6': 'O',
+  '\u1ED4': 'O',
+  '\u00D5': 'O',
+  '\u1E4C': 'O',
+  '\u022C': 'O',
+  '\u1E4E': 'O',
+  '\u014C': 'O',
+  '\u1E50': 'O',
+  '\u1E52': 'O',
+  '\u014E': 'O',
+  '\u022E': 'O',
+  '\u0230': 'O',
+  '\u00D6': 'O',
+  '\u022A': 'O',
+  '\u1ECE': 'O',
+  '\u0150': 'O',
+  '\u01D1': 'O',
+  '\u020C': 'O',
+  '\u020E': 'O',
+  '\u01A0': 'O',
+  '\u1EDC': 'O',
+  '\u1EDA': 'O',
+  '\u1EE0': 'O',
+  '\u1EDE': 'O',
+  '\u1EE2': 'O',
+  '\u1ECC': 'O',
+  '\u1ED8': 'O',
+  '\u01EA': 'O',
+  '\u01EC': 'O',
+  '\u00D8': 'O',
+  '\u01FE': 'O',
+  '\u0186': 'O',
+  '\u019F': 'O',
+  '\uA74A': 'O',
+  '\uA74C': 'O',
+  '\u01A2': 'OI',
+  '\uA74E': 'OO',
+  '\u0222': 'OU',
+  '\u24C5': 'P',
+  '\uFF30': 'P',
+  '\u1E54': 'P',
+  '\u1E56': 'P',
+  '\u01A4': 'P',
+  '\u2C63': 'P',
+  '\uA750': 'P',
+  '\uA752': 'P',
+  '\uA754': 'P',
+  '\u24C6': 'Q',
+  '\uFF31': 'Q',
+  '\uA756': 'Q',
+  '\uA758': 'Q',
+  '\u024A': 'Q',
+  '\u24C7': 'R',
+  '\uFF32': 'R',
+  '\u0154': 'R',
+  '\u1E58': 'R',
+  '\u0158': 'R',
+  '\u0210': 'R',
+  '\u0212': 'R',
+  '\u1E5A': 'R',
+  '\u1E5C': 'R',
+  '\u0156': 'R',
+  '\u1E5E': 'R',
+  '\u024C': 'R',
+  '\u2C64': 'R',
+  '\uA75A': 'R',
+  '\uA7A6': 'R',
+  '\uA782': 'R',
+  '\u24C8': 'S',
+  '\uFF33': 'S',
+  '\u1E9E': 'S',
+  '\u015A': 'S',
+  '\u1E64': 'S',
+  '\u015C': 'S',
+  '\u1E60': 'S',
+  '\u0160': 'S',
+  '\u1E66': 'S',
+  '\u1E62': 'S',
+  '\u1E68': 'S',
+  '\u0218': 'S',
+  '\u015E': 'S',
+  '\u2C7E': 'S',
+  '\uA7A8': 'S',
+  '\uA784': 'S',
+  '\u24C9': 'T',
+  '\uFF34': 'T',
+  '\u1E6A': 'T',
+  '\u0164': 'T',
+  '\u1E6C': 'T',
+  '\u021A': 'T',
+  '\u0162': 'T',
+  '\u1E70': 'T',
+  '\u1E6E': 'T',
+  '\u0166': 'T',
+  '\u01AC': 'T',
+  '\u01AE': 'T',
+  '\u023E': 'T',
+  '\uA786': 'T',
+  '\uA728': 'TZ',
+  '\u24CA': 'U',
+  '\uFF35': 'U',
+  '\u00D9': 'U',
+  '\u00DA': 'U',
+  '\u00DB': 'U',
+  '\u0168': 'U',
+  '\u1E78': 'U',
+  '\u016A': 'U',
+  '\u1E7A': 'U',
+  '\u016C': 'U',
+  '\u00DC': 'U',
+  '\u01DB': 'U',
+  '\u01D7': 'U',
+  '\u01D5': 'U',
+  '\u01D9': 'U',
+  '\u1EE6': 'U',
+  '\u016E': 'U',
+  '\u0170': 'U',
+  '\u01D3': 'U',
+  '\u0214': 'U',
+  '\u0216': 'U',
+  '\u01AF': 'U',
+  '\u1EEA': 'U',
+  '\u1EE8': 'U',
+  '\u1EEE': 'U',
+  '\u1EEC': 'U',
+  '\u1EF0': 'U',
+  '\u1EE4': 'U',
+  '\u1E72': 'U',
+  '\u0172': 'U',
+  '\u1E76': 'U',
+  '\u1E74': 'U',
+  '\u0244': 'U',
+  '\u24CB': 'V',
+  '\uFF36': 'V',
+  '\u1E7C': 'V',
+  '\u1E7E': 'V',
+  '\u01B2': 'V',
+  '\uA75E': 'V',
+  '\u0245': 'V',
+  '\uA760': 'VY',
+  '\u24CC': 'W',
+  '\uFF37': 'W',
+  '\u1E80': 'W',
+  '\u1E82': 'W',
+  '\u0174': 'W',
+  '\u1E86': 'W',
+  '\u1E84': 'W',
+  '\u1E88': 'W',
+  '\u2C72': 'W',
+  '\u24CD': 'X',
+  '\uFF38': 'X',
+  '\u1E8A': 'X',
+  '\u1E8C': 'X',
+  '\u24CE': 'Y',
+  '\uFF39': 'Y',
+  '\u1EF2': 'Y',
+  '\u00DD': 'Y',
+  '\u0176': 'Y',
+  '\u1EF8': 'Y',
+  '\u0232': 'Y',
+  '\u1E8E': 'Y',
+  '\u0178': 'Y',
+  '\u1EF6': 'Y',
+  '\u1EF4': 'Y',
+  '\u01B3': 'Y',
+  '\u024E': 'Y',
+  '\u1EFE': 'Y',
+  '\u24CF': 'Z',
+  '\uFF3A': 'Z',
+  '\u0179': 'Z',
+  '\u1E90': 'Z',
+  '\u017B': 'Z',
+  '\u017D': 'Z',
+  '\u1E92': 'Z',
+  '\u1E94': 'Z',
+  '\u01B5': 'Z',
+  '\u0224': 'Z',
+  '\u2C7F': 'Z',
+  '\u2C6B': 'Z',
+  '\uA762': 'Z',
+  '\u24D0': 'a',
+  '\uFF41': 'a',
+  '\u1E9A': 'a',
+  '\u00E0': 'a',
+  '\u00E1': 'a',
+  '\u00E2': 'a',
+  '\u1EA7': 'a',
+  '\u1EA5': 'a',
+  '\u1EAB': 'a',
+  '\u1EA9': 'a',
+  '\u00E3': 'a',
+  '\u0101': 'a',
+  '\u0103': 'a',
+  '\u1EB1': 'a',
+  '\u1EAF': 'a',
+  '\u1EB5': 'a',
+  '\u1EB3': 'a',
+  '\u0227': 'a',
+  '\u01E1': 'a',
+  '\u00E4': 'a',
+  '\u01DF': 'a',
+  '\u1EA3': 'a',
+  '\u00E5': 'a',
+  '\u01FB': 'a',
+  '\u01CE': 'a',
+  '\u0201': 'a',
+  '\u0203': 'a',
+  '\u1EA1': 'a',
+  '\u1EAD': 'a',
+  '\u1EB7': 'a',
+  '\u1E01': 'a',
+  '\u0105': 'a',
+  '\u2C65': 'a',
+  '\u0250': 'a',
+  '\uA733': 'aa',
+  '\u00E6': 'ae',
+  '\u01FD': 'ae',
+  '\u01E3': 'ae',
+  '\uA735': 'ao',
+  '\uA737': 'au',
+  '\uA739': 'av',
+  '\uA73B': 'av',
+  '\uA73D': 'ay',
+  '\u24D1': 'b',
+  '\uFF42': 'b',
+  '\u1E03': 'b',
+  '\u1E05': 'b',
+  '\u1E07': 'b',
+  '\u0180': 'b',
+  '\u0183': 'b',
+  '\u0253': 'b',
+  '\u24D2': 'c',
+  '\uFF43': 'c',
+  '\u0107': 'c',
+  '\u0109': 'c',
+  '\u010B': 'c',
+  '\u010D': 'c',
+  '\u00E7': 'c',
+  '\u1E09': 'c',
+  '\u0188': 'c',
+  '\u023C': 'c',
+  '\uA73F': 'c',
+  '\u2184': 'c',
+  '\u24D3': 'd',
+  '\uFF44': 'd',
+  '\u1E0B': 'd',
+  '\u010F': 'd',
+  '\u1E0D': 'd',
+  '\u1E11': 'd',
+  '\u1E13': 'd',
+  '\u1E0F': 'd',
+  '\u0111': 'd',
+  '\u018C': 'd',
+  '\u0256': 'd',
+  '\u0257': 'd',
+  '\uA77A': 'd',
+  '\u01F3': 'dz',
+  '\u01C6': 'dz',
+  '\u24D4': 'e',
+  '\uFF45': 'e',
+  '\u00E8': 'e',
+  '\u00E9': 'e',
+  '\u00EA': 'e',
+  '\u1EC1': 'e',
+  '\u1EBF': 'e',
+  '\u1EC5': 'e',
+  '\u1EC3': 'e',
+  '\u1EBD': 'e',
+  '\u0113': 'e',
+  '\u1E15': 'e',
+  '\u1E17': 'e',
+  '\u0115': 'e',
+  '\u0117': 'e',
+  '\u00EB': 'e',
+  '\u1EBB': 'e',
+  '\u011B': 'e',
+  '\u0205': 'e',
+  '\u0207': 'e',
+  '\u1EB9': 'e',
+  '\u1EC7': 'e',
+  '\u0229': 'e',
+  '\u1E1D': 'e',
+  '\u0119': 'e',
+  '\u1E19': 'e',
+  '\u1E1B': 'e',
+  '\u0247': 'e',
+  '\u025B': 'e',
+  '\u01DD': 'e',
+  '\u24D5': 'f',
+  '\uFF46': 'f',
+  '\u1E1F': 'f',
+  '\u0192': 'f',
+  '\uA77C': 'f',
+  '\u24D6': 'g',
+  '\uFF47': 'g',
+  '\u01F5': 'g',
+  '\u011D': 'g',
+  '\u1E21': 'g',
+  '\u011F': 'g',
+  '\u0121': 'g',
+  '\u01E7': 'g',
+  '\u0123': 'g',
+  '\u01E5': 'g',
+  '\u0260': 'g',
+  '\uA7A1': 'g',
+  '\u1D79': 'g',
+  '\uA77F': 'g',
+  '\u24D7': 'h',
+  '\uFF48': 'h',
+  '\u0125': 'h',
+  '\u1E23': 'h',
+  '\u1E27': 'h',
+  '\u021F': 'h',
+  '\u1E25': 'h',
+  '\u1E29': 'h',
+  '\u1E2B': 'h',
+  '\u1E96': 'h',
+  '\u0127': 'h',
+  '\u2C68': 'h',
+  '\u2C76': 'h',
+  '\u0265': 'h',
+  '\u0195': 'hv',
+  '\u24D8': 'i',
+  '\uFF49': 'i',
+  '\u00EC': 'i',
+  '\u00ED': 'i',
+  '\u00EE': 'i',
+  '\u0129': 'i',
+  '\u012B': 'i',
+  '\u012D': 'i',
+  '\u00EF': 'i',
+  '\u1E2F': 'i',
+  '\u1EC9': 'i',
+  '\u01D0': 'i',
+  '\u0209': 'i',
+  '\u020B': 'i',
+  '\u1ECB': 'i',
+  '\u012F': 'i',
+  '\u1E2D': 'i',
+  '\u0268': 'i',
+  '\u0131': 'i',
+  '\u24D9': 'j',
+  '\uFF4A': 'j',
+  '\u0135': 'j',
+  '\u01F0': 'j',
+  '\u0249': 'j',
+  '\u24DA': 'k',
+  '\uFF4B': 'k',
+  '\u1E31': 'k',
+  '\u01E9': 'k',
+  '\u1E33': 'k',
+  '\u0137': 'k',
+  '\u1E35': 'k',
+  '\u0199': 'k',
+  '\u2C6A': 'k',
+  '\uA741': 'k',
+  '\uA743': 'k',
+  '\uA745': 'k',
+  '\uA7A3': 'k',
+  '\u24DB': 'l',
+  '\uFF4C': 'l',
+  '\u0140': 'l',
+  '\u013A': 'l',
+  '\u013E': 'l',
+  '\u1E37': 'l',
+  '\u1E39': 'l',
+  '\u013C': 'l',
+  '\u1E3D': 'l',
+  '\u1E3B': 'l',
+  '\u017F': 'l',
+  '\u0142': 'l',
+  '\u019A': 'l',
+  '\u026B': 'l',
+  '\u2C61': 'l',
+  '\uA749': 'l',
+  '\uA781': 'l',
+  '\uA747': 'l',
+  '\u01C9': 'lj',
+  '\u24DC': 'm',
+  '\uFF4D': 'm',
+  '\u1E3F': 'm',
+  '\u1E41': 'm',
+  '\u1E43': 'm',
+  '\u0271': 'm',
+  '\u026F': 'm',
+  '\u24DD': 'n',
+  '\uFF4E': 'n',
+  '\u01F9': 'n',
+  '\u0144': 'n',
+  '\u00F1': 'n',
+  '\u1E45': 'n',
+  '\u0148': 'n',
+  '\u1E47': 'n',
+  '\u0146': 'n',
+  '\u1E4B': 'n',
+  '\u1E49': 'n',
+  '\u019E': 'n',
+  '\u0272': 'n',
+  '\u0149': 'n',
+  '\uA791': 'n',
+  '\uA7A5': 'n',
+  '\u01CC': 'nj',
+  '\u24DE': 'o',
+  '\uFF4F': 'o',
+  '\u00F2': 'o',
+  '\u00F3': 'o',
+  '\u00F4': 'o',
+  '\u1ED3': 'o',
+  '\u1ED1': 'o',
+  '\u1ED7': 'o',
+  '\u1ED5': 'o',
+  '\u00F5': 'o',
+  '\u1E4D': 'o',
+  '\u022D': 'o',
+  '\u1E4F': 'o',
+  '\u014D': 'o',
+  '\u1E51': 'o',
+  '\u1E53': 'o',
+  '\u014F': 'o',
+  '\u022F': 'o',
+  '\u0231': 'o',
+  '\u00F6': 'o',
+  '\u022B': 'o',
+  '\u1ECF': 'o',
+  '\u0151': 'o',
+  '\u01D2': 'o',
+  '\u020D': 'o',
+  '\u020F': 'o',
+  '\u01A1': 'o',
+  '\u1EDD': 'o',
+  '\u1EDB': 'o',
+  '\u1EE1': 'o',
+  '\u1EDF': 'o',
+  '\u1EE3': 'o',
+  '\u1ECD': 'o',
+  '\u1ED9': 'o',
+  '\u01EB': 'o',
+  '\u01ED': 'o',
+  '\u00F8': 'o',
+  '\u01FF': 'o',
+  '\u0254': 'o',
+  '\uA74B': 'o',
+  '\uA74D': 'o',
+  '\u0275': 'o',
+  '\u01A3': 'oi',
+  '\u0223': 'ou',
+  '\uA74F': 'oo',
+  '\u24DF': 'p',
+  '\uFF50': 'p',
+  '\u1E55': 'p',
+  '\u1E57': 'p',
+  '\u01A5': 'p',
+  '\u1D7D': 'p',
+  '\uA751': 'p',
+  '\uA753': 'p',
+  '\uA755': 'p',
+  '\u24E0': 'q',
+  '\uFF51': 'q',
+  '\u024B': 'q',
+  '\uA757': 'q',
+  '\uA759': 'q',
+  '\u24E1': 'r',
+  '\uFF52': 'r',
+  '\u0155': 'r',
+  '\u1E59': 'r',
+  '\u0159': 'r',
+  '\u0211': 'r',
+  '\u0213': 'r',
+  '\u1E5B': 'r',
+  '\u1E5D': 'r',
+  '\u0157': 'r',
+  '\u1E5F': 'r',
+  '\u024D': 'r',
+  '\u027D': 'r',
+  '\uA75B': 'r',
+  '\uA7A7': 'r',
+  '\uA783': 'r',
+  '\u24E2': 's',
+  '\uFF53': 's',
+  '\u00DF': 's',
+  '\u015B': 's',
+  '\u1E65': 's',
+  '\u015D': 's',
+  '\u1E61': 's',
+  '\u0161': 's',
+  '\u1E67': 's',
+  '\u1E63': 's',
+  '\u1E69': 's',
+  '\u0219': 's',
+  '\u015F': 's',
+  '\u023F': 's',
+  '\uA7A9': 's',
+  '\uA785': 's',
+  '\u1E9B': 's',
+  '\u24E3': 't',
+  '\uFF54': 't',
+  '\u1E6B': 't',
+  '\u1E97': 't',
+  '\u0165': 't',
+  '\u1E6D': 't',
+  '\u021B': 't',
+  '\u0163': 't',
+  '\u1E71': 't',
+  '\u1E6F': 't',
+  '\u0167': 't',
+  '\u01AD': 't',
+  '\u0288': 't',
+  '\u2C66': 't',
+  '\uA787': 't',
+  '\uA729': 'tz',
+  '\u24E4': 'u',
+  '\uFF55': 'u',
+  '\u00F9': 'u',
+  '\u00FA': 'u',
+  '\u00FB': 'u',
+  '\u0169': 'u',
+  '\u1E79': 'u',
+  '\u016B': 'u',
+  '\u1E7B': 'u',
+  '\u016D': 'u',
+  '\u00FC': 'u',
+  '\u01DC': 'u',
+  '\u01D8': 'u',
+  '\u01D6': 'u',
+  '\u01DA': 'u',
+  '\u1EE7': 'u',
+  '\u016F': 'u',
+  '\u0171': 'u',
+  '\u01D4': 'u',
+  '\u0215': 'u',
+  '\u0217': 'u',
+  '\u01B0': 'u',
+  '\u1EEB': 'u',
+  '\u1EE9': 'u',
+  '\u1EEF': 'u',
+  '\u1EED': 'u',
+  '\u1EF1': 'u',
+  '\u1EE5': 'u',
+  '\u1E73': 'u',
+  '\u0173': 'u',
+  '\u1E77': 'u',
+  '\u1E75': 'u',
+  '\u0289': 'u',
+  '\u24E5': 'v',
+  '\uFF56': 'v',
+  '\u1E7D': 'v',
+  '\u1E7F': 'v',
+  '\u028B': 'v',
+  '\uA75F': 'v',
+  '\u028C': 'v',
+  '\uA761': 'vy',
+  '\u24E6': 'w',
+  '\uFF57': 'w',
+  '\u1E81': 'w',
+  '\u1E83': 'w',
+  '\u0175': 'w',
+  '\u1E87': 'w',
+  '\u1E85': 'w',
+  '\u1E98': 'w',
+  '\u1E89': 'w',
+  '\u2C73': 'w',
+  '\u24E7': 'x',
+  '\uFF58': 'x',
+  '\u1E8B': 'x',
+  '\u1E8D': 'x',
+  '\u24E8': 'y',
+  '\uFF59': 'y',
+  '\u1EF3': 'y',
+  '\u00FD': 'y',
+  '\u0177': 'y',
+  '\u1EF9': 'y',
+  '\u0233': 'y',
+  '\u1E8F': 'y',
+  '\u00FF': 'y',
+  '\u1EF7': 'y',
+  '\u1E99': 'y',
+  '\u1EF5': 'y',
+  '\u01B4': 'y',
+  '\u024F': 'y',
+  '\u1EFF': 'y',
+  '\u24E9': 'z',
+  '\uFF5A': 'z',
+  '\u017A': 'z',
+  '\u1E91': 'z',
+  '\u017C': 'z',
+  '\u017E': 'z',
+  '\u1E93': 'z',
+  '\u1E95': 'z',
+  '\u01B6': 'z',
+  '\u0225': 'z',
+  '\u0240': 'z',
+  '\u2C6C': 'z',
+  '\uA763': 'z',
+  '\u0386': '\u0391',
+  '\u0388': '\u0395',
+  '\u0389': '\u0397',
+  '\u038A': '\u0399',
+  '\u03AA': '\u0399',
+  '\u038C': '\u039F',
+  '\u038E': '\u03A5',
+  '\u03AB': '\u03A5',
+  '\u038F': '\u03A9',
+  '\u03AC': '\u03B1',
+  '\u03AD': '\u03B5',
+  '\u03AE': '\u03B7',
+  '\u03AF': '\u03B9',
+  '\u03CA': '\u03B9',
+  '\u0390': '\u03B9',
+  '\u03CC': '\u03BF',
+  '\u03CD': '\u03C5',
+  '\u03CB': '\u03C5',
+  '\u03B0': '\u03C5',
+  '\u03C9': '\u03C9',
+  '\u03C2': '\u03C3'
+};
+
+
+function stripDiacritics (text) {
+  // Used 'uni range + named function' from http://jsperf.com/diacritics/18
+  function match(a) {
+    return DIACRITICS[a] || a;
+  }
+  return text.replace(/[^\u0000-\u007E]/g, match);
+}
+
+// The following matcher is a modification version of the default matcher
+// of select2
+module.exports = matcher = function(params, data) {
+  // Always return the object if there is nothing to compare
+  if ($.trim(params.term) === '') {
+    return data;
+  }
+
+  // Do a recursive check for options with children
+  if (data.children && data.children.length > 0) {
+    // Clone the data object if there are children
+    // This is required as we modify the object to remove any non-matches
+    var match = $.extend(true, {}, data);
+
+    // Check each child of the option
+    for (var c = data.children.length - 1; c >= 0; c--) {
+      var child = data.children[c];
+
+      var matches = matcher(params, child);
+
+      // If there wasn't a match, remove the object in the array
+      if (matches == null) {
+        match.children.splice(c, 1);
+      }
+    }
+
+    // If any children matched, return the new object
+    if (match.children.length > 0) {
+      return match;
+    }
+
+    // If there were no matching children, check just the plain object
+    return matcher(params, match);
+  }
+
+  var original = stripDiacritics(data.text).toUpperCase();
+  var term = stripDiacritics(params.term).toUpperCase();
+
+  // Check if the text contains the term
+  if (original.indexOf(term) > -1) {
+    return data;
+  }
+
+  // add by Haixing Hu: also match the value of an option
+  if (data.id) {
+    var originalValue = stripDiacritics(data.id).toUpperCase();
+    if (originalValue.indexOf(term) > -1) {
+      return data;
+    }
+  }
+
+  // If it doesn't contain the term, don't return anything
+  return null;
+}
\ No newline at end of file
Index: public/node_modules/vue/src/core/instance/render-helpers/render-static.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render-helpers/render-static.js	(revision )
+++ public/node_modules/vue/src/core/instance/render-helpers/render-static.js	(revision )
@@ -0,0 +1,60 @@
+/* @flow */
+
+import { cloneVNode, cloneVNodes } from 'core/vdom/vnode'
+
+/**
+ * Runtime helper for rendering static trees.
+ */
+export function renderStatic (
+  index: number,
+  isInFor?: boolean
+): VNode | Array<VNode> {
+  let tree = this._staticTrees[index]
+  // if has already-rendered static tree and not inside v-for,
+  // we can reuse the same tree by doing a shallow clone.
+  if (tree && !isInFor) {
+    return Array.isArray(tree)
+      ? cloneVNodes(tree)
+      : cloneVNode(tree)
+  }
+  // otherwise, render a fresh tree.
+  tree = this._staticTrees[index] =
+    this.$options.staticRenderFns[index].call(this._renderProxy)
+  markStatic(tree, `__static__${index}`, false)
+  return tree
+}
+
+/**
+ * Runtime helper for v-once.
+ * Effectively it means marking the node as static with a unique key.
+ */
+export function markOnce (
+  tree: VNode | Array<VNode>,
+  index: number,
+  key: string
+) {
+  markStatic(tree, `__once__${index}${key ? `_${key}` : ``}`, true)
+  return tree
+}
+
+function markStatic (
+  tree: VNode | Array<VNode>,
+  key: string,
+  isOnce: boolean
+) {
+  if (Array.isArray(tree)) {
+    for (let i = 0; i < tree.length; i++) {
+      if (tree[i] && typeof tree[i] !== 'string') {
+        markStaticNode(tree[i], `${key}_${i}`, isOnce)
+      }
+    }
+  } else {
+    markStaticNode(tree, key, isOnce)
+  }
+}
+
+function markStaticNode (node, key, isOnce) {
+  node.isStatic = true
+  node.key = key
+  node.isOnce = isOnce
+}
Index: public/node_modules/vue/src/core/observer/watcher.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/observer/watcher.js	(revision )
+++ public/node_modules/vue/src/core/observer/watcher.js	(revision )
@@ -0,0 +1,266 @@
+/* @flow */
+
+import { queueWatcher } from './scheduler'
+import Dep, { pushTarget, popTarget } from './dep'
+
+import {
+  warn,
+  remove,
+  isObject,
+  parsePath,
+  _Set as Set,
+  handleError
+} from '../util/index'
+
+let uid = 0
+
+/**
+ * A watcher parses an expression, collects dependencies,
+ * and fires callback when the expression value changes.
+ * This is used for both the $watch() api and directives.
+ */
+export default class Watcher {
+  vm: Component;
+  expression: string;
+  cb: Function;
+  id: number;
+  deep: boolean;
+  user: boolean;
+  lazy: boolean;
+  sync: boolean;
+  dirty: boolean;
+  active: boolean;
+  deps: Array<Dep>;
+  newDeps: Array<Dep>;
+  depIds: Set;
+  newDepIds: Set;
+  getter: Function;
+  value: any;
+
+  constructor (
+    vm: Component,
+    expOrFn: string | Function,
+    cb: Function,
+    options?: Object
+  ) {
+    this.vm = vm
+    vm._watchers.push(this)
+    // options
+    if (options) {
+      this.deep = !!options.deep
+      this.user = !!options.user
+      this.lazy = !!options.lazy
+      this.sync = !!options.sync
+    } else {
+      this.deep = this.user = this.lazy = this.sync = false
+    }
+    this.cb = cb
+    this.id = ++uid // uid for batching
+    this.active = true
+    this.dirty = this.lazy // for lazy watchers
+    this.deps = []
+    this.newDeps = []
+    this.depIds = new Set()
+    this.newDepIds = new Set()
+    this.expression = process.env.NODE_ENV !== 'production'
+      ? expOrFn.toString()
+      : ''
+    // parse expression for getter
+    if (typeof expOrFn === 'function') {
+      this.getter = expOrFn
+    } else {
+      this.getter = parsePath(expOrFn)
+      if (!this.getter) {
+        this.getter = function () {}
+        process.env.NODE_ENV !== 'production' && warn(
+          `Failed watching path: "${expOrFn}" ` +
+          'Watcher only accepts simple dot-delimited paths. ' +
+          'For full control, use a function instead.',
+          vm
+        )
+      }
+    }
+    this.value = this.lazy
+      ? undefined
+      : this.get()
+  }
+
+  /**
+   * Evaluate the getter, and re-collect dependencies.
+   */
+  get () {
+    pushTarget(this)
+    let value
+    const vm = this.vm
+    if (this.user) {
+      try {
+        value = this.getter.call(vm, vm)
+      } catch (e) {
+        handleError(e, vm, `getter for watcher "${this.expression}"`)
+      }
+    } else {
+      value = this.getter.call(vm, vm)
+    }
+    // "touch" every property so they are all tracked as
+    // dependencies for deep watching
+    if (this.deep) {
+      traverse(value)
+    }
+    popTarget()
+    this.cleanupDeps()
+    return value
+  }
+
+  /**
+   * Add a dependency to this directive.
+   */
+  addDep (dep: Dep) {
+    const id = dep.id
+    if (!this.newDepIds.has(id)) {
+      this.newDepIds.add(id)
+      this.newDeps.push(dep)
+      if (!this.depIds.has(id)) {
+        dep.addSub(this)
+      }
+    }
+  }
+
+  /**
+   * Clean up for dependency collection.
+   */
+  cleanupDeps () {
+    let i = this.deps.length
+    while (i--) {
+      const dep = this.deps[i]
+      if (!this.newDepIds.has(dep.id)) {
+        dep.removeSub(this)
+      }
+    }
+    let tmp = this.depIds
+    this.depIds = this.newDepIds
+    this.newDepIds = tmp
+    this.newDepIds.clear()
+    tmp = this.deps
+    this.deps = this.newDeps
+    this.newDeps = tmp
+    this.newDeps.length = 0
+  }
+
+  /**
+   * Subscriber interface.
+   * Will be called when a dependency changes.
+   */
+  update () {
+    /* istanbul ignore else */
+    if (this.lazy) {
+      this.dirty = true
+    } else if (this.sync) {
+      this.run()
+    } else {
+      queueWatcher(this)
+    }
+  }
+
+  /**
+   * Scheduler job interface.
+   * Will be called by the scheduler.
+   */
+  run () {
+    if (this.active) {
+      const value = this.get()
+      if (
+        value !== this.value ||
+        // Deep watchers and watchers on Object/Arrays should fire even
+        // when the value is the same, because the value may
+        // have mutated.
+        isObject(value) ||
+        this.deep
+      ) {
+        // set new value
+        const oldValue = this.value
+        this.value = value
+        if (this.user) {
+          try {
+            this.cb.call(this.vm, value, oldValue)
+          } catch (e) {
+            handleError(e, this.vm, `callback for watcher "${this.expression}"`)
+          }
+        } else {
+          this.cb.call(this.vm, value, oldValue)
+        }
+      }
+    }
+  }
+
+  /**
+   * Evaluate the value of the watcher.
+   * This only gets called for lazy watchers.
+   */
+  evaluate () {
+    this.value = this.get()
+    this.dirty = false
+  }
+
+  /**
+   * Depend on all deps collected by this watcher.
+   */
+  depend () {
+    let i = this.deps.length
+    while (i--) {
+      this.deps[i].depend()
+    }
+  }
+
+  /**
+   * Remove self from all dependencies' subscriber list.
+   */
+  teardown () {
+    if (this.active) {
+      // remove self from vm's watcher list
+      // this is a somewhat expensive operation so we skip it
+      // if the vm is being destroyed.
+      if (!this.vm._isBeingDestroyed) {
+        remove(this.vm._watchers, this)
+      }
+      let i = this.deps.length
+      while (i--) {
+        this.deps[i].removeSub(this)
+      }
+      this.active = false
+    }
+  }
+}
+
+/**
+ * Recursively traverse an object to evoke all converted
+ * getters, so that every nested property inside the object
+ * is collected as a "deep" dependency.
+ */
+const seenObjects = new Set()
+function traverse (val: any) {
+  seenObjects.clear()
+  _traverse(val, seenObjects)
+}
+
+function _traverse (val: any, seen: Set) {
+  let i, keys
+  const isA = Array.isArray(val)
+  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {
+    return
+  }
+  if (val.__ob__) {
+    const depId = val.__ob__.dep.id
+    if (seen.has(depId)) {
+      return
+    }
+    seen.add(depId)
+  }
+  if (isA) {
+    i = val.length
+    while (i--) _traverse(val[i], seen)
+  } else {
+    keys = Object.keys(val)
+    i = keys.length
+    while (i--) _traverse(val[keys[i]], seen)
+  }
+}
Index: .idea/deployment.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/deployment.xml	(revision 3d426e1c0d52d26cb969fee1b80a5af3508614bb)
+++ .idea/deployment.xml	(revision )
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="PublishConfigData" serverName="meizu" persistUploadOnCheckin="false">
+  <component name="PublishConfigData" serverName="meizu" uploadOnCheckin="e7c24154-2c6d-44a4-97c5-499936abe7bd">
     <serverData>
       <paths name="meizu">
         <serverdata>
@@ -17,5 +17,6 @@
         </serverdata>
       </paths>
     </serverData>
+    <option name="myUploadOnCheckinName" value="qcloud" />
   </component>
 </project>
\ No newline at end of file
Index: public/node_modules/vue/src/server/render.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/server/render.js	(revision )
+++ public/node_modules/vue/src/server/render.js	(revision )
@@ -0,0 +1,215 @@
+/* @flow */
+
+import { escape } from 'he'
+import { RenderContext } from './render-context'
+import { compileToFunctions } from 'web/compiler/index'
+import { createComponentInstanceForVnode } from 'core/vdom/create-component'
+
+let warned = Object.create(null)
+const warnOnce = msg => {
+  if (!warned[msg]) {
+    warned[msg] = true
+    console.warn(`\n\u001b[31m${msg}\u001b[39m\n`)
+  }
+}
+
+const compilationCache = Object.create(null)
+const normalizeRender = vm => {
+  const { render, template } = vm.$options
+  if (!render) {
+    if (template) {
+      const renderFns = (
+        compilationCache[template] ||
+        (compilationCache[template] = compileToFunctions(template))
+      )
+      Object.assign(vm.$options, renderFns)
+    } else {
+      throw new Error(
+        `render function or template not defined in component: ${
+          vm.$options.name || vm.$options._componentTag || 'anonymous'
+        }`
+      )
+    }
+  }
+}
+
+function renderNode (node, isRoot, context) {
+  const { write, next } = context
+  if (node.componentOptions) {
+    // check cache hit
+    const Ctor = node.componentOptions.Ctor
+    const getKey = Ctor.options.serverCacheKey
+    const name = Ctor.options.name
+    const cache = context.cache
+    if (getKey && cache && name) {
+      const key = name + '::' + getKey(node.componentOptions.propsData)
+      const { has, get } = context
+      if (has) {
+        has(key, hit => {
+          if (hit && get) {
+            get(key, res => write(res, next))
+          } else {
+            renderComponentWithCache(node, isRoot, key, context)
+          }
+        })
+      } else if (get) {
+        get(key, res => {
+          if (res) {
+            write(res, next)
+          } else {
+            renderComponentWithCache(node, isRoot, key, context)
+          }
+        })
+      }
+    } else {
+      if (getKey && !cache) {
+        warnOnce(
+          `[vue-server-renderer] Component ${
+            Ctor.options.name || '(anonymous)'
+          } implemented serverCacheKey, ` +
+          'but no cache was provided to the renderer.'
+        )
+      }
+      if (getKey && !name) {
+        warnOnce(
+          `[vue-server-renderer] Components that implement "serverCacheKey" ` +
+          `must also define a unique "name" option.`
+        )
+      }
+      renderComponent(node, isRoot, context)
+    }
+  } else {
+    if (node.tag) {
+      renderElement(node, isRoot, context)
+    } else if (node.isComment) {
+      write(`<!--${node.text}-->`, next)
+    } else {
+      write(node.raw ? node.text : escape(String(node.text)), next)
+    }
+  }
+}
+
+function renderComponent (node, isRoot, context) {
+  const prevActive = context.activeInstance
+  const child = context.activeInstance = createComponentInstanceForVnode(node, context.activeInstance)
+  normalizeRender(child)
+  const childNode = child._render()
+  childNode.parent = node
+  context.renderStates.push({
+    type: 'Component',
+    prevActive
+  })
+  renderNode(childNode, isRoot, context)
+}
+
+function renderComponentWithCache (node, isRoot, key, context) {
+  const write = context.write
+  write.caching = true
+  const buffer = write.cacheBuffer
+  const bufferIndex = buffer.push('') - 1
+  context.renderStates.push({
+    type: 'ComponentWithCache',
+    buffer, bufferIndex, key
+  })
+  renderComponent(node, isRoot, context)
+}
+
+function renderElement (el, isRoot, context) {
+  if (isRoot) {
+    if (!el.data) el.data = {}
+    if (!el.data.attrs) el.data.attrs = {}
+    el.data.attrs['server-rendered'] = 'true'
+  }
+  const startTag = renderStartingTag(el, context)
+  const endTag = `</${el.tag}>`
+  const { write, next } = context
+  if (context.isUnaryTag(el.tag)) {
+    write(startTag, next)
+  } else if (!el.children || !el.children.length) {
+    write(startTag + endTag, next)
+  } else {
+    const children: Array<VNode> = el.children
+    context.renderStates.push({
+      type: 'Element',
+      rendered: 0,
+      total: children.length,
+      endTag, children
+    })
+    write(startTag, next)
+  }
+}
+
+function hasAncestorData (node: VNode) {
+  const parentNode = node.parent
+  return parentNode && (parentNode.data || hasAncestorData(parentNode))
+}
+
+function renderStartingTag (node: VNode, context) {
+  let markup = `<${node.tag}`
+  const { directives, modules } = context
+
+  // construct synthetic data for module processing
+  // because modules like style also produce code by parent VNode data
+  if (!node.data && hasAncestorData(node)) {
+    node.data = {}
+  }
+  if (node.data) {
+    // check directives
+    const dirs = node.data.directives
+    if (dirs) {
+      for (let i = 0; i < dirs.length; i++) {
+        const dirRenderer = directives[dirs[i].name]
+        if (dirRenderer) {
+          // directives mutate the node's data
+          // which then gets rendered by modules
+          dirRenderer(node, dirs[i])
+        }
+      }
+    }
+    // apply other modules
+    for (let i = 0; i < modules.length; i++) {
+      const res = modules[i](node)
+      if (res) {
+        markup += res
+      }
+    }
+  }
+  // attach scoped CSS ID
+  let scopeId
+  const activeInstance = context.activeInstance
+  if (activeInstance &&
+      activeInstance !== node.context &&
+      (scopeId = activeInstance.$options._scopeId)) {
+    markup += ` ${scopeId}`
+  }
+  while (node) {
+    if ((scopeId = node.context.$options._scopeId)) {
+      markup += ` ${scopeId}`
+    }
+    node = node.parent
+  }
+  return markup + '>'
+}
+
+export function createRenderFunction (
+  modules: Array<Function>,
+  directives: Object,
+  isUnaryTag: Function,
+  cache: any
+) {
+  return function render (
+    component: Component,
+    write: (text: string, next: Function) => void,
+    done: Function
+  ) {
+    warned = Object.create(null)
+    const context = new RenderContext({
+      activeInstance: component,
+      write, done, renderNode,
+      isUnaryTag, modules, directives,
+      cache
+    })
+    normalizeRender(component)
+    renderNode(component._render(), true, context)
+  }
+}
Index: public/node_modules/vue/src/platforms/web/server/directives/show.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/server/directives/show.js	(revision )
+++ public/node_modules/vue/src/platforms/web/server/directives/show.js	(revision )
@@ -0,0 +1,8 @@
+/* @flow */
+
+export default function show (node: VNodeWithData, dir: VNodeDirective) {
+  if (!dir.value) {
+    const style: any = node.data.style || (node.data.style = {})
+    style.display = 'none'
+  }
+}
Index: public/node_modules/vue/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/package.json	(revision )
+++ public/node_modules/vue/package.json	(revision )
@@ -0,0 +1,124 @@
+{
+  "name": "vue",
+  "version": "2.2.2",
+  "description": "Reactive, component-oriented view layer for modern web interfaces.",
+  "main": "dist/vue.runtime.common.js",
+  "module": "dist/vue.runtime.esm.js",
+  "unpkg": "dist/vue.js",
+  "typings": "types/index.d.ts",
+  "files": [
+    "src",
+    "dist/*.js",
+    "types/*.d.ts"
+  ],
+  "scripts": {
+    "dev": "TARGET=web-full-dev rollup -w -c build/config.js",
+    "dev:cjs": "TARGET=web-runtime-cjs rollup -w -c build/config.js",
+    "dev:test": "karma start build/karma.dev.config.js",
+    "dev:ssr": "TARGET=web-server-renderer rollup -w -c build/config.js",
+    "dev:compiler": "TARGET=web-compiler rollup -w -c build/config.js",
+    "dev:weex": "TARGET=weex-framework rollup -w -c build/config.js",
+    "dev:weex:compiler": "TARGET=weex-compiler rollup -w -c build/config.js",
+    "build": "node build/build.js",
+    "build:ssr": "npm run build -- vue.runtime.common.js,vue-server-renderer",
+    "build:weex": "npm run build -- weex-vue-framework,weex-template-compiler",
+    "test": "npm run lint && flow check && npm run test:types && npm run test:cover && npm run test:e2e -- --env phantomjs && npm run test:ssr && npm run test:weex",
+    "test:unit": "karma start build/karma.unit.config.js",
+    "test:cover": "karma start build/karma.cover.config.js",
+    "test:e2e": "npm run build -- vue.min.js && node test/e2e/runner.js",
+    "test:weex": "npm run build:weex && jasmine JASMINE_CONFIG_PATH=test/weex/jasmine.json",
+    "test:ssr": "npm run build:ssr && jasmine JASMINE_CONFIG_PATH=test/ssr/jasmine.json",
+    "test:sauce": "npm run sauce -- 0 && npm run sauce -- 1 && npm run sauce -- 2",
+    "test:types": "tsc -p ./types/test/tsconfig.json",
+    "lint": "eslint src build test",
+    "flow": "flow check",
+    "sauce": "SAUCE=true karma start build/karma.sauce.config.js",
+    "bench:ssr": "npm run build:ssr && NODE_ENV=production node benchmarks/ssr/renderToString.js && NODE_ENV=production VUE_ENV=server node benchmarks/ssr/renderToStream.js",
+    "release": "bash build/release.sh",
+    "release:weex": "bash build/release-weex.sh",
+    "install:hooks": "ln -fs ../../build/git-hooks/pre-commit .git/hooks/pre-commit"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/vuejs/vue.git"
+  },
+  "keywords": [
+    "vue"
+  ],
+  "author": {
+    "name": "Evan You"
+  },
+  "license": "MIT",
+  "bugs": {
+    "url": "https://github.com/vuejs/vue/issues"
+  },
+  "homepage": "https://github.com/vuejs/vue#readme",
+  "devDependencies": {
+    "babel-core": "^6.9.0",
+    "babel-eslint": "^7.1.0",
+    "babel-helper-vue-jsx-merge-props": "^2.0.2",
+    "babel-loader": "^6.2.4",
+    "babel-plugin-istanbul": "^4.0.0",
+    "babel-plugin-syntax-dynamic-import": "^6.18.0",
+    "babel-plugin-syntax-jsx": "^6.18.0",
+    "babel-plugin-transform-vue-jsx": "^3.2.0",
+    "babel-preset-es2015": "^6.9.0",
+    "babel-preset-flow-vue": "^1.0.0",
+    "buble": "^0.15.2",
+    "chromedriver": "^2.21.2",
+    "codecov.io": "^0.1.6",
+    "cross-spawn": "^5.0.1",
+    "de-indent": "^1.0.2",
+    "es6-promise": "^4.0.5",
+    "eslint": "^3.10.1",
+    "eslint-config-vue": "^2.0.1",
+    "eslint-loader": "^1.3.0",
+    "eslint-plugin-flowtype": "^2.16.0",
+    "eslint-plugin-jasmine": "^2.1.0",
+    "eslint-plugin-vue": "^2.0.0",
+    "flow-bin": "^0.39.0",
+    "he": "^1.1.0",
+    "http-server": "^0.9.0",
+    "jasmine": "^2.5.2",
+    "jasmine-core": "^2.5.2",
+    "karma": "^1.1.0",
+    "karma-chrome-launcher": "^2.0.0",
+    "karma-coverage": "^1.0.0",
+    "karma-firefox-launcher": "^1.0.0",
+    "karma-jasmine": "^1.0.2",
+    "karma-mocha-reporter": "^2.0.4",
+    "karma-phantomjs-launcher": "^1.0.0",
+    "karma-safari-launcher": "^1.0.0",
+    "karma-sauce-launcher": "^1.0.0",
+    "karma-sourcemap-loader": "^0.3.0",
+    "karma-webpack": "^2.0.1",
+    "lodash": "^4.17.1",
+    "nightwatch": "^0.9.9",
+    "nightwatch-helpers": "^1.2.0",
+    "phantomjs-prebuilt": "^2.1.1",
+    "resolve": "^1.2.0",
+    "rollup": "^0.41.4",
+    "rollup-plugin-alias": "^1.2.0",
+    "rollup-plugin-babel": "^2.4.0",
+    "rollup-plugin-buble": "^0.15.0",
+    "rollup-plugin-flow-no-whitespace": "^1.0.0",
+    "rollup-plugin-replace": "^1.1.0",
+    "rollup-watch": "^3.2.2",
+    "selenium-server": "^2.53.1",
+    "typescript": "^2.1.6",
+    "uglify-js": "^2.6.2",
+    "vue-ssr-html-stream": "^2.1.0",
+    "vue-ssr-webpack-plugin": "^1.0.0",
+    "webpack": "^2.2.0",
+    "weex-js-runtime": "^0.17.0-alpha4",
+    "weex-vdom-tester": "^0.1.4"
+  },
+  "readme": "<p align=\"center\"><a href=\"https://vuejs.org\" target=\"_blank\"><img width=\"100\"src=\"https://vuejs.org/images/logo.png\"></a></p>\n\n<p align=\"center\">\n  <a href=\"https://circleci.com/gh/vuejs/vue/tree/dev\"><img src=\"https://img.shields.io/circleci/project/vuejs/vue/dev.svg\" alt=\"Build Status\"></a>\n  <a href=\"https://codecov.io/github/vuejs/vue?branch=dev\"><img src=\"https://img.shields.io/codecov/c/github/vuejs/vue/dev.svg\" alt=\"Coverage Status\"></a>\n  <a href=\"https://www.npmjs.com/package/vue\"><img src=\"https://img.shields.io/npm/dt/vue.svg\" alt=\"Downloads\"></a>\n  <a href=\"https://www.npmjs.com/package/vue\"><img src=\"https://img.shields.io/npm/v/vue.svg\" alt=\"Version\"></a>\n  <a href=\"https://www.npmjs.com/package/vue\"><img src=\"https://img.shields.io/npm/l/vue.svg\" alt=\"License\"></a>\n  <br>\n  <a href=\"https://saucelabs.com/u/vuejs\"><img src=\"https://saucelabs.com/browser-matrix/vuejs.svg\" alt=\"Sauce Test Status\"></a>\n</p>\n\n## Supporting Vue.js\n\nVue.js is an MIT-licensed open source project. Its ongoing development is made possible thanks to the support by these awesome [backers](https://github.com/vuejs/vue/blob/dev/BACKERS.md). If you'd like to join them, check out [Vue.js' Patreon campaign](https://www.patreon.com/evanyou).\n\n<p align=\"center\">\n  <b>Special thanks to the generous sponsorship by:</b>\n  <br><br>\n  <a href=\"http://www.thedifferenceengine.io/\">\n    <img width=\"300px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/tde.png\">\n  </a>\n  <br><br>\n  <a href=\"https://jsfiddle.net/\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/jsfiddle.png\">\n  </a>\n  <br><br>\n  <a href=\"https://laravel.com/\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/laravel.png\">\n  </a>\n  <br><br>\n  <a href=\"https://chaitin.cn/\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/chaitin.png\">\n  </a>\n  <br><br>\n  <a href=\"https://htmlburger.com/\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/htmlburger.png\">\n  </a>\n  <br><br>\n  <a href=\"https://starter.someline.com/\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/someline.png\">\n  </a>\n  <br><br>\n  <a href=\"http://monterail.com/\" target=\"_blank\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/monterail.png\">\n  </a>\n  <br><br>\n  <a href=\"https://www.trisoft.ro/\" target=\"_blank\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/trisoft.png\">\n  </a>\n  <br><br>\n  <a href=\"https://www.2mhost.com/\" target=\"_blank\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/2mhost.png\">\n  </a>\n  <br><br>\n  <a href=\"https://vuejsjob.com/?ref=vuejs\" target=\"_blank\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/vuejobs.png\">\n  </a>\n  <br><br>\n  <a href=\"https://leanpub.com/vuejs2\" target=\"_blank\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/tmvuejs2.png\">\n  </a>\n  <br><br>\n  <a href=\"https://stdlib.com/\" target=\"_blank\">\n    <img width=\"120px\" src=\"https://raw.githubusercontent.com/vuejs/vuejs.org/master/themes/vue/source/images/stdlib.png\">\n  </a>\n</p>\n\n## Intro\n\nVue.js is a library for building interactive web interfaces. It provides data-reactive components with a simple and flexible API. Core features include:\n\n- [Declarative rendering with a plain JavaScript object based reactivity system.](https://vuejs.org/guide/index.html#Declarative-Rendering)\n- [Component-oriented development style with tooling support](https://vuejs.org/guide/index.html#Composing-with-Components)\n- Lean and extensible core\n- [Flexible transition effect system](https://vuejs.org/guide/transitions.html)\n- Fast without the need for complex optimization\n\nNote that Vue.js only supports [ES5-compliant browsers](http://kangax.github.io/compat-table/es5/) (IE8 and below are not supported). To check out live examples and docs, visit [vuejs.org](https://vuejs.org).\n\n## Questions\n\nFor questions and support please use the [Gitter chat room](https://gitter.im/vuejs/vue) or [the official forum](http://forum.vuejs.org). The issue list of this repo is **exclusively** for bug reports and feature requests.\n\n## Issues\n\nPlease make sure to read the [Issue Reporting Checklist](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md#issue-reporting-guidelines) before opening an issue. Issues not conforming to the guidelines may be closed immediately.\n\n## Contribution\n\nPlease make sure to read the [Contributing Guide](https://github.com/vuejs/vue/blob/dev/.github/CONTRIBUTING.md) before making a pull request. If you have a Vue-related project/component/tool, add it with a pull-request to [this curated list](https://github.com/vuejs/awesome-vue)!\n\n## Changelog\n\nDetails changes for each release are documented in the [release notes](https://github.com/vuejs/vue/releases).\n\n## Stay In Touch\n\n- For latest releases and announcements, follow on Twitter: [@vuejs](https://twitter.com/vuejs)\n\n## License\n\n[MIT](http://opensource.org/licenses/MIT)\n\nCopyright (c) 2013-present, Yuxi (Evan) You\n",
+  "readmeFilename": "README.md",
+  "_id": "vue@2.2.2",
+  "dist": {
+    "shasum": "867c76c9b7ce182c702f4a979430d1605740fc64"
+  },
+  "_from": "vue@",
+  "_resolved": "https://registry.npmjs.org/vue/-/vue-2.2.2.tgz"
+}
Index: public/node_modules/vue-resource/src/http/response.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/response.js	(revision )
+++ public/node_modules/vue-resource/src/http/response.js	(revision )
@@ -0,0 +1,63 @@
+/**
+ * HTTP Response.
+ */
+
+import Headers from './headers';
+import Promise from '../promise';
+import { when, isBlob, isString } from '../util';
+
+export default class Response {
+
+    constructor(body, {url, headers, status, statusText}) {
+
+        this.url = url;
+        this.ok = status >= 200 && status < 300;
+        this.status = status || 0;
+        this.statusText = statusText || '';
+        this.headers = new Headers(headers);
+        this.body = body;
+
+        if (isString(body)) {
+
+            this.bodyText = body;
+
+        } else if (isBlob(body)) {
+
+            this.bodyBlob = body;
+
+            if (isBlobText(body)) {
+                this.bodyText = blobText(body);
+            }
+        }
+    }
+
+    blob() {
+        return when(this.bodyBlob);
+    }
+
+    text() {
+        return when(this.bodyText);
+    }
+
+    json() {
+        return when(this.text(), text => JSON.parse(text));
+    }
+
+}
+
+function blobText(body) {
+    return new Promise((resolve) => {
+
+        var reader = new FileReader();
+
+        reader.readAsText(body);
+        reader.onload = () => {
+            resolve(reader.result);
+        };
+
+    });
+}
+
+function isBlobText(body) {
+    return body.type.indexOf('text') === 0 || body.type.indexOf('json') !== -1;
+}
Index: public/node_modules/vue/dist/vue.min.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/dist/vue.min.js	(revision )
+++ public/node_modules/vue/dist/vue.min.js	(revision )
@@ -0,0 +1,8 @@
+/*!
+ * Vue.js v2.2.2
+ * (c) 2014-2017 Evan You
+ * Released under the MIT License.
+ */
+!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):e.Vue=t()}(this,function(){"use strict";function e(e){return null==e?"":"object"==typeof e?JSON.stringify(e,null,2):String(e)}function t(e){var t=parseFloat(e);return isNaN(t)?e:t}function n(e,t){for(var n=Object.create(null),r=e.split(","),i=0;i<r.length;i++)n[r[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}function r(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}function i(e,t){return Ni.call(e,t)}function o(e){return"string"==typeof e||"number"==typeof e}function a(e){var t=Object.create(null);return function(n){var r=t[n];return r||(t[n]=e(n))}}function s(e,t){function n(n){var r=arguments.length;return r?r>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n}function c(e,t){t=t||0;for(var n=e.length-t,r=new Array(n);n--;)r[n]=e[n+t];return r}function u(e,t){for(var n in t)e[n]=t[n];return e}function l(e){return null!==e&&"object"==typeof e}function f(e){return Ri.call(e)===Fi}function p(e){for(var t={},n=0;n<e.length;n++)e[n]&&u(t,e[n]);return t}function d(){}function v(e){return e.reduce(function(e,t){return e.concat(t.staticKeys||[])},[]).join(",")}function h(e,t){var n=l(e),r=l(t);if(!n||!r)return!n&&!r&&String(e)===String(t);try{return JSON.stringify(e)===JSON.stringify(t)}catch(n){return e===t}}function m(e,t){for(var n=0;n<e.length;n++)if(h(e[n],t))return n;return-1}function g(e){var t=!1;return function(){t||(t=!0,e())}}function y(e){return/native code/.test(e.toString())}function _(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function b(e,t,n,r){Object.defineProperty(e,t,{value:n,enumerable:!!r,writable:!0,configurable:!0})}function $(e){if(!ro.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}function w(e){ao.target&&so.push(ao.target),ao.target=e}function x(){ao.target=so.pop()}function C(e,t){e.__proto__=t}function k(e,t,n){for(var r=0,i=n.length;r<i;r++){var o=n[r];b(e,o,t[o])}}function A(e,t){if(l(e)){var n;return i(e,"__ob__")&&e.__ob__ instanceof po?n=e.__ob__:fo.shouldConvert&&!Qi()&&(Array.isArray(e)||f(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new po(e)),t&&n&&n.vmCount++,n}}function O(e,t,n,r){var i=new ao,o=Object.getOwnPropertyDescriptor(e,t);if(!o||o.configurable!==!1){var a=o&&o.get,s=o&&o.set,c=A(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=a?a.call(e):n;return ao.target&&(i.depend(),c&&c.dep.depend(),Array.isArray(t)&&E(t)),t},set:function(t){var r=a?a.call(e):n;t===r||t!==t&&r!==r||(s?s.call(e,t):n=t,c=A(t),i.notify())}})}}function S(e,t,n){if(Array.isArray(e))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(i(e,t))return e[t]=n,n;var r=e.__ob__;return e._isVue||r&&r.vmCount?n:r?(O(r.value,t,n),r.dep.notify(),n):(e[t]=n,n)}function T(e,t){if(Array.isArray(e))return void e.splice(t,1);var n=e.__ob__;e._isVue||n&&n.vmCount||i(e,t)&&(delete e[t],n&&n.dep.notify())}function E(e){for(var t=void 0,n=0,r=e.length;n<r;n++)t=e[n],t&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&E(t)}function j(e,t){if(!t)return e;for(var n,r,o,a=Object.keys(t),s=0;s<a.length;s++)n=a[s],r=e[n],o=t[n],i(e,n)?f(r)&&f(o)&&j(r,o):S(e,n,o);return e}function N(e,t){return t?e?e.concat(t):Array.isArray(t)?t:[t]:e}function I(e,t){var n=Object.create(e||null);return t?u(n,t):n}function L(e){var t=e.props;if(t){var n,r,i,o={};if(Array.isArray(t))for(n=t.length;n--;)r=t[n],"string"==typeof r&&(i=Li(r),o[i]={type:null});else if(f(t))for(var a in t)r=t[a],i=Li(a),o[i]=f(r)?r:{type:r};e.props=o}}function D(e){var t=e.directives;if(t)for(var n in t){var r=t[n];"function"==typeof r&&(t[n]={bind:r,update:r})}}function M(e,t,n){function r(r){var i=vo[r]||ho;l[r]=i(e[r],t[r],n,r)}L(t),D(t);var o=t.extends;if(o&&(e="function"==typeof o?M(e,o.options,n):M(e,o,n)),t.mixins)for(var a=0,s=t.mixins.length;a<s;a++){var c=t.mixins[a];c.prototype instanceof ft&&(c=c.options),e=M(e,c,n)}var u,l={};for(u in e)r(u);for(u in t)i(e,u)||r(u);return l}function P(e,t,n,r){if("string"==typeof n){var o=e[t];if(i(o,n))return o[n];var a=Li(n);if(i(o,a))return o[a];var s=Di(a);if(i(o,s))return o[s];var c=o[n]||o[a]||o[s];return c}}function R(e,t,n,r){var o=t[e],a=!i(n,e),s=n[e];if(U(Boolean,o.type)&&(a&&!i(o,"default")?s=!1:U(String,o.type)||""!==s&&s!==Pi(e)||(s=!0)),void 0===s){s=F(r,o,e);var c=fo.shouldConvert;fo.shouldConvert=!0,A(s),fo.shouldConvert=c}return s}function F(e,t,n){if(i(t,"default")){var r=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:"function"==typeof r&&"Function"!==H(t.type)?r.call(e):r}}function H(e){var t=e&&e.toString().match(/^\s*function (\w+)/);return t&&t[1]}function U(e,t){if(!Array.isArray(t))return H(t)===H(e);for(var n=0,r=t.length;n<r;n++)if(H(t[n])===H(e))return!0;return!1}function B(e,t,n){if(Bi.errorHandler)Bi.errorHandler.call(null,e,t,n);else{if(!zi||"undefined"==typeof console)throw e;console.error(e)}}function V(e){return new mo(void 0,void 0,void 0,String(e))}function z(e){var t=new mo(e.tag,e.data,e.children,e.text,e.elm,e.context,e.componentOptions);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isCloned=!0,t}function J(e){for(var t=e.length,n=new Array(t),r=0;r<t;r++)n[r]=z(e[r]);return n}function K(e){function t(){var e=arguments,n=t.fns;if(!Array.isArray(n))return n.apply(null,arguments);for(var r=0;r<n.length;r++)n[r].apply(null,e)}return t.fns=e,t}function q(e,t,n,r,i){var o,a,s,c;for(o in e)a=e[o],s=t[o],c=bo(o),a&&(s?a!==s&&(s.fns=a,e[o]=s):(a.fns||(a=e[o]=K(a)),n(c.name,a,c.once,c.capture)));for(o in t)e[o]||(c=bo(o),r(c.name,t[o],c.capture))}function W(e,t,n){function i(){n.apply(this,arguments),r(o.fns,i)}var o,a=e[t];a?a.fns&&a.merged?(o=a,o.fns.push(i)):o=K([a,i]):o=K([i]),o.merged=!0,e[t]=o}function Z(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}function G(e){return o(e)?[V(e)]:Array.isArray(e)?Y(e):void 0}function Y(e,t){var n,r,i,a=[];for(n=0;n<e.length;n++)r=e[n],null!=r&&"boolean"!=typeof r&&(i=a[a.length-1],Array.isArray(r)?a.push.apply(a,Y(r,(t||"")+"_"+n)):o(r)?i&&i.text?i.text+=String(r):""!==r&&a.push(V(r)):r.text&&i&&i.text?a[a.length-1]=V(i.text+r.text):(r.tag&&null==r.key&&null!=t&&(r.key="__vlist"+t+"_"+n+"__"),a.push(r)));return a}function Q(e){return e&&e.filter(function(e){return e&&e.componentOptions})[0]}function X(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&ne(e,t)}function ee(e,t,n){n?yo.$once(e,t):yo.$on(e,t)}function te(e,t){yo.$off(e,t)}function ne(e,t,n){yo=e,q(t,n||{},ee,te,e)}function re(e){var t=/^hook:/;e.prototype.$on=function(e,n){var r=this,i=this;if(Array.isArray(e))for(var o=0,a=e.length;o<a;o++)r.$on(e[o],n);else(i._events[e]||(i._events[e]=[])).push(n),t.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){function n(){r.$off(e,n),t.apply(r,arguments)}var r=this;return n.fn=t,r.$on(e,n),r},e.prototype.$off=function(e,t){var n=this,r=this;if(!arguments.length)return r._events=Object.create(null),r;if(Array.isArray(e)){for(var i=0,o=e.length;i<o;i++)n.$off(e[i],t);return r}var a=r._events[e];if(!a)return r;if(1===arguments.length)return r._events[e]=null,r;for(var s,c=a.length;c--;)if(s=a[c],s===t||s.fn===t){a.splice(c,1);break}return r},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?c(n):n;for(var r=c(arguments,1),i=0,o=n.length;i<o;i++)n[i].apply(t,r)}return t}}function ie(e,t){var n={};if(!e)return n;for(var r,i,o=[],a=0,s=e.length;a<s;a++)if(i=e[a],(i.context===t||i.functionalContext===t)&&i.data&&(r=i.data.slot)){var c=n[r]||(n[r]=[]);"template"===i.tag?c.push.apply(c,i.children):c.push(i)}else o.push(i);return o.every(oe)||(n.default=o),n}function oe(e){return e.isComment||" "===e.text}function ae(e){for(var t={},n=0;n<e.length;n++)t[e[n][0]]=e[n][1];return t}function se(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}function ce(e){e.prototype._update=function(e,t){var n=this;n._isMounted&&ve(n,"beforeUpdate");var r=n.$el,i=n._vnode,o=$o;$o=n,n._vnode=e,i?n.$el=n.__patch__(i,e):n.$el=n.__patch__(n.$el,e,t,!1,n.$options._parentElm,n.$options._refElm),$o=o,r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){var e=this;e._watcher&&e._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){ve(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||r(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,ve(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.__patch__(e._vnode,null)}}}function ue(e,t,n){e.$el=t,e.$options.render||(e.$options.render=_o),ve(e,"beforeMount");var r;return r=function(){e._update(e._render(),n)},e._watcher=new So(e,r,d),n=!1,null==e.$vnode&&(e._isMounted=!0,ve(e,"mounted")),e}function le(e,t,n,r,i){var o=!!(i||e.$options._renderChildren||r.data.scopedSlots||e.$scopedSlots!==no);if(e.$options._parentVnode=r,e.$vnode=r,e._vnode&&(e._vnode.parent=r),e.$options._renderChildren=i,t&&e.$options.props){fo.shouldConvert=!1;for(var a=e._props,s=e.$options._propKeys||[],c=0;c<s.length;c++){var u=s[c];a[u]=R(u,e.$options.props,t,e)}fo.shouldConvert=!0,e.$options.propsData=t}if(n){var l=e.$options._parentListeners;e.$options._parentListeners=n,ne(e,n,l)}o&&(e.$slots=ie(i,r.context),e.$forceUpdate())}function fe(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function pe(e,t){if(t){if(e._directInactive=!1,fe(e))return}else if(e._directInactive)return;if(e._inactive||null==e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)pe(e.$children[n]);ve(e,"activated")}}function de(e,t){if(!(t&&(e._directInactive=!0,fe(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)de(e.$children[n]);ve(e,"deactivated")}}function ve(e,t){var n=e.$options[t];if(n)for(var r=0,i=n.length;r<i;r++)try{n[r].call(e)}catch(n){B(n,e,t+" hook")}e._hasHookEvent&&e.$emit("hook:"+t)}function he(){wo.length=0,xo={},Co=ko=!1}function me(){ko=!0;var e,t,n;for(wo.sort(function(e,t){return e.id-t.id}),Ao=0;Ao<wo.length;Ao++)e=wo[Ao],t=e.id,xo[t]=null,e.run();for(Ao=wo.length;Ao--;)e=wo[Ao],n=e.vm,n._watcher===e&&n._isMounted&&ve(n,"updated");Xi&&Bi.devtools&&Xi.emit("flush"),he()}function ge(e){var t=e.id;if(null==xo[t]){if(xo[t]=!0,ko){for(var n=wo.length-1;n>=0&&wo[n].id>e.id;)n--;wo.splice(Math.max(n,Ao)+1,0,e)}else wo.push(e);Co||(Co=!0,to(me))}}function ye(e){To.clear(),_e(e,To)}function _e(e,t){var n,r,i=Array.isArray(e);if((i||l(e))&&Object.isExtensible(e)){if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(i)for(n=e.length;n--;)_e(e[n],t);else for(r=Object.keys(e),n=r.length;n--;)_e(e[r[n]],t)}}function be(e,t,n){Eo.get=function(){return this[t][n]},Eo.set=function(e){this[t][n]=e},Object.defineProperty(e,n,Eo)}function $e(e){e._watchers=[];var t=e.$options;t.props&&we(e,t.props),t.methods&&Oe(e,t.methods),t.data?xe(e):A(e._data={},!0),t.computed&&Ce(e,t.computed),t.watch&&Se(e,t.watch)}function we(e,t){var n=e.$options.propsData||{},r=e._props={},i=e.$options._propKeys=[],o=!e.$parent;fo.shouldConvert=o;var a=function(o){i.push(o);var a=R(o,t,n,e);O(r,o,a),o in e||be(e,"_props",o)};for(var s in t)a(s);fo.shouldConvert=!0}function xe(e){var t=e.$options.data;t=e._data="function"==typeof t?t.call(e):t||{},f(t)||(t={});for(var n=Object.keys(t),r=e.$options.props,o=n.length;o--;)r&&i(r,n[o])||_(n[o])||be(e,"_data",n[o]);A(t,!0)}function Ce(e,t){var n=e._computedWatchers=Object.create(null);for(var r in t){var i=t[r],o="function"==typeof i?i:i.get;n[r]=new So(e,o,d,jo),r in e||ke(e,r,i)}}function ke(e,t,n){"function"==typeof n?(Eo.get=Ae(t),Eo.set=d):(Eo.get=n.get?n.cache!==!1?Ae(t):n.get:d,Eo.set=n.set?n.set:d),Object.defineProperty(e,t,Eo)}function Ae(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),ao.target&&t.depend(),t.value}}function Oe(e,t){e.$options.props;for(var n in t)e[n]=null==t[n]?d:s(t[n],e)}function Se(e,t){for(var n in t){var r=t[n];if(Array.isArray(r))for(var i=0;i<r.length;i++)Te(e,n,r[i]);else Te(e,n,r)}}function Te(e,t,n){var r;f(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,r)}function Ee(e){var t={};t.get=function(){return this._data};var n={};n.get=function(){return this._props},Object.defineProperty(e.prototype,"$data",t),Object.defineProperty(e.prototype,"$props",n),e.prototype.$set=S,e.prototype.$delete=T,e.prototype.$watch=function(e,t,n){var r=this;n=n||{},n.user=!0;var i=new So(r,e,t,n);return n.immediate&&t.call(r,i.value),function(){i.teardown()}}}function je(e,t,n,r,i){if(e){var o=n.$options._base;if(l(e)&&(e=o.extend(e)),"function"==typeof e){if(!e.cid)if(e.resolved)e=e.resolved;else if(e=Re(e,o,function(){n.$forceUpdate()}),!e)return;ct(e),t=t||{},t.model&&Ve(e.options,t);var a=Fe(t,e);if(e.options.functional)return Ne(e,a,t,n,r);var s=t.on;t.on=t.nativeOn,e.options.abstract&&(t={}),Ue(t);var c=e.options.name||i,u=new mo("vue-component-"+e.cid+(c?"-"+c:""),t,void 0,void 0,void 0,n,{Ctor:e,propsData:a,listeners:s,tag:i,children:r});return u}}}function Ne(e,t,n,r,i){var o={},a=e.options.props;if(a)for(var s in a)o[s]=R(s,a,t);var c=Object.create(r),u=function(e,t,n,r){return ze(c,e,t,n,r,!0)},l=e.options.render.call(null,u,{props:o,data:n,parent:r,children:i,slots:function(){return ie(i,r)}});return l instanceof mo&&(l.functionalContext=r,n.slot&&((l.data||(l.data={})).slot=n.slot)),l}function Ie(e,t,n,r){var i=e.componentOptions,o={_isComponent:!0,parent:t,propsData:i.propsData,_componentTag:i.tag,_parentVnode:e,_parentListeners:i.listeners,_renderChildren:i.children,_parentElm:n||null,_refElm:r||null},a=e.data.inlineTemplate;return a&&(o.render=a.render,o.staticRenderFns=a.staticRenderFns),new i.Ctor(o)}function Le(e,t,n,r){if(!e.componentInstance||e.componentInstance._isDestroyed){var i=e.componentInstance=Ie(e,$o,n,r);i.$mount(t?e.elm:void 0,t)}else if(e.data.keepAlive){var o=e;De(o,o)}}function De(e,t){var n=t.componentOptions,r=t.componentInstance=e.componentInstance;le(r,n.propsData,n.listeners,t,n.children)}function Me(e){e.componentInstance._isMounted||(e.componentInstance._isMounted=!0,ve(e.componentInstance,"mounted")),e.data.keepAlive&&pe(e.componentInstance,!0)}function Pe(e){e.componentInstance._isDestroyed||(e.data.keepAlive?de(e.componentInstance,!0):e.componentInstance.$destroy())}function Re(e,t,n){if(!e.requested){e.requested=!0;var r=e.pendingCallbacks=[n],i=!0,o=function(n){if(l(n)&&(n=t.extend(n)),e.resolved=n,!i)for(var o=0,a=r.length;o<a;o++)r[o](n)},a=function(e){},s=e(o,a);return s&&"function"==typeof s.then&&!e.resolved&&s.then(o,a),i=!1,e.resolved}e.pendingCallbacks.push(n)}function Fe(e,t){var n=t.options.props;if(n){var r={},i=e.attrs,o=e.props,a=e.domProps;if(i||o||a)for(var s in n){var c=Pi(s);He(r,o,s,c,!0)||He(r,i,s,c)||He(r,a,s,c)}return r}}function He(e,t,n,r,o){if(t){if(i(t,n))return e[n]=t[n],o||delete t[n],!0;if(i(t,r))return e[n]=t[r],o||delete t[r],!0}return!1}function Ue(e){e.hook||(e.hook={});for(var t=0;t<Io.length;t++){var n=Io[t],r=e.hook[n],i=No[n];e.hook[n]=r?Be(i,r):i}}function Be(e,t){return function(n,r,i,o){e(n,r,i,o),t(n,r,i,o)}}function Ve(e,t){var n=e.model&&e.model.prop||"value",r=e.model&&e.model.event||"input";(t.props||(t.props={}))[n]=t.model.value;var i=t.on||(t.on={});i[r]?i[r]=[t.model.callback].concat(i[r]):i[r]=t.model.callback}function ze(e,t,n,r,i,a){return(Array.isArray(n)||o(n))&&(i=r,r=n,n=void 0),a&&(i=Do),Je(e,t,n,r,i)}function Je(e,t,n,r,i){if(n&&n.__ob__)return _o();if(!t)return _o();Array.isArray(r)&&"function"==typeof r[0]&&(n=n||{},n.scopedSlots={default:r[0]},r.length=0),i===Do?r=G(r):i===Lo&&(r=Z(r));var o,a;if("string"==typeof t){var s;a=Bi.getTagNamespace(t),o=Bi.isReservedTag(t)?new mo(Bi.parsePlatformTagName(t),n,r,void 0,void 0,e):(s=P(e.$options,"components",t))?je(s,n,e,r,t):new mo(t,n,r,void 0,void 0,e)}else o=je(t,n,e,r);return o?(a&&Ke(o,a),o):_o()}function Ke(e,t){if(e.ns=t,"foreignObject"!==e.tag&&e.children)for(var n=0,r=e.children.length;n<r;n++){var i=e.children[n];i.tag&&!i.ns&&Ke(i,t)}}function qe(e,t){var n,r,i,o,a;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),r=0,i=e.length;r<i;r++)n[r]=t(e[r],r);else if("number"==typeof e)for(n=new Array(e),r=0;r<e;r++)n[r]=t(r+1,r);else if(l(e))for(o=Object.keys(e),n=new Array(o.length),r=0,i=o.length;r<i;r++)a=o[r],n[r]=t(e[a],a,r);return n}function We(e,t,n,r){var i=this.$scopedSlots[e];if(i)return n=n||{},r&&u(n,r),i(n)||t;var o=this.$slots[e];return o||t}function Ze(e){return P(this.$options,"filters",e,!0)||Ui}function Ge(e,t,n){var r=Bi.keyCodes[t]||n;return Array.isArray(r)?r.indexOf(e)===-1:r!==e}function Ye(e,t,n,r){if(n)if(l(n)){Array.isArray(n)&&(n=p(n));for(var i in n)if("class"===i||"style"===i)e[i]=n[i];else{var o=e.attrs&&e.attrs.type,a=r||Bi.mustUseProp(t,o,i)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={});a[i]=n[i]}}else;return e}function Qe(e,t){var n=this._staticTrees[e];return n&&!t?Array.isArray(n)?J(n):z(n):(n=this._staticTrees[e]=this.$options.staticRenderFns[e].call(this._renderProxy),et(n,"__static__"+e,!1),n)}function Xe(e,t,n){return et(e,"__once__"+t+(n?"_"+n:""),!0),e}function et(e,t,n){if(Array.isArray(e))for(var r=0;r<e.length;r++)e[r]&&"string"!=typeof e[r]&&tt(e[r],t+"_"+r,n);else tt(e,t,n)}function tt(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function nt(e){e.$vnode=null,e._vnode=null,e._staticTrees=null;var t=e.$options._parentVnode,n=t&&t.context;e.$slots=ie(e.$options._renderChildren,n),e.$scopedSlots=no,e._c=function(t,n,r,i){return ze(e,t,n,r,i,!1)},e.$createElement=function(t,n,r,i){return ze(e,t,n,r,i,!0)}}function rt(n){n.prototype.$nextTick=function(e){return to(e,this)},n.prototype._render=function(){var e=this,t=e.$options,n=t.render,r=t.staticRenderFns,i=t._parentVnode;if(e._isMounted)for(var o in e.$slots)e.$slots[o]=J(e.$slots[o]);e.$scopedSlots=i&&i.data.scopedSlots||no,r&&!e._staticTrees&&(e._staticTrees=[]),e.$vnode=i;var a;try{a=n.call(e._renderProxy,e.$createElement)}catch(t){B(t,e,"render function"),a=e._vnode}return a instanceof mo||(a=_o()),a.parent=i,a},n.prototype._o=Xe,n.prototype._n=t,n.prototype._s=e,n.prototype._l=qe,n.prototype._t=We,n.prototype._q=h,n.prototype._i=m,n.prototype._m=Qe,n.prototype._f=Ze,n.prototype._k=Ge,n.prototype._b=Ye,n.prototype._v=V,n.prototype._e=_o,n.prototype._u=ae}function it(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}function ot(e){var t=e.$options.inject;if(t)for(var n=Array.isArray(t),r=n?t:eo?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++)for(var o=r[i],a=n?o:t[o],s=e;s;){if(s._provided&&a in s._provided){e[o]=s._provided[a];break}s=s.$parent}}function at(e){e.prototype._init=function(e){var t=this;t._uid=Mo++,t._isVue=!0,e&&e._isComponent?st(t,e):t.$options=M(ct(t.constructor),e||{},t),t._renderProxy=t,t._self=t,se(t),X(t),nt(t),ve(t,"beforeCreate"),ot(t),$e(t),it(t),ve(t,"created"),t.$options.el&&t.$mount(t.$options.el)}}function st(e,t){var n=e.$options=Object.create(e.constructor.options);n.parent=t.parent,n.propsData=t.propsData,n._parentVnode=t._parentVnode,n._parentListeners=t._parentListeners,n._renderChildren=t._renderChildren,n._componentTag=t._componentTag,n._parentElm=t._parentElm,n._refElm=t._refElm,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}function ct(e){var t=e.options;if(e.super){var n=ct(e.super),r=e.superOptions;if(n!==r){e.superOptions=n;var i=ut(e);i&&u(e.extendOptions,i),t=e.options=M(n,e.extendOptions),t.name&&(t.components[t.name]=e)}}return t}function ut(e){var t,n=e.options,r=e.sealedOptions;for(var i in n)n[i]!==r[i]&&(t||(t={}),t[i]=lt(n[i],r[i]));return t}function lt(e,t){if(Array.isArray(e)){var n=[];t=Array.isArray(t)?t:[t];for(var r=0;r<e.length;r++)t.indexOf(e[r])<0&&n.push(e[r]);return n}return e}function ft(e){this._init(e)}function pt(e){e.use=function(e){if(!e.installed){var t=c(arguments,1);return t.unshift(this),"function"==typeof e.install?e.install.apply(e,t):"function"==typeof e&&e.apply(null,t),e.installed=!0,this}}}function dt(e){e.mixin=function(e){this.options=M(this.options,e)}}function vt(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,r=n.cid,i=e._Ctor||(e._Ctor={});if(i[r])return i[r];var o=e.name||n.options.name,a=function(e){this._init(e)};return a.prototype=Object.create(n.prototype),a.prototype.constructor=a,a.cid=t++,a.options=M(n.options,e),a.super=n,a.options.props&&ht(a),a.options.computed&&mt(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,Bi._assetTypes.forEach(function(e){a[e]=n[e]}),o&&(a.options.components[o]=a),a.superOptions=n.options,a.extendOptions=e,a.sealedOptions=u({},a.options),i[r]=a,a}}function ht(e){var t=e.options.props;for(var n in t)be(e.prototype,"_props",n)}function mt(e){var t=e.options.computed;for(var n in t)ke(e.prototype,n,t[n])}function gt(e){Bi._assetTypes.forEach(function(t){e[t]=function(e,n){return n?("component"===t&&f(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}})}function yt(e){return e&&(e.Ctor.options.name||e.tag)}function _t(e,t){return"string"==typeof e?e.split(",").indexOf(t)>-1:e instanceof RegExp&&e.test(t)}function bt(e,t){for(var n in e){var r=e[n];if(r){var i=yt(r.componentOptions);i&&!t(i)&&($t(r),e[n]=null)}}}function $t(e){e&&(e.componentInstance._inactive||ve(e.componentInstance,"deactivated"),e.componentInstance.$destroy())}function wt(e){var t={};t.get=function(){return Bi},Object.defineProperty(e,"config",t),e.util={warn:io,extend:u,mergeOptions:M,defineReactive:O},e.set=S,e.delete=T,e.nextTick=to,e.options=Object.create(null),Bi._assetTypes.forEach(function(t){e.options[t+"s"]=Object.create(null)}),e.options._base=e,u(e.options.components,Fo),pt(e),dt(e),vt(e),gt(e)}function xt(e){for(var t=e.data,n=e,r=e;r.componentInstance;)r=r.componentInstance._vnode,r.data&&(t=Ct(r.data,t));for(;n=n.parent;)n.data&&(t=Ct(t,n.data));return kt(t)}function Ct(e,t){return{staticClass:At(e.staticClass,t.staticClass),class:e.class?[e.class,t.class]:t.class}}function kt(e){var t=e.class,n=e.staticClass;return n||t?At(n,Ot(t)):""}function At(e,t){return e?t?e+" "+t:e:t||""}function Ot(e){var t="";if(!e)return t;if("string"==typeof e)return e;if(Array.isArray(e)){for(var n,r=0,i=e.length;r<i;r++)e[r]&&(n=Ot(e[r]))&&(t+=n+" ");return t.slice(0,-1)}if(l(e)){for(var o in e)e[o]&&(t+=o+" ");return t.slice(0,-1)}return t}function St(e){return oa(e)?"svg":"math"===e?"math":void 0}function Tt(e){if(!zi)return!0;if(sa(e))return!1;if(e=e.toLowerCase(),null!=ca[e])return ca[e];var t=document.createElement(e);return e.indexOf("-")>-1?ca[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:ca[e]=/HTMLUnknownElement/.test(t.toString())}function Et(e){if("string"==typeof e){var t=document.querySelector(e);return t?t:document.createElement("div")}return e}function jt(e,t){var n=document.createElement(e);return"select"!==e?n:(t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)}function Nt(e,t){return document.createElementNS(ra[e],t)}function It(e){return document.createTextNode(e)}function Lt(e){return document.createComment(e)}function Dt(e,t,n){e.insertBefore(t,n)}function Mt(e,t){e.removeChild(t)}function Pt(e,t){e.appendChild(t)}function Rt(e){return e.parentNode}function Ft(e){return e.nextSibling}function Ht(e){return e.tagName}function Ut(e,t){e.textContent=t}function Bt(e,t,n){e.setAttribute(t,n)}function Vt(e,t){var n=e.data.ref;if(n){var i=e.context,o=e.componentInstance||e.elm,a=i.$refs;t?Array.isArray(a[n])?r(a[n],o):a[n]===o&&(a[n]=void 0):e.data.refInFor?Array.isArray(a[n])&&a[n].indexOf(o)<0?a[n].push(o):a[n]=[o]:a[n]=o}}function zt(e){return null==e}function Jt(e){return null!=e}function Kt(e,t){return e.key===t.key&&e.tag===t.tag&&e.isComment===t.isComment&&!e.data==!t.data}function qt(e,t,n){var r,i,o={};for(r=t;r<=n;++r)i=e[r].key,Jt(i)&&(o[i]=r);return o}function Wt(e){function t(e){return new mo(O.tagName(e).toLowerCase(),{},[],void 0,e)}function r(e,t){function n(){0===--n.listeners&&i(e)}return n.listeners=t,n}function i(e){var t=O.parentNode(e);t&&O.removeChild(t,e)}function a(e,t,n,r,i){if(e.isRootInsert=!i,!s(e,t,n,r)){var o=e.data,a=e.children,c=e.tag;Jt(c)?(e.elm=e.ns?O.createElementNS(e.ns,c):O.createElement(c,e),v(e),f(e,a,t),Jt(o)&&d(e,t),l(n,e.elm,r)):e.isComment?(e.elm=O.createComment(e.text),l(n,e.elm,r)):(e.elm=O.createTextNode(e.text),l(n,e.elm,r))}}function s(e,t,n,r){var i=e.data;if(Jt(i)){var o=Jt(e.componentInstance)&&i.keepAlive;if(Jt(i=i.hook)&&Jt(i=i.init)&&i(e,!1,n,r),Jt(e.componentInstance))return c(e,t),o&&u(e,t,n,r),!0}}function c(e,t){e.data.pendingInsert&&t.push.apply(t,e.data.pendingInsert),e.elm=e.componentInstance.$el,p(e)?(d(e,t),v(e)):(Vt(e),t.push(e))}function u(e,t,n,r){for(var i,o=e;o.componentInstance;)if(o=o.componentInstance._vnode,Jt(i=o.data)&&Jt(i=i.transition)){for(i=0;i<k.activate.length;++i)k.activate[i](fa,o);t.push(o);break}l(n,e.elm,r)}function l(e,t,n){e&&(n?O.insertBefore(e,t,n):O.appendChild(e,t))}function f(e,t,n){if(Array.isArray(t))for(var r=0;r<t.length;++r)a(t[r],n,e.elm,null,!0);else o(e.text)&&O.appendChild(e.elm,O.createTextNode(e.text))}function p(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return Jt(e.tag)}function d(e,t){for(var n=0;n<k.create.length;++n)k.create[n](fa,e);x=e.data.hook,Jt(x)&&(x.create&&x.create(fa,e),x.insert&&t.push(e))}function v(e){for(var t,n=e;n;)Jt(t=n.context)&&Jt(t=t.$options._scopeId)&&O.setAttribute(e.elm,t,""),n=n.parent;Jt(t=$o)&&t!==e.context&&Jt(t=t.$options._scopeId)&&O.setAttribute(e.elm,t,"")}function h(e,t,n,r,i,o){for(;r<=i;++r)a(n[r],o,e,t)}function m(e){var t,n,r=e.data;if(Jt(r))for(Jt(t=r.hook)&&Jt(t=t.destroy)&&t(e),t=0;t<k.destroy.length;++t)k.destroy[t](e);if(Jt(t=e.children))for(n=0;n<e.children.length;++n)m(e.children[n])}function g(e,t,n,r){for(;n<=r;++n){var o=t[n];Jt(o)&&(Jt(o.tag)?(y(o),m(o)):i(o.elm))}}function y(e,t){if(t||Jt(e.data)){var n=k.remove.length+1;for(t?t.listeners+=n:t=r(e.elm,n),Jt(x=e.componentInstance)&&Jt(x=x._vnode)&&Jt(x.data)&&y(x,t),x=0;x<k.remove.length;++x)k.remove[x](e,t);Jt(x=e.data.hook)&&Jt(x=x.remove)?x(e,t):t()}else i(e.elm)}function _(e,t,n,r,i){for(var o,s,c,u,l=0,f=0,p=t.length-1,d=t[0],v=t[p],m=n.length-1,y=n[0],_=n[m],$=!i;l<=p&&f<=m;)zt(d)?d=t[++l]:zt(v)?v=t[--p]:Kt(d,y)?(b(d,y,r),d=t[++l],y=n[++f]):Kt(v,_)?(b(v,_,r),v=t[--p],_=n[--m]):Kt(d,_)?(b(d,_,r),$&&O.insertBefore(e,d.elm,O.nextSibling(v.elm)),d=t[++l],_=n[--m]):Kt(v,y)?(b(v,y,r),$&&O.insertBefore(e,v.elm,d.elm),v=t[--p],y=n[++f]):(zt(o)&&(o=qt(t,l,p)),s=Jt(y.key)?o[y.key]:null,zt(s)?(a(y,r,e,d.elm),y=n[++f]):(c=t[s],Kt(c,y)?(b(c,y,r),t[s]=void 0,$&&O.insertBefore(e,y.elm,d.elm),y=n[++f]):(a(y,r,e,d.elm),y=n[++f])));l>p?(u=zt(n[m+1])?null:n[m+1].elm,h(e,u,n,f,m,r)):f>m&&g(e,t,l,p)}function b(e,t,n,r){if(e!==t){if(t.isStatic&&e.isStatic&&t.key===e.key&&(t.isCloned||t.isOnce))return t.elm=e.elm,void(t.componentInstance=e.componentInstance);var i,o=t.data,a=Jt(o);a&&Jt(i=o.hook)&&Jt(i=i.prepatch)&&i(e,t);var s=t.elm=e.elm,c=e.children,u=t.children;if(a&&p(t)){for(i=0;i<k.update.length;++i)k.update[i](e,t);Jt(i=o.hook)&&Jt(i=i.update)&&i(e,t)}zt(t.text)?Jt(c)&&Jt(u)?c!==u&&_(s,c,u,n,r):Jt(u)?(Jt(e.text)&&O.setTextContent(s,""),h(s,null,u,0,u.length-1,n)):Jt(c)?g(s,c,0,c.length-1):Jt(e.text)&&O.setTextContent(s,""):e.text!==t.text&&O.setTextContent(s,t.text),a&&Jt(i=o.hook)&&Jt(i=i.postpatch)&&i(e,t)}}function $(e,t,n){if(n&&e.parent)e.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}function w(e,t,n){t.elm=e;var r=t.tag,i=t.data,o=t.children;if(Jt(i)&&(Jt(x=i.hook)&&Jt(x=x.init)&&x(t,!0),Jt(x=t.componentInstance)))return c(t,n),!0;if(Jt(r)){if(Jt(o))if(e.hasChildNodes()){for(var a=!0,s=e.firstChild,u=0;u<o.length;u++){if(!s||!w(s,o[u],n)){a=!1;break}s=s.nextSibling}if(!a||s)return!1}else f(t,o,n);if(Jt(i))for(var l in i)if(!S(l)){d(t,n);break}}else e.data!==t.text&&(e.data=t.text);return!0}var x,C,k={},A=e.modules,O=e.nodeOps;for(x=0;x<pa.length;++x)for(k[pa[x]]=[],C=0;C<A.length;++C)void 0!==A[C][pa[x]]&&k[pa[x]].push(A[C][pa[x]]);var S=n("attrs,style,class,staticClass,staticStyle,key");return function(e,n,r,i,o,s){if(!n)return void(e&&m(e));var c=!1,u=[];if(e){var l=Jt(e.nodeType);if(!l&&Kt(e,n))b(e,n,u,i);else{if(l){if(1===e.nodeType&&e.hasAttribute("server-rendered")&&(e.removeAttribute("server-rendered"),r=!0),r&&w(e,n,u))return $(n,u,!0),e;e=t(e)}var f=e.elm,d=O.parentNode(f);if(a(n,u,f._leaveCb?null:d,O.nextSibling(f)),n.parent){for(var v=n.parent;v;)v.elm=n.elm,v=v.parent;if(p(n))for(var h=0;h<k.create.length;++h)k.create[h](fa,n.parent)}null!==d?g(d,[e],0,0):Jt(e.tag)&&m(e)}}else c=!0,a(n,u,o,s);return $(n,u,c),n.elm}}function Zt(e,t){(e.data.directives||t.data.directives)&&Gt(e,t)}function Gt(e,t){var n,r,i,o=e===fa,a=t===fa,s=Yt(e.data.directives,e.context),c=Yt(t.data.directives,t.context),u=[],l=[];for(n in c)r=s[n],i=c[n],r?(i.oldValue=r.value,Xt(i,"update",t,e),i.def&&i.def.componentUpdated&&l.push(i)):(Xt(i,"bind",t,e),i.def&&i.def.inserted&&u.push(i));if(u.length){var f=function(){for(var n=0;n<u.length;n++)Xt(u[n],"inserted",t,e)};o?W(t.data.hook||(t.data.hook={}),"insert",f):f()}if(l.length&&W(t.data.hook||(t.data.hook={}),"postpatch",function(){for(var n=0;n<l.length;n++)Xt(l[n],"componentUpdated",t,e)}),!o)for(n in s)c[n]||Xt(s[n],"unbind",e,e,a)}function Yt(e,t){var n=Object.create(null);if(!e)return n;var r,i;for(r=0;r<e.length;r++)i=e[r],i.modifiers||(i.modifiers=va),n[Qt(i)]=i,i.def=P(t.$options,"directives",i.name,!0);return n}function Qt(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function Xt(e,t,n,r,i){var o=e.def&&e.def[t];o&&o(n.elm,e,n,r,i)}function en(e,t){if(e.data.attrs||t.data.attrs){var n,r,i,o=t.elm,a=e.data.attrs||{},s=t.data.attrs||{};s.__ob__&&(s=t.data.attrs=u({},s));for(n in s)r=s[n],i=a[n],i!==r&&tn(o,n,r);qi&&s.value!==a.value&&tn(o,"value",s.value);for(n in a)null==s[n]&&(ea(n)?o.removeAttributeNS(Xo,ta(n)):Yo(n)||o.removeAttribute(n))}}function tn(e,t,n){Qo(t)?na(n)?e.removeAttribute(t):e.setAttribute(t,t):Yo(t)?e.setAttribute(t,na(n)||"false"===n?"false":"true"):ea(t)?na(n)?e.removeAttributeNS(Xo,ta(t)):e.setAttributeNS(Xo,t,n):na(n)?e.removeAttribute(t):e.setAttribute(t,n)}function nn(e,t){var n=t.elm,r=t.data,i=e.data;if(r.staticClass||r.class||i&&(i.staticClass||i.class)){var o=xt(t),a=n._transitionClasses;a&&(o=At(o,Ot(a))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}function rn(e){function t(){(a||(a=[])).push(e.slice(v,i).trim()),v=i+1}var n,r,i,o,a,s=!1,c=!1,u=!1,l=!1,f=0,p=0,d=0,v=0;for(i=0;i<e.length;i++)if(r=n,n=e.charCodeAt(i),s)39===n&&92!==r&&(s=!1);else if(c)34===n&&92!==r&&(c=!1);else if(u)96===n&&92!==r&&(u=!1);else if(l)47===n&&92!==r&&(l=!1);else if(124!==n||124===e.charCodeAt(i+1)||124===e.charCodeAt(i-1)||f||p||d){switch(n){case 34:c=!0;break;case 39:s=!0;break;case 96:u=!0;break;case 40:d++;break;case 41:d--;break;case 91:p++;break;case 93:p--;break;case 123:f++;break;case 125:f--}if(47===n){for(var h=i-1,m=void 0;h>=0&&(m=e.charAt(h)," "===m);h--);m&&ya.test(m)||(l=!0)}}else void 0===o?(v=i+1,o=e.slice(0,i).trim()):t();if(void 0===o?o=e.slice(0,i).trim():0!==v&&t(),a)for(i=0;i<a.length;i++)o=on(o,a[i]);return o}function on(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";
+var r=t.slice(0,n),i=t.slice(n+1);return'_f("'+r+'")('+e+","+i}function an(e){console.error("[Vue compiler]: "+e)}function sn(e,t){return e?e.map(function(e){return e[t]}).filter(function(e){return e}):[]}function cn(e,t,n){(e.props||(e.props=[])).push({name:t,value:n})}function un(e,t,n){(e.attrs||(e.attrs=[])).push({name:t,value:n})}function ln(e,t,n,r,i,o){(e.directives||(e.directives=[])).push({name:t,rawName:n,value:r,arg:i,modifiers:o})}function fn(e,t,n,r,i){r&&r.capture&&(delete r.capture,t="!"+t),r&&r.once&&(delete r.once,t="~"+t);var o;r&&r.native?(delete r.native,o=e.nativeEvents||(e.nativeEvents={})):o=e.events||(e.events={});var a={value:n,modifiers:r},s=o[t];Array.isArray(s)?i?s.unshift(a):s.push(a):s?o[t]=i?[a,s]:[s,a]:o[t]=a}function pn(e,t,n){var r=dn(e,":"+t)||dn(e,"v-bind:"+t);if(null!=r)return rn(r);if(n!==!1){var i=dn(e,t);if(null!=i)return JSON.stringify(i)}}function dn(e,t){var n;if(null!=(n=e.attrsMap[t]))for(var r=e.attrsList,i=0,o=r.length;i<o;i++)if(r[i].name===t){r.splice(i,1);break}return n}function vn(e,t,n){var r=n||{},i=r.number,o=r.trim,a="$$v",s=a;o&&(s="(typeof "+a+" === 'string'? "+a+".trim(): "+a+")"),i&&(s="_n("+s+")");var c=hn(t,s);e.model={value:"("+t+")",expression:'"'+t+'"',callback:"function ("+a+") {"+c+"}"}}function hn(e,t){var n=mn(e);return null===n.idx?e+"="+t:"var $$exp = "+n.exp+", $$idx = "+n.idx+";if (!Array.isArray($$exp)){"+e+"="+t+"}else{$$exp.splice($$idx, 1, "+t+")}"}function mn(e){if(Uo=e,Ho=Uo.length,Vo=zo=Jo=0,e.indexOf("[")<0||e.lastIndexOf("]")<Ho-1)return{exp:e,idx:null};for(;!yn();)Bo=gn(),_n(Bo)?$n(Bo):91===Bo&&bn(Bo);return{exp:e.substring(0,zo),idx:e.substring(zo+1,Jo)}}function gn(){return Uo.charCodeAt(++Vo)}function yn(){return Vo>=Ho}function _n(e){return 34===e||39===e}function bn(e){var t=1;for(zo=Vo;!yn();)if(e=gn(),_n(e))$n(e);else if(91===e&&t++,93===e&&t--,0===t){Jo=Vo;break}}function $n(e){for(var t=e;!yn()&&(e=gn(),e!==t););}function wn(e,t,n){Ko=n;var r=t.value,i=t.modifiers,o=e.tag,a=e.attrsMap.type;if("select"===o)kn(e,r,i);else if("input"===o&&"checkbox"===a)xn(e,r,i);else if("input"===o&&"radio"===a)Cn(e,r,i);else if("input"===o||"textarea"===o)An(e,r,i);else if(!Bi.isReservedTag(o))return vn(e,r,i),!1;return!0}function xn(e,t,n){var r=n&&n.number,i=pn(e,"value")||"null",o=pn(e,"true-value")||"true",a=pn(e,"false-value")||"false";cn(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===o?":("+t+")":":_q("+t+","+o+")")),fn(e,ba,"var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+o+"):("+a+");if(Array.isArray($$a)){var $$v="+(r?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$c){$$i<0&&("+t+"=$$a.concat($$v))}else{$$i>-1&&("+t+"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}}else{"+t+"=$$c}",null,!0)}function Cn(e,t,n){var r=n&&n.number,i=pn(e,"value")||"null";i=r?"_n("+i+")":i,cn(e,"checked","_q("+t+","+i+")"),fn(e,ba,hn(t,i),null,!0)}function kn(e,t,n){var r=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(r?"_n(val)":"val")+"})",o="$event.target.multiple ? $$selectedVal : $$selectedVal[0]",a="var $$selectedVal = "+i+";";a=a+" "+hn(t,o),fn(e,"change",a,null,!0)}function An(e,t,n){var r=e.attrsMap.type,i=n||{},o=i.lazy,a=i.number,s=i.trim,c=!o&&"range"!==r,u=o?"change":"range"===r?_a:"input",l="$event.target.value";s&&(l="$event.target.value.trim()"),a&&(l="_n("+l+")");var f=hn(t,l);c&&(f="if($event.target.composing)return;"+f),cn(e,"value","("+t+")"),fn(e,u,f,null,!0),(s||a||"number"===r)&&fn(e,"blur","$forceUpdate()")}function On(e){var t;e[_a]&&(t=Ki?"change":"input",e[t]=[].concat(e[_a],e[t]||[]),delete e[_a]),e[ba]&&(t=Yi?"click":"change",e[t]=[].concat(e[ba],e[t]||[]),delete e[ba])}function Sn(e,t,n,r){if(n){var i=t,o=qo;t=function(n){var a=1===arguments.length?i(n):i.apply(null,arguments);null!==a&&Tn(e,t,r,o)}}qo.addEventListener(e,t,r)}function Tn(e,t,n,r){(r||qo).removeEventListener(e,t,n)}function En(e,t){if(e.data.on||t.data.on){var n=t.data.on||{},r=e.data.on||{};qo=t.elm,On(n),q(n,r,Sn,Tn,t.context)}}function jn(e,t){if(e.data.domProps||t.data.domProps){var n,r,i=t.elm,o=e.data.domProps||{},a=t.data.domProps||{};a.__ob__&&(a=t.data.domProps=u({},a));for(n in o)null==a[n]&&(i[n]="");for(n in a)if(r=a[n],"textContent"!==n&&"innerHTML"!==n||(t.children&&(t.children.length=0),r!==o[n]))if("value"===n){i._value=r;var s=null==r?"":String(r);Nn(i,t,s)&&(i.value=s)}else i[n]=r}}function Nn(e,t,n){return!e.composing&&("option"===t.tag||In(e,n)||Ln(e,n))}function In(e,t){return document.activeElement!==e&&e.value!==t}function Ln(e,n){var r=e.value,i=e._vModifiers;return i&&i.number||"number"===e.type?t(r)!==t(n):i&&i.trim?r.trim()!==n.trim():r!==n}function Dn(e){var t=Mn(e.style);return e.staticStyle?u(e.staticStyle,t):t}function Mn(e){return Array.isArray(e)?p(e):"string"==typeof e?xa(e):e}function Pn(e,t){var n,r={};if(t)for(var i=e;i.componentInstance;)i=i.componentInstance._vnode,i.data&&(n=Dn(i.data))&&u(r,n);(n=Dn(e.data))&&u(r,n);for(var o=e;o=o.parent;)o.data&&(n=Dn(o.data))&&u(r,n);return r}function Rn(e,t){var n=t.data,r=e.data;if(n.staticStyle||n.style||r.staticStyle||r.style){var i,o,a=t.elm,s=e.data.staticStyle,c=e.data.style||{},l=s||c,f=Mn(t.data.style)||{};t.data.style=f.__ob__?u({},f):f;var p=Pn(t,!0);for(o in l)null==p[o]&&Aa(a,o,"");for(o in p)i=p[o],i!==l[o]&&Aa(a,o,null==i?"":i)}}function Fn(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(/\s+/).forEach(function(t){return e.classList.add(t)}):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function Hn(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(/\s+/).forEach(function(t){return e.classList.remove(t)}):e.classList.remove(t);else{for(var n=" "+(e.getAttribute("class")||"")+" ",r=" "+t+" ";n.indexOf(r)>=0;)n=n.replace(r," ");e.setAttribute("class",n.trim())}}function Un(e){if(e){if("object"==typeof e){var t={};return e.css!==!1&&u(t,Ea(e.name||"v")),u(t,e),t}return"string"==typeof e?Ea(e):void 0}}function Bn(e){Ra(function(){Ra(e)})}function Vn(e,t){(e._transitionClasses||(e._transitionClasses=[])).push(t),Fn(e,t)}function zn(e,t){e._transitionClasses&&r(e._transitionClasses,t),Hn(e,t)}function Jn(e,t,n){var r=Kn(e,t),i=r.type,o=r.timeout,a=r.propCount;if(!i)return n();var s=i===Na?Da:Pa,c=0,u=function(){e.removeEventListener(s,l),n()},l=function(t){t.target===e&&++c>=a&&u()};setTimeout(function(){c<a&&u()},o+1),e.addEventListener(s,l)}function Kn(e,t){var n,r=window.getComputedStyle(e),i=r[La+"Delay"].split(", "),o=r[La+"Duration"].split(", "),a=qn(i,o),s=r[Ma+"Delay"].split(", "),c=r[Ma+"Duration"].split(", "),u=qn(s,c),l=0,f=0;t===Na?a>0&&(n=Na,l=a,f=o.length):t===Ia?u>0&&(n=Ia,l=u,f=c.length):(l=Math.max(a,u),n=l>0?a>u?Na:Ia:null,f=n?n===Na?o.length:c.length:0);var p=n===Na&&Fa.test(r[La+"Property"]);return{type:n,timeout:l,propCount:f,hasTransform:p}}function qn(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map(function(t,n){return Wn(t)+Wn(e[n])}))}function Wn(e){return 1e3*Number(e.slice(0,-1))}function Zn(e,n){var r=e.elm;r._leaveCb&&(r._leaveCb.cancelled=!0,r._leaveCb());var i=Un(e.data.transition);if(i&&!r._enterCb&&1===r.nodeType){for(var o=i.css,a=i.type,s=i.enterClass,c=i.enterToClass,u=i.enterActiveClass,f=i.appearClass,p=i.appearToClass,d=i.appearActiveClass,v=i.beforeEnter,h=i.enter,m=i.afterEnter,y=i.enterCancelled,_=i.beforeAppear,b=i.appear,$=i.afterAppear,w=i.appearCancelled,x=i.duration,C=$o,k=$o.$vnode;k&&k.parent;)k=k.parent,C=k.context;var A=!C._isMounted||!e.isRootInsert;if(!A||b||""===b){var O=A&&f?f:s,S=A&&d?d:u,T=A&&p?p:c,E=A?_||v:v,j=A&&"function"==typeof b?b:h,N=A?$||m:m,I=A?w||y:y,L=t(l(x)?x.enter:x),D=o!==!1&&!qi,M=Qn(j),P=r._enterCb=g(function(){D&&(zn(r,T),zn(r,S)),P.cancelled?(D&&zn(r,O),I&&I(r)):N&&N(r),r._enterCb=null});e.data.show||W(e.data.hook||(e.data.hook={}),"insert",function(){var t=r.parentNode,n=t&&t._pending&&t._pending[e.key];n&&n.tag===e.tag&&n.elm._leaveCb&&n.elm._leaveCb(),j&&j(r,P)}),E&&E(r),D&&(Vn(r,O),Vn(r,S),Bn(function(){Vn(r,T),zn(r,O),P.cancelled||M||(Yn(L)?setTimeout(P,L):Jn(r,a,P))})),e.data.show&&(n&&n(),j&&j(r,P)),D||M||P()}}}function Gn(e,n){function r(){w.cancelled||(e.data.show||((i.parentNode._pending||(i.parentNode._pending={}))[e.key]=e),p&&p(i),_&&(Vn(i,c),Vn(i,f),Bn(function(){Vn(i,u),zn(i,c),w.cancelled||b||(Yn($)?setTimeout(w,$):Jn(i,s,w))})),d&&d(i,w),_||b||w())}var i=e.elm;i._enterCb&&(i._enterCb.cancelled=!0,i._enterCb());var o=Un(e.data.transition);if(!o)return n();if(!i._leaveCb&&1===i.nodeType){var a=o.css,s=o.type,c=o.leaveClass,u=o.leaveToClass,f=o.leaveActiveClass,p=o.beforeLeave,d=o.leave,v=o.afterLeave,h=o.leaveCancelled,m=o.delayLeave,y=o.duration,_=a!==!1&&!qi,b=Qn(d),$=t(l(y)?y.leave:y),w=i._leaveCb=g(function(){i.parentNode&&i.parentNode._pending&&(i.parentNode._pending[e.key]=null),_&&(zn(i,u),zn(i,f)),w.cancelled?(_&&zn(i,c),h&&h(i)):(n(),v&&v(i)),i._leaveCb=null});m?m(r):r()}}function Yn(e){return"number"==typeof e&&!isNaN(e)}function Qn(e){if(!e)return!1;var t=e.fns;return t?Qn(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function Xn(e,t){t.data.show||Zn(t)}function er(e,t,n){var r=t.value,i=e.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=e.options.length;s<c;s++)if(a=e.options[s],i)o=m(r,nr(a))>-1,a.selected!==o&&(a.selected=o);else if(h(nr(a),r))return void(e.selectedIndex!==s&&(e.selectedIndex=s));i||(e.selectedIndex=-1)}}function tr(e,t){for(var n=0,r=t.length;n<r;n++)if(h(nr(t[n]),e))return!1;return!0}function nr(e){return"_value"in e?e._value:e.value}function rr(e){e.target.composing=!0}function ir(e){e.target.composing=!1,or(e.target,"input")}function or(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function ar(e){return!e.componentInstance||e.data&&e.data.transition?e:ar(e.componentInstance._vnode)}function sr(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?sr(Q(t.children)):e}function cr(e){var t={},n=e.$options;for(var r in n.propsData)t[r]=e[r];var i=n._parentListeners;for(var o in i)t[Li(o)]=i[o];return t}function ur(e,t){return/\d-keep-alive$/.test(t.tag)?e("keep-alive"):null}function lr(e){for(;e=e.parent;)if(e.data.transition)return!0}function fr(e,t){return t.key===e.key&&t.tag===e.tag}function pr(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function dr(e){e.data.newPos=e.elm.getBoundingClientRect()}function vr(e){var t=e.data.pos,n=e.data.newPos,r=t.left-n.left,i=t.top-n.top;if(r||i){e.data.moved=!0;var o=e.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+i+"px)",o.transitionDuration="0s"}}function hr(e,t){var n=document.createElement("div");return n.innerHTML='<div a="'+e+'">',n.innerHTML.indexOf(t)>0}function mr(e){return Qa=Qa||document.createElement("div"),Qa.innerHTML=e,Qa.textContent}function gr(e,t){var n=t?Rs:Ps;return e.replace(n,function(e){return Ms[e]})}function yr(e,t){function n(t){f+=t,e=e.substring(t)}function r(){var t=e.match(us);if(t){var r={tagName:t[1],attrs:[],start:f};n(t[0].length);for(var i,o;!(i=e.match(ls))&&(o=e.match(as));)n(o[0].length),r.attrs.push(o);if(i)return r.unarySlash=i[1],n(i[0].length),r.end=f,r}}function i(e){var n=e.tagName,r=e.unarySlash;u&&("p"===s&&ns(n)&&o(s),ts(n)&&s===n&&o(n));for(var i=l(n)||"html"===n&&"head"===s||!!r,a=e.attrs.length,f=new Array(a),p=0;p<a;p++){var d=e.attrs[p];hs&&d[0].indexOf('""')===-1&&(""===d[3]&&delete d[3],""===d[4]&&delete d[4],""===d[5]&&delete d[5]);var v=d[3]||d[4]||d[5]||"";f[p]={name:d[1],value:gr(v,t.shouldDecodeNewlines)}}i||(c.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:f}),s=n),t.start&&t.start(n,f,i,e.start,e.end)}function o(e,n,r){var i,o;if(null==n&&(n=f),null==r&&(r=f),e&&(o=e.toLowerCase()),e)for(i=c.length-1;i>=0&&c[i].lowerCasedTag!==o;i--);else i=0;if(i>=0){for(var a=c.length-1;a>=i;a--)t.end&&t.end(c[a].tag,n,r);c.length=i,s=i&&c[i-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,r):"p"===o&&(t.start&&t.start(e,[],!1,n,r),t.end&&t.end(e,n,r))}for(var a,s,c=[],u=t.expectHTML,l=t.isUnaryTag||Hi,f=0;e;){if(a=e,s&&Ls(s)){var p=s.toLowerCase(),d=Ds[p]||(Ds[p]=new RegExp("([\\s\\S]*?)(</"+p+"[^>]*>)","i")),v=0,h=e.replace(d,function(e,n,r){return v=r.length,"script"!==p&&"style"!==p&&"noscript"!==p&&(n=n.replace(/<!--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),t.chars&&t.chars(n),""});f+=e.length-h.length,e=h,o(p,f-v,f)}else{var m=e.indexOf("<");if(0===m){if(ds.test(e)){var g=e.indexOf("-->");if(g>=0){n(g+3);continue}}if(vs.test(e)){var y=e.indexOf("]>");if(y>=0){n(y+2);continue}}var _=e.match(ps);if(_){n(_[0].length);continue}var b=e.match(fs);if(b){var $=f;n(b[0].length),o(b[1],$,f);continue}var w=r();if(w){i(w);continue}}var x=void 0,C=void 0,k=void 0;if(m>=0){for(C=e.slice(m);!(fs.test(C)||us.test(C)||ds.test(C)||vs.test(C)||(k=C.indexOf("<",1),k<0));)m+=k,C=e.slice(m);x=e.substring(0,m),n(m)}m<0&&(x=e,e=""),t.chars&&x&&t.chars(x)}if(e===a){t.chars&&t.chars(e);break}}o()}function _r(e,t){var n=t?Us(t):Fs;if(n.test(e)){for(var r,i,o=[],a=n.lastIndex=0;r=n.exec(e);){i=r.index,i>a&&o.push(JSON.stringify(e.slice(a,i)));var s=rn(r[1].trim());o.push("_s("+s+")"),a=i+r[0].length}return a<e.length&&o.push(JSON.stringify(e.slice(a))),o.join("+")}}function br(e,t){function n(e){e.pre&&(s=!1),_s(e.tag)&&(c=!1)}ms=t.warn||an,gs=t.getTagNamespace||Hi,ys=t.mustUseProp||Hi,_s=t.isPreTag||Hi,bs=sn(t.modules,"preTransformNode"),$s=sn(t.modules,"transformNode"),ws=sn(t.modules,"postTransformNode"),xs=t.delimiters;var r,i,o=[],a=t.preserveWhitespace!==!1,s=!1,c=!1;return yr(e,{warn:ms,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,shouldDecodeNewlines:t.shouldDecodeNewlines,start:function(e,a,u){function l(e){}var f=i&&i.ns||gs(e);Ki&&"svg"===f&&(a=Rr(a));var p={type:1,tag:e,attrsList:a,attrsMap:Mr(a),parent:i,children:[]};f&&(p.ns=f),Pr(p)&&!Qi()&&(p.forbidden=!0);for(var d=0;d<bs.length;d++)bs[d](p,t);if(s||($r(p),p.pre&&(s=!0)),_s(p.tag)&&(c=!0),s)wr(p);else{kr(p),Ar(p),Er(p),xr(p),p.plain=!p.key&&!a.length,Cr(p),jr(p),Nr(p);for(var v=0;v<$s.length;v++)$s[v](p,t);Ir(p)}if(r?o.length||r.if&&(p.elseif||p.else)&&(l(p),Tr(r,{exp:p.elseif,block:p})):(r=p,l(r)),i&&!p.forbidden)if(p.elseif||p.else)Or(p,i);else if(p.slotScope){i.plain=!1;var h=p.slotTarget||'"default"';(i.scopedSlots||(i.scopedSlots={}))[h]=p}else i.children.push(p),p.parent=i;u?n(p):(i=p,o.push(p));for(var m=0;m<ws.length;m++)ws[m](p,t)},end:function(){var e=o[o.length-1],t=e.children[e.children.length-1];t&&3===t.type&&" "===t.text&&!c&&e.children.pop(),o.length-=1,i=o[o.length-1],n(e)},chars:function(e){if(i&&(!Ki||"textarea"!==i.tag||i.attrsMap.placeholder!==e)){var t=i.children;if(e=c||e.trim()?Zs(e):a&&t.length?" ":""){var n;!s&&" "!==e&&(n=_r(e,xs))?t.push({type:2,expression:n,text:e}):" "===e&&t.length&&" "===t[t.length-1].text||t.push({type:3,text:e})}}}}),r}function $r(e){null!=dn(e,"v-pre")&&(e.pre=!0)}function wr(e){var t=e.attrsList.length;if(t)for(var n=e.attrs=new Array(t),r=0;r<t;r++)n[r]={name:e.attrsList[r].name,value:JSON.stringify(e.attrsList[r].value)};else e.pre||(e.plain=!0)}function xr(e){var t=pn(e,"key");t&&(e.key=t)}function Cr(e){var t=pn(e,"ref");t&&(e.ref=t,e.refInFor=Lr(e))}function kr(e){var t;if(t=dn(e,"v-for")){var n=t.match(zs);if(!n)return;e.for=n[2].trim();var r=n[1].trim(),i=r.match(Js);i?(e.alias=i[1].trim(),e.iterator1=i[2].trim(),i[3]&&(e.iterator2=i[3].trim())):e.alias=r}}function Ar(e){var t=dn(e,"v-if");if(t)e.if=t,Tr(e,{exp:t,block:e});else{null!=dn(e,"v-else")&&(e.else=!0);var n=dn(e,"v-else-if");n&&(e.elseif=n)}}function Or(e,t){var n=Sr(t.children);n&&n.if&&Tr(n,{exp:e.elseif,block:e})}function Sr(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}function Tr(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function Er(e){var t=dn(e,"v-once");null!=t&&(e.once=!0)}function jr(e){if("slot"===e.tag)e.slotName=pn(e,"name");else{var t=pn(e,"slot");t&&(e.slotTarget='""'===t?'"default"':t),"template"===e.tag&&(e.slotScope=dn(e,"scope"))}}function Nr(e){var t;(t=pn(e,"is"))&&(e.component=t),null!=dn(e,"inline-template")&&(e.inlineTemplate=!0)}function Ir(e){var t,n,r,i,o,a,s,c,u=e.attrsList;for(t=0,n=u.length;t<n;t++)if(r=i=u[t].name,o=u[t].value,Bs.test(r))if(e.hasBindings=!0,s=Dr(r),s&&(r=r.replace(Ws,"")),Ks.test(r))r=r.replace(Ks,""),o=rn(o),c=!1,s&&(s.prop&&(c=!0,r=Li(r),"innerHtml"===r&&(r="innerHTML")),s.camel&&(r=Li(r))),c||ys(e.tag,e.attrsMap.type,r)?cn(e,r,o):un(e,r,o);else if(Vs.test(r))r=r.replace(Vs,""),fn(e,r,o,s);else{r=r.replace(Bs,"");var l=r.match(qs);l&&(a=l[1])&&(r=r.slice(0,-(a.length+1))),ln(e,r,i,o,a,s)}else un(e,r,JSON.stringify(o))}function Lr(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}function Dr(e){var t=e.match(Ws);if(t){var n={};return t.forEach(function(e){n[e.slice(1)]=!0}),n}}function Mr(e){for(var t={},n=0,r=e.length;n<r;n++)t[e[n].name]=e[n].value;return t}function Pr(e){return"style"===e.tag||"script"===e.tag&&(!e.attrsMap.type||"text/javascript"===e.attrsMap.type)}function Rr(e){for(var t=[],n=0;n<e.length;n++){var r=e[n];Gs.test(r.name)||(r.name=r.name.replace(Ys,""),t.push(r))}return t}function Fr(e,t){e&&(Cs=Qs(t.staticKeys||""),ks=t.isReservedTag||Hi,Ur(e),Br(e,!1))}function Hr(e){return n("type,tag,attrsList,attrsMap,plain,parent,children,attrs"+(e?","+e:""))}function Ur(e){if(e.static=zr(e),1===e.type){if(!ks(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var r=e.children[t];Ur(r),r.static||(e.static=!1)}}}function Br(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,r=e.children.length;n<r;n++)Br(e.children[n],t||!!e.for);e.ifConditions&&Vr(e.ifConditions,t)}}function Vr(e,t){for(var n=1,r=e.length;n<r;n++)Br(e[n].block,t)}function zr(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||ji(e.tag)||!ks(e.tag)||Jr(e)||!Object.keys(e).every(Cs))))}function Jr(e){for(;e.parent;){if(e=e.parent,"template"!==e.tag)return!1;if(e.for)return!0}return!1}function Kr(e,t){var n=t?"nativeOn:{":"on:{";for(var r in e)n+='"'+r+'":'+qr(r,e[r])+",";return n.slice(0,-1)+"}"}function qr(e,t){if(!t)return"function(){}";if(Array.isArray(t))return"["+t.map(function(t){return qr(e,t)}).join(",")+"]";var n=ec.test(t.value),r=Xs.test(t.value);if(t.modifiers){var i="",o=[];for(var a in t.modifiers)rc[a]?(i+=rc[a],tc[a]&&o.push(a)):o.push(a);o.length&&(i+=Wr(o));var s=n?t.value+"($event)":r?"("+t.value+")($event)":t.value;return"function($event){"+i+s+"}"}return n||r?t.value:"function($event){"+t.value+"}"}function Wr(e){return"if(!('button' in $event)&&"+e.map(Zr).join("&&")+")return null;"}function Zr(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=tc[e];return"_k($event.keyCode,"+JSON.stringify(e)+(n?","+JSON.stringify(n):"")+")"}function Gr(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+(t.modifiers&&t.modifiers.prop?",true":"")+")"}}function Yr(e,t){var n=js,r=js=[],i=Ns;Ns=0,Is=t,As=t.warn||an,Os=sn(t.modules,"transformCode"),Ss=sn(t.modules,"genData"),Ts=t.directives||{},Es=t.isReservedTag||Hi;var o=e?Qr(e):'_c("div")';return js=n,Ns=i,{render:"with(this){return "+o+"}",staticRenderFns:r}}function Qr(e){if(e.staticRoot&&!e.staticProcessed)return Xr(e);if(e.once&&!e.onceProcessed)return ei(e);if(e.for&&!e.forProcessed)return ri(e);if(e.if&&!e.ifProcessed)return ti(e);if("template"!==e.tag||e.slotTarget){if("slot"===e.tag)return hi(e);var t;if(e.component)t=mi(e.component,e);else{var n=e.plain?void 0:ii(e),r=e.inlineTemplate?null:ui(e,!0);t="_c('"+e.tag+"'"+(n?","+n:"")+(r?","+r:"")+")"}for(var i=0;i<Os.length;i++)t=Os[i](e,t);return t}return ui(e)||"void 0"}function Xr(e){return e.staticProcessed=!0,js.push("with(this){return "+Qr(e)+"}"),"_m("+(js.length-1)+(e.staticInFor?",true":"")+")"}function ei(e){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return ti(e);if(e.staticInFor){for(var t="",n=e.parent;n;){if(n.for){t=n.key;break}n=n.parent}return t?"_o("+Qr(e)+","+Ns++ +(t?","+t:"")+")":Qr(e)}return Xr(e)}function ti(e){return e.ifProcessed=!0,ni(e.ifConditions.slice())}function ni(e){function t(e){return e.once?ei(e):Qr(e)}if(!e.length)return"_e()";var n=e.shift();return n.exp?"("+n.exp+")?"+t(n.block)+":"+ni(e):""+t(n.block)}function ri(e){var t=e.for,n=e.alias,r=e.iterator1?","+e.iterator1:"",i=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,"_l(("+t+"),function("+n+r+i+"){return "+Qr(e)+"})"}function ii(e){var t="{",n=oi(e);n&&(t+=n+","),e.key&&(t+="key:"+e.key+","),e.ref&&(t+="ref:"+e.ref+","),e.refInFor&&(t+="refInFor:true,"),e.pre&&(t+="pre:true,"),e.component&&(t+='tag:"'+e.tag+'",');for(var r=0;r<Ss.length;r++)t+=Ss[r](e);if(e.attrs&&(t+="attrs:{"+gi(e.attrs)+"},"),e.props&&(t+="domProps:{"+gi(e.props)+"},"),e.events&&(t+=Kr(e.events)+","),e.nativeEvents&&(t+=Kr(e.nativeEvents,!0)+","),e.slotTarget&&(t+="slot:"+e.slotTarget+","),e.scopedSlots&&(t+=si(e.scopedSlots)+","),e.model&&(t+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var i=ai(e);i&&(t+=i+",")}return t=t.replace(/,$/,"")+"}",e.wrapData&&(t=e.wrapData(t)),t}function oi(e){var t=e.directives;if(t){var n,r,i,o,a="directives:[",s=!1;for(n=0,r=t.length;n<r;n++){i=t[n],o=!0;var c=Ts[i.name]||ic[i.name];c&&(o=!!c(e,i,As)),o&&(s=!0,a+='{name:"'+i.name+'",rawName:"'+i.rawName+'"'+(i.value?",value:("+i.value+"),expression:"+JSON.stringify(i.value):"")+(i.arg?',arg:"'+i.arg+'"':"")+(i.modifiers?",modifiers:"+JSON.stringify(i.modifiers):"")+"},")}return s?a.slice(0,-1)+"]":void 0}}function ai(e){var t=e.children[0];if(1===t.type){var n=Yr(t,Is);return"inlineTemplate:{render:function(){"+n.render+"},staticRenderFns:["+n.staticRenderFns.map(function(e){return"function(){"+e+"}"}).join(",")+"]}"}}function si(e){return"scopedSlots:_u(["+Object.keys(e).map(function(t){return ci(t,e[t])}).join(",")+"])"}function ci(e,t){return"["+e+",function("+String(t.attrsMap.scope)+"){return "+("template"===t.tag?ui(t)||"void 0":Qr(t))+"}]"}function ui(e,t){var n=e.children;if(n.length){var r=n[0];if(1===n.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag)return Qr(r);var i=t?li(n):0;return"["+n.map(di).join(",")+"]"+(i?","+i:"")}}function li(e){for(var t=0,n=0;n<e.length;n++){var r=e[n];if(1===r.type){if(fi(r)||r.ifConditions&&r.ifConditions.some(function(e){return fi(e.block)})){t=2;break}(pi(r)||r.ifConditions&&r.ifConditions.some(function(e){return pi(e.block)}))&&(t=1)}}return t}function fi(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function pi(e){return!Es(e.tag)}function di(e){return 1===e.type?Qr(e):vi(e)}function vi(e){return"_v("+(2===e.type?e.expression:yi(JSON.stringify(e.text)))+")"}function hi(e){var t=e.slotName||'"default"',n=ui(e),r="_t("+t+(n?","+n:""),i=e.attrs&&"{"+e.attrs.map(function(e){return Li(e.name)+":"+e.value}).join(",")+"}",o=e.attrsMap["v-bind"];return!i&&!o||n||(r+=",null"),i&&(r+=","+i),o&&(r+=(i?"":",null")+","+o),r+")"}function mi(e,t){var n=t.inlineTemplate?null:ui(t,!0);return"_c("+e+","+ii(t)+(n?","+n:"")+")"}function gi(e){for(var t="",n=0;n<e.length;n++){var r=e[n];t+='"'+r.name+'":'+yi(r.value)+","}return t.slice(0,-1)}function yi(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function _i(e,t){var n=br(e.trim(),t);Fr(n,t);var r=Yr(n,t);return{ast:n,render:r.render,staticRenderFns:r.staticRenderFns}}function bi(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),d}}function $i(e){function t(t,n){var r=Object.create(e),i=[],o=[];if(r.warn=function(e,t){(t?o:i).push(e)},n){n.modules&&(r.modules=(e.modules||[]).concat(n.modules)),n.directives&&(r.directives=u(Object.create(e.directives),n.directives));for(var a in n)"modules"!==a&&"directives"!==a&&(r[a]=n[a])}var s=_i(t,r);return s.errors=i,s.tips=o,s}function n(e,n,i){n=n||{};var o=n.delimiters?String(n.delimiters)+e:e;if(r[o])return r[o];var a=t(e,n),s={},c=[];s.render=bi(a.render,c);var u=a.staticRenderFns.length;s.staticRenderFns=new Array(u);for(var l=0;l<u;l++)s.staticRenderFns[l]=bi(a.staticRenderFns[l],c);return r[o]=s}var r=Object.create(null);return{compile:t,compileToFunctions:n}}function wi(e,t){var n=(t.warn||an,dn(e,"class"));n&&(e.staticClass=JSON.stringify(n));var r=pn(e,"class",!1);r&&(e.classBinding=r)}function xi(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}function Ci(e,t){var n=(t.warn||an,dn(e,"style"));n&&(e.staticStyle=JSON.stringify(xa(n)));var r=pn(e,"style",!1);r&&(e.styleBinding=r)}function ki(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}function Ai(e,t){t.value&&cn(e,"textContent","_s("+t.value+")")}function Oi(e,t){t.value&&cn(e,"innerHTML","_s("+t.value+")")}function Si(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}var Ti,Ei,ji=n("slot,component",!0),Ni=Object.prototype.hasOwnProperty,Ii=/-(\w)/g,Li=a(function(e){return e.replace(Ii,function(e,t){return t?t.toUpperCase():""})}),Di=a(function(e){return e.charAt(0).toUpperCase()+e.slice(1)}),Mi=/([^-])([A-Z])/g,Pi=a(function(e){return e.replace(Mi,"$1-$2").replace(Mi,"$1-$2").toLowerCase()}),Ri=Object.prototype.toString,Fi="[object Object]",Hi=function(){return!1},Ui=function(e){return e},Bi={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:Hi,isUnknownElement:Hi,getTagNamespace:d,parsePlatformTagName:Ui,mustUseProp:Hi,_assetTypes:["component","directive","filter"],_lifecycleHooks:["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated"],_maxUpdateCount:100},Vi="__proto__"in{},zi="undefined"!=typeof window,Ji=zi&&window.navigator.userAgent.toLowerCase(),Ki=Ji&&/msie|trident/.test(Ji),qi=Ji&&Ji.indexOf("msie 9.0")>0,Wi=Ji&&Ji.indexOf("edge/")>0,Zi=Ji&&Ji.indexOf("android")>0,Gi=Ji&&/iphone|ipad|ipod|ios/.test(Ji),Yi=Ji&&/chrome\/\d+/.test(Ji)&&!Wi,Qi=function(){return void 0===Ti&&(Ti=!zi&&"undefined"!=typeof global&&"server"===global.process.env.VUE_ENV),Ti},Xi=zi&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__,eo="undefined"!=typeof Symbol&&y(Symbol)&&"undefined"!=typeof Reflect&&y(Reflect.ownKeys),to=function(){function e(){r=!1;var e=n.slice(0);n.length=0;for(var t=0;t<e.length;t++)e[t]()}var t,n=[],r=!1;if("undefined"!=typeof Promise&&y(Promise)){var i=Promise.resolve(),o=function(e){console.error(e)};t=function(){i.then(e).catch(o),Gi&&setTimeout(d)}}else if("undefined"==typeof MutationObserver||!y(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())t=function(){setTimeout(e,0)};else{var a=1,s=new MutationObserver(e),c=document.createTextNode(String(a));s.observe(c,{characterData:!0}),t=function(){a=(a+1)%2,c.data=String(a)}}return function(e,i){var o;if(n.push(function(){e&&e.call(i),o&&o(i)}),r||(r=!0,t()),!e&&"undefined"!=typeof Promise)return new Promise(function(e){o=e})}}();Ei="undefined"!=typeof Set&&y(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return this.set[e]===!0},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var no=Object.freeze({}),ro=/[^\w.$]/,io=d,oo=0,ao=function(){this.id=oo++,this.subs=[]};ao.prototype.addSub=function(e){this.subs.push(e)},ao.prototype.removeSub=function(e){r(this.subs,e)},ao.prototype.depend=function(){ao.target&&ao.target.addDep(this)},ao.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},ao.target=null;var so=[],co=Array.prototype,uo=Object.create(co);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(e){var t=co[e];b(uo,e,function(){for(var n=arguments,r=arguments.length,i=new Array(r);r--;)i[r]=n[r];var o,a=t.apply(this,i),s=this.__ob__;switch(e){case"push":o=i;break;case"unshift":o=i;break;case"splice":o=i.slice(2)}return o&&s.observeArray(o),s.dep.notify(),a})});var lo=Object.getOwnPropertyNames(uo),fo={shouldConvert:!0,isSettingProps:!1},po=function(e){if(this.value=e,this.dep=new ao,this.vmCount=0,b(e,"__ob__",this),Array.isArray(e)){var t=Vi?C:k;t(e,uo,lo),this.observeArray(e)}else this.walk(e)};po.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)O(e,t[n],e[t[n]])},po.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)A(e[t])};var vo=Bi.optionMergeStrategies;vo.data=function(e,t,n){return n?e||t?function(){var r="function"==typeof t?t.call(n):t,i="function"==typeof e?e.call(n):void 0;return r?j(r,i):i}:void 0:t?"function"!=typeof t?e:e?function(){return j(t.call(this),e.call(this))}:t:e},Bi._lifecycleHooks.forEach(function(e){vo[e]=N}),Bi._assetTypes.forEach(function(e){vo[e+"s"]=I}),vo.watch=function(e,t){if(!t)return Object.create(e||null);if(!e)return t;var n={};u(n,e);for(var r in t){var i=n[r],o=t[r];i&&!Array.isArray(i)&&(i=[i]),n[r]=i?i.concat(o):[o]}return n},vo.props=vo.methods=vo.computed=function(e,t){if(!t)return Object.create(e||null);if(!e)return t;var n=Object.create(null);return u(n,e),u(n,t),n};var ho=function(e,t){return void 0===t?e:t},mo=function(e,t,n,r,i,o,a){this.tag=e,this.data=t,this.children=n,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.functionalContext=void 0,this.key=t&&t.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1},go={child:{}};go.child.get=function(){return this.componentInstance},Object.defineProperties(mo.prototype,go);var yo,_o=function(){var e=new mo;return e.text="",e.isComment=!0,e},bo=a(function(e){var t="~"===e.charAt(0);e=t?e.slice(1):e;var n="!"===e.charAt(0);return e=n?e.slice(1):e,{name:e,once:t,capture:n}}),$o=null,wo=[],xo={},Co=!1,ko=!1,Ao=0,Oo=0,So=function(e,t,n,r){this.vm=e,e._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++Oo,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new Ei,this.newDepIds=new Ei,this.expression="","function"==typeof t?this.getter=t:(this.getter=$(t),this.getter||(this.getter=function(){})),this.value=this.lazy?void 0:this.get()};So.prototype.get=function(){w(this);var e,t=this.vm;if(this.user)try{e=this.getter.call(t,t)}catch(e){B(e,t,'getter for watcher "'+this.expression+'"')}else e=this.getter.call(t,t);return this.deep&&ye(e),x(),this.cleanupDeps(),e},So.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},So.prototype.cleanupDeps=function(){for(var e=this,t=this.deps.length;t--;){var n=e.deps[t];e.newDepIds.has(n.id)||n.removeSub(e)}var r=this.depIds;this.depIds=this.newDepIds,this.newDepIds=r,this.newDepIds.clear(),r=this.deps,this.deps=this.newDeps,this.newDeps=r,this.newDeps.length=0},So.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ge(this)},So.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||l(e)||this.deep){var t=this.value;if(this.value=e,this.user)try{this.cb.call(this.vm,e,t)}catch(e){B(e,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,e,t)}}},So.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},So.prototype.depend=function(){for(var e=this,t=this.deps.length;t--;)e.deps[t].depend()},So.prototype.teardown=function(){var e=this;if(this.active){this.vm._isBeingDestroyed||r(this.vm._watchers,this);for(var t=this.deps.length;t--;)e.deps[t].removeSub(e);
+this.active=!1}};var To=new Ei,Eo={enumerable:!0,configurable:!0,get:d,set:d},jo={lazy:!0},No={init:Le,prepatch:De,insert:Me,destroy:Pe},Io=Object.keys(No),Lo=1,Do=2,Mo=0;at(ft),Ee(ft),re(ft),ce(ft),rt(ft);var Po=[String,RegExp],Ro={name:"keep-alive",abstract:!0,props:{include:Po,exclude:Po},created:function(){this.cache=Object.create(null)},destroyed:function(){var e=this;for(var t in e.cache)$t(e.cache[t])},watch:{include:function(e){bt(this.cache,function(t){return _t(e,t)})},exclude:function(e){bt(this.cache,function(t){return!_t(e,t)})}},render:function(){var e=Q(this.$slots.default),t=e&&e.componentOptions;if(t){var n=yt(t);if(n&&(this.include&&!_t(this.include,n)||this.exclude&&_t(this.exclude,n)))return e;var r=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;this.cache[r]?e.componentInstance=this.cache[r].componentInstance:this.cache[r]=e,e.data.keepAlive=!0}return e}},Fo={KeepAlive:Ro};wt(ft),Object.defineProperty(ft.prototype,"$isServer",{get:Qi}),ft.version="2.2.2";var Ho,Uo,Bo,Vo,zo,Jo,Ko,qo,Wo,Zo=n("input,textarea,option,select"),Go=function(e,t,n){return"value"===n&&Zo(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},Yo=n("contenteditable,draggable,spellcheck"),Qo=n("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Xo="http://www.w3.org/1999/xlink",ea=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},ta=function(e){return ea(e)?e.slice(6,e.length):""},na=function(e){return null==e||e===!1},ra={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ia=n("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template"),oa=n("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),aa=function(e){return"pre"===e},sa=function(e){return ia(e)||oa(e)},ca=Object.create(null),ua=Object.freeze({createElement:jt,createElementNS:Nt,createTextNode:It,createComment:Lt,insertBefore:Dt,removeChild:Mt,appendChild:Pt,parentNode:Rt,nextSibling:Ft,tagName:Ht,setTextContent:Ut,setAttribute:Bt}),la={create:function(e,t){Vt(t)},update:function(e,t){e.data.ref!==t.data.ref&&(Vt(e,!0),Vt(t))},destroy:function(e){Vt(e,!0)}},fa=new mo("",{},[]),pa=["create","activate","update","remove","destroy"],da={create:Zt,update:Zt,destroy:function(e){Zt(e,fa)}},va=Object.create(null),ha=[la,da],ma={create:en,update:en},ga={create:nn,update:nn},ya=/[\w).+\-_$\]]/,_a="__r",ba="__c",$a={create:En,update:En},wa={create:jn,update:jn},xa=a(function(e){var t={},n=/;(?![^(]*\))/g,r=/:(.+)/;return e.split(n).forEach(function(e){if(e){var n=e.split(r);n.length>1&&(t[n[0].trim()]=n[1].trim())}}),t}),Ca=/^--/,ka=/\s*!important$/,Aa=function(e,t,n){Ca.test(t)?e.style.setProperty(t,n):ka.test(n)?e.style.setProperty(t,n.replace(ka,""),"important"):e.style[Sa(t)]=n},Oa=["Webkit","Moz","ms"],Sa=a(function(e){if(Wo=Wo||document.createElement("div"),e=Li(e),"filter"!==e&&e in Wo.style)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<Oa.length;n++){var r=Oa[n]+t;if(r in Wo.style)return r}}),Ta={create:Rn,update:Rn},Ea=a(function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}}),ja=zi&&!qi,Na="transition",Ia="animation",La="transition",Da="transitionend",Ma="animation",Pa="animationend";ja&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(La="WebkitTransition",Da="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Ma="WebkitAnimation",Pa="webkitAnimationEnd"));var Ra=zi&&window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout,Fa=/\b(transform|all)(,|$)/,Ha=zi?{create:Xn,activate:Xn,remove:function(e,t){e.data.show?t():Gn(e,t)}}:{},Ua=[ma,ga,$a,wa,Ta,Ha],Ba=Ua.concat(ha),Va=Wt({nodeOps:ua,modules:Ba});qi&&document.addEventListener("selectionchange",function(){var e=document.activeElement;e&&e.vmodel&&or(e,"input")});var za={inserted:function(e,t,n){if("select"===n.tag){var r=function(){er(e,t,n.context)};r(),(Ki||Wi)&&setTimeout(r,0)}else"textarea"!==n.tag&&"text"!==e.type||(e._vModifiers=t.modifiers,t.modifiers.lazy||(Zi||(e.addEventListener("compositionstart",rr),e.addEventListener("compositionend",ir)),qi&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){er(e,t,n.context);var r=e.multiple?t.value.some(function(t){return tr(t,e.options)}):t.value!==t.oldValue&&tr(t.value,e.options);r&&or(e,"change")}}},Ja={bind:function(e,t,n){var r=t.value;n=ar(n);var i=n.data&&n.data.transition,o=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;r&&i&&!qi?(n.data.show=!0,Zn(n,function(){e.style.display=o})):e.style.display=r?o:"none"},update:function(e,t,n){var r=t.value,i=t.oldValue;if(r!==i){n=ar(n);var o=n.data&&n.data.transition;o&&!qi?(n.data.show=!0,r?Zn(n,function(){e.style.display=e.__vOriginalDisplay}):Gn(n,function(){e.style.display="none"})):e.style.display=r?e.__vOriginalDisplay:"none"}},unbind:function(e,t,n,r,i){i||(e.style.display=e.__vOriginalDisplay)}},Ka={model:za,show:Ja},qa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]},Wa={name:"transition",props:qa,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(function(e){return e.tag}),n.length)){var r=this.mode,i=n[0];if(lr(this.$vnode))return i;var a=sr(i);if(!a)return i;if(this._leaving)return ur(e,i);var s="__transition-"+this._uid+"-";a.key=null==a.key?s+a.tag:o(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=cr(this),l=this._vnode,f=sr(l);if(a.data.directives&&a.data.directives.some(function(e){return"show"===e.name})&&(a.data.show=!0),f&&f.data&&!fr(a,f)){var p=f&&(f.data.transition=u({},c));if("out-in"===r)return this._leaving=!0,W(p,"afterLeave",function(){t._leaving=!1,t.$forceUpdate()}),ur(e,i);if("in-out"===r){var d,v=function(){d()};W(c,"afterEnter",v),W(c,"enterCancelled",v),W(p,"delayLeave",function(e){d=e})}}return i}}},Za=u({tag:String,moveClass:String},qa);delete Za.mode;var Ga={props:Za,render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=cr(this),s=0;s<i.length;s++){var c=i[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(o.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=e(t,null,u),this.removed=l}return e(t,null,o)},beforeUpdate:function(){this.__patch__(this._vnode,this.kept,!1,!0),this._vnode=this.kept},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";if(e.length&&this.hasMove(e[0].elm,t)){e.forEach(pr),e.forEach(dr),e.forEach(vr);var n=document.body;n.offsetHeight;e.forEach(function(e){if(e.data.moved){var n=e.elm,r=n.style;Vn(n,t),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Da,n._moveCb=function e(r){r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Da,e),n._moveCb=null,zn(n,t))})}})}},methods:{hasMove:function(e,t){if(!ja)return!1;if(null!=this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach(function(e){Hn(n,e)}),Fn(n,t),n.style.display="none",this.$el.appendChild(n);var r=Kn(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}},Ya={Transition:Wa,TransitionGroup:Ga};ft.config.mustUseProp=Go,ft.config.isReservedTag=sa,ft.config.getTagNamespace=St,ft.config.isUnknownElement=Tt,u(ft.options.directives,Ka),u(ft.options.components,Ya),ft.prototype.__patch__=zi?Va:d,ft.prototype.$mount=function(e,t){return e=e&&zi?Et(e):void 0,ue(this,e,t)},setTimeout(function(){Bi.devtools&&Xi&&Xi.emit("init",ft)},0);var Qa,Xa=!!zi&&hr("\n","&#10;"),es=n("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),ts=n("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),ns=n("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),rs=/([^\s"'<>\/=]+)/,is=/(?:=)/,os=[/"([^"]*)"+/.source,/'([^']*)'+/.source,/([^\s"'=<>`]+)/.source],as=new RegExp("^\\s*"+rs.source+"(?:\\s*("+is.source+")\\s*(?:"+os.join("|")+"))?"),ss="[a-zA-Z_][\\w\\-\\.]*",cs="((?:"+ss+"\\:)?"+ss+")",us=new RegExp("^<"+cs),ls=/^\s*(\/?)>/,fs=new RegExp("^<\\/"+cs+"[^>]*>"),ps=/^<!DOCTYPE [^>]+>/i,ds=/^<!--/,vs=/^<!\[/,hs=!1;"x".replace(/x(.)?/g,function(e,t){hs=""===t});var ms,gs,ys,_s,bs,$s,ws,xs,Cs,ks,As,Os,Ss,Ts,Es,js,Ns,Is,Ls=n("script,style",!0),Ds={},Ms={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n"},Ps=/&(?:lt|gt|quot|amp);/g,Rs=/&(?:lt|gt|quot|amp|#10);/g,Fs=/\{\{((?:.|\n)+?)\}\}/g,Hs=/[-.*+?^${}()|[\]\/\\]/g,Us=a(function(e){var t=e[0].replace(Hs,"\\$&"),n=e[1].replace(Hs,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")}),Bs=/^v-|^@|^:/,Vs=/^@|^v-on:/,zs=/(.*?)\s+(?:in|of)\s+(.*)/,Js=/\((\{[^}]*\}|[^,]*),([^,]*)(?:,([^,]*))?\)/,Ks=/^:|^v-bind:/,qs=/:(.*)$/,Ws=/\.[^.]+/g,Zs=a(mr),Gs=/^xmlns:NS\d+/,Ys=/^NS\d+:/,Qs=a(Hr),Xs=/^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/,ec=/^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/,tc={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},nc=function(e){return"if("+e+")return null;"},rc={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:nc("$event.target !== $event.currentTarget"),ctrl:nc("!$event.ctrlKey"),shift:nc("!$event.shiftKey"),alt:nc("!$event.altKey"),meta:nc("!$event.metaKey"),left:nc("'button' in $event && $event.button !== 0"),middle:nc("'button' in $event && $event.button !== 1"),right:nc("'button' in $event && $event.button !== 2")},ic={bind:Gr,cloak:d},oc={staticKeys:["staticClass"],transformNode:wi,genData:xi},ac={staticKeys:["staticStyle"],transformNode:Ci,genData:ki},sc=[oc,ac],cc={model:wn,text:Ai,html:Oi},uc={expectHTML:!0,modules:sc,directives:cc,isPreTag:aa,isUnaryTag:es,mustUseProp:Go,isReservedTag:sa,getTagNamespace:St,staticKeys:v(sc)},lc=$i(uc),fc=lc.compileToFunctions,pc=a(function(e){var t=Et(e);return t&&t.innerHTML}),dc=ft.prototype.$mount;return ft.prototype.$mount=function(e,t){if(e=e&&Et(e),e===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var r=n.template;if(r)if("string"==typeof r)"#"===r.charAt(0)&&(r=pc(r));else{if(!r.nodeType)return this;r=r.innerHTML}else e&&(r=Si(e));if(r){var i=fc(r,{shouldDecodeNewlines:Xa,delimiters:n.delimiters},this),o=i.render,a=i.staticRenderFns;n.render=o,n.staticRenderFns=a}}return dc.call(this,e,t)},ft.compile=fc,ft});
\ No newline at end of file
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/readme.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/readme.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/readme.md	(revision )
@@ -0,0 +1,42 @@
+# is-stream [![Build Status](https://travis-ci.org/sindresorhus/is-stream.svg?branch=master)](https://travis-ci.org/sindresorhus/is-stream)
+
+> Check if something is a [Node.js stream](https://nodejs.org/api/stream.html)
+
+
+## Install
+
+```
+$ npm install --save is-stream
+```
+
+
+## Usage
+
+```js
+const fs = require('fs');
+const isStream = require('is-stream');
+
+isStream(fs.createReadStream('unicorn.png'));
+//=> true
+
+isStream({});
+//=> false
+```
+
+
+## API
+
+### isStream(stream)
+
+#### isStream.writable(stream)
+
+#### isStream.readable(stream)
+
+#### isStream.duplex(stream)
+
+#### isStream.transform(stream)
+
+
+## License
+
+MIT  [Sindre Sorhus](https://sindresorhus.com)
Index: public/node_modules/vue/src/platforms/web/runtime/patch.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/patch.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/patch.js	(revision )
@@ -0,0 +1,12 @@
+/* @flow */
+
+import * as nodeOps from 'web/runtime/node-ops'
+import { createPatchFunction } from 'core/vdom/patch'
+import baseModules from 'core/vdom/modules/index'
+import platformModules from 'web/runtime/modules/index'
+
+// the directive module should be applied last, after all
+// built-in modules have been applied.
+const modules = platformModules.concat(baseModules)
+
+export const patch: Function = createPatchFunction({ nodeOps, modules })
Index: public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/README.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/duplexer3/README.md	(revision )
@@ -0,0 +1,115 @@
+# duplexer3 [![Build Status](https://travis-ci.org/floatdrop/duplexer3.svg?branch=master)](https://travis-ci.org/floatdrop/duplexer3) [![Coverage Status](https://coveralls.io/repos/floatdrop/duplexer3/badge.svg?branch=master&service=github)](https://coveralls.io/github/floatdrop/duplexer3?branch=master)
+
+Like [duplexer2](https://github.com/deoxxa/duplexer2) but using Streams3 without readable-stream dependency
+
+```javascript
+var stream = require("stream");
+
+var duplexer3 = require("duplexer3");
+
+var writable = new stream.Writable({objectMode: true}),
+    readable = new stream.Readable({objectMode: true});
+
+writable._write = function _write(input, encoding, done) {
+  if (readable.push(input)) {
+    return done();
+  } else {
+    readable.once("drain", done);
+  }
+};
+
+readable._read = function _read(n) {
+  // no-op
+};
+
+// simulate the readable thing closing after a bit
+writable.once("finish", function() {
+  setTimeout(function() {
+    readable.push(null);
+  }, 500);
+});
+
+var duplex = duplexer3(writable, readable);
+
+duplex.on("data", function(e) {
+  console.log("got data", JSON.stringify(e));
+});
+
+duplex.on("finish", function() {
+  console.log("got finish event");
+});
+
+duplex.on("end", function() {
+  console.log("got end event");
+});
+
+duplex.write("oh, hi there", function() {
+  console.log("finished writing");
+});
+
+duplex.end(function() {
+  console.log("finished ending");
+});
+```
+
+```
+got data "oh, hi there"
+finished writing
+got finish event
+finished ending
+got end event
+```
+
+## Overview
+
+This is a reimplementation of [duplexer](https://www.npmjs.com/package/duplexer) using the
+Streams3 API which is standard in Node as of v4. Everything largely
+works the same.
+
+
+
+## Installation
+
+[Available via `npm`](https://docs.npmjs.com/cli/install):
+
+```
+$ npm i duplexer3
+```
+
+## API
+
+### duplexer3
+
+Creates a new `DuplexWrapper` object, which is the actual class that implements
+most of the fun stuff. All that fun stuff is hidden. DON'T LOOK.
+
+```javascript
+duplexer3([options], writable, readable)
+```
+
+```javascript
+const duplex = duplexer3(new stream.Writable(), new stream.Readable());
+```
+
+Arguments
+
+* __options__ - an object specifying the regular `stream.Duplex` options, as
+  well as the properties described below.
+* __writable__ - a writable stream
+* __readable__ - a readable stream
+
+Options
+
+* __bubbleErrors__ - a boolean value that specifies whether to bubble errors
+  from the underlying readable/writable streams. Default is `true`.
+
+
+## License
+
+3-clause BSD. [A copy](./LICENSE) is included with the source.
+
+## Contact
+
+* GitHub ([deoxxa](http://github.com/deoxxa))
+* Twitter ([@deoxxa](http://twitter.com/deoxxa))
+* Email ([deoxxa@fknsrs.biz](mailto:deoxxa@fknsrs.biz))
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-redirect/package.json	(revision )
@@ -0,0 +1,49 @@
+{
+  "name": "is-redirect",
+  "version": "1.0.0",
+  "description": "Check if a number is a redirect HTTP status code",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/is-redirect"
+  },
+  "author": {
+    "name": "Sindre Sorhus",
+    "email": "sindresorhus@gmail.com",
+    "url": "sindresorhus.com"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "node test.js"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "redirect",
+    "http",
+    "https",
+    "status",
+    "code",
+    "codes",
+    "is",
+    "check",
+    "detect"
+  ],
+  "devDependencies": {
+    "ava": "0.0.4"
+  },
+  "readme": "# is-redirect [![Build Status](https://travis-ci.org/sindresorhus/is-redirect.svg?branch=master)](https://travis-ci.org/sindresorhus/is-redirect)\n\n> Check if a number is a [redirect HTTP status code](http://en.wikipedia.org/wiki/List_of_HTTP_status_codes#3xx_Redirection)\n\n\n## Install\n\n```\n$ npm install --save is-redirect\n```\n\n\n## Usage\n\n```js\nvar isRedirect = require('is-redirect');\n\nisRedirect(302);\n//=> true\n\nisRedirect(200);\n//=> false\n```\n\n\n## License\n\nMIT  [Sindre Sorhus](http://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/is-redirect/issues"
+  },
+  "_id": "is-redirect@1.0.0",
+  "dist": {
+    "shasum": "34e1440b607f835daa6f78e7e9c4c59c1816bcde"
+  },
+  "_from": "is-redirect@^1.0.0",
+  "_resolved": "https://registry.npmjs.org/is-redirect/-/is-redirect-1.0.0.tgz"
+}
Index: public/node_modules/vue/src/platforms/web/runtime/directives/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/web/runtime/directives/index.js	(revision )
+++ public/node_modules/vue/src/platforms/web/runtime/directives/index.js	(revision )
@@ -0,0 +1,7 @@
+import model from './model'
+import show from './show'
+
+export default {
+  model,
+  show
+}
Index: public/node_modules/vue/src/entries/weex-factory.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/entries/weex-factory.js	(revision )
+++ public/node_modules/vue/src/entries/weex-factory.js	(revision )
@@ -0,0 +1,6 @@
+// this entry is built and wrapped with a factory function
+// used to generate a fresh copy of Vue for every Weex instance.
+
+import Vue from 'weex/runtime/index'
+
+exports.Vue = Vue
Index: resources/views/web/form/invite_vue.blade.php
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- resources/views/web/form/invite_vue.blade.php	(revision )
+++ resources/views/web/form/invite_vue.blade.php	(revision )
@@ -0,0 +1,111 @@
+@extends('layouts.app')
+
+@section('content')
+    <div class="container">
+        <div class="row">
+            <div class="col-md-10 col-md-offset-1">
+                <div class="panel panel-default">
+                    <div class="panel-heading"></div>
+
+                    <div class="panel-body">
+                        <form id="vm-form" v-on:submit.prevent="submit" class="form-horizontal" role="form"
+                              action="{{route('web.admin.store')}}" method="post">
+                            {!! csrf_field() !!}
+                            <div class="form-group">
+
+                                <label for="form" class="col-sm-2 control-label"></label>
+                                <div class="col-sm-10">
+                                    <vue-select :options="options" v-model="mytable" id="mytable" name="tableId" :searchable="true"
+                                            class="form-control select select-primary select-block mbl">
+                                        <option v-for="f in forms" :value="f">@{{ f.name }}</option>
+                                    </vue-select>
+                                </div>
+                            </div>
+
+                        </form>
+                    </div>
+                </div>
+            </div>
+        </div>
+    </div>
+@endsection
+
+@section('js')
+    <script src="{{cdnAsset('/node_modules/vue/dist/vue.min.js')}}"></script>
+    <script src="{{cdnAsset('/node_modules/vue-resource/dist/vue-resource.min.js')}}"></script>
+    <script src="{{cdnAsset('/node_modules/vue-select2/dist/vue-select.min.js')}}"></script>
+    <script>
+        $(function () {
+//                                    $(':radio').radiocheck();
+//                        $(':checkbox').bootstrapSwitch();
+//                        $("select").select2({dropdownCssClass: 'dropdown-inverse'});
+
+            Vue.component('vue-select',{
+                props: ['options', 'value'],
+                mounted: function () {
+                    var vm = this
+                    $(this.$el)
+                        .val(this.value)
+                        // init select2
+                        .select2({ data: this.options })
+                        // emit event on change.
+                        .on('change', function () {
+                            vm.$emit('input', this.value)
+                        })
+                },
+                watch: {
+                    value: function (value) {
+                        // update value
+                        $(this.$el).val(value)
+                    },
+                    options: function (options) {
+                        // update options
+                        $(this.$el).select2({ data: options })
+                    }
+                },
+                destroyed: function () {
+                    $(this.$el).off().select2('destroy')
+                }
+            });
+            var vm = new Vue({
+                el: '#vm-form',
+                data: {
+                    forms: null,
+                    mytable: null,
+                    authorities: null,
+                    stages: null,
+                    add_condition: null,
+                    users: 'asd',
+                    remark: ''
+                },
+                created: function () {
+                    this.init();
+                    window.$vm = this;
+                },
+                methods: {
+                    init: function () {
+                        var that = this;
+                        that.$resource('/web/admin/getOwnForms').get().then(function (resp) {
+                            // APIjson():
+                            resp.json().then(function (result) {
+                                console.log(result);
+
+                                // VMtodos:
+                                that.forms = result;
+                            });
+                        }, function (resp) {
+                            // API:
+                            alert('error');
+                        });
+//                        $(':radio').radiocheck();
+//                        $(':checkbox').bootstrapSwitch();
+//                        $("select").select2({dropdownCssClass: 'dropdown-inverse'});
+                    },
+                    submit: function () {
+                        alert(JSON.stringify(this.$data))
+                    }
+                }
+            });
+        });
+    </script>
+@endsection
Index: public/node_modules/vue-resource/src/http/interceptor/before.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/interceptor/before.js	(revision )
+++ public/node_modules/vue-resource/src/http/interceptor/before.js	(revision )
@@ -0,0 +1,14 @@
+/**
+ * Before Interceptor.
+ */
+
+import { isFunction } from '../../util';
+
+export default function (request, next) {
+
+    if (isFunction(request.before)) {
+        request.before.call(this, request);
+    }
+
+    next();
+}
Index: public/node_modules/vue/src/core/instance/render-helpers/check-keycodes.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/instance/render-helpers/check-keycodes.js	(revision )
+++ public/node_modules/vue/src/core/instance/render-helpers/check-keycodes.js	(revision )
@@ -0,0 +1,19 @@
+/* @flow */
+
+import config from 'core/config'
+
+/**
+ * Runtime helper for checking keyCodes from config.
+ */
+export function checkKeyCodes (
+  eventKeyCode: number,
+  key: string,
+  builtInAlias: number | Array<number> | void
+): boolean {
+  const keyCodes = config.keyCodes[key] || builtInAlias
+  if (Array.isArray(keyCodes)) {
+    return keyCodes.indexOf(eventKeyCode) === -1
+  } else {
+    return keyCodes !== eventKeyCode
+  }
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-retry-allowed/index.js	(revision )
@@ -0,0 +1,60 @@
+'use strict';
+
+var WHITELIST = [
+	'ETIMEDOUT',
+	'ECONNRESET',
+	'EADDRINUSE',
+	'ESOCKETTIMEDOUT',
+	'ECONNREFUSED',
+	'EPIPE'
+];
+
+var BLACKLIST = [
+	'ENOTFOUND',
+	'ENETUNREACH',
+
+	// SSL errors from https://github.com/nodejs/node/blob/ed3d8b13ee9a705d89f9e0397d9e96519e7e47ac/src/node_crypto.cc#L1950
+	'UNABLE_TO_GET_ISSUER_CERT',
+	'UNABLE_TO_GET_CRL',
+	'UNABLE_TO_DECRYPT_CERT_SIGNATURE',
+	'UNABLE_TO_DECRYPT_CRL_SIGNATURE',
+	'UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY',
+	'CERT_SIGNATURE_FAILURE',
+	'CRL_SIGNATURE_FAILURE',
+	'CERT_NOT_YET_VALID',
+	'CERT_HAS_EXPIRED',
+	'CRL_NOT_YET_VALID',
+	'CRL_HAS_EXPIRED',
+	'ERROR_IN_CERT_NOT_BEFORE_FIELD',
+	'ERROR_IN_CERT_NOT_AFTER_FIELD',
+	'ERROR_IN_CRL_LAST_UPDATE_FIELD',
+	'ERROR_IN_CRL_NEXT_UPDATE_FIELD',
+	'OUT_OF_MEM',
+	'DEPTH_ZERO_SELF_SIGNED_CERT',
+	'SELF_SIGNED_CERT_IN_CHAIN',
+	'UNABLE_TO_GET_ISSUER_CERT_LOCALLY',
+	'UNABLE_TO_VERIFY_LEAF_SIGNATURE',
+	'CERT_CHAIN_TOO_LONG',
+	'CERT_REVOKED',
+	'INVALID_CA',
+	'PATH_LENGTH_EXCEEDED',
+	'INVALID_PURPOSE',
+	'CERT_UNTRUSTED',
+	'CERT_REJECTED'
+];
+
+module.exports = function (err) {
+	if (!err || !err.code) {
+		return true;
+	}
+
+	if (WHITELIST.indexOf(err.code) !== -1) {
+		return true;
+	}
+
+	if (BLACKLIST.indexOf(err.code) !== -1) {
+		return false;
+	}
+
+	return true;
+};
Index: public/node_modules/vue/src/platforms/weex/runtime/modules/class.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/modules/class.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/modules/class.js	(revision )
@@ -0,0 +1,65 @@
+/* @flow */
+
+import { extend } from 'shared/util'
+
+function updateClass (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  const el = vnode.elm
+  const ctx = vnode.context
+
+  const data: VNodeData = vnode.data
+  const oldData: VNodeData = oldVnode.data
+  if (!data.staticClass && !data.class &&
+      (!oldData || (!oldData.staticClass && !oldData.class))) {
+    return
+  }
+
+  const oldClassList = []
+  // unlike web, weex vnode staticClass is an Array
+  const oldStaticClass: any = oldData.staticClass
+  if (oldStaticClass) {
+    oldClassList.push.apply(oldClassList, oldStaticClass)
+  }
+  if (oldData.class) {
+    oldClassList.push.apply(oldClassList, oldData.class)
+  }
+
+  const classList = []
+  // unlike web, weex vnode staticClass is an Array
+  const staticClass: any = data.staticClass
+  if (staticClass) {
+    classList.push.apply(classList, staticClass)
+  }
+  if (data.class) {
+    classList.push.apply(classList, data.class)
+  }
+
+  const style = getStyle(oldClassList, classList, ctx)
+  for (const key in style) {
+    el.setStyle(key, style[key])
+  }
+}
+
+function getStyle (oldClassList: Array<string>, classList: Array<string>, ctx: Component): Object {
+  // style is a weex-only injected object
+  // compiled from <style> tags in weex files
+  const stylesheet: any = ctx.$options.style || {}
+  const result = {}
+  classList.forEach(name => {
+    const style = stylesheet[name]
+    extend(result, style)
+  })
+  oldClassList.forEach(name => {
+    const style = stylesheet[name]
+    for (const key in style) {
+      if (!result.hasOwnProperty(key)) {
+        result[key] = ''
+      }
+    }
+  })
+  return result
+}
+
+export default {
+  create: updateClass,
+  update: updateClass
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/README.md	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/README.md	(revision )
@@ -0,0 +1,581 @@
+# safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![downloads][downloads-image]][npm-url]
+
+#### Safer Node.js Buffer API
+
+**Use the new Node.js v6 Buffer APIs (`Buffer.from`, `Buffer.alloc`,
+`Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`) in Node.js v0.10, v0.12, v4.x, and v5.x.**
+
+**Uses the built-in implementations when available.**
+
+[travis-image]: https://img.shields.io/travis/feross/safe-buffer.svg
+[travis-url]: https://travis-ci.org/feross/safe-buffer
+[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
+[npm-url]: https://npmjs.org/package/safe-buffer
+[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
+
+## install
+
+```
+npm install safe-buffer
+```
+
+## usage
+
+The goal of this package is to provide a safe replacement for the node.js `Buffer`.
+
+It's a drop-in replacement for `Buffer`. You can use it by adding one `require` line to
+the top of your node.js modules:
+
+```js
+var Buffer = require('safe-buffer').Buffer
+
+// Existing buffer code will continue to work without issues:
+
+new Buffer('hey', 'utf8')
+new Buffer([1, 2, 3], 'utf8')
+new Buffer(obj)
+new Buffer(16) // create an uninitialized buffer (potentially unsafe)
+
+// But you can use these new explicit APIs to make clear what you want:
+
+Buffer.from('hey', 'utf8') // convert from many types to a Buffer
+Buffer.alloc(16) // create a zero-filled buffer (safe)
+Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
+```
+
+## api
+
+### Class Method: Buffer.from(array)
+<!-- YAML
+added: v3.0.0
+-->
+
+* `array` {Array}
+
+Allocates a new `Buffer` using an `array` of octets.
+
+```js
+const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
+  // creates a new Buffer containing ASCII bytes
+  // ['b','u','f','f','e','r']
+```
+
+A `TypeError` will be thrown if `array` is not an `Array`.
+
+### Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])
+<!-- YAML
+added: v5.10.0
+-->
+
+* `arrayBuffer` {ArrayBuffer} The `.buffer` property of a `TypedArray` or
+  a `new ArrayBuffer()`
+* `byteOffset` {Number} Default: `0`
+* `length` {Number} Default: `arrayBuffer.length - byteOffset`
+
+When passed a reference to the `.buffer` property of a `TypedArray` instance,
+the newly created `Buffer` will share the same allocated memory as the
+TypedArray.
+
+```js
+const arr = new Uint16Array(2);
+arr[0] = 5000;
+arr[1] = 4000;
+
+const buf = Buffer.from(arr.buffer); // shares the memory with arr;
+
+console.log(buf);
+  // Prints: <Buffer 88 13 a0 0f>
+
+// changing the TypedArray changes the Buffer also
+arr[1] = 6000;
+
+console.log(buf);
+  // Prints: <Buffer 88 13 70 17>
+```
+
+The optional `byteOffset` and `length` arguments specify a memory range within
+the `arrayBuffer` that will be shared by the `Buffer`.
+
+```js
+const ab = new ArrayBuffer(10);
+const buf = Buffer.from(ab, 0, 2);
+console.log(buf.length);
+  // Prints: 2
+```
+
+A `TypeError` will be thrown if `arrayBuffer` is not an `ArrayBuffer`.
+
+### Class Method: Buffer.from(buffer)
+<!-- YAML
+added: v3.0.0
+-->
+
+* `buffer` {Buffer}
+
+Copies the passed `buffer` data onto a new `Buffer` instance.
+
+```js
+const buf1 = Buffer.from('buffer');
+const buf2 = Buffer.from(buf1);
+
+buf1[0] = 0x61;
+console.log(buf1.toString());
+  // 'auffer'
+console.log(buf2.toString());
+  // 'buffer' (copy is not changed)
+```
+
+A `TypeError` will be thrown if `buffer` is not a `Buffer`.
+
+### Class Method: Buffer.from(str[, encoding])
+<!-- YAML
+added: v5.10.0
+-->
+
+* `str` {String} String to encode.
+* `encoding` {String} Encoding to use, Default: `'utf8'`
+
+Creates a new `Buffer` containing the given JavaScript string `str`. If
+provided, the `encoding` parameter identifies the character encoding.
+If not provided, `encoding` defaults to `'utf8'`.
+
+```js
+const buf1 = Buffer.from('this is a tst');
+console.log(buf1.toString());
+  // prints: this is a tst
+console.log(buf1.toString('ascii'));
+  // prints: this is a tC)st
+
+const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
+console.log(buf2.toString());
+  // prints: this is a tst
+```
+
+A `TypeError` will be thrown if `str` is not a string.
+
+### Class Method: Buffer.alloc(size[, fill[, encoding]])
+<!-- YAML
+added: v5.10.0
+-->
+
+* `size` {Number}
+* `fill` {Value} Default: `undefined`
+* `encoding` {String} Default: `utf8`
+
+Allocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the
+`Buffer` will be *zero-filled*.
+
+```js
+const buf = Buffer.alloc(5);
+console.log(buf);
+  // <Buffer 00 00 00 00 00>
+```
+
+The `size` must be less than or equal to the value of
+`require('buffer').kMaxLength` (on 64-bit architectures, `kMaxLength` is
+`(2^31)-1`). Otherwise, a [`RangeError`][] is thrown. A zero-length Buffer will
+be created if a `size` less than or equal to 0 is specified.
+
+If `fill` is specified, the allocated `Buffer` will be initialized by calling
+`buf.fill(fill)`. See [`buf.fill()`][] for more information.
+
+```js
+const buf = Buffer.alloc(5, 'a');
+console.log(buf);
+  // <Buffer 61 61 61 61 61>
+```
+
+If both `fill` and `encoding` are specified, the allocated `Buffer` will be
+initialized by calling `buf.fill(fill, encoding)`. For example:
+
+```js
+const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
+console.log(buf);
+  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
+```
+
+Calling `Buffer.alloc(size)` can be significantly slower than the alternative
+`Buffer.allocUnsafe(size)` but ensures that the newly created `Buffer` instance
+contents will *never contain sensitive data*.
+
+A `TypeError` will be thrown if `size` is not a number.
+
+### Class Method: Buffer.allocUnsafe(size)
+<!-- YAML
+added: v5.10.0
+-->
+
+* `size` {Number}
+
+Allocates a new *non-zero-filled* `Buffer` of `size` bytes.  The `size` must
+be less than or equal to the value of `require('buffer').kMaxLength` (on 64-bit
+architectures, `kMaxLength` is `(2^31)-1`). Otherwise, a [`RangeError`][] is
+thrown. A zero-length Buffer will be created if a `size` less than or equal to
+0 is specified.
+
+The underlying memory for `Buffer` instances created in this way is *not
+initialized*. The contents of the newly created `Buffer` are unknown and
+*may contain sensitive data*. Use [`buf.fill(0)`][] to initialize such
+`Buffer` instances to zeroes.
+
+```js
+const buf = Buffer.allocUnsafe(5);
+console.log(buf);
+  // <Buffer 78 e0 82 02 01>
+  // (octets will be different, every time)
+buf.fill(0);
+console.log(buf);
+  // <Buffer 00 00 00 00 00>
+```
+
+A `TypeError` will be thrown if `size` is not a number.
+
+Note that the `Buffer` module pre-allocates an internal `Buffer` instance of
+size `Buffer.poolSize` that is used as a pool for the fast allocation of new
+`Buffer` instances created using `Buffer.allocUnsafe(size)` (and the deprecated
+`new Buffer(size)` constructor) only when `size` is less than or equal to
+`Buffer.poolSize >> 1` (floor of `Buffer.poolSize` divided by two). The default
+value of `Buffer.poolSize` is `8192` but can be modified.
+
+Use of this pre-allocated internal memory pool is a key difference between
+calling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.
+Specifically, `Buffer.alloc(size, fill)` will *never* use the internal Buffer
+pool, while `Buffer.allocUnsafe(size).fill(fill)` *will* use the internal
+Buffer pool if `size` is less than or equal to half `Buffer.poolSize`. The
+difference is subtle but can be important when an application requires the
+additional performance that `Buffer.allocUnsafe(size)` provides.
+
+### Class Method: Buffer.allocUnsafeSlow(size)
+<!-- YAML
+added: v5.10.0
+-->
+
+* `size` {Number}
+
+Allocates a new *non-zero-filled* and non-pooled `Buffer` of `size` bytes.  The
+`size` must be less than or equal to the value of
+`require('buffer').kMaxLength` (on 64-bit architectures, `kMaxLength` is
+`(2^31)-1`). Otherwise, a [`RangeError`][] is thrown. A zero-length Buffer will
+be created if a `size` less than or equal to 0 is specified.
+
+The underlying memory for `Buffer` instances created in this way is *not
+initialized*. The contents of the newly created `Buffer` are unknown and
+*may contain sensitive data*. Use [`buf.fill(0)`][] to initialize such
+`Buffer` instances to zeroes.
+
+When using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,
+allocations under 4KB are, by default, sliced from a single pre-allocated
+`Buffer`. This allows applications to avoid the garbage collection overhead of
+creating many individually allocated Buffers. This approach improves both
+performance and memory usage by eliminating the need to track and cleanup as
+many `Persistent` objects.
+
+However, in the case where a developer may need to retain a small chunk of
+memory from a pool for an indeterminate amount of time, it may be appropriate
+to create an un-pooled Buffer instance using `Buffer.allocUnsafeSlow()` then
+copy out the relevant bits.
+
+```js
+// need to keep around a few small chunks of memory
+const store = [];
+
+socket.on('readable', () => {
+  const data = socket.read();
+  // allocate for retained data
+  const sb = Buffer.allocUnsafeSlow(10);
+  // copy the data into the new allocation
+  data.copy(sb, 0, 0, 10);
+  store.push(sb);
+});
+```
+
+Use of `Buffer.allocUnsafeSlow()` should be used only as a last resort *after*
+a developer has observed undue memory retention in their applications.
+
+A `TypeError` will be thrown if `size` is not a number.
+
+### All the Rest
+
+The rest of the `Buffer` API is exactly the same as in node.js.
+[See the docs](https://nodejs.org/api/buffer.html).
+
+
+## Related links
+
+- [Node.js issue: Buffer(number) is unsafe](https://github.com/nodejs/node/issues/4660)
+- [Node.js Enhancement Proposal: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)
+
+## Why is `Buffer` unsafe?
+
+Today, the node.js `Buffer` constructor is overloaded to handle many different argument
+types like `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array`, etc.),
+`ArrayBuffer`, and also `Number`.
+
+The API is optimized for convenience: you can throw any type at it, and it will try to do
+what you want.
+
+Because the Buffer constructor is so powerful, you often see code like this:
+
+```js
+// Convert UTF-8 strings to hex
+function toHex (str) {
+  return new Buffer(str).toString('hex')
+}
+```
+
+***But what happens if `toHex` is called with a `Number` argument?***
+
+### Remote Memory Disclosure
+
+If an attacker can make your program call the `Buffer` constructor with a `Number`
+argument, then they can make it allocate uninitialized memory from the node.js process.
+This could potentially disclose TLS private keys, user data, or database passwords.
+
+When the `Buffer` constructor is passed a `Number` argument, it returns an
+**UNINITIALIZED** block of memory of the specified `size`. When you create a `Buffer` like
+this, you **MUST** overwrite the contents before returning it to the user.
+
+From the [node.js docs](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):
+
+> `new Buffer(size)`
+>
+> - `size` Number
+>
+> The underlying memory for `Buffer` instances created in this way is not initialized.
+> **The contents of a newly created `Buffer` are unknown and could contain sensitive
+> data.** Use `buf.fill(0)` to initialize a Buffer to zeroes.
+
+(Emphasis our own.)
+
+Whenever the programmer intended to create an uninitialized `Buffer` you often see code
+like this:
+
+```js
+var buf = new Buffer(16)
+
+// Immediately overwrite the uninitialized buffer with data from another buffer
+for (var i = 0; i < buf.length; i++) {
+  buf[i] = otherBuf[i]
+}
+```
+
+
+### Would this ever be a problem in real code?
+
+Yes. It's surprisingly common to forget to check the type of your variables in a
+dynamically-typed language like JavaScript.
+
+Usually the consequences of assuming the wrong type is that your program crashes with an
+uncaught exception. But the failure mode for forgetting to check the type of arguments to
+the `Buffer` constructor is more catastrophic.
+
+Here's an example of a vulnerable service that takes a JSON payload and converts it to
+hex:
+
+```js
+// Take a JSON payload {str: "some string"} and convert it to hex
+var server = http.createServer(function (req, res) {
+  var data = ''
+  req.setEncoding('utf8')
+  req.on('data', function (chunk) {
+    data += chunk
+  })
+  req.on('end', function () {
+    var body = JSON.parse(data)
+    res.end(new Buffer(body.str).toString('hex'))
+  })
+})
+
+server.listen(8080)
+```
+
+In this example, an http client just has to send:
+
+```json
+{
+  "str": 1000
+}
+```
+
+and it will get back 1,000 bytes of uninitialized memory from the server.
+
+This is a very serious bug. It's similar in severity to the
+[the Heartbleed bug](http://heartbleed.com/) that allowed disclosure of OpenSSL process
+memory by remote attackers.
+
+
+### Which real-world packages were vulnerable?
+
+#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)
+
+[Mathias Buus](https://github.com/mafintosh) and I
+([Feross Aboukhadijeh](http://feross.org/)) found this issue in one of our own packages,
+[`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). The bug would allow
+anyone on the internet to send a series of messages to a user of `bittorrent-dht` and get
+them to reveal 20 bytes at a time of uninitialized memory from the node.js process.
+
+Here's
+[the commit](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8)
+that fixed it. We released a new fixed version, created a
+[Node Security Project disclosure](https://nodesecurity.io/advisories/68), and deprecated all
+vulnerable versions on npm so users will get a warning to upgrade to a newer version.
+
+#### [`ws`](https://www.npmjs.com/package/ws)
+
+That got us wondering if there were other vulnerable packages. Sure enough, within a short
+period of time, we found the same issue in [`ws`](https://www.npmjs.com/package/ws), the
+most popular WebSocket implementation in node.js.
+
+If certain APIs were called with `Number` parameters instead of `String` or `Buffer` as
+expected, then uninitialized server memory would be disclosed to the remote peer.
+
+These were the vulnerable methods:
+
+```js
+socket.send(number)
+socket.ping(number)
+socket.pong(number)
+```
+
+Here's a vulnerable socket server with some echo functionality:
+
+```js
+server.on('connection', function (socket) {
+  socket.on('message', function (message) {
+    message = JSON.parse(message)
+    if (message.type === 'echo') {
+      socket.send(message.data) // send back the user's message
+    }
+  })
+})
+```
+
+`socket.send(number)` called on the server, will disclose server memory.
+
+Here's [the release](https://github.com/websockets/ws/releases/tag/1.0.1) where the issue
+was fixed, with a more detailed explanation. Props to
+[Arnout Kazemier](https://github.com/3rd-Eden) for the quick fix. Here's the
+[Node Security Project disclosure](https://nodesecurity.io/advisories/67).
+
+
+### What's the solution?
+
+It's important that node.js offers a fast way to get memory otherwise performance-critical
+applications would needlessly get a lot slower.
+
+But we need a better way to *signal our intent* as programmers. **When we want
+uninitialized memory, we should request it explicitly.**
+
+Sensitive functionality should not be packed into a developer-friendly API that loosely
+accepts many different types. This type of API encourages the lazy practice of passing
+variables in without checking the type very carefully.
+
+#### A new API: `Buffer.allocUnsafe(number)`
+
+The functionality of creating buffers with uninitialized memory should be part of another
+API. We propose `Buffer.allocUnsafe(number)`. This way, it's not part of an API that
+frequently gets user input of all sorts of different types passed into it.
+
+```js
+var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!
+
+// Immediately overwrite the uninitialized buffer with data from another buffer
+for (var i = 0; i < buf.length; i++) {
+  buf[i] = otherBuf[i]
+}
+```
+
+
+### How do we fix node.js core?
+
+We sent [a PR to node.js core](https://github.com/nodejs/node/pull/4514) (merged as
+`semver-major`) which defends against one case:
+
+```js
+var str = 16
+new Buffer(str, 'utf8')
+```
+
+In this situation, it's implied that the programmer intended the first argument to be a
+string, since they passed an encoding as a second argument. Today, node.js will allocate
+uninitialized memory in the case of `new Buffer(number, encoding)`, which is probably not
+what the programmer intended.
+
+But this is only a partial solution, since if the programmer does `new Buffer(variable)`
+(without an `encoding` parameter) there's no way to know what they intended. If `variable`
+is sometimes a number, then uninitialized memory will sometimes be returned.
+
+### What's the real long-term fix?
+
+We could deprecate and remove `new Buffer(number)` and use `Buffer.allocUnsafe(number)` when
+we need uninitialized memory. But that would break 1000s of packages.
+
+~~We believe the best solution is to:~~
+
+~~1. Change `new Buffer(number)` to return safe, zeroed-out memory~~
+
+~~2. Create a new API for creating uninitialized Buffers. We propose: `Buffer.allocUnsafe(number)`~~
+
+#### Update
+
+We now support adding three new APIs:
+
+- `Buffer.from(value)` - convert from any type to a buffer
+- `Buffer.alloc(size)` - create a zero-filled buffer
+- `Buffer.allocUnsafe(size)` - create an uninitialized buffer with given size
+
+This solves the core problem that affected `ws` and `bittorrent-dht` which is
+`Buffer(variable)` getting tricked into taking a number argument.
+
+This way, existing code continues working and the impact on the npm ecosystem will be
+minimal. Over time, npm maintainers can migrate performance-critical code to use
+`Buffer.allocUnsafe(number)` instead of `new Buffer(number)`.
+
+
+### Conclusion
+
+We think there's a serious design issue with the `Buffer` API as it exists today. It
+promotes insecure software by putting high-risk functionality into a convenient API
+with friendly "developer ergonomics".
+
+This wasn't merely a theoretical exercise because we found the issue in some of the
+most popular npm packages.
+
+Fortunately, there's an easy fix that can be applied today. Use `safe-buffer` in place of
+`buffer`.
+
+```js
+var Buffer = require('safe-buffer').Buffer
+```
+
+Eventually, we hope that node.js core can switch to this new, safer behavior. We believe
+the impact on the ecosystem would be minimal since it's not a breaking change.
+Well-maintained, popular packages would be updated to use `Buffer.alloc` quickly, while
+older, insecure packages would magically become safe from this attack vector.
+
+
+## links
+
+- [Node.js PR: buffer: throw if both length and enc are passed](https://github.com/nodejs/node/pull/4514)
+- [Node Security Project disclosure for `ws`](https://nodesecurity.io/advisories/67)
+- [Node Security Project disclosure for`bittorrent-dht`](https://nodesecurity.io/advisories/68)
+
+
+## credit
+
+The original issues in `bittorrent-dht`
+([disclosure](https://nodesecurity.io/advisories/68)) and
+`ws` ([disclosure](https://nodesecurity.io/advisories/67)) were discovered by
+[Mathias Buus](https://github.com/mafintosh) and
+[Feross Aboukhadijeh](http://feross.org/).
+
+Thanks to [Adam Baldwin](https://github.com/evilpacket) for helping disclose these issues
+and for his work running the [Node Security Project](https://nodesecurity.io/).
+
+Thanks to [John Hiesey](https://github.com/jhiesey) for proofreading this README and
+auditing the code.
+
+
+## license
+
+MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
Index: public/node_modules/vue-select2/.npmignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/.npmignore	(revision )
+++ public/node_modules/vue-select2/.npmignore	(revision )
@@ -0,0 +1,4 @@
+/lib
+/coverage
+/node_modules
+npm-debug.log
Index: public/node_modules/vue/src/core/util/props.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/props.js	(revision )
+++ public/node_modules/vue/src/core/util/props.js	(revision )
@@ -0,0 +1,183 @@
+/* @flow */
+
+import { hasOwn, isObject, isPlainObject, capitalize, hyphenate } from 'shared/util'
+import { observe, observerState } from '../observer/index'
+import { warn } from './debug'
+
+type PropOptions = {
+  type: Function | Array<Function> | null,
+  default: any,
+  required: ?boolean,
+  validator: ?Function
+};
+
+export function validateProp (
+  key: string,
+  propOptions: Object,
+  propsData: Object,
+  vm?: Component
+): any {
+  const prop = propOptions[key]
+  const absent = !hasOwn(propsData, key)
+  let value = propsData[key]
+  // handle boolean props
+  if (isType(Boolean, prop.type)) {
+    if (absent && !hasOwn(prop, 'default')) {
+      value = false
+    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
+      value = true
+    }
+  }
+  // check default value
+  if (value === undefined) {
+    value = getPropDefaultValue(vm, prop, key)
+    // since the default value is a fresh copy,
+    // make sure to observe it.
+    const prevShouldConvert = observerState.shouldConvert
+    observerState.shouldConvert = true
+    observe(value)
+    observerState.shouldConvert = prevShouldConvert
+  }
+  if (process.env.NODE_ENV !== 'production') {
+    assertProp(prop, key, value, vm, absent)
+  }
+  return value
+}
+
+/**
+ * Get the default value of a prop.
+ */
+function getPropDefaultValue (vm: ?Component, prop: PropOptions, key: string): any {
+  // no default, return undefined
+  if (!hasOwn(prop, 'default')) {
+    return undefined
+  }
+  const def = prop.default
+  // warn against non-factory defaults for Object & Array
+  if (process.env.NODE_ENV !== 'production' && isObject(def)) {
+    warn(
+      'Invalid default value for prop "' + key + '": ' +
+      'Props with type Object/Array must use a factory function ' +
+      'to return the default value.',
+      vm
+    )
+  }
+  // the raw prop value was also undefined from previous render,
+  // return previous default value to avoid unnecessary watcher trigger
+  if (vm && vm.$options.propsData &&
+    vm.$options.propsData[key] === undefined &&
+    vm._props[key] !== undefined) {
+    return vm._props[key]
+  }
+  // call factory function for non-Function types
+  // a value is Function if its prototype is function even across different execution context
+  return typeof def === 'function' && getType(prop.type) !== 'Function'
+    ? def.call(vm)
+    : def
+}
+
+/**
+ * Assert whether a prop is valid.
+ */
+function assertProp (
+  prop: PropOptions,
+  name: string,
+  value: any,
+  vm: ?Component,
+  absent: boolean
+) {
+  if (prop.required && absent) {
+    warn(
+      'Missing required prop: "' + name + '"',
+      vm
+    )
+    return
+  }
+  if (value == null && !prop.required) {
+    return
+  }
+  let type = prop.type
+  let valid = !type || type === true
+  const expectedTypes = []
+  if (type) {
+    if (!Array.isArray(type)) {
+      type = [type]
+    }
+    for (let i = 0; i < type.length && !valid; i++) {
+      const assertedType = assertType(value, type[i])
+      expectedTypes.push(assertedType.expectedType || '')
+      valid = assertedType.valid
+    }
+  }
+  if (!valid) {
+    warn(
+      'Invalid prop: type check failed for prop "' + name + '".' +
+      ' Expected ' + expectedTypes.map(capitalize).join(', ') +
+      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',
+      vm
+    )
+    return
+  }
+  const validator = prop.validator
+  if (validator) {
+    if (!validator(value)) {
+      warn(
+        'Invalid prop: custom validator check failed for prop "' + name + '".',
+        vm
+      )
+    }
+  }
+}
+
+/**
+ * Assert the type of a value
+ */
+function assertType (value: any, type: Function): {
+  valid: boolean,
+  expectedType: ?string
+} {
+  let valid
+  let expectedType = getType(type)
+  if (expectedType === 'String') {
+    valid = typeof value === (expectedType = 'string')
+  } else if (expectedType === 'Number') {
+    valid = typeof value === (expectedType = 'number')
+  } else if (expectedType === 'Boolean') {
+    valid = typeof value === (expectedType = 'boolean')
+  } else if (expectedType === 'Function') {
+    valid = typeof value === (expectedType = 'function')
+  } else if (expectedType === 'Object') {
+    valid = isPlainObject(value)
+  } else if (expectedType === 'Array') {
+    valid = Array.isArray(value)
+  } else {
+    valid = value instanceof type
+  }
+  return {
+    valid,
+    expectedType
+  }
+}
+
+/**
+ * Use function string name to check built-in types,
+ * because a simple equality check will fail when running
+ * across different vms / iframes.
+ */
+function getType (fn) {
+  const match = fn && fn.toString().match(/^\s*function (\w+)/)
+  return match && match[1]
+}
+
+function isType (type, fn) {
+  if (!Array.isArray(fn)) {
+    return getType(fn) === getType(type)
+  }
+  for (let i = 0, len = fn.length; i < len; i++) {
+    if (getType(fn[i]) === getType(type)) {
+      return true
+    }
+  }
+  /* istanbul ignore next */
+  return false
+}
Index: public/node_modules/vue-select2/dist/vue-select.min.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/dist/vue-select.min.js	(revision )
+++ public/node_modules/vue-select2/dist/vue-select.min.js	(revision )
@@ -0,0 +1,6 @@
+/*!
+ * vue-select2 v0.2.6
+ * (c) 2016 Haixing Hu
+ * Released under the MIT License.
+ */
+!function(e){function t(n){if(o[n])return o[n].exports;var i=o[n]={exports:{},id:n,loaded:!1};return e[n].call(i.exports,i,i.exports,t),i.loaded=!0,i.exports}var o={};return t.m=e,t.c=o,t.p="",t(0)}([function(e,t,o){var n="en-US";e.exports={replace:!0,inherit:!1,template:"<select class='form-control' v-model='model' :name='name' style='width: 100%'><option v-if='optionsType === \"values\"' v-for='val in options' :value='val'>{{val}}</option><option v-if='optionsType === \"options\"' v-for='opt in options' :value='opt.value'>{{opt.text}}</option><optgroup v-if='optionsType === \"groups\"' v-for='group in options' :label='group.label'><option v-for='opt in group.options' :value='opt.value'>{{opt.text}}</option></optgroup></select>",props:{options:{type:Array,required:!0},model:{required:!0,twoWay:!0},searchable:{type:Boolean,required:!1,"default":!1},matchValue:{type:Boolean,required:!1,"default":!0},name:{type:String,required:!1,"default":""},language:{type:String,required:!1,"default":""},theme:{type:String,required:!1,"default":"bootstrap"}},data:function(){return{optionsType:"unknown"}},beforeCompile:function(){this.isChanging=!1,this.control=null,this.optionsType=this.getOptionsType()},watch:{options:function(e,t){this.optionsType=this.getOptionsType();var o=this.inOptions(this.model),n=o?this.model:null;this.control.removeData("data"),this.control.val(n).trigger("change")},model:function(e,t){this.isChanging||(this.isChanging=!0,this.control.val(e).trigger("change"),this.isChanging=!1)}},ready:function(){var e=this.language;null!==e&&""!==e||(e=this.$language?this.$language:n);var t={theme:this.theme,language:this.getLanguageCode(e)};this.searchable?this.matchValue&&(t.matcher=o(1)):t.minimumResultsForSearch=1/0,this.control=$(this.$el),this.control.select2(t);var i=this;this.control.on("change",function(e){i.isChanging||(i.isChanging=!0,i.model=i.control.val(),i.$nextTick(function(){i.isChanging=!1}))})},methods:{getOptionsType:function(){if(0===this.options.length)return"values";var e=this.options[0];return"string"==typeof e||e instanceof String?"values":"undefined"!=typeof e.text?"options":"undefined"!=typeof e.label?"groups":"unknown"},inOptions:function(e){var t,o,n=this.getOptionsType(),i=this.options;switch(n){case"values":for(t=0;t<i.length;++t)if(e===i[t])return!0;break;case"options":for(t=0;t<i.length;++t)if(e===i[t].value)return!0;break;case"groups":for(t=0;t<i.length;++t){var r=i[t].options;for(o=0;o<r.length;++o)if(e===r[o].value)return!0}}return!1},getLanguageCode:function(e){if(null===e||0===e.length)return"en";if(e.length<=2)return e;switch(e){case"pt-BR":case"zh-CN":case"zh-TW":return e;default:return e.substr(0,2)}}}}},function(e,t){function o(e){function t(e){return n[e]||e}return e.replace(/[^\u0000-\u007E]/g,t)}var n={"":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"AA","":"AE","":"AE","":"AE","":"AO","":"AU","":"AV","":"AV","":"AY","":"B","":"B","":"B","":"B","":"B","":"B","":"B","":"B","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"DZ","":"DZ","":"Dz","":"Dz","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"F","":"F","":"F","":"F","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"J","":"J","":"J","":"J","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"LJ","":"Lj","":"M","":"M","":"M","":"M","":"M","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"NJ","":"Nj","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"OI","":"OO","":"OU","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"Q","":"Q","":"Q","":"Q","":"Q","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"TZ","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"V","":"V","":"V","":"V","":"V","":"V","":"VY","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"aa","":"ae","":"ae","":"ae","":"ao","":"au","":"av","":"av","":"ay","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"dz","":"dz","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"f","":"f","":"f","":"f","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"hv","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"j","":"j","":"j","":"j","":"j","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"lj","":"m","":"m","":"m","":"m","":"m","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"nj","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"oi","":"ou","":"oo","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"q","":"q","":"q","":"q","":"q","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"tz","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"v","":"v","":"v","":"v","":"v","":"v","":"v","":"vy","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":"","":""};e.exports=matcher=function(e,t){if(""===$.trim(e.term))return t;if(t.children&&t.children.length>0){for(var n=$.extend(!0,{},t),i=t.children.length-1;i>=0;i--){var r=t.children[i],a=matcher(e,r);null==a&&n.children.splice(i,1)}return n.children.length>0?n:matcher(e,n)}var u=o(t.text).toUpperCase(),s=o(e.term).toUpperCase();if(u.indexOf(s)>-1)return t;if(t.id){var l=o(t.id).toUpperCase();if(l.indexOf(s)>-1)return t}return null}}]);
\ No newline at end of file
Index: public/node_modules/vue-resource/node_modules/got/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/index.js	(revision )
@@ -0,0 +1,364 @@
+'use strict';
+const EventEmitter = require('events');
+const http = require('http');
+const https = require('https');
+const PassThrough = require('stream').PassThrough;
+const urlLib = require('url');
+const querystring = require('querystring');
+const duplexer3 = require('duplexer3');
+const isStream = require('is-stream');
+const getStream = require('get-stream');
+const timedOut = require('timed-out');
+const urlParseLax = require('url-parse-lax');
+const lowercaseKeys = require('lowercase-keys');
+const isRedirect = require('is-redirect');
+const unzipResponse = require('unzip-response');
+const createErrorClass = require('create-error-class');
+const isRetryAllowed = require('is-retry-allowed');
+const Buffer = require('safe-buffer').Buffer;
+const pkg = require('./package');
+
+function requestAsEventEmitter(opts) {
+	opts = opts || {};
+
+	const ee = new EventEmitter();
+	const requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);
+	let redirectCount = 0;
+	let retryCount = 0;
+	let redirectUrl;
+
+	const get = opts => {
+		const fn = opts.protocol === 'https:' ? https : http;
+
+		const req = fn.request(opts, res => {
+			const statusCode = res.statusCode;
+
+			if (isRedirect(statusCode) && opts.followRedirect && 'location' in res.headers && (opts.method === 'GET' || opts.method === 'HEAD')) {
+				res.resume();
+
+				if (++redirectCount > 10) {
+					ee.emit('error', new got.MaxRedirectsError(statusCode, opts), null, res);
+					return;
+				}
+
+				const bufferString = Buffer.from(res.headers.location, 'binary').toString();
+
+				redirectUrl = urlLib.resolve(urlLib.format(opts), bufferString);
+				const redirectOpts = Object.assign({}, opts, urlLib.parse(redirectUrl));
+
+				ee.emit('redirect', res, redirectOpts);
+
+				get(redirectOpts);
+
+				return;
+			}
+
+			setImmediate(() => {
+				const response = typeof unzipResponse === 'function' && req.method !== 'HEAD' ? unzipResponse(res) : res;
+				response.url = redirectUrl || requestUrl;
+				response.requestUrl = requestUrl;
+
+				ee.emit('response', response);
+			});
+		});
+
+		req.once('error', err => {
+			const backoff = opts.retries(++retryCount, err);
+
+			if (backoff) {
+				setTimeout(get, backoff, opts);
+				return;
+			}
+
+			ee.emit('error', new got.RequestError(err, opts));
+		});
+
+		if (opts.gotTimeout) {
+			timedOut(req, opts.gotTimeout);
+		}
+
+		setImmediate(() => {
+			ee.emit('request', req);
+		});
+	};
+
+	get(opts);
+	return ee;
+}
+
+function asPromise(opts) {
+	return new Promise((resolve, reject) => {
+		const ee = requestAsEventEmitter(opts);
+
+		ee.on('request', req => {
+			if (isStream(opts.body)) {
+				opts.body.pipe(req);
+				opts.body = undefined;
+				return;
+			}
+
+			req.end(opts.body);
+		});
+
+		ee.on('response', res => {
+			const stream = opts.encoding === null ? getStream.buffer(res) : getStream(res, opts);
+
+			stream
+				.catch(err => reject(new got.ReadError(err, opts)))
+				.then(data => {
+					const statusCode = res.statusCode;
+					const limitStatusCode = opts.followRedirect ? 299 : 399;
+
+					res.body = data;
+
+					if (opts.json && res.body) {
+						try {
+							res.body = JSON.parse(res.body);
+						} catch (e) {
+							throw new got.ParseError(e, statusCode, opts, data);
+						}
+					}
+
+					if (statusCode < 200 || statusCode > limitStatusCode) {
+						throw new got.HTTPError(statusCode, opts);
+					}
+
+					resolve(res);
+				})
+				.catch(err => {
+					Object.defineProperty(err, 'response', {value: res});
+					reject(err);
+				});
+		});
+
+		ee.on('error', reject);
+	});
+}
+
+function asStream(opts) {
+	const input = new PassThrough();
+	const output = new PassThrough();
+	const proxy = duplexer3(input, output);
+
+	if (opts.json) {
+		throw new Error('got can not be used as stream when options.json is used');
+	}
+
+	if (opts.body) {
+		proxy.write = () => {
+			throw new Error('got\'s stream is not writable when options.body is used');
+		};
+	}
+
+	const ee = requestAsEventEmitter(opts);
+
+	ee.on('request', req => {
+		proxy.emit('request', req);
+
+		if (isStream(opts.body)) {
+			opts.body.pipe(req);
+			return;
+		}
+
+		if (opts.body) {
+			req.end(opts.body);
+			return;
+		}
+
+		if (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {
+			input.pipe(req);
+			return;
+		}
+
+		req.end();
+	});
+
+	ee.on('response', res => {
+		const statusCode = res.statusCode;
+
+		res.pipe(output);
+
+		if (statusCode < 200 || statusCode > 299) {
+			proxy.emit('error', new got.HTTPError(statusCode, opts), null, res);
+			return;
+		}
+
+		proxy.emit('response', res);
+	});
+
+	ee.on('redirect', proxy.emit.bind(proxy, 'redirect'));
+	ee.on('error', proxy.emit.bind(proxy, 'error'));
+
+	return proxy;
+}
+
+function normalizeArguments(url, opts) {
+	if (typeof url !== 'string' && typeof url !== 'object') {
+		throw new Error(`Parameter \`url\` must be a string or object, not ${typeof url}`);
+	}
+
+	if (typeof url === 'string') {
+		url = url.replace(/^unix:/, 'http://$&');
+		url = urlParseLax(url);
+
+		if (url.auth) {
+			throw new Error('Basic authentication must be done with auth option');
+		}
+	}
+
+	opts = Object.assign(
+		{
+			protocol: 'http:',
+			path: '',
+			retries: 5
+		},
+		url,
+		opts
+	);
+
+	opts.headers = Object.assign({
+		'user-agent': `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`,
+		'accept-encoding': 'gzip,deflate'
+	}, lowercaseKeys(opts.headers));
+
+	const query = opts.query;
+
+	if (query) {
+		if (typeof query !== 'string') {
+			opts.query = querystring.stringify(query);
+		}
+
+		opts.path = `${opts.path.split('?')[0]}?${opts.query}`;
+		delete opts.query;
+	}
+
+	if (opts.json && opts.headers.accept === undefined) {
+		opts.headers.accept = 'application/json';
+	}
+
+	let body = opts.body;
+
+	if (body) {
+		if (typeof body !== 'string' && !(body !== null && typeof body === 'object')) {
+			throw new Error('options.body must be a ReadableStream, string, Buffer or plain Object');
+		}
+
+		opts.method = opts.method || 'POST';
+
+		if (isStream(body) && typeof body.getBoundary === 'function') {
+			// Special case for https://github.com/form-data/form-data
+			opts.headers['content-type'] = opts.headers['content-type'] || `multipart/form-data; boundary=${body.getBoundary()}`;
+		} else if (body !== null && typeof body === 'object' && !Buffer.isBuffer(body) && !isStream(body)) {
+			opts.headers['content-type'] = opts.headers['content-type'] || 'application/x-www-form-urlencoded';
+			body = opts.body = querystring.stringify(body);
+		}
+
+		if (opts.headers['content-length'] === undefined && opts.headers['transfer-encoding'] === undefined && !isStream(body)) {
+			const length = typeof body === 'string' ? Buffer.byteLength(body) : body.length;
+			opts.headers['content-length'] = length;
+		}
+	}
+
+	opts.method = (opts.method || 'GET').toUpperCase();
+
+	if (opts.hostname === 'unix') {
+		const matches = /(.+):(.+)/.exec(opts.path);
+
+		if (matches) {
+			opts.socketPath = matches[1];
+			opts.path = matches[2];
+			opts.host = null;
+		}
+	}
+
+	if (typeof opts.retries !== 'function') {
+		const retries = opts.retries;
+
+		opts.retries = (iter, err) => {
+			if (iter > retries || !isRetryAllowed(err)) {
+				return 0;
+			}
+
+			const noise = Math.random() * 100;
+
+			return ((1 << iter) * 1000) + noise;
+		};
+	}
+
+	if (opts.followRedirect === undefined) {
+		opts.followRedirect = true;
+	}
+
+	if (opts.timeout) {
+		opts.gotTimeout = opts.timeout;
+		delete opts.timeout;
+	}
+
+	return opts;
+}
+
+function got(url, opts) {
+	try {
+		return asPromise(normalizeArguments(url, opts));
+	} catch (err) {
+		return Promise.reject(err);
+	}
+}
+
+const helpers = [
+	'get',
+	'post',
+	'put',
+	'patch',
+	'head',
+	'delete'
+];
+
+helpers.forEach(el => {
+	got[el] = (url, opts) => got(url, Object.assign({}, opts, {method: el}));
+});
+
+got.stream = (url, opts) => asStream(normalizeArguments(url, opts));
+
+for (const el of helpers) {
+	got.stream[el] = (url, opts) => got.stream(url, Object.assign({}, opts, {method: el}));
+}
+
+function stdError(error, opts) {
+	if (error.code !== undefined) {
+		this.code = error.code;
+	}
+
+	Object.assign(this, {
+		message: error.message,
+		host: opts.host,
+		hostname: opts.hostname,
+		method: opts.method,
+		path: opts.path
+	});
+}
+
+got.RequestError = createErrorClass('RequestError', stdError);
+got.ReadError = createErrorClass('ReadError', stdError);
+got.ParseError = createErrorClass('ParseError', function (e, statusCode, opts, data) {
+	stdError.call(this, e, opts);
+	this.statusCode = statusCode;
+	this.statusMessage = http.STATUS_CODES[this.statusCode];
+	this.message = `${e.message} in "${urlLib.format(opts)}": \n${data.slice(0, 77)}...`;
+});
+
+got.HTTPError = createErrorClass('HTTPError', function (statusCode, opts) {
+	stdError.call(this, {}, opts);
+	this.statusCode = statusCode;
+	this.statusMessage = http.STATUS_CODES[this.statusCode];
+	this.message = `Response code ${this.statusCode} (${this.statusMessage})`;
+});
+
+got.MaxRedirectsError = createErrorClass('MaxRedirectsError', function (statusCode, opts) {
+	stdError.call(this, {}, opts);
+	this.statusCode = statusCode;
+	this.statusMessage = http.STATUS_CODES[this.statusCode];
+	this.message = 'Redirected 10 times. Aborting.';
+});
+
+module.exports = got;
Index: public/node_modules/vue-resource/src/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/index.js	(revision )
+++ public/node_modules/vue-resource/src/index.js	(revision )
@@ -0,0 +1,57 @@
+/**
+ * Install plugin.
+ */
+
+import Url from './url/index';
+import Http from './http/index';
+import Promise from './promise';
+import Resource from './resource';
+import Util, { options } from './util';
+
+function plugin(Vue) {
+
+    if (plugin.installed) {
+        return;
+    }
+
+    Util(Vue);
+
+    Vue.url = Url;
+    Vue.http = Http;
+    Vue.resource = Resource;
+    Vue.Promise = Promise;
+
+    Object.defineProperties(Vue.prototype, {
+
+        $url: {
+            get() {
+                return options(Vue.url, this, this.$options.url);
+            }
+        },
+
+        $http: {
+            get() {
+                return options(Vue.http, this, this.$options.http);
+            }
+        },
+
+        $resource: {
+            get() {
+                return Vue.resource.bind(this);
+            }
+        },
+
+        $promise: {
+            get() {
+                return (executor) => new Vue.Promise(executor, this);
+            }
+        }
+
+    });
+}
+
+if (typeof window !== 'undefined' && window.Vue) {
+    window.Vue.use(plugin);
+}
+
+export default plugin;
Index: public/node_modules/vue-resource/src/http/request.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/request.js	(revision )
+++ public/node_modules/vue-resource/src/http/request.js	(revision )
@@ -0,0 +1,38 @@
+/**
+ * HTTP Request.
+ */
+
+import Url from '../url/index';
+import Headers from './headers';
+import Response from './response';
+import { assign, toUpper } from '../util';
+
+export default class Request {
+
+    constructor(options) {
+
+        this.body = null;
+        this.params = {};
+
+        assign(this, options, {
+            method: toUpper(options.method || 'GET')
+        });
+
+        if (!(this.headers instanceof Headers)) {
+            this.headers = new Headers(this.headers);
+        }
+    }
+
+    getUrl(){
+        return Url(this);
+    }
+
+    getBody(){
+        return this.body;
+    }
+
+    respondWith(body, options) {
+        return new Response(body, assign(options || {}, {url: this.getUrl()}));
+    }
+
+}
Index: public/node_modules/vue-resource/.npmignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/.npmignore	(revision )
+++ public/node_modules/vue-resource/.npmignore	(revision )
@@ -0,0 +1,3 @@
+build
+docs
+bower.json
\ No newline at end of file
Index: public/node_modules/vue/src/platforms/weex/runtime/modules/style.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/modules/style.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/modules/style.js	(revision )
@@ -0,0 +1,68 @@
+/* @flow */
+
+import { extend, cached, camelize } from 'shared/util'
+
+const normalize = cached(camelize)
+
+function createStyle (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (!vnode.data.staticStyle) {
+    updateStyle(oldVnode, vnode)
+    return
+  }
+  const elm = vnode.elm
+  const staticStyle = vnode.data.staticStyle
+  for (const name in staticStyle) {
+    if (staticStyle[name]) {
+      elm.setStyle(normalize(name), staticStyle[name])
+    }
+  }
+  updateStyle(oldVnode, vnode)
+}
+
+function updateStyle (oldVnode: VNodeWithData, vnode: VNodeWithData) {
+  if (!oldVnode.data.style && !vnode.data.style) {
+    return
+  }
+  let cur, name
+  const elm = vnode.elm
+  const oldStyle: any = oldVnode.data.style || {}
+  let style: any = vnode.data.style || {}
+
+  const needClone = style.__ob__
+
+  // handle array syntax
+  if (Array.isArray(style)) {
+    style = vnode.data.style = toObject(style)
+  }
+
+  // clone the style for future updates,
+  // in case the user mutates the style object in-place.
+  if (needClone) {
+    style = vnode.data.style = extend({}, style)
+  }
+
+  for (name in oldStyle) {
+    if (!style[name]) {
+      elm.setStyle(normalize(name), '')
+    }
+  }
+  for (name in style) {
+    cur = style[name]
+    elm.setStyle(normalize(name), cur)
+  }
+}
+
+function toObject (arr) {
+  const res = {}
+  for (var i = 0; i < arr.length; i++) {
+    if (arr[i]) {
+      extend(res, arr[i])
+    }
+  }
+  return res
+}
+
+export default {
+  create: createStyle,
+  update: updateStyle
+}
Index: public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/safe-buffer/package.json	(revision )
@@ -0,0 +1,46 @@
+{
+  "name": "safe-buffer",
+  "description": "Safer Node.js Buffer API",
+  "version": "5.0.1",
+  "author": {
+    "name": "Feross Aboukhadijeh",
+    "email": "feross@feross.org",
+    "url": "http://feross.org"
+  },
+  "bugs": {
+    "url": "https://github.com/feross/safe-buffer/issues"
+  },
+  "browser": "./browser.js",
+  "devDependencies": {
+    "standard": "^7.0.0",
+    "tape": "^4.0.0",
+    "zuul": "^3.0.0"
+  },
+  "homepage": "https://github.com/feross/safe-buffer",
+  "keywords": [
+    "buffer",
+    "buffer allocate",
+    "node security",
+    "safe",
+    "safe-buffer",
+    "security",
+    "uninitialized"
+  ],
+  "license": "MIT",
+  "main": "index.js",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/feross/safe-buffer.git"
+  },
+  "scripts": {
+    "test": "standard && tape test.js"
+  },
+  "readme": "# safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![downloads][downloads-image]][npm-url]\n\n#### Safer Node.js Buffer API\n\n**Use the new Node.js v6 Buffer APIs (`Buffer.from`, `Buffer.alloc`,\n`Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`) in Node.js v0.10, v0.12, v4.x, and v5.x.**\n\n**Uses the built-in implementations when available.**\n\n[travis-image]: https://img.shields.io/travis/feross/safe-buffer.svg\n[travis-url]: https://travis-ci.org/feross/safe-buffer\n[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg\n[npm-url]: https://npmjs.org/package/safe-buffer\n[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg\n\n## install\n\n```\nnpm install safe-buffer\n```\n\n## usage\n\nThe goal of this package is to provide a safe replacement for the node.js `Buffer`.\n\nIt's a drop-in replacement for `Buffer`. You can use it by adding one `require` line to\nthe top of your node.js modules:\n\n```js\nvar Buffer = require('safe-buffer').Buffer\n\n// Existing buffer code will continue to work without issues:\n\nnew Buffer('hey', 'utf8')\nnew Buffer([1, 2, 3], 'utf8')\nnew Buffer(obj)\nnew Buffer(16) // create an uninitialized buffer (potentially unsafe)\n\n// But you can use these new explicit APIs to make clear what you want:\n\nBuffer.from('hey', 'utf8') // convert from many types to a Buffer\nBuffer.alloc(16) // create a zero-filled buffer (safe)\nBuffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)\n```\n\n## api\n\n### Class Method: Buffer.from(array)\n<!-- YAML\nadded: v3.0.0\n-->\n\n* `array` {Array}\n\nAllocates a new `Buffer` using an `array` of octets.\n\n```js\nconst buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);\n  // creates a new Buffer containing ASCII bytes\n  // ['b','u','f','f','e','r']\n```\n\nA `TypeError` will be thrown if `array` is not an `Array`.\n\n### Class Method: Buffer.from(arrayBuffer[, byteOffset[, length]])\n<!-- YAML\nadded: v5.10.0\n-->\n\n* `arrayBuffer` {ArrayBuffer} The `.buffer` property of a `TypedArray` or\n  a `new ArrayBuffer()`\n* `byteOffset` {Number} Default: `0`\n* `length` {Number} Default: `arrayBuffer.length - byteOffset`\n\nWhen passed a reference to the `.buffer` property of a `TypedArray` instance,\nthe newly created `Buffer` will share the same allocated memory as the\nTypedArray.\n\n```js\nconst arr = new Uint16Array(2);\narr[0] = 5000;\narr[1] = 4000;\n\nconst buf = Buffer.from(arr.buffer); // shares the memory with arr;\n\nconsole.log(buf);\n  // Prints: <Buffer 88 13 a0 0f>\n\n// changing the TypedArray changes the Buffer also\narr[1] = 6000;\n\nconsole.log(buf);\n  // Prints: <Buffer 88 13 70 17>\n```\n\nThe optional `byteOffset` and `length` arguments specify a memory range within\nthe `arrayBuffer` that will be shared by the `Buffer`.\n\n```js\nconst ab = new ArrayBuffer(10);\nconst buf = Buffer.from(ab, 0, 2);\nconsole.log(buf.length);\n  // Prints: 2\n```\n\nA `TypeError` will be thrown if `arrayBuffer` is not an `ArrayBuffer`.\n\n### Class Method: Buffer.from(buffer)\n<!-- YAML\nadded: v3.0.0\n-->\n\n* `buffer` {Buffer}\n\nCopies the passed `buffer` data onto a new `Buffer` instance.\n\n```js\nconst buf1 = Buffer.from('buffer');\nconst buf2 = Buffer.from(buf1);\n\nbuf1[0] = 0x61;\nconsole.log(buf1.toString());\n  // 'auffer'\nconsole.log(buf2.toString());\n  // 'buffer' (copy is not changed)\n```\n\nA `TypeError` will be thrown if `buffer` is not a `Buffer`.\n\n### Class Method: Buffer.from(str[, encoding])\n<!-- YAML\nadded: v5.10.0\n-->\n\n* `str` {String} String to encode.\n* `encoding` {String} Encoding to use, Default: `'utf8'`\n\nCreates a new `Buffer` containing the given JavaScript string `str`. If\nprovided, the `encoding` parameter identifies the character encoding.\nIf not provided, `encoding` defaults to `'utf8'`.\n\n```js\nconst buf1 = Buffer.from('this is a tst');\nconsole.log(buf1.toString());\n  // prints: this is a tst\nconsole.log(buf1.toString('ascii'));\n  // prints: this is a tC)st\n\nconst buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');\nconsole.log(buf2.toString());\n  // prints: this is a tst\n```\n\nA `TypeError` will be thrown if `str` is not a string.\n\n### Class Method: Buffer.alloc(size[, fill[, encoding]])\n<!-- YAML\nadded: v5.10.0\n-->\n\n* `size` {Number}\n* `fill` {Value} Default: `undefined`\n* `encoding` {String} Default: `utf8`\n\nAllocates a new `Buffer` of `size` bytes. If `fill` is `undefined`, the\n`Buffer` will be *zero-filled*.\n\n```js\nconst buf = Buffer.alloc(5);\nconsole.log(buf);\n  // <Buffer 00 00 00 00 00>\n```\n\nThe `size` must be less than or equal to the value of\n`require('buffer').kMaxLength` (on 64-bit architectures, `kMaxLength` is\n`(2^31)-1`). Otherwise, a [`RangeError`][] is thrown. A zero-length Buffer will\nbe created if a `size` less than or equal to 0 is specified.\n\nIf `fill` is specified, the allocated `Buffer` will be initialized by calling\n`buf.fill(fill)`. See [`buf.fill()`][] for more information.\n\n```js\nconst buf = Buffer.alloc(5, 'a');\nconsole.log(buf);\n  // <Buffer 61 61 61 61 61>\n```\n\nIf both `fill` and `encoding` are specified, the allocated `Buffer` will be\ninitialized by calling `buf.fill(fill, encoding)`. For example:\n\n```js\nconst buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');\nconsole.log(buf);\n  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>\n```\n\nCalling `Buffer.alloc(size)` can be significantly slower than the alternative\n`Buffer.allocUnsafe(size)` but ensures that the newly created `Buffer` instance\ncontents will *never contain sensitive data*.\n\nA `TypeError` will be thrown if `size` is not a number.\n\n### Class Method: Buffer.allocUnsafe(size)\n<!-- YAML\nadded: v5.10.0\n-->\n\n* `size` {Number}\n\nAllocates a new *non-zero-filled* `Buffer` of `size` bytes.  The `size` must\nbe less than or equal to the value of `require('buffer').kMaxLength` (on 64-bit\narchitectures, `kMaxLength` is `(2^31)-1`). Otherwise, a [`RangeError`][] is\nthrown. A zero-length Buffer will be created if a `size` less than or equal to\n0 is specified.\n\nThe underlying memory for `Buffer` instances created in this way is *not\ninitialized*. The contents of the newly created `Buffer` are unknown and\n*may contain sensitive data*. Use [`buf.fill(0)`][] to initialize such\n`Buffer` instances to zeroes.\n\n```js\nconst buf = Buffer.allocUnsafe(5);\nconsole.log(buf);\n  // <Buffer 78 e0 82 02 01>\n  // (octets will be different, every time)\nbuf.fill(0);\nconsole.log(buf);\n  // <Buffer 00 00 00 00 00>\n```\n\nA `TypeError` will be thrown if `size` is not a number.\n\nNote that the `Buffer` module pre-allocates an internal `Buffer` instance of\nsize `Buffer.poolSize` that is used as a pool for the fast allocation of new\n`Buffer` instances created using `Buffer.allocUnsafe(size)` (and the deprecated\n`new Buffer(size)` constructor) only when `size` is less than or equal to\n`Buffer.poolSize >> 1` (floor of `Buffer.poolSize` divided by two). The default\nvalue of `Buffer.poolSize` is `8192` but can be modified.\n\nUse of this pre-allocated internal memory pool is a key difference between\ncalling `Buffer.alloc(size, fill)` vs. `Buffer.allocUnsafe(size).fill(fill)`.\nSpecifically, `Buffer.alloc(size, fill)` will *never* use the internal Buffer\npool, while `Buffer.allocUnsafe(size).fill(fill)` *will* use the internal\nBuffer pool if `size` is less than or equal to half `Buffer.poolSize`. The\ndifference is subtle but can be important when an application requires the\nadditional performance that `Buffer.allocUnsafe(size)` provides.\n\n### Class Method: Buffer.allocUnsafeSlow(size)\n<!-- YAML\nadded: v5.10.0\n-->\n\n* `size` {Number}\n\nAllocates a new *non-zero-filled* and non-pooled `Buffer` of `size` bytes.  The\n`size` must be less than or equal to the value of\n`require('buffer').kMaxLength` (on 64-bit architectures, `kMaxLength` is\n`(2^31)-1`). Otherwise, a [`RangeError`][] is thrown. A zero-length Buffer will\nbe created if a `size` less than or equal to 0 is specified.\n\nThe underlying memory for `Buffer` instances created in this way is *not\ninitialized*. The contents of the newly created `Buffer` are unknown and\n*may contain sensitive data*. Use [`buf.fill(0)`][] to initialize such\n`Buffer` instances to zeroes.\n\nWhen using `Buffer.allocUnsafe()` to allocate new `Buffer` instances,\nallocations under 4KB are, by default, sliced from a single pre-allocated\n`Buffer`. This allows applications to avoid the garbage collection overhead of\ncreating many individually allocated Buffers. This approach improves both\nperformance and memory usage by eliminating the need to track and cleanup as\nmany `Persistent` objects.\n\nHowever, in the case where a developer may need to retain a small chunk of\nmemory from a pool for an indeterminate amount of time, it may be appropriate\nto create an un-pooled Buffer instance using `Buffer.allocUnsafeSlow()` then\ncopy out the relevant bits.\n\n```js\n// need to keep around a few small chunks of memory\nconst store = [];\n\nsocket.on('readable', () => {\n  const data = socket.read();\n  // allocate for retained data\n  const sb = Buffer.allocUnsafeSlow(10);\n  // copy the data into the new allocation\n  data.copy(sb, 0, 0, 10);\n  store.push(sb);\n});\n```\n\nUse of `Buffer.allocUnsafeSlow()` should be used only as a last resort *after*\na developer has observed undue memory retention in their applications.\n\nA `TypeError` will be thrown if `size` is not a number.\n\n### All the Rest\n\nThe rest of the `Buffer` API is exactly the same as in node.js.\n[See the docs](https://nodejs.org/api/buffer.html).\n\n\n## Related links\n\n- [Node.js issue: Buffer(number) is unsafe](https://github.com/nodejs/node/issues/4660)\n- [Node.js Enhancement Proposal: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() soft-deprecate](https://github.com/nodejs/node-eps/pull/4)\n\n## Why is `Buffer` unsafe?\n\nToday, the node.js `Buffer` constructor is overloaded to handle many different argument\ntypes like `String`, `Array`, `Object`, `TypedArrayView` (`Uint8Array`, etc.),\n`ArrayBuffer`, and also `Number`.\n\nThe API is optimized for convenience: you can throw any type at it, and it will try to do\nwhat you want.\n\nBecause the Buffer constructor is so powerful, you often see code like this:\n\n```js\n// Convert UTF-8 strings to hex\nfunction toHex (str) {\n  return new Buffer(str).toString('hex')\n}\n```\n\n***But what happens if `toHex` is called with a `Number` argument?***\n\n### Remote Memory Disclosure\n\nIf an attacker can make your program call the `Buffer` constructor with a `Number`\nargument, then they can make it allocate uninitialized memory from the node.js process.\nThis could potentially disclose TLS private keys, user data, or database passwords.\n\nWhen the `Buffer` constructor is passed a `Number` argument, it returns an\n**UNINITIALIZED** block of memory of the specified `size`. When you create a `Buffer` like\nthis, you **MUST** overwrite the contents before returning it to the user.\n\nFrom the [node.js docs](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):\n\n> `new Buffer(size)`\n>\n> - `size` Number\n>\n> The underlying memory for `Buffer` instances created in this way is not initialized.\n> **The contents of a newly created `Buffer` are unknown and could contain sensitive\n> data.** Use `buf.fill(0)` to initialize a Buffer to zeroes.\n\n(Emphasis our own.)\n\nWhenever the programmer intended to create an uninitialized `Buffer` you often see code\nlike this:\n\n```js\nvar buf = new Buffer(16)\n\n// Immediately overwrite the uninitialized buffer with data from another buffer\nfor (var i = 0; i < buf.length; i++) {\n  buf[i] = otherBuf[i]\n}\n```\n\n\n### Would this ever be a problem in real code?\n\nYes. It's surprisingly common to forget to check the type of your variables in a\ndynamically-typed language like JavaScript.\n\nUsually the consequences of assuming the wrong type is that your program crashes with an\nuncaught exception. But the failure mode for forgetting to check the type of arguments to\nthe `Buffer` constructor is more catastrophic.\n\nHere's an example of a vulnerable service that takes a JSON payload and converts it to\nhex:\n\n```js\n// Take a JSON payload {str: \"some string\"} and convert it to hex\nvar server = http.createServer(function (req, res) {\n  var data = ''\n  req.setEncoding('utf8')\n  req.on('data', function (chunk) {\n    data += chunk\n  })\n  req.on('end', function () {\n    var body = JSON.parse(data)\n    res.end(new Buffer(body.str).toString('hex'))\n  })\n})\n\nserver.listen(8080)\n```\n\nIn this example, an http client just has to send:\n\n```json\n{\n  \"str\": 1000\n}\n```\n\nand it will get back 1,000 bytes of uninitialized memory from the server.\n\nThis is a very serious bug. It's similar in severity to the\n[the Heartbleed bug](http://heartbleed.com/) that allowed disclosure of OpenSSL process\nmemory by remote attackers.\n\n\n### Which real-world packages were vulnerable?\n\n#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)\n\n[Mathias Buus](https://github.com/mafintosh) and I\n([Feross Aboukhadijeh](http://feross.org/)) found this issue in one of our own packages,\n[`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). The bug would allow\nanyone on the internet to send a series of messages to a user of `bittorrent-dht` and get\nthem to reveal 20 bytes at a time of uninitialized memory from the node.js process.\n\nHere's\n[the commit](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8)\nthat fixed it. We released a new fixed version, created a\n[Node Security Project disclosure](https://nodesecurity.io/advisories/68), and deprecated all\nvulnerable versions on npm so users will get a warning to upgrade to a newer version.\n\n#### [`ws`](https://www.npmjs.com/package/ws)\n\nThat got us wondering if there were other vulnerable packages. Sure enough, within a short\nperiod of time, we found the same issue in [`ws`](https://www.npmjs.com/package/ws), the\nmost popular WebSocket implementation in node.js.\n\nIf certain APIs were called with `Number` parameters instead of `String` or `Buffer` as\nexpected, then uninitialized server memory would be disclosed to the remote peer.\n\nThese were the vulnerable methods:\n\n```js\nsocket.send(number)\nsocket.ping(number)\nsocket.pong(number)\n```\n\nHere's a vulnerable socket server with some echo functionality:\n\n```js\nserver.on('connection', function (socket) {\n  socket.on('message', function (message) {\n    message = JSON.parse(message)\n    if (message.type === 'echo') {\n      socket.send(message.data) // send back the user's message\n    }\n  })\n})\n```\n\n`socket.send(number)` called on the server, will disclose server memory.\n\nHere's [the release](https://github.com/websockets/ws/releases/tag/1.0.1) where the issue\nwas fixed, with a more detailed explanation. Props to\n[Arnout Kazemier](https://github.com/3rd-Eden) for the quick fix. Here's the\n[Node Security Project disclosure](https://nodesecurity.io/advisories/67).\n\n\n### What's the solution?\n\nIt's important that node.js offers a fast way to get memory otherwise performance-critical\napplications would needlessly get a lot slower.\n\nBut we need a better way to *signal our intent* as programmers. **When we want\nuninitialized memory, we should request it explicitly.**\n\nSensitive functionality should not be packed into a developer-friendly API that loosely\naccepts many different types. This type of API encourages the lazy practice of passing\nvariables in without checking the type very carefully.\n\n#### A new API: `Buffer.allocUnsafe(number)`\n\nThe functionality of creating buffers with uninitialized memory should be part of another\nAPI. We propose `Buffer.allocUnsafe(number)`. This way, it's not part of an API that\nfrequently gets user input of all sorts of different types passed into it.\n\n```js\nvar buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!\n\n// Immediately overwrite the uninitialized buffer with data from another buffer\nfor (var i = 0; i < buf.length; i++) {\n  buf[i] = otherBuf[i]\n}\n```\n\n\n### How do we fix node.js core?\n\nWe sent [a PR to node.js core](https://github.com/nodejs/node/pull/4514) (merged as\n`semver-major`) which defends against one case:\n\n```js\nvar str = 16\nnew Buffer(str, 'utf8')\n```\n\nIn this situation, it's implied that the programmer intended the first argument to be a\nstring, since they passed an encoding as a second argument. Today, node.js will allocate\nuninitialized memory in the case of `new Buffer(number, encoding)`, which is probably not\nwhat the programmer intended.\n\nBut this is only a partial solution, since if the programmer does `new Buffer(variable)`\n(without an `encoding` parameter) there's no way to know what they intended. If `variable`\nis sometimes a number, then uninitialized memory will sometimes be returned.\n\n### What's the real long-term fix?\n\nWe could deprecate and remove `new Buffer(number)` and use `Buffer.allocUnsafe(number)` when\nwe need uninitialized memory. But that would break 1000s of packages.\n\n~~We believe the best solution is to:~~\n\n~~1. Change `new Buffer(number)` to return safe, zeroed-out memory~~\n\n~~2. Create a new API for creating uninitialized Buffers. We propose: `Buffer.allocUnsafe(number)`~~\n\n#### Update\n\nWe now support adding three new APIs:\n\n- `Buffer.from(value)` - convert from any type to a buffer\n- `Buffer.alloc(size)` - create a zero-filled buffer\n- `Buffer.allocUnsafe(size)` - create an uninitialized buffer with given size\n\nThis solves the core problem that affected `ws` and `bittorrent-dht` which is\n`Buffer(variable)` getting tricked into taking a number argument.\n\nThis way, existing code continues working and the impact on the npm ecosystem will be\nminimal. Over time, npm maintainers can migrate performance-critical code to use\n`Buffer.allocUnsafe(number)` instead of `new Buffer(number)`.\n\n\n### Conclusion\n\nWe think there's a serious design issue with the `Buffer` API as it exists today. It\npromotes insecure software by putting high-risk functionality into a convenient API\nwith friendly \"developer ergonomics\".\n\nThis wasn't merely a theoretical exercise because we found the issue in some of the\nmost popular npm packages.\n\nFortunately, there's an easy fix that can be applied today. Use `safe-buffer` in place of\n`buffer`.\n\n```js\nvar Buffer = require('safe-buffer').Buffer\n```\n\nEventually, we hope that node.js core can switch to this new, safer behavior. We believe\nthe impact on the ecosystem would be minimal since it's not a breaking change.\nWell-maintained, popular packages would be updated to use `Buffer.alloc` quickly, while\nolder, insecure packages would magically become safe from this attack vector.\n\n\n## links\n\n- [Node.js PR: buffer: throw if both length and enc are passed](https://github.com/nodejs/node/pull/4514)\n- [Node Security Project disclosure for `ws`](https://nodesecurity.io/advisories/67)\n- [Node Security Project disclosure for`bittorrent-dht`](https://nodesecurity.io/advisories/68)\n\n\n## credit\n\nThe original issues in `bittorrent-dht`\n([disclosure](https://nodesecurity.io/advisories/68)) and\n`ws` ([disclosure](https://nodesecurity.io/advisories/67)) were discovered by\n[Mathias Buus](https://github.com/mafintosh) and\n[Feross Aboukhadijeh](http://feross.org/).\n\nThanks to [Adam Baldwin](https://github.com/evilpacket) for helping disclose these issues\nand for his work running the [Node Security Project](https://nodesecurity.io/).\n\nThanks to [John Hiesey](https://github.com/jhiesey) for proofreading this README and\nauditing the code.\n\n\n## license\n\nMIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)\n",
+  "readmeFilename": "README.md",
+  "_id": "safe-buffer@5.0.1",
+  "dist": {
+    "shasum": "4315ba90da80d050c8a3d02f93f2b08ea5adb1e6"
+  },
+  "_from": "safe-buffer@^5.0.1",
+  "_resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.0.1.tgz"
+}
Index: public/node_modules/vue-select2/LICENSE
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-select2/LICENSE	(revision )
+++ public/node_modules/vue-select2/LICENSE	(revision )
@@ -0,0 +1,22 @@
+The MIT License (MIT)
+
+Copyright (c) 2015 Haixing Hu
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
Index: public/node_modules/vue/src/core/vdom/patch.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/vdom/patch.js	(revision )
+++ public/node_modules/vue/src/core/vdom/patch.js	(revision )
@@ -0,0 +1,635 @@
+/**
+ * Virtual DOM patching algorithm based on Snabbdom by
+ * Simon Friis Vindum (@paldepind)
+ * Licensed under the MIT License
+ * https://github.com/paldepind/snabbdom/blob/master/LICENSE
+ *
+ * modified by Evan You (@yyx990803)
+ *
+
+/*
+ * Not type-checking this because this file is perf-critical and the cost
+ * of making flow understand it is not worth it.
+ */
+
+import config from '../config'
+import VNode from './vnode'
+import { makeMap, isPrimitive, warn } from '../util/index'
+import { activeInstance } from '../instance/lifecycle'
+import { registerRef } from './modules/ref'
+
+export const emptyNode = new VNode('', {}, [])
+
+const hooks = ['create', 'activate', 'update', 'remove', 'destroy']
+
+function isUndef (s) {
+  return s == null
+}
+
+function isDef (s) {
+  return s != null
+}
+
+function sameVnode (vnode1, vnode2) {
+  return (
+    vnode1.key === vnode2.key &&
+    vnode1.tag === vnode2.tag &&
+    vnode1.isComment === vnode2.isComment &&
+    !vnode1.data === !vnode2.data
+  )
+}
+
+function createKeyToOldIdx (children, beginIdx, endIdx) {
+  let i, key
+  const map = {}
+  for (i = beginIdx; i <= endIdx; ++i) {
+    key = children[i].key
+    if (isDef(key)) map[key] = i
+  }
+  return map
+}
+
+export function createPatchFunction (backend) {
+  let i, j
+  const cbs = {}
+
+  const { modules, nodeOps } = backend
+
+  for (i = 0; i < hooks.length; ++i) {
+    cbs[hooks[i]] = []
+    for (j = 0; j < modules.length; ++j) {
+      if (modules[j][hooks[i]] !== undefined) cbs[hooks[i]].push(modules[j][hooks[i]])
+    }
+  }
+
+  function emptyNodeAt (elm) {
+    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
+  }
+
+  function createRmCb (childElm, listeners) {
+    function remove () {
+      if (--remove.listeners === 0) {
+        removeNode(childElm)
+      }
+    }
+    remove.listeners = listeners
+    return remove
+  }
+
+  function removeNode (el) {
+    const parent = nodeOps.parentNode(el)
+    // element may have already been removed due to v-html / v-text
+    if (parent) {
+      nodeOps.removeChild(parent, el)
+    }
+  }
+
+  let inPre = 0
+  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {
+    vnode.isRootInsert = !nested // for transition enter check
+    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
+      return
+    }
+
+    const data = vnode.data
+    const children = vnode.children
+    const tag = vnode.tag
+    if (isDef(tag)) {
+      if (process.env.NODE_ENV !== 'production') {
+        if (data && data.pre) {
+          inPre++
+        }
+        if (
+          !inPre &&
+          !vnode.ns &&
+          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&
+          config.isUnknownElement(tag)
+        ) {
+          warn(
+            'Unknown custom element: <' + tag + '> - did you ' +
+            'register the component correctly? For recursive components, ' +
+            'make sure to provide the "name" option.',
+            vnode.context
+          )
+        }
+      }
+      vnode.elm = vnode.ns
+        ? nodeOps.createElementNS(vnode.ns, tag)
+        : nodeOps.createElement(tag, vnode)
+      setScope(vnode)
+
+      /* istanbul ignore if */
+      if (__WEEX__) {
+        // in Weex, the default insertion order is parent-first.
+        // List items can be optimized to use children-first insertion
+        // with append="tree".
+        const appendAsTree = data && data.appendAsTree
+        if (!appendAsTree) {
+          if (isDef(data)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue)
+          }
+          insert(parentElm, vnode.elm, refElm)
+        }
+        createChildren(vnode, children, insertedVnodeQueue)
+        if (appendAsTree) {
+          if (isDef(data)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue)
+          }
+          insert(parentElm, vnode.elm, refElm)
+        }
+      } else {
+        createChildren(vnode, children, insertedVnodeQueue)
+        if (isDef(data)) {
+          invokeCreateHooks(vnode, insertedVnodeQueue)
+        }
+        insert(parentElm, vnode.elm, refElm)
+      }
+
+      if (process.env.NODE_ENV !== 'production' && data && data.pre) {
+        inPre--
+      }
+    } else if (vnode.isComment) {
+      vnode.elm = nodeOps.createComment(vnode.text)
+      insert(parentElm, vnode.elm, refElm)
+    } else {
+      vnode.elm = nodeOps.createTextNode(vnode.text)
+      insert(parentElm, vnode.elm, refElm)
+    }
+  }
+
+  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    let i = vnode.data
+    if (isDef(i)) {
+      const isReactivated = isDef(vnode.componentInstance) && i.keepAlive
+      if (isDef(i = i.hook) && isDef(i = i.init)) {
+        i(vnode, false /* hydrating */, parentElm, refElm)
+      }
+      // after calling the init hook, if the vnode is a child component
+      // it should've created a child instance and mounted it. the child
+      // component also has set the placeholder vnode's elm.
+      // in that case we can just return the element and be done.
+      if (isDef(vnode.componentInstance)) {
+        initComponent(vnode, insertedVnodeQueue)
+        if (isReactivated) {
+          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)
+        }
+        return true
+      }
+    }
+  }
+
+  function initComponent (vnode, insertedVnodeQueue) {
+    if (vnode.data.pendingInsert) {
+      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert)
+    }
+    vnode.elm = vnode.componentInstance.$el
+    if (isPatchable(vnode)) {
+      invokeCreateHooks(vnode, insertedVnodeQueue)
+      setScope(vnode)
+    } else {
+      // empty component root.
+      // skip all element-related modules except for ref (#3455)
+      registerRef(vnode)
+      // make sure to invoke the insert hook
+      insertedVnodeQueue.push(vnode)
+    }
+  }
+
+  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
+    let i
+    // hack for #4339: a reactivated component with inner transition
+    // does not trigger because the inner node's created hooks are not called
+    // again. It's not ideal to involve module-specific logic in here but
+    // there doesn't seem to be a better way to do it.
+    let innerNode = vnode
+    while (innerNode.componentInstance) {
+      innerNode = innerNode.componentInstance._vnode
+      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
+        for (i = 0; i < cbs.activate.length; ++i) {
+          cbs.activate[i](emptyNode, innerNode)
+        }
+        insertedVnodeQueue.push(innerNode)
+        break
+      }
+    }
+    // unlike a newly created component,
+    // a reactivated keep-alive component doesn't insert itself
+    insert(parentElm, vnode.elm, refElm)
+  }
+
+  function insert (parent, elm, ref) {
+    if (parent) {
+      if (ref) {
+        nodeOps.insertBefore(parent, elm, ref)
+      } else {
+        nodeOps.appendChild(parent, elm)
+      }
+    }
+  }
+
+  function createChildren (vnode, children, insertedVnodeQueue) {
+    if (Array.isArray(children)) {
+      for (let i = 0; i < children.length; ++i) {
+        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true)
+      }
+    } else if (isPrimitive(vnode.text)) {
+      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text))
+    }
+  }
+
+  function isPatchable (vnode) {
+    while (vnode.componentInstance) {
+      vnode = vnode.componentInstance._vnode
+    }
+    return isDef(vnode.tag)
+  }
+
+  function invokeCreateHooks (vnode, insertedVnodeQueue) {
+    for (let i = 0; i < cbs.create.length; ++i) {
+      cbs.create[i](emptyNode, vnode)
+    }
+    i = vnode.data.hook // Reuse variable
+    if (isDef(i)) {
+      if (i.create) i.create(emptyNode, vnode)
+      if (i.insert) insertedVnodeQueue.push(vnode)
+    }
+  }
+
+  // set scope id attribute for scoped CSS.
+  // this is implemented as a special case to avoid the overhead
+  // of going through the normal attribute patching process.
+  function setScope (vnode) {
+    let i
+    let ancestor = vnode
+    while (ancestor) {
+      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
+        nodeOps.setAttribute(vnode.elm, i, '')
+      }
+      ancestor = ancestor.parent
+    }
+    // for slot content they should also get the scopeId from the host instance.
+    if (isDef(i = activeInstance) &&
+        i !== vnode.context &&
+        isDef(i = i.$options._scopeId)) {
+      nodeOps.setAttribute(vnode.elm, i, '')
+    }
+  }
+
+  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm)
+    }
+  }
+
+  function invokeDestroyHook (vnode) {
+    let i, j
+    const data = vnode.data
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode)
+      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode)
+    }
+    if (isDef(i = vnode.children)) {
+      for (j = 0; j < vnode.children.length; ++j) {
+        invokeDestroyHook(vnode.children[j])
+      }
+    }
+  }
+
+  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
+    for (; startIdx <= endIdx; ++startIdx) {
+      const ch = vnodes[startIdx]
+      if (isDef(ch)) {
+        if (isDef(ch.tag)) {
+          removeAndInvokeRemoveHook(ch)
+          invokeDestroyHook(ch)
+        } else { // Text node
+          removeNode(ch.elm)
+        }
+      }
+    }
+  }
+
+  function removeAndInvokeRemoveHook (vnode, rm) {
+    if (rm || isDef(vnode.data)) {
+      const listeners = cbs.remove.length + 1
+      if (!rm) {
+        // directly removing
+        rm = createRmCb(vnode.elm, listeners)
+      } else {
+        // we have a recursively passed down rm callback
+        // increase the listeners count
+        rm.listeners += listeners
+      }
+      // recursively invoke hooks on child component root node
+      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
+        removeAndInvokeRemoveHook(i, rm)
+      }
+      for (i = 0; i < cbs.remove.length; ++i) {
+        cbs.remove[i](vnode, rm)
+      }
+      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
+        i(vnode, rm)
+      } else {
+        rm()
+      }
+    } else {
+      removeNode(vnode.elm)
+    }
+  }
+
+  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
+    let oldStartIdx = 0
+    let newStartIdx = 0
+    let oldEndIdx = oldCh.length - 1
+    let oldStartVnode = oldCh[0]
+    let oldEndVnode = oldCh[oldEndIdx]
+    let newEndIdx = newCh.length - 1
+    let newStartVnode = newCh[0]
+    let newEndVnode = newCh[newEndIdx]
+    let oldKeyToIdx, idxInOld, elmToMove, refElm
+
+    // removeOnly is a special flag used only by <transition-group>
+    // to ensure removed elements stay in correct relative positions
+    // during leaving transitions
+    const canMove = !removeOnly
+
+    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
+      if (isUndef(oldStartVnode)) {
+        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
+      } else if (isUndef(oldEndVnode)) {
+        oldEndVnode = oldCh[--oldEndIdx]
+      } else if (sameVnode(oldStartVnode, newStartVnode)) {
+        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
+        oldStartVnode = oldCh[++oldStartIdx]
+        newStartVnode = newCh[++newStartIdx]
+      } else if (sameVnode(oldEndVnode, newEndVnode)) {
+        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
+        oldEndVnode = oldCh[--oldEndIdx]
+        newEndVnode = newCh[--newEndIdx]
+      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
+        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
+        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
+        oldStartVnode = oldCh[++oldStartIdx]
+        newEndVnode = newCh[--newEndIdx]
+      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
+        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
+        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
+        oldEndVnode = oldCh[--oldEndIdx]
+        newStartVnode = newCh[++newStartIdx]
+      } else {
+        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
+        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null
+        if (isUndef(idxInOld)) { // New element
+          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)
+          newStartVnode = newCh[++newStartIdx]
+        } else {
+          elmToMove = oldCh[idxInOld]
+          /* istanbul ignore if */
+          if (process.env.NODE_ENV !== 'production' && !elmToMove) {
+            warn(
+              'It seems there are duplicate keys that is causing an update error. ' +
+              'Make sure each v-for item has a unique key.'
+            )
+          }
+          if (sameVnode(elmToMove, newStartVnode)) {
+            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)
+            oldCh[idxInOld] = undefined
+            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)
+            newStartVnode = newCh[++newStartIdx]
+          } else {
+            // same key but different element. treat as new element
+            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)
+            newStartVnode = newCh[++newStartIdx]
+          }
+        }
+      }
+    }
+    if (oldStartIdx > oldEndIdx) {
+      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
+      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
+    } else if (newStartIdx > newEndIdx) {
+      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
+    }
+  }
+
+  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
+    if (oldVnode === vnode) {
+      return
+    }
+    // reuse element for static trees.
+    // note we only do this if the vnode is cloned -
+    // if the new node is not cloned it means the render functions have been
+    // reset by the hot-reload-api and we need to do a proper re-render.
+    if (vnode.isStatic &&
+        oldVnode.isStatic &&
+        vnode.key === oldVnode.key &&
+        (vnode.isCloned || vnode.isOnce)) {
+      vnode.elm = oldVnode.elm
+      vnode.componentInstance = oldVnode.componentInstance
+      return
+    }
+    let i
+    const data = vnode.data
+    const hasData = isDef(data)
+    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {
+      i(oldVnode, vnode)
+    }
+    const elm = vnode.elm = oldVnode.elm
+    const oldCh = oldVnode.children
+    const ch = vnode.children
+    if (hasData && isPatchable(vnode)) {
+      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
+      if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)
+    }
+    if (isUndef(vnode.text)) {
+      if (isDef(oldCh) && isDef(ch)) {
+        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
+      } else if (isDef(ch)) {
+        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
+        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
+      } else if (isDef(oldCh)) {
+        removeVnodes(elm, oldCh, 0, oldCh.length - 1)
+      } else if (isDef(oldVnode.text)) {
+        nodeOps.setTextContent(elm, '')
+      }
+    } else if (oldVnode.text !== vnode.text) {
+      nodeOps.setTextContent(elm, vnode.text)
+    }
+    if (hasData) {
+      if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)
+    }
+  }
+
+  function invokeInsertHook (vnode, queue, initial) {
+    // delay insert hooks for component root nodes, invoke them after the
+    // element is really inserted
+    if (initial && vnode.parent) {
+      vnode.parent.data.pendingInsert = queue
+    } else {
+      for (let i = 0; i < queue.length; ++i) {
+        queue[i].data.hook.insert(queue[i])
+      }
+    }
+  }
+
+  let bailed = false
+  // list of modules that can skip create hook during hydration because they
+  // are already rendered on the client or has no need for initialization
+  const isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key')
+
+  // Note: this is a browser-only function so we can assume elms are DOM nodes.
+  function hydrate (elm, vnode, insertedVnodeQueue) {
+    if (process.env.NODE_ENV !== 'production') {
+      if (!assertNodeMatch(elm, vnode)) {
+        return false
+      }
+    }
+    vnode.elm = elm
+    const { tag, data, children } = vnode
+    if (isDef(data)) {
+      if (isDef(i = data.hook) && isDef(i = i.init)) i(vnode, true /* hydrating */)
+      if (isDef(i = vnode.componentInstance)) {
+        // child component. it should have hydrated its own tree.
+        initComponent(vnode, insertedVnodeQueue)
+        return true
+      }
+    }
+    if (isDef(tag)) {
+      if (isDef(children)) {
+        // empty element, allow client to pick up and populate children
+        if (!elm.hasChildNodes()) {
+          createChildren(vnode, children, insertedVnodeQueue)
+        } else {
+          let childrenMatch = true
+          let childNode = elm.firstChild
+          for (let i = 0; i < children.length; i++) {
+            if (!childNode || !hydrate(childNode, children[i], insertedVnodeQueue)) {
+              childrenMatch = false
+              break
+            }
+            childNode = childNode.nextSibling
+          }
+          // if childNode is not null, it means the actual childNodes list is
+          // longer than the virtual children list.
+          if (!childrenMatch || childNode) {
+            if (process.env.NODE_ENV !== 'production' &&
+                typeof console !== 'undefined' &&
+                !bailed) {
+              bailed = true
+              console.warn('Parent: ', elm)
+              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children)
+            }
+            return false
+          }
+        }
+      }
+      if (isDef(data)) {
+        for (const key in data) {
+          if (!isRenderedModule(key)) {
+            invokeCreateHooks(vnode, insertedVnodeQueue)
+            break
+          }
+        }
+      }
+    } else if (elm.data !== vnode.text) {
+      elm.data = vnode.text
+    }
+    return true
+  }
+
+  function assertNodeMatch (node, vnode) {
+    if (vnode.tag) {
+      return (
+        vnode.tag.indexOf('vue-component') === 0 ||
+        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
+      )
+    } else {
+      return node.nodeType === (vnode.isComment ? 8 : 3)
+    }
+  }
+
+  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
+    if (!vnode) {
+      if (oldVnode) invokeDestroyHook(oldVnode)
+      return
+    }
+
+    let isInitialPatch = false
+    const insertedVnodeQueue = []
+
+    if (!oldVnode) {
+      // empty mount (likely as component), create new root element
+      isInitialPatch = true
+      createElm(vnode, insertedVnodeQueue, parentElm, refElm)
+    } else {
+      const isRealElement = isDef(oldVnode.nodeType)
+      if (!isRealElement && sameVnode(oldVnode, vnode)) {
+        // patch existing root node
+        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
+      } else {
+        if (isRealElement) {
+          // mounting to a real element
+          // check if this is server-rendered content and if we can perform
+          // a successful hydration.
+          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {
+            oldVnode.removeAttribute('server-rendered')
+            hydrating = true
+          }
+          if (hydrating) {
+            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
+              invokeInsertHook(vnode, insertedVnodeQueue, true)
+              return oldVnode
+            } else if (process.env.NODE_ENV !== 'production') {
+              warn(
+                'The client-side rendered virtual DOM tree is not matching ' +
+                'server-rendered content. This is likely caused by incorrect ' +
+                'HTML markup, for example nesting block-level elements inside ' +
+                '<p>, or missing <tbody>. Bailing hydration and performing ' +
+                'full client-side render.'
+              )
+            }
+          }
+          // either not server-rendered, or hydration failed.
+          // create an empty node and replace it
+          oldVnode = emptyNodeAt(oldVnode)
+        }
+        // replacing existing element
+        const oldElm = oldVnode.elm
+        const parentElm = nodeOps.parentNode(oldElm)
+        createElm(
+          vnode,
+          insertedVnodeQueue,
+          // extremely rare edge case: do not insert if old element is in a
+          // leaving transition. Only happens when combining transition +
+          // keep-alive + HOCs. (#4590)
+          oldElm._leaveCb ? null : parentElm,
+          nodeOps.nextSibling(oldElm)
+        )
+
+        if (vnode.parent) {
+          // component root element replaced.
+          // update parent placeholder node element, recursively
+          let ancestor = vnode.parent
+          while (ancestor) {
+            ancestor.elm = vnode.elm
+            ancestor = ancestor.parent
+          }
+          if (isPatchable(vnode)) {
+            for (let i = 0; i < cbs.create.length; ++i) {
+              cbs.create[i](emptyNode, vnode.parent)
+            }
+          }
+        }
+
+        if (parentElm !== null) {
+          removeVnodes(parentElm, [oldVnode], 0, 0)
+        } else if (isDef(oldVnode.tag)) {
+          invokeDestroyHook(oldVnode)
+        }
+      }
+    }
+
+    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
+    return vnode.elm
+  }
+}
Index: public/node_modules/vue-resource/test/resource.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/test/resource.js	(revision )
+++ public/node_modules/vue-resource/test/resource.js	(revision )
@@ -0,0 +1,51 @@
+import Vue from 'vue';
+
+describe('this.$resource', function () {
+
+    it('get({file: "valid.json"})', (done) => {
+
+        var vm = new Vue({
+
+            created() {
+
+                var resource = this.$resource('data{/file}');
+
+                resource.get({file: 'valid.json'}).then((res) => {
+
+                    expect(res.ok).toBe(true);
+                    expect(res.status).toBe(200);
+                    expect(res.data.foo).toBe('bar');
+
+                    done();
+                });
+
+            }
+
+        });
+
+    });
+
+    it('save({file: "valid.json"}, {foo: "bar"})', (done) => {
+
+        var vm = new Vue({
+
+            created() {
+
+                var resource = this.$resource('data{/file}');
+
+                resource.save({file: 'valid.json'}, {foo: 'bar'}).then((res) => {
+
+                    expect(res.ok).toBe(true);
+                    expect(res.status).toBe(200);
+                    expect(res.data.foo).toBe('bar');
+
+                    done();
+                });
+
+            }
+
+        });
+
+    });
+
+});
Index: public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/index.js	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/lowercase-keys/index.js	(revision )
@@ -0,0 +1,11 @@
+'use strict';
+module.exports = function (obj) {
+	var ret = {};
+	var keys = Object.keys(Object(obj));
+
+	for (var i = 0; i < keys.length; i++) {
+		ret[keys[i].toLowerCase()] = obj[keys[i]];
+	}
+
+	return ret;
+};
Index: public/node_modules/vue/src/platforms/weex/runtime/modules/transition.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/platforms/weex/runtime/modules/transition.js	(revision )
+++ public/node_modules/vue/src/platforms/weex/runtime/modules/transition.js	(revision )
@@ -0,0 +1,265 @@
+import { warn } from 'core/util/debug'
+import { extend, once, noop } from 'shared/util'
+import { activeInstance } from 'core/instance/lifecycle'
+import { resolveTransition } from 'web/runtime/transition-util'
+
+export default {
+  create: enter,
+  activate: enter,
+  remove: leave
+}
+
+function enter (_, vnode) {
+  const el = vnode.elm
+
+  // call leave callback now
+  if (el._leaveCb) {
+    el._leaveCb.cancelled = true
+    el._leaveCb()
+  }
+
+  const data = resolveTransition(vnode.data.transition)
+  if (!data) {
+    return
+  }
+
+  /* istanbul ignore if */
+  if (el._enterCb) {
+    return
+  }
+
+  const {
+    enterClass,
+    enterToClass,
+    enterActiveClass,
+    appearClass,
+    appearToClass,
+    appearActiveClass,
+    beforeEnter,
+    enter,
+    afterEnter,
+    enterCancelled,
+    beforeAppear,
+    appear,
+    afterAppear,
+    appearCancelled
+  } = data
+
+  let context = activeInstance
+  let transitionNode = activeInstance.$vnode
+  while (transitionNode && transitionNode.parent) {
+    transitionNode = transitionNode.parent
+    context = transitionNode.context
+  }
+
+  const isAppear = !context._isMounted || !vnode.isRootInsert
+
+  if (isAppear && !appear && appear !== '') {
+    return
+  }
+
+  const startClass = isAppear ? appearClass : enterClass
+  const toClass = isAppear ? appearToClass : enterToClass
+  const activeClass = isAppear ? appearActiveClass : enterActiveClass
+  const beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter
+  const enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter
+  const afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter
+  const enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled
+
+  const userWantsControl =
+    enterHook &&
+    // enterHook may be a bound method which exposes
+    // the length of original fn as _length
+    (enterHook._length || enterHook.length) > 1
+
+  const stylesheet = vnode.context.$options.style || {}
+  const startState = stylesheet[startClass]
+  const transitionProperties = (stylesheet['@TRANSITION'] && stylesheet['@TRANSITION'][activeClass]) || {}
+  const endState = getEnterTargetState(el, stylesheet, startClass, toClass, activeClass, vnode.context)
+  const needAnimation = Object.keys(endState).length > 0
+
+  const cb = el._enterCb = once(() => {
+    if (cb.cancelled) {
+      enterCancelledHook && enterCancelledHook(el)
+    } else {
+      afterEnterHook && afterEnterHook(el)
+    }
+    el._enterCb = null
+  })
+
+  // We need to wait until the native element has been inserted, but currently
+  // there's no API to do that. So we have to wait "one frame" - not entirely
+  // sure if this is guaranteed to be enough (e.g. on slow devices?)
+  setTimeout(() => {
+    const parent = el.parentNode
+    const pendingNode = parent && parent._pending && parent._pending[vnode.key]
+    if (pendingNode &&
+        pendingNode.context === vnode.context &&
+        pendingNode.tag === vnode.tag &&
+        pendingNode.elm._leaveCb) {
+      pendingNode.elm._leaveCb()
+    }
+    enterHook && enterHook(el, cb)
+
+    if (needAnimation) {
+      const animation = vnode.context.$requireWeexModule('animation')
+      animation.transition(el.ref, {
+        styles: endState,
+        duration: transitionProperties.duration || 0,
+        delay: transitionProperties.delay || 0,
+        timingFunction: transitionProperties.timingFunction || 'linear'
+      }, userWantsControl ? noop : cb)
+    } else if (!userWantsControl) {
+      cb()
+    }
+  }, 16)
+
+  // start enter transition
+  beforeEnterHook && beforeEnterHook(el)
+
+  if (startState) {
+    for (const key in startState) {
+      el.setStyle(key, startState[key])
+    }
+  }
+
+  if (!needAnimation && !userWantsControl) {
+    cb()
+  }
+}
+
+function leave (vnode, rm) {
+  const el = vnode.elm
+
+  // call enter callback now
+  if (el._enterCb) {
+    el._enterCb.cancelled = true
+    el._enterCb()
+  }
+
+  const data = resolveTransition(vnode.data.transition)
+  if (!data) {
+    return rm()
+  }
+
+  if (el._leaveCb) {
+    return
+  }
+
+  const {
+    leaveClass,
+    leaveToClass,
+    leaveActiveClass,
+    beforeLeave,
+    leave,
+    afterLeave,
+    leaveCancelled,
+    delayLeave
+  } = data
+
+  const userWantsControl =
+    leave &&
+    // leave hook may be a bound method which exposes
+    // the length of original fn as _length
+    (leave._length || leave.length) > 1
+
+  const stylesheet = vnode.context.$options.style || {}
+  const startState = stylesheet[leaveClass]
+  const endState = stylesheet[leaveToClass] || stylesheet[leaveActiveClass]
+  const transitionProperties = (stylesheet['@TRANSITION'] && stylesheet['@TRANSITION'][leaveActiveClass]) || {}
+
+  const cb = el._leaveCb = once(() => {
+    if (el.parentNode && el.parentNode._pending) {
+      el.parentNode._pending[vnode.key] = null
+    }
+    if (cb.cancelled) {
+      leaveCancelled && leaveCancelled(el)
+    } else {
+      rm()
+      afterLeave && afterLeave(el)
+    }
+    el._leaveCb = null
+  })
+
+  if (delayLeave) {
+    delayLeave(performLeave)
+  } else {
+    performLeave()
+  }
+
+  function performLeave () {
+    const animation = vnode.context.$requireWeexModule('animation')
+    // the delayed leave may have already been cancelled
+    if (cb.cancelled) {
+      return
+    }
+    // record leaving element
+    if (!vnode.data.show) {
+      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode
+    }
+    beforeLeave && beforeLeave(el)
+
+    if (startState) {
+      animation.transition(el.ref, {
+        styles: startState
+      }, next)
+    } else {
+      next()
+    }
+
+    function next () {
+      animation.transition(el.ref, {
+        styles: endState,
+        duration: transitionProperties.duration || 0,
+        delay: transitionProperties.delay || 0,
+        timingFunction: transitionProperties.timingFunction || 'linear'
+      }, userWantsControl ? noop : cb)
+    }
+
+    leave && leave(el, cb)
+    if (!endState && !userWantsControl) {
+      cb()
+    }
+  }
+}
+
+// determine the target animation style for an entering transition.
+function getEnterTargetState (el, stylesheet, startClass, endClass, activeClass, vm) {
+  const targetState = {}
+  const startState = stylesheet[startClass]
+  const endState = stylesheet[endClass]
+  const activeState = stylesheet[activeClass]
+  // 1. fallback to element's default styling
+  if (startState) {
+    for (const key in startState) {
+      targetState[key] = el.style[key]
+      if (
+        process.env.NODE_ENV !== 'production' &&
+        targetState[key] == null &&
+        (!activeState || activeState[key] == null) &&
+        (!endState || endState[key] == null)
+      ) {
+        warn(
+          `transition property "${key}" is declared in enter starting class (.${startClass}), ` +
+          `but not declared anywhere in enter ending class (.${endClass}), ` +
+          `enter active cass (.${activeClass}) or the element's default styling. ` +
+          `Note in Weex, CSS properties need explicit values to be transitionable.`
+        )
+      }
+    }
+  }
+  // 2. if state is mixed in active state, extract them while excluding
+  //    transition properties
+  if (activeState) {
+    for (const key in activeState) {
+      if (key.indexOf('transition') !== 0) {
+        targetState[key] = activeState[key]
+      }
+    }
+  }
+  // 3. explicit endState has highest priority
+  if (endState) {
+    extend(targetState, endState)
+  }
+  return targetState
+}
Index: public/node_modules/vue/src/core/util/debug.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/core/util/debug.js	(revision )
+++ public/node_modules/vue/src/core/util/debug.js	(revision )
@@ -0,0 +1,59 @@
+import config from '../config'
+import { noop } from 'shared/util'
+
+let warn = noop
+let tip = noop
+let formatComponentName
+
+if (process.env.NODE_ENV !== 'production') {
+  const hasConsole = typeof console !== 'undefined'
+  const classifyRE = /(?:^|[-_])(\w)/g
+  const classify = str => str
+    .replace(classifyRE, c => c.toUpperCase())
+    .replace(/[-_]/g, '')
+
+  warn = (msg, vm) => {
+    if (hasConsole && (!config.silent)) {
+      console.error(`[Vue warn]: ${msg} ` + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ))
+    }
+  }
+
+  tip = (msg, vm) => {
+    if (hasConsole && (!config.silent)) {
+      console.warn(`[Vue tip]: ${msg} ` + (
+        vm ? formatLocation(formatComponentName(vm)) : ''
+      ))
+    }
+  }
+
+  formatComponentName = (vm, includeFile) => {
+    if (vm.$root === vm) {
+      return '<Root>'
+    }
+    let name = vm._isVue
+      ? vm.$options.name || vm.$options._componentTag
+      : vm.name
+
+    const file = vm._isVue && vm.$options.__file
+    if (!name && file) {
+      const match = file.match(/([^/\\]+)\.vue$/)
+      name = match && match[1]
+    }
+
+    return (
+      (name ? `<${classify(name)}>` : `<Anonymous>`) +
+      (file && includeFile !== false ? ` at ${file}` : '')
+    )
+  }
+
+  const formatLocation = str => {
+    if (str === `<Anonymous>`) {
+      str += ` - use the "name" option for better debugging messages.`
+    }
+    return `\n(found in ${str})`
+  }
+}
+
+export { warn, tip, formatComponentName }
Index: public/node_modules/vue-resource/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/package.json	(revision )
+++ public/node_modules/vue-resource/package.json	(revision )
@@ -0,0 +1,55 @@
+{
+  "name": "vue-resource",
+  "version": "1.2.1",
+  "main": "dist/vue-resource.common.js",
+  "jsnext:main": "dist/vue-resource.es2015.js",
+  "description": "The HTTP client for Vue.js",
+  "homepage": "https://github.com/pagekit/vue-resource#readme",
+  "license": "MIT",
+  "keywords": [
+    "vue",
+    "xhr",
+    "http",
+    "ajax"
+  ],
+  "bugs": {
+    "url": "https://github.com/pagekit/vue-resource/issues"
+  },
+  "repository": {
+    "type": "git",
+    "url": "git+https://github.com/pagekit/vue-resource.git"
+  },
+  "scripts": {
+    "test": "jest --env=node",
+    "build": "node build/build.js",
+    "release": "node build/release.js",
+    "webpack": "webpack --config test/webpack.config.js"
+  },
+  "browser": {
+    "got": false
+  },
+  "dependencies": {
+    "got": "^6.7.1"
+  },
+  "devDependencies": {
+    "buble": "^0.15.2",
+    "buble-loader": "^0.4.0",
+    "generate-release": "^0.11.0",
+    "jasmine-core": "^2.5.2",
+    "jest": "^19.0.2",
+    "replace-in-file": "^2.0.1",
+    "rollup": "^0.41.4",
+    "rollup-plugin-buble": "^0.15.0",
+    "uglify-js": "^2.7.5",
+    "vue": "^2.2.1",
+    "webpack": "^2.2.0"
+  },
+  "readme": "# vue-resource [![Version](https://img.shields.io/npm/v/vue-resource.svg)](https://www.npmjs.com/package/vue-resource) [![License](https://img.shields.io/npm/l/vue-resource.svg)](https://www.npmjs.com/package/vue-resource) [![Downloads](https://img.shields.io/npm/dt/vue-resource.svg)](https://www.npmjs.com/package/vue-resource)\n\nThe plugin for [Vue.js](http://vuejs.org) provides services for making web requests and handle responses using a [XMLHttpRequest](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) or JSONP.\n\n## Features\n\n- Supports the [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) API and [URI Templates](https://medialize.github.io/URI.js/uri-template.html)\n- Supports [interceptors](docs/http.md#interceptors) for request and response\n- Supports latest Firefox, Chrome, Safari, Opera and IE9+\n- Compact size 14KB (5.3KB gzipped)\n\n## Installation\n\n### NPM\n```\n$ npm install vue-resource\n```\n\n### Bower\n```\n$ bower install vue-resource\n```\n\n### CDN\nAvailable on [jsdelivr](https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js), [cdnjs](https://cdnjs.com/libraries/vue-resource) or [unpkg](https://unpkg.com/vue-resource@1.2.1/dist/vue-resource.min.js).\n```html\n<script src=\"https://cdn.jsdelivr.net/vue.resource/1.2.1/vue-resource.min.js\"></script>\n```\n\n## Example\n```js\n{\n  // GET /someUrl\n  this.$http.get('/someUrl').then(response => {\n\n    // get body data\n    this.someData = response.body;\n\n  }, response => {\n    // error callback\n  });\n}\n```\n\n## Documentation\n\n- [Configuration](docs/config.md)\n- [HTTP Requests/Response](docs/http.md)\n- [Creating Resources](docs/resource.md)\n- [Code Recipes](docs/recipes.md)\n- [API Reference](docs/api.md)\n\n## Changelog\n\nDetails changes for each release are documented in the [release notes](https://github.com/vuejs/vue-resource/releases).\n\n## Contribution\n\nIf you find a bug or want to contribute to the code or documentation, you can help by submitting an [issue](https://github.com/vuejs/vue-resource/issues) or a [pull request](https://github.com/vuejs/vue-resource/pulls).\n\n## License\n\n[MIT](http://opensource.org/licenses/MIT)\n",
+  "readmeFilename": "README.md",
+  "_id": "vue-resource@1.2.1",
+  "dist": {
+    "shasum": "f0c741dbd46c5fa75e669b95b90faef7acaa55b2"
+  },
+  "_from": "vue-resource@",
+  "_resolved": "https://registry.npmjs.org/vue-resource/-/vue-resource-1.2.1.tgz"
+}
Index: public/node_modules/vue-resource/src/http/client/index.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/src/http/client/index.js	(revision )
+++ public/node_modules/vue-resource/src/http/client/index.js	(revision )
@@ -0,0 +1,72 @@
+/**
+ * Base client.
+ */
+
+import Promise from '../../promise';
+import xhrClient from './xhr';
+import nodeClient from './node';
+import { warn, when, isObject, isFunction, inBrowser } from '../../util';
+
+export default function (context) {
+
+    var reqHandlers = [sendRequest], resHandlers = [], handler;
+
+    if (!isObject(context)) {
+        context = null;
+    }
+
+    function Client(request) {
+        return new Promise(resolve => {
+
+            function exec() {
+
+                handler = reqHandlers.pop();
+
+                if (isFunction(handler)) {
+                    handler.call(context, request, next);
+                } else {
+                    warn(`Invalid interceptor of type ${typeof handler}, must be a function`);
+                    next();
+                }
+            }
+
+            function next(response) {
+
+                if (isFunction(response)) {
+
+                    resHandlers.unshift(response);
+
+                } else if (isObject(response)) {
+
+                    resHandlers.forEach(handler => {
+                        response = when(response, response => {
+                            return handler.call(context, response) || response;
+                        });
+                    });
+
+                    when(response, resolve);
+
+                    return;
+                }
+
+                exec();
+            }
+
+            exec();
+
+        }, context);
+    }
+
+    Client.use = handler => {
+        reqHandlers.push(handler);
+    };
+
+    return Client;
+}
+
+function sendRequest(request, resolve) {
+
+    var client = request.client || (inBrowser ? xhrClient : nodeClient);
+
+    resolve(client(request));
+}
Index: public/node_modules/vue-resource/dist/README.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/dist/README.md	(revision )
+++ public/node_modules/vue-resource/dist/README.md	(revision )
@@ -0,0 +1,3 @@
+# NOTE!
+
+The `dist` folder contains the standalone build for vue-resource, however files here are only checked-in when a release happens. If you are on the `dev` branch, files here are **NOT** up to date. Only the `master` branch contains the built files for the latest stable version.
Index: public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/package.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/package.json	(revision )
+++ public/node_modules/vue-resource/node_modules/got/node_modules/is-stream/package.json	(revision )
@@ -0,0 +1,52 @@
+{
+  "name": "is-stream",
+  "version": "1.1.0",
+  "description": "Check if something is a Node.js stream",
+  "license": "MIT",
+  "repository": {
+    "type": "git",
+    "url": "git://github.com/sindresorhus/is-stream"
+  },
+  "author": {
+    "name": "Sindre Sorhus",
+    "email": "sindresorhus@gmail.com",
+    "url": "sindresorhus.com"
+  },
+  "engines": {
+    "node": ">=0.10.0"
+  },
+  "scripts": {
+    "test": "xo && ava"
+  },
+  "files": [
+    "index.js"
+  ],
+  "keywords": [
+    "stream",
+    "type",
+    "streams",
+    "writable",
+    "readable",
+    "duplex",
+    "transform",
+    "check",
+    "detect",
+    "is"
+  ],
+  "devDependencies": {
+    "ava": "*",
+    "tempfile": "^1.1.0",
+    "xo": "*"
+  },
+  "readme": "# is-stream [![Build Status](https://travis-ci.org/sindresorhus/is-stream.svg?branch=master)](https://travis-ci.org/sindresorhus/is-stream)\n\n> Check if something is a [Node.js stream](https://nodejs.org/api/stream.html)\n\n\n## Install\n\n```\n$ npm install --save is-stream\n```\n\n\n## Usage\n\n```js\nconst fs = require('fs');\nconst isStream = require('is-stream');\n\nisStream(fs.createReadStream('unicorn.png'));\n//=> true\n\nisStream({});\n//=> false\n```\n\n\n## API\n\n### isStream(stream)\n\n#### isStream.writable(stream)\n\n#### isStream.readable(stream)\n\n#### isStream.duplex(stream)\n\n#### isStream.transform(stream)\n\n\n## License\n\nMIT  [Sindre Sorhus](https://sindresorhus.com)\n",
+  "readmeFilename": "readme.md",
+  "bugs": {
+    "url": "https://github.com/sindresorhus/is-stream/issues"
+  },
+  "_id": "is-stream@1.1.0",
+  "dist": {
+    "shasum": "3be161142e3a77eef9e61c741520b8b6265c2b9e"
+  },
+  "_from": "is-stream@^1.0.0",
+  "_resolved": "https://registry.npmjs.org/is-stream/-/is-stream-1.1.0.tgz"
+}
Index: public/node_modules/vue/src/sfc/parser.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- public/node_modules/vue/src/sfc/parser.js	(revision )
+++ public/node_modules/vue/src/sfc/parser.js	(revision )
@@ -0,0 +1,116 @@
+/* @flow */
+
+import deindent from 'de-indent'
+import { parseHTML } from 'compiler/parser/html-parser'
+import { makeMap } from 'shared/util'
+
+const splitRE = /\r?\n/g
+const replaceRE = /./g
+const isSpecialTag = makeMap('script,style,template', true)
+
+type Attribute = {
+  name: string,
+  value: string
+};
+
+/**
+ * Parse a single-file component (*.vue) file into an SFC Descriptor Object.
+ */
+export function parseComponent (
+  content: string,
+  options?: Object = {}
+ ): SFCDescriptor {
+  const sfc: SFCDescriptor = {
+    template: null,
+    script: null,
+    styles: [],
+    customBlocks: []
+  }
+  let depth = 0
+  let currentBlock: ?(SFCBlock | SFCCustomBlock) = null
+
+  function start (
+    tag: string,
+    attrs: Array<Attribute>,
+    unary: boolean,
+    start: number,
+    end: number
+  ) {
+    if (depth === 0) {
+      currentBlock = {
+        type: tag,
+        content: '',
+        start: end,
+        attrs: attrs.reduce((cumulated, { name, value }) => {
+          cumulated[name] = value || true
+          return cumulated
+        }, Object.create(null))
+      }
+      if (isSpecialTag(tag)) {
+        checkAttrs(currentBlock, attrs)
+        if (tag === 'style') {
+          sfc.styles.push(currentBlock)
+        } else {
+          sfc[tag] = currentBlock
+        }
+      } else { // custom blocks
+        sfc.customBlocks.push(currentBlock)
+      }
+    }
+    if (!unary) {
+      depth++
+    }
+  }
+
+  function checkAttrs (block: SFCBlock, attrs: Array<Attribute>) {
+    for (let i = 0; i < attrs.length; i++) {
+      const attr = attrs[i]
+      if (attr.name === 'lang') {
+        block.lang = attr.value
+      }
+      if (attr.name === 'scoped') {
+        block.scoped = true
+      }
+      if (attr.name === 'module') {
+        block.module = attr.value || true
+      }
+      if (attr.name === 'src') {
+        block.src = attr.value
+      }
+    }
+  }
+
+  function end (tag: string, start: number, end: number) {
+    if (depth === 1 && currentBlock) {
+      currentBlock.end = start
+      let text = deindent(content.slice(currentBlock.start, currentBlock.end))
+      // pad content so that linters and pre-processors can output correct
+      // line numbers in errors and warnings
+      if (currentBlock.type !== 'template' && options.pad) {
+        text = padContent(currentBlock, options.pad) + text
+      }
+      currentBlock.content = text
+      currentBlock = null
+    }
+    depth--
+  }
+
+  function padContent (block: SFCBlock | SFCCustomBlock, pad: true | "line" | "space") {
+    if (pad === 'space') {
+      return content.slice(0, block.start).replace(replaceRE, ' ')
+    } else {
+      const offset = content.slice(0, block.start).split(splitRE).length
+      const padChar = block.type === 'script' && !block.lang
+        ? '//\n'
+        : '\n'
+      return Array(offset).join(padChar)
+    }
+  }
+
+  parseHTML(content, {
+    start,
+    end
+  })
+
+  return sfc
+}
diff --git public/node_modules/vue-select2/screenshot.png public/node_modules/vue-select2/screenshot.png
new file mode 100644
index 0000000000000000000000000000000000000000..b55635a5963ed6843d2da81104d54f494eddf643
GIT binary patch
literal 62579
zc%1CIQ*>rs^Di29$F^<TwrzB5+qRu_Y}>Zgv6GI~vAxr8zu)&i`<x!*-0aJ}#=Lme
znkxLNX4R}GOio4=8Uh0X00015Tuev-002Y^004*t?91mD@h;pB005K%GeJQ)aX~>m
zIeQypGfN`?0JWf`RB$Hc?WN0Xhw~BU=^L&;E#dh4VHLSjZ~>HXd?1(+O(7IGz5=<T
zKnaw1cszo@re^2yOV{1oQu}7-V(UZm{i+G?OU4_N2QEPBNhbk;z&8p2f&M%&mS7Go
znJF5rR8{~WIy^uD-#JKJ^js?=qc89Ip17nMi2JRNw7MTF=O2{wJY8|F0C<!H9xp;W
zf?=K^t{VfQaCrcHk8pP#wes-Yk4$mLU;_YQTCWjrAD5H5zurPTeAbp%ju6}s0I1SZ
zP<wF!);068D8F3D-U<eT07xSqAfkN%fJTgCz68`6uuIJdWzo;g-R@>f8WGt12*LgM
z7%zVClclBo0Dixr>IN-GMMH<*L4N4=#Qvxc3>Nyp4hV6L1BHvU^o|nsG+F4~F8Ydf
zV5Rqz0_^oZa2o-f7xn9dfk$C!pZ3M|IPHD^=$pq`_b=f`7n^U1wHvx5fooWg4^i{Y
z+?N*?md<d3p@V=gpcrT$`;P#e!`)bjN8hee2m`F7KUR)#j=*PFzS6(IL&0RxGhORi
zx>ozp3xO`9zeP+Q<9)%^<$eS9N`3S55=xx%n+}C52lm*4>j(BSj6Cb@lpg@UPYLLd
zs(62@<#6T2gG&Xb^^LjaM!2IC+qev66Ug!5LrP(>OM0|N57{OjXfZ4(*av)UJa{j-
zEuXw-1fhp|n}ZhultcasQ1n!MLlnKG01lA!$cvrL2(X6$;ONySim3m76x;1B=Zho<
z#L)xA20&{k9RZA<1EA!G^5ZK>55h8_$xoO|Jb*wTpiodzeg-k%G`z1`06{rOO1|c{
z*i8N?KVaH=1?d2Sdm-tdje7|m!4`X5YJmCSz7T|%;v0t|?t}>8ql<yh`rhI*j(o8X
z=EC<Og9;Ch79h=$B15GJ9LvEtLUBYr3C0m5{2^%yqY=EAi%SPY5^(&@Sq&gLFzK7s
zGE!3jZ14M}9vhBK&~zWDExQ&hYyZY2z$;Kz5N{tQm~Rh08r(XVT_A!0s$Q5a|06zF
z=x!*K5KkVK9q>%>ktmnw1c3_Nnix|&%4iUhXc<9N?7bM*HQhBE1EhLrg$N6wN8EIr
z!wB=9EE0P-G;z2BKYD(K+<S?d5(WjXa+tZmU9L_Jiu~4$DHE^;TxBSW0B3%{5AY+Z
zTO&u{Hb`!N9X^|HbZEwrWFpuGVOM=Zdb4yXba$yQsqzy9#*h*H_WDLOU(`@7(O5v!
zV=4!o^+jtXm$4Bj5WEqP5hM|C<JsaZ<I9Pxhy;luh&T)83;YXC3Y-i03q}h-3s}Wo
z#7xAxcWl{kG8m>XP(vmAkbhe5;A|h*t{E~J5*W4_S{u$7nv9l>w2kP*dl8e8qT($P
zxZuYS@Ji|kzWcs1KcRq92Z0392f+#x2*V3A4w4O$N+3vhOIS&`jJb|^j;$pMCQ>R9
zDFG?9Dd{K;mxh;|D@e;($;~N9Drzc(D457EDex9~%Le4a=gbse<%$=U=D6|I^F`$B
z7cLYI&Sm9vO00>ti-i;+7BCh;=8YG$%dm<yi^vMnieB*f1a^gX1$ZX|_Tu$?n}F+!
zo%}IEH+2~hmnok<lR}?)^<|fAmjsbA0VRP}@rxqx9Apvhgx19KMDN65s%ENgEuOlN
zT7|m4x`f)Znu^-7nzH&;1$sqPg`y>0I#@ciCXgoRnqm{QGmNv~J=neEFW6;OHZ-;d
zHh;EjHV*b=b~AQnHemJ}whIUEpLvI~2N2s7KTq~Gc8zygcA^hxc5(JLx8e6{55>35
ze!2}xj+GCb4yO;V^|ucVkD5%mBvwb;gl7lphVlA-5cu$Z6#3@(=J$~Mq4+)cOZgA^
zU->)vGYaepd>04_8Vec<oavM3>+MSk3K9MW?-mCTM-YcEucpM$BzIeP6pAJxrA{SP
zp=BwMA*H3sCDI||DdW%ICq*EfC%ltDlwA<9$3E&knyqlHfUlrhSX5|MAYGtXuvV~S
zBxHEWAk1J;w^#S2F08JyPIpge-*aDLk7VC$e{x@T^kL+JoQwhv$(oFc@|xV80)<kB
zY=&H&+=!f8L4^F2jFh68(x#lOM5vUh%u@wf6<VcI*{hnQ<e=PH*@{0?bVIUJ%1b3c
zvR`pGe5it?xhTcB^`HZ#IypwAa528A#yQrx^PUu&9NS+eVXCMq{G5J+hC47TS0{Kg
zhbOA5(>wRw0vHF_Cx9b>S<tN?q@RW`F|KrmJs;e_*`UKN>gsz~-Y9*7jv|Ai=A6Ks
z8zVfUzj`{mrM15Irst6V7QsZ`Ac7i(W>&MO5wWS$@<|r+>grhA$a7{?!=!w=x2A?B
z?3%{fg)@iqiu2sP!2QfUH%uaoH4HOMdbE3VYjnL#yv%UMmkjj`;7m<zIvN<7BpS@B
z=PFb!)Q!E3+4Uh<a2yW%qgu`gk5G@0uZ1Bg!&b71#rY<chgB(ss;x`G&9yGI4;VVA
zKJXtiqT{5~CM&8NtV=GVvKzEZ7oFX0A8sG}0F%D2zDax=J$*g2{385?{OP^Py~@2W
z_|f>#xyy3XKic(}^m_F=x3RWG`$P$Z2xke5Vau_)Y+a+iNt8qe62J;KiOj%9q!-T!
z%#h|E>NDww>o@6R>)YVw@*p_xnPrG+xvwj9@V_>K7y|L+9+ExG?BzQQH^d}iheUhe
zUWo5WOG#@<F-VokkVwPGcqbDi#iw7N1@4A5Dc#Q(%m*a|lb+6!&4QUB7AwgnWr<|L
zaB-*7q<fRUnFPxYB}kP{yiROTc`ha}&YD0>{mQ=M<V>xM)s7FC0v|``Eq1HoNa0}R
zaoO&8dOF~$>WJ*HLFJ<1no1d`?G$sTf8Me5Q|CV=?vi9rafSqj&_y~%Vn(V*E=IM{
zxo_pt$Wyk@PwZr>za38Mp-eCeHk#ZA+J8bm3QrApQN^yh*Hvs&Q5;oBQ*Tv8R$<n(
zQrytYS5s6RS4r3Yx+J_rz0|${tNR&;xC_3Dr~?ZM9!T3VJ|Bd9!eR(h8q>p?a-+*G
z<U_^|(MnN-aUN@_V-ev8!`jI@hyBu?wQRb%<{WpJhw|C_nK1S(_DW_!W@+Zj!|sKR
zqp)M8<BJRJt?R86udO@XqQwU1vdQYhQEqSl*SFQT2i#I#bDxUq$8*F&Qfgob;7Qs2
zY!>bWpGBq;x@E2cwt0>Uu633?mRa^P_SHA7i>H42-C93X6k3s?vtd%wbrNGzFOscp
zD7Pmg3S)B<4zn-J30L7K%I_9UOZzr~TTBxa6V4OIliZojnb|r$w4R=rPtGp%ci2zu
zuf$V@-yaw*)>5F8LwH-f)n3uA>`aKQlH3~~6MhtPW;gQiYCC9Xz6w0nb!XirJy|TU
zw%TxGs$f=khj?$TOf2hfmTju6o_}mV8kmtfqt<KIkajHH&)ptQcptrc2cq_#x{&+g
z>C|N70-P!jaQLZF{(u4Ilej7-dAH$*i-1jilm%?)MGggSgQD!mg<pyrCF5EJ+zq@V
z5yz(<x{I??s8Q5Vz|ObMK`-7YEH;2MP%^GFbT$dopVV(3^3FEMaPYH8dV!qAxM0}g
z`Uvdt{Z=d&V4EgZWm=~e*wP+YSP-0;*bocVPSuGO#HHY^xt+gbQ3$_}lO(cW->7vb
z6eTCkN{wg*imjt9v0>H8{x<xD75XMB8p9*)C><hgdqQO*gvweIMU7ZJWVL1G`%39r
z1ZNF<Jcl(0H5+W}x<jQSrwdu{#!~-~;*#X3CI;;R;nDc%@b)wsAGR0<2&fgP4~#lg
zCO9S}ZZsOttN$g1J-IozJ1vSsAV)NF7Aya4$pn4jE=HJ!xW=eCxjm_n0=w*NLGEmm
z40U#v1n!9Gbj3IYM}phEsk3YJ2Ya?w_f4-`Amr5(IqDo_9j!JQ6%_?_Rg0Fgf~xzA
zgy;(2ljC5qg)OmHl5L}Vlu@ONw&PprDJbg+28VU@x`z3ByWkShYQ@IRGKM{CDRm5+
z%Nj>8M@pOAMjkf}ti5|S*TC&5uY{ZD$LP6Yp-EtGTkaG5s(j|5o&l=vI<60^_`QPh
znBDV{)Jl0swW{&)q2pmb>dEF*w}DQbr;q*9d5A0}SGjX`Jg=^1`$M5c=dr~~vmz${
z)+7sYQ%Tce^RPG51=6pfi`I9gt;6N5j|F7_;#inoIiyJcayT3@d?dcfd|d;Qnj4}m
zJ34gIR+J!ABM4=7C)P=%Glq>X!2a;#0|OJo1jFV72LtEh@I&am$RlTi29xEZq*K#G
z03bXN(cl}1G^p&<7&OMDRYbis;F2_wQ4%gAO5+Ek#N#1k%arD1;N*(rHYHN!&gIHw
zCgy<_tEQtCjOI3{9rIQT?IpMd-)zVXg!FEETc-EI&HU3kTMIxJ^?U2aPr{wbq;o18
zGxNBMfmihw?B+`cTStgzkS~l~#Rf9hy*3QSZgN!<T#&n#NrxW_bTfR^d{uL_WBF?o
zLT$+`(A?Oty0EX#E;+U}_f+Pm(NftEZS9b*l)xKAk7MYuOvDN#^CX5yE($9$Qzfz4
zSCSTOPp*$EZd;%}q}r*@7!gcX>PGGPrWRYH)}wAT-8`Ot2rB`O5?>3H5q#Hg8;>NW
zD#TI+87mlLrmU!P*NrISQg$kBYdX+5<J)k23pwS*5VNV<h_{^YK656mBd>4G+t)cg
z+SqS;a}I_HlgWPp)Lz+m@M!W-enG(H@eK5^eB0aUxn-Q<zsL>WZk2C3bT&w%Z5w7K
z71ni^%FOm=s(;bAmp-z5TYvUnTw5P>ku1A#NZ#^R(h}G8dP*~ye39&RzgT*}Ji1s<
zFVnnV)8mynOFVD-1^uS=oauuV`$e>etJXQ&_YF=>2$BKC$oF6<rxwmR0jUpvRBgnF
z42t}%B)(MAOv6<4Xmj?0k%57np0j444yA^<mUlaKCu8^fe%6lL(AwnEh%QYmWhxaC
zzNgrLn377QA{ODhu)ao}Y#D!>8i_WG%9QM;2*04bT9}HNs+;_N+6i_e!JQ$ruCxI)
zy%mIh;gwXg46XLo7T;Fvxb3j%`eTuJTWNDz8GF=Iop7^JoN`5DKvW)e{aMup=8JWR
z{V<{o&y+h&M^(*fh2~+d{sRast1LAwpbf<Z_v_be@hzTi&39tJV?TL*oZcb)y4+uS
z%QZIJknp=9*$6ly_d-r0TM=f_R$TVnRUBPhxksj(wT#1xh`aIr37LwwGNHw@#phXC
zVjiAl+m1MPFfAr0hTs|a+&53ZB7RL}v^fyBqE49{8tI6Q%XX#8!FiE)(B+KOFCW)A
zg^8EGBX=?c*w;h6lxHpZQyP@Tmor*iTU5_4EN-=Ky5)CoKTWP^W@A2F$T8cojyD`N
zt!~^|MYN_YW^KuDta$s>SyYSe_~~9Obh*3<#Q5VZ@v3`Kyi+;WcpvqHeUuE}L>L6@
zmVhUXhNdJbRvVk@q;<%6-F%Do+%(9wio4smDhx8}hrOemFBj$MRA+pjy-hmQoEmyJ
zK3bfBO~_2<e$Q_0zWz8|8=>W=1h92N1PD<CP=oUrX8;6v4D(`S#|BW@16U>pMjHgo
zS*iqZ&-1qR&Ix-XVf+cKz?ZqK#{ul4uj+=O1?2RT#}y{ImuCP>9MPj6j|{skAdCN$
zj<5porEld@`w_b~g;4-YkO_Y=)Jub`4)6)OFkC_yI-mW=_K`IdFbT+9fYG3cfv8x4
zn7ufQ_=fn4oqY=g14o^sJs*x}7eBmkEkC*_sJxMUz1-5A>5SB@$gKPv^DO7=1-+I*
z!?)Kdr9R7n*Qi4Og)Hdd#qq3x+);2lo;{B7vx)xUo3Q2}+PEz-UzKkvm&rfG^;F^A
z<S}NPYEgHr5RBrB3k3=*4Gj&C4O#b%_dJlT$xz6R$Z!?$OTLsomF+UWG7~n$H{3W`
zAH$q_F@Iy3XAY<9(q}LZW?X6(!#`K@V1a1rbxt|^ihZAHnDM49p<N7H+tTi?b>(?M
z9l(2jvmCRyMVv!rORh#h#L_^T!O*vBYd}OY#@)u8{4Qp=egmSuW4SKoC~+dT%^R25
zmV)ALPP0L8z&3s><<sOW<3O|ZG|>_B6pT6!;f=J4y3r=3j-bP#K%%STi7dVDvZ>s@
zG%@csPrDJ?7S@vFqj@_Oa3Dy{dycZHXyG%LHaobqar0B|VyM4Dv?FHiYetqe3<^|v
z)CBLeE50n3*;p}wF_x~!l<`yy6$DKoHEp$;xA|M&1M>x^G3C|pluqBp8!&JQASN8p
zH6N-PFs&_GfiGkZMneGnWmc+}u^397e_t+E3H*0oXFVPLY+TTkKG|(-ebg9HBz%%s
zC^1n(czYaT|8V}hyyF?bBN-^dU|;k;iEq>TOJcvoR>j=J>&1O``s^SLs|;yJtVTr1
ze~}lFdyy@bAe5Swl$$k}>CE8d@8+Er^G@{i(ha!!iwBuywnl?aj}385IcIGI2Sm5X
zD%%R%T3r3Orn<SmOu8I~T!xf@hy$C1bO}d_z(Kr0Voi)q-iytP4KC;&uNdn}N{`1?
zI#TJ#S1R;W-}g6<URA%djMAC}s$@7j<-l&scQ5~f6nrhRIdmwElLqL(9N{_+W3fCm
z&$4x18Bk$RH|Go4Se~i*o+}QkB5PC4aUqQhyam*~0PxlmpK}Jc_T$->t#8|wT90>(
z{@IvnB`&t57bGn|XjnchuwVsg95Iu0a4uYScQ(e@bLyI%G2txshHL5Ibs03|H3f7k
zWhgu{+$M!CQA8V^2DOsS$*ESMx~wj^fThEFr|mu}I9;omX1%D*p((A6_=CnoQ@UM1
zbjxeF3YI&p6UyuEZ8b(D+ZCq62ZiZTkL{b`aqHIdtn1H#;*=RhUK0kL`mR>)!x~@j
zwHKO0ub*G*k%MGAEF4dlt6wlR)3=(s&n<sheN6G9`~afC<JWpS=)n&BnDVB!JL?80
zhlAJ&RKoj8hA|fKJy%@+zV#b08&Vg*7U|-5DlkPMggoRcWbyzay!1FuGVOWvc_a-G
zFC^|r_&y>79X;h*;bm<E*?1lW@L5SVsB<vupow(L;Po(1|GpsoWQJJ#fD<BS#ye>Y
z#P7tbbB;TX2Djo+@lXztpi+wyh7&Pr3hIsO4=ZiUitH0?=<KMi8ZGs%o^Fj#El=>T
z7a%y`ix5T-A)#tv6ybIeilHBgYNRR@khAp+^>q&Rkk>ZI2goK#I^?qD6D3n+)TPyC
zzs%yy98N|~zn_90XVaT9c$!RD?^tRWvRL3-qFXJP^jl);vHrySm3rK8qJOO619p7A
zCx6;{XcbZYF!=oR!V8`VK>@`dA`;XYRl~lHPLAe8;?BKzET-Ba);DO7x@#9!KH5cY
zqo6G-lWEVxowl9I?me{q%P@Ma)lGlniJQ04_gq0aPUA`}%;q?yZsa;fRlAzIBEDp*
ze5LZH9Je)h<%exVIsFAp6?r3Q14$$Pxsl@!mt+@l7hcz&%k9^f1B6Y()WA)$s$b`V
z)kUhfQE|#K4!@81h_fVdb>30z++9~pucw2iG$USErUWNT^WIh;RXKa9=vwHizO2^f
z-gUZ+8+tenJGoquZmYf%z8M;M<Kn`l!2pyjy}am#9eyD}_3d<cdEwlDdGSCVFgEz&
zTNTT@wdRw}tOS76{E-&|s3-n$;d1c-baHJ+)^~N<2><|?Wu~O&s3tANVPIoLqi1NN
zZ$#s2Wef28;d15p{Ap$6sE6ljWohle;mS?$&j^ms-@iZ865#za#L<GAKuuZ>PteBR
z2#=YDiH44V2LcZdkIUZBm_tEG<lpI^Z`=f?j*hk*w6rcRE;KHTG&c4owDj!k?6h<Y
zv<wW?pChOp+^ik-T&b-c2>&edpLK+c91QHuY#q&Ptnq%o>*?D#IdT&a{5$5)^JgO?
zSF``w$=cyxwmuo8{oO-LPeVuh-?e`)|NAS4oSCbUrJ9hLm65f>=N>%t^mKGww14gT
z>s0ms>1SsC-)5@+e`a#g{=Yc-BQDy1<;4TRMf+db^FV~w58nd-@BxSm@hiCk{_3=m
zB0SE#c*!IR$j`jbG?gaURyOP&@lQ0Pj4OKxI!2Y&B{yz>TsNJlGHg)@NbH@3wypco
z-qs`G+u-ZiyiL?FE#VkF-{6QL$?Do5>7Zg2<Cv@KTWF~{237}8L>rlxx&eh_w3|hk
zmPYjOptMq?^&Vh$l=Y=6rl-pNoj1F<?6q9?Elaoa{ww%5JV1oMHZr(JExia#B0iwM
zHV!}vDObE$0Pw#w-yi^F5){03;=eEbIT7mrPW(SS(T^4m@ZXUcCO|7v5XTdvB623p
z{WKp<3CITL4nlb8lX!$*hxEFpot)WD*bm*XQnuUI8+*4MuRFS-5~k_nKWF!#!@Hir
zB21Ogs0jY6Y1+)5sd(HC2aoB6sznsO9$eq0{`8VVphpUnF``;F3?Z^Cn&V81BYXmF
zY2vHMmQ)alYG|1Ct<XL}>Epo++vso*F<%fJ06>k@4uF!1_}_10KlkBlRx)OnZ^)$(
z%JoWo*gR9ad83U<FA8)vCptru6;eA_z|&^xa=R?42x%$&W-S6Roer&Q)GMZC2ne2e
z+c#ZmGwdJjOj?4H84j&!R`fnaa3kgmk#NIi@r&^vN%X8Bhz-*%!}tH_GjKHPsN~UX
zp{;IGy44Xj3OgC>9Y2N8B=BP-jNOdF&!SU4H1FM}E1{#u-zNDzyMqi!DYb*Ft|H|R
zy^O>^ZP{W~${Db(NiofDTIf(cF`GgxE?Lp1?PJELZ&kziP&8##BsmKj^<J@QVIG?I
zN4cm&B>?FUlu6~LD2lY!%Xwh#V}7qTMfj=asojd&=|2)y1~=U)*U!zU4!1=4dQ8-`
zTi(KnNYfr`QsnVvb%<%bqq%DAQCZ5<cp;n}$hCtGs^7TePWczZi_m}U@e%^@r$vzN
z_Nd;{Z)!icNcEizb~i!Pc<m46@`|*}PR&jXL^C!RjaL)tcm|QkYHQzM?}n}R-dYhv
zC`kiQg<gydM;HIiX#<F<p1p=YmFzz&+sc5?=X<$>IyqsZX;QODhsuh?n&SrBlWMXX
z#;vXlE#AX4CA^5Rhyqu&rT?6%>NBgh&WoQ+)p4UNJl$(-&YO;l<!6ZF(<cqv>zb(!
z9x7KbVdRoIRmi1^*Nk_uXpTjV<!LZAUHmRnKsACzR7+{F5?A}{)FRE0TrmI>I?wS^
z>}BftWS1U*Ys-Yi!FTVRrAgW#d1!|0jMW`uX0O6Nq(ld|qMMT~pkYCL)NcU%kgJh!
zX!wpXB2wNAKi?hs&JLu)fuf$Gx>}`B;xqv~WFz%b0CNy?k>RN=+yVK_2)3raGfI2A
zC7siG9;+?AN}!!$xZe(#tn8PY^MF4kxz+fGw|Td%6o(-VrV?*-`Z$BMu>z;Prww6i
z<^*-QLyy-&R5^}xbj0gKGWp}Wd@*OWWO~w#`qXr$_MDTzB6u4n=H6Do5Q)k5BNfGq
zK=f%IO3NSfk^}yPg1PSi)gMKoCiy~F65gn3pNVvshUyJ8J^$Dx_YrJD)E@Y$R#K*m
zlwt!mN2pD93Pao;(3`#?mb!|ivB~E_5<ImzI(F9vq^5%vtl5^d61L;~peBzUbkb)&
z?w9)n>d4#<IkV5gz<HXA-Wjz_Pm5u13WzR?%e3&Q9y9@iVj=?1(PbAY71LAQN=<FD
z&)myOuULBFf$z8ug*<k<rCZKc93)j2=jn)<nJ_3C=;Dd)vbJ$xIk>h$?YQxaTIXON
ztyg3oR?``kJDExJ!%N76YtRYlzAh9-YdEzPG8(@^xP5F(D}r<FXa{RZpjH5SpT+ad
zg>H6EAvfBd*gQtEidOI7Uh8RhMk}g6qLh=+G)dJ>74oaS=QMOQesWd(_<n!p3VcJx
z487aQO<PGhx}}IQJzKp7lBRXBl_6li_nE0qoj6Ffi;D46#;{Xs6T0Xh5oZFV>?s}g
zEB*145i&iCfmy!ghKVsv3dD9}&$~0Glx;Ec$tC_Cwd{^tmcmSF<ccwM++;9oap>z6
zMO5-D4}C`+*u5(H;H;G7k`N0;`@!{y_30}05dvR`lD`yW?IsbI330%S)ZCDe<c;P-
z$kaN;hW`9c78R|WT*5L7J^{ix!vUX!P6p$o94Q;_KtYLPA@%h3MOIT>z|*e2z{;U0
z;7qNyP6%O5q=UUYu?@k3_<=sttw?h+Rl{~oA{w2Wxjtyd!UngTO5V*Ncdf<E3W!rB
zw8&VdD{b(gLN|IGBayi5+7Zj36C1749_x$?V{pyhQ}uKEwtM}SO56la^9!WyUsD#H
zh<TT(cUu+W>Ur1IQy_P4;>I_EBgxsPo^|^#se+^N>Fs}@NQ%!FG%9XNPy5H01`+)@
zvY<s@+Dy<^7t@0|DgBU^!tp>gp-C80Ga=0@-T6Mje!W(ENwGJ`GaNDi<sRTLd^o-j
z2Ft_8zA(M00N2Z24=!k>Tovu4(z#Mum^`tFun99YAKyqO>+S@_Dw;2R6EBWpRNCfX
zsw|*1V&z}~rgo@*0oX)wl2s=r)R(-<)L^ktNk#=4?kwrZxxbo>c_Uw|6^5L|Wo@F2
z<W|qt#?DLQb9X!M4i>O2LBf+XKD5Uco;b5kB&<Hm?bZh$<&-TD=dyU{1W}Kj$;KY9
z?C4CrpJ*RqG`%9hWWiNIiEP6453_v8pT1woub=1-V#fJ<&hPo^VeWpy9bm@IKTBO9
zfOB^PzbQhhscZHR4PmI9Z}Dq})rONva|keR0FW=?!>Err`0UrtH~S5b-;kZAuxzQS
z=hfF(?rCdk_GaSi@(kW$i}cyMWJvP}Txj(rk~SY->Y3}ITUcN&t9e9*K<-{99|%}d
zg;E4l8cC$)%}aaRum{CJ3K}QFqQYHjG@>ZTT0-Scc0h~-A8<mZ>Z<kh`PVcXyEJS^
zXOSG&ah2W|V%}XoXo_YHnG={{gqkT1HJEn}KXe9^J1b_P*0l1>sh3g7OX^5DxauZ%
zCt}6JNfxHvF&@Q{h4-ll!~cYi+}*wo_r|I`9-dK3y8%iCw?ZNBjtw7EAfps3t@eQ!
zr#!(*aM0i95s{E(AQRqnf3IQd9hrLW*i`>6q&8(>aS2^Yzc;mzWF(b@rK_NC1H&kf
z9yl2l7UafW6vJC}h<bj*e5A6xPWoHMj6|PkL+>+G{sX?lM81tA1w>c%6M0oM8HfjK
zO)q%Y+Do?ZEEQ?24vLUUXEtu?)X)mOGNEyJkrvwo-I4~we&ke9$2Q4~_C-mrYY|)*
z#-bEdi6r*20t>Jh!u}n_ff0*l&Y4-}s3(L<KPsZJ@5;Qt!-?bu=&i)ZkyMfLM{xOQ
z39EZ|CbP4a7e`P*;?)8s5?ssVMR`Ff1{RAe)O?7>?QIPZZR2EVjNl8A+8?^JY<&TG
zSF3s;&1@f*i%h29Rn_(gZglm@cNXS|I@RaAy7v;IUz|OFcR-8S2F{aolM_~=QX<KJ
z+VCujTiTtGt|RUXjN+F@{j|Hap22e0cnz)K4xH9_JAqoffvYrQz9=5-EhnzG0C5Rk
zo7qD#DYC~}x!Wy4MvQ<g499fqeCQf|H0NeAE`>tVaE)x|uC$E^P<_j=b^n<i`pvDw
zP^g9a#-Yx3=&<pT1R_aZD4JKR-!TP4@LbEOZD!R0)#4#Uq7Bo77GHv>{d`Zoe7nVZ
zkxR5oR>Ir><d5Z>fy@0r;{kebBK;sE$kIEHnlj1Yb6G*eLJ6~)d?(M`0S3ZXJe`HF
z!Ca!lmOc(?CslcsN+!PVVa|ybI;Y2!mHkKw(v>N-iQwOi+8X<!QV_LoU?qnVV8#)U
z=O(L4!zj|pg{Y>Kk{nh`lftg2><URLO>lOJcVQzMMT;ajTZw8B+|T8zbA?nD_0*?S
zCd`etgFZmhQ!2LVHI7YNcrR!@q<S_3ulDUA!<qVOu_f2VUCwN^Y7<x11nSo3mzkwx
zqrRCMf)GA`z=;$+|M)hZBwM-LG}t19*%niEO^UvLwu{z`0a(e?GX)+!TF+Chcx4;5
zBZcW6dS9274cK0c{RRWc+j^dwB$ljX@W3?ev;u)H{^yhl`;5+$M(DEsgp2Wrrm>`}
z5d0|Zr&szY*GL<>+t3{DBI%g@JD2rjq4|p&_N?)(QdRFbp}Nxyy}=^c#$l-AVMB+S
z7jel;4;leB6mmO>4P-Hu;BUmnB;c0BvbHW|6p5;+n&)AF*&XzQ>hs@?hQDmd9Va|K
z%8bQdRJd4OZbGP0P&ZSFChw{(eq#gjgK#h_J#TeURBP^l&_oo;svC}(37tHnl;<Lr
zlIRFfLKroK{vf~Mr>f?lK@Yf&n+;zPJr$GCxq+XZKM_sYg6)3a0`)2X`b1OQv`Ect
zhIZ{iWp|*>P7^FT0biHdbJEo6lf0L=@hPeL<#6?dG9Gk6MfvhUPUi+`Sv}Juu`nhk
znq+A=vca_0KZo%pI^1WV$_spC`EMSeOel8%BP_LnX}=+Lp_zg3YY<M;C5OhM3!5oQ
zoQe8aXdNk+<)Ma<HC7|2c=E1}szjmW(mN4ig>oq$!f>`d*`DSxz1*DY_Ennt0w8(+
z%i5^d$SS0ySCUKp@mstq$;0@mQVe8M5sG>PqpIP4!g^BEjHA|!V&RenkLk_@p<WrW
zGp%2oih5IG#P~UpL?U1FSQ<#$3EQ193ox_0gBX|kU>jo?MF`Q(fnQ1A_0V_2CQ&46
z^#ONIdK31E$-DIC;RVW?4VEy3LIqt+I%8#|(7UlcD|{1>l%<gSWX!sWfq-)8sSJWy
zEkfJJ3PT|^?U<8YDxYNWm+N~Xi)AF?)tW`aD4KSkrb8#}EcK_+cnoaCmBpwL_e$jo
z(=x+v2!9OGMB+2OnMUHpB>gAlb0r2djISw!PfUmuJkF3tnI%eC)FGjBYri#~{C--$
z+|0~$JZ`dsj6tj1#b#GnC1C8(kl(QB*!Egk(W*Anw7#nmupzIwyOS@Z(`_!0wJ9+^
zF;e%%BFLoG<^~UsM-Rc+BD&LKdF*i}!@||WX>?W}fLhw<i}|Qi*+#z!C@xKq`(ESp
zw1e2e@!E!hVw;@i0(3uVG`)z)DOiz^IwMNCmLV;UpxFBjzXfKWTsN-tooL3aIQupg
zJ{OCMT$@@v#rdMDR4qxyotsx^g%cR@X;OvPPo6*Amdp4`+Uwk*>wo;oXmr^80ycz3
zJM;PpQHb2f>xhbGuKHeVouQQ!^$lwc8a?gYwz=ADDrck2?^MW*C01$cfAwkaJ_8qa
zP(aw5WOT34hV$-XPx_22<Wr54vt1??(kDL*w>^6;q_C=+dt_}`nv4EQnj%TG<+f{N
zX^^q`xvk_=s<;H<M67c7<L%ywiuf8M7|NMt+F0moV;84}Qm%=+&Uku!Rw5LCMu*C`
z9@9VZ!VSMK3dx~C*0SWEcT|y_*K+xdsGWYIC1VaFw_6&C;3i}FJTk-(jDEdmIV42d
zU6gK(5KGf*_x**At9&UB+1N4XZMR5*>*jXRB;_sh*k-WY5o%+BWO5^;G=(h3{cGYq
zm^yaIoH3&*g28h$8g&>X587zEt6@LGyaAxR=_OZ`NtMd}1IzeAfiZ&+@)3IUSOW%!
zc!TRpQ?r?EaFTi@Qv6|M3s{0mKs&{RfqNCK+GRra2?-{!BA9WA>Tht;F@!r@>YEUA
zG=vbyQDB=acSU)tUmeM?Z<0GGN=rubG8wt6t)S)H7XptJwo5oW<7-R$*YW>A^BAOr
z&h2<)1@Dh8DTVQnhcm=|zTHmxxoE7nS}*qI{(7B!@RqhpMYEnP%&xAs95Ppo4YZ$`
z-K*e<{`Kx0S0=b`%~KWIIK}|Oa&KX-l`)92CE35Qeyg9di}ZXh;?WIRjz0&82jkgX
z@6Co#9;EdgoR2%%n0AVkLRoK;S(ry<^t$o*EJC;LK0$<{tiM^CYh?!ARThP_U!AaI
zngV;Gyew@h|8d5hijq>D2JCis=?oOto)DS_hq3=aM{RQw<~XXgT1i2VD?$>io6|V8
zlD!mVjh-Z~7r!YH-d5atV&`5{AN^>J;$;3Pfw+H}Q@Elnw}_GP_~%HtREN*$+p8y-
zb{78!!8{&7E7($w>nvNlXkPYr$QzG~qY1lta31~z9l=Z5NM<XeL~+Z^8{DHn@gkFo
zcL$>i{g5k8EaZ@2_4oW(jzca#6z;5WdYt!k#C<TT5`~nb<dWfOM)kUEU_y3}Y_3#0
z`6n!^lgTV>XNSt~E8KS$l6h*q(HM<Z`=8x`pi!u!o4X6|pBh)B?$lX~+(HV?CBLMr
z=^%wHCs5bA!-td&&Io&??V&gi&X&UM^(=B(do3B)r#KC1jA&XDrVA)JDRr-@Mr*=u
zcg?`WDA1kse(~r;)QEVt5!H1>$u!vZ%)9FRn0V~cr;SEcZPOgJW7|*`4XhlXks|cZ
zm&dBqD6gB(*y29D;RwOk?Zi5|J~@+8?cJJ`7x1QxAkA;4H{ih^0G_!X+Azo*Jh1r5
z`UgG{#Gk=o#Qyl|zjA~GS~#z@e;XxQqF?=VcOqJ|!1+9LQPt2{m^|u32#irg!Gor}
zBosU|(**AAhz7=;Af9U8&nuKtzi6bboBD+%@&+cb5V}B3ldPE(`zSJ4qI9j?XS7Z;
z&AJLUKpW%DrnQvyzibD>awlO9cjoMqXr7$L6<^X)F0W$%&Dt>fU#k6>?EnU}+2={K
zIZ^H%c!sHazfJ~`;8$`yQu~aRKFGL<hHEyrH1?4v#o0GKB4S)FkXX)>F9I4z?O)W{
zLxxBW!{a?wnOrF{P_5PL=13qCloi9c?e5D^s#>^N_vSpKN5@^xD<gaoRTR&6Cin8?
zZ)Jue2#Qr$g!J?&!zsHR77rWemq?bt6C5;+tQkCL{SNdhJy99fT2u?D;w(2=n6Q@K
zp4+bP=#&4Pv=iVzj!)AFje`D!*xAf}0frb~(|`+LU~FSwWD6C<#wfq#$Dq*v><&&x
zP9(O4&YiZuIY)v7zIv5MQW@reTcNmk#7Bo#PbAhi!@X2(79%fv13jN_{-(9@h8hIo
zpILt$zLF<qaERyU$DqQtD)-^Q1zJ5^dBrDAnEQ=1Z&XU0Yfqal&Mz8)7vDB&q%LOn
zoMK$*VO{=rsuBYrX{3?;xKlH*?_wphE?2~S0Ee5fTRf2(^k9k(8rNFl?xHBU<!YDs
zE6OP{Tv$-NK`0c+#<@jJouJk)>!1vUeBYd5c%M3W!mhR!ooMWy-yI)?X7B`>50N;5
zCqagthS@>74jZ$d&u|>U?3ZzZJP7p|LWZsQyn6Q1RI(=VQdp-gT>XsUG1>r!i5Zhx
zL5ot_>TA~SAyHh9w^>x=zs?O1#8mGZD5p;1k9(g^?$L3DvkA#AhUMYXI$=;x**mFe
zrRUlaK9ssT+myOk3vImHRcY@q6TyKrxp#qUXC*~JG)9C_4gub6u5byMp6jkBpYyc9
zg3(i&A9qB{TrvQQgz8;7N(_dHli=!88?l6qwbAYWK`-fg&0e{6H`xpahb(q=TR^|)
zhIj!gl9N$Xc6gYk1XOR3o43#T)Fx6iiNg1^jQVnRPw}<jO5eDMWDRJOg0;<=i8*4(
zuzES;Th#+e(@U{!xv+J7{mb<i!fkGoOJ}wLo?KIZsi@JS$umUIej<_xDS7>)PISTa
z`IU34_;=%2iE{!j)_|5q8c~2|s_@<&6!T?D6MCXZf7a^WC0>~BCEz=Rf`*O-6Uwge
zSgP*2FV&*h78J`rG0}Ss4<l>SUm~Y(cQh)X6`NOQ_N-&a?&CtK^^2sm{jQp39hys6
z#-~1Y(Nt8o6n3dbs$UKmdE1aHUxj#LB|m2ra|ZBi_!Q5Kr9n6#QaqO}!pA<gu`#GD
zpVim~$^`t!SEM2SbAR2Tq9XR6`|B`11_rsj5!bGwHCrDmARLdv*{^C4T~V!hnDY{D
z5xc-HDs+}z@CaMvz)S5BSxpv#u(fzowBtdu^yaQDwQ}#1EJi0d?k&MpMLT|lEG9Gb
zXf#XfwRVCJg<WGg(bU<}mHGLR3uCpQ!~rahx@>M^hLbz;m+rMd{8aKR1PgEZiKQh1
zN@>rK?9A-WC}mij@$|@pjWG4Ni2~bWn0ZX(rlw<2#DvNGtN{xt7m1Y{ew>u@sj#DU
zE9RjSB)Hq|hlbGX<AyUSAdM*G-w`DFL9%y=96%1>v8`#$3z}{Ypr$Q4?+&YNgr*d`
z_qmjnt*M`9ESx#Cm?U!6pR7jvwErOWkf?{4eHuJ^@J~cV0|Ti0fnC8}SwtmoP$|09
zXAt=^uWfmTPuHkbK{bj@?Padzk!cb)x55>f6qJjovfr1e(3K&eo`=yedL41J8x+3}
zIqXzqB|)AvMlKl{Pn%o{y{TC^9(J4Tb&*r6hO5khWI}l!k)%M~i@!+4LoY^7CTSle
zF=Vn-Q{$}Lv713Of<;rE5mqPEXztK#VAS<NgiUwt9&-6;U0WwaY^n{}cN|CvA*DB%
zM@5f8j!)vOxM<sScz2^i8jPYcMj@$W!`%gFQQZ0`H@%DplheD7=c`BmH}De5**n7+
zZr+6(F6L2}U}XM)v%r+4-%vbVlRlZ@!5+NsW9v8xZj$)18hm+q72I*MpiQEBtSJ+Y
zQ=dXEkEN{I;W42@Y~WSA7*uRAzB9Mif~geJHDO>x=)cGy+Y@8f<!Rp;+%CIRgU2Hs
z%@00!-Nkm3VM=Y|mtgZVTw_=tCdo5A^(Nz6yN(5A`QGuv(gEbaZg<4+L-Ef>$GLUT
ztsh(}=P>=%$(N}CH{o4MqgaJDYuu?-Vfho=Kd`w}99)OSSu-ZNmt9}s1g$j0A1dHs
z^w@~U{EA)Lg+SGLTwmwZG<D!e+fcqF|0=8EgvBK!sD7mJh}4ZE<`V9e*BhNu&s=&M
zvcH>LvdxS&G99;&ohf9$36ks<?rmw}ieaflh)K|fmB9Q4_2=q~7)UE#F$`+=&rvJ(
z6YX~`X>_ma@%zY;Y}M(>FIzUuf$T6u=FXDc)Ms65dzDx1Uk17vyT;1>A=gx!)+x0u
zKYmuw`UtuQV^0*si=7w8CJ&uDem_jxxBFJdCPq@*o`6J4s9&g8-+ykKS3Bc%vODxM
zRfHqo93`374(9Gly**Y~cHG+=6GIUX8<xFJsKB`QEFxigoC6j4Vd{MGgy7yrr*k_Z
z&6SCQ&urT*49<t$=V7R`Ri#B57=q!CC(t?fmT{AbTvdhw-j^pcC8eou6&Dwj{l^~^
z6MjY$$B(s4e=D-}fc~}-R9gjhqQ6$z=6;8Cj<0IpLH^j#|JHs2A$;}%$xws{{jF$f
z%K@a6nh}jFneeyzo)+I{uU3!ve(YaX_63m<{Y?Jmt_;lnN*3hr$`>SCDHg(CnL7To
z3wsW4D(SzH1^D}d2aq&Lkl=5XMK)|e3MrZ4m_qTtkwx>nVoCF}z+UXHRpS3YS%3C|
zW+=gg{Z*QdpGgEeHg7V?-^gn51?jQ{93H@r`;A&<pcPA$?$>?VxKYE)m#vR3a~+cS
ze|Hfkxon;Gf^lxg)_prs)vI5jxt3#R`G+-nzomD)?SVqIKQ%LQz(T60m1*x_TCZbC
z*PBV!tEXw7_l)Sk4U+$;AMtVH!aHQ^{l59}C_m=%uG%M4B4Liu2>N&NCKLdf1l5#*
z9qDuAF8J#XYIo0Rb$4{N=RRdyoe;OW!GF{>F2Sd+;r)DE{CL?9do@a${nJACWz|Ty
z*X}no_`m^aM#=g6z<yUNr1+@&<@>&AYhzbR(p(EUSpE?#GosvLGE4|C@5j@$1x<hC
zKZ-;LyPP>ON;Qg(0};#N<Kq^8`6NNiNZb#M^<Qmq0v6KA!y+6loz~%kWATE=`X+tS
ztU~bn61L?MM91T-5t3H~CiXv|6Y!N(k`;(>`_w%R<Zn%nOF3lxRnyFfIei7jN)uv#
zg_!zp0IC~*-zEB+E=$rriD1sx7x^o;#|1vIJ<c$PMfx`o@lAqs$vMav6Ztua;d#Uk
z-0O(A>x76@g5Muv3z7s?Zg}-<`wwe>bTlf_rf~Nx-s9L70%nnz+;x~_KC3r*EgI-~
z{g=?gcs`QGpaB(x(l;nen2-_c$xAkigiVH0Y$8}}S{WHm_!%f?g!UR%bFyP^oub4g
zwsgVF4Z!9#@O1WTVN1!Eus!@L_jTH?O4J#jMR6e7-;B|sv!#2afz+vG{~AzRH)X83
zMC)I@A?K_sMRO0pFD=2fkoCyYy;3lGTq!U&kV#|^REu!#jAfx<_BpUJNl3-c=q16R
z=j4TYfc&_tW?~rnulvaO3Zy9se3Z!;$TE|Jm&xLOmaZ}6SpKq%U!Wgw1Pv-fTTG5#
zWPqlMn*8Ir11NHy9u11X)(4t9OFu}KrO|rC!$@?m|E<wXEj)4ZsUuFJ2>L$Q)@PTT
zi!Gp*$3|2w8f5A>7THM=2d#O&`c1H$?<W$MIl9tE|8h{u4`0T@7!nns<0%ZQ9D{^t
z%246=&d^oEOltF9v>KOlMg;#gI)}{DRRWTE^*{d`@dK782(1%>T!#-DRusyYy>c`F
zCFH?lVTq(RqVklgS*acoBz-wHB8$^wne!Mqwum-s6sVhoX(m#S6pNf-Pb=5O+2h_=
z?h!fnanlo<HAoG$M1RtmFTRDgMbDVhub?f<u1EpVf&X2<CqV4A&fxajGX|;a*(V!7
zt<^sJ%32>VI0N{osc9$u{?-d9#FEf@9kRS3@l91qNLj3Mnt<%MK8}o_9@w<g8M?9(
z*fmj1pOT||X=e3gxW^LdYniXR20fjxUzoZOfr843P146tArSF$6j9n72yxCZQ8ei1
zyN=3tJd}J+5rNj}vbPkV6(pR==!0hxs~8&n@%dz(LbH#Sruwg%eUz!E>5)#3C}D|E
z2Y7yAKj{$MgTN=qWM+usPvIw~rXcc_S~nS^|LYRt5k`ujS9;d+u+^7WGfYpj{SU5x
z(oGBRm5vMmRE4cOooP^tpf1UaH;j|83gcX1x@igrYsem0#9crwqLMm3NiXc<ruG;s
zn2!<BQCug-<KjZOgk_*ia$AmnQ`}=Ez9@a|ogpsy^<-OvoMcbHTjuydmY2>M{F*W?
zchG(wPDUf-ra%7H&deK()uZ!VqE9^jMKg*;GXPPImAMU3n@b{rhj!m^(UO7UieE??
zsHn~yyh#RWJOg>C?M7_qIGcJ(v*;s|;I~yv+JCwe-8Q>1*ljH-T&J~pE{rYA0WE#m
zkJ|aw4I@*-n&p+KSoaLPMIxOCz@0EQV}#5R9<2ae@j%r=o|ND&oS$@^5rJxQL`1Uq
z1-q$G&M3}<sYq9sXhRt3H9yDoS#eN_1+cCb@~Ms&&>e>u>p+T&_rgLI#vIpS(iw{3
zF-}ExY|&jLhvYgxw58D}bS`{LSqcpBZ-)?ETkKHJ^Hpvu4c3xzSE`z!{RC+7oa?VT
zxd#l|!MHE=l+_LcrjCY0#e|IEl1)_wF;^QsDZ2lAM#>0&Gcoxpo5e-0DQsXssG*@T
zR@5mG$I|>&f(Z=NMxT`qs9QE*e8bn>gc60IvbCy6DESykeaNq8gbgFUJQZ?7grL*+
zs7APkZCOb45N{TSHh8GLhW1+J$eDEZ`P!0mk<@ypX~aNhVNtnO04Kfo+aZd;wjSGe
zjO}H_r>ZXSsHiavK`I$zPI@#M$#?umjC*=^){v<I9vsmSJz3!^=Zn;l7@bI|M!>ZT
zJxjU!7;qLzcMAC4jFDWLD}%hg-UBL*uSN}<07G8TYMB}RXH#qkxS}&HtP$t6bXrz|
zsn@Gldz(ZDUpTkbHu)g4z!N~M4PgtDwJ1Y&nu$6=3&YLik|fzYlc^aOp%8Lws6y<;
zHuVSzdBuOmBjyB+67vGkoLnv_f@(kElZ3n{8#i<ivScFc<chgPb#v9a79<iQG-$rH
zw8QoGmjZa|&|XS;>qvE*JGs;BD%u-tUwv6jF5Wv_1KW&yaea1#R<sh4(sz>d;gBbr
z>Bc*jy;5WCOk_BQ(=RFp5TPbtA19Xta#68=dbulj+~X#Sk`m1xzU4)RMjt~^1)!`m
zzB`^9K5{ADu?t*G5WPFn9B$4Gl{&0&S-rHCPMf6Z$IIv$3(;BWu7>0ZkI^7(|8a+M
z61nBWCQU^R?U3?c3k?MM{{6e{?od>`!lAHwp3C|{Z|1%m2-8>nZS<?!nXqOX9o7nF
z`{dHnJC8Oh#zus}nr>|Een>T(2Yl?Tp=h+0@BQv#iNvP;61OyMt8ZvJ%W#AKWFke`
zp}kgGs>!B;4|XogF(|cQI%=(igAbSGOUzKR5f{uWr-+3UwyKPlrB2%FJLwv6uiB;;
z7(+wXEh9F11I~MX@?zwoLYwMc<(gN|g}RV$-v^Xo88;ZZG6ut+&*i*-!S!f&Yj!ER
z;*B9Z7QuCLM&94kP#x8&VAR)Q7q~dzjkUWcBHMEo5srhodes~TNpml}>VfGV?6n0S
z%+`i`#rU{ETUd-=%IPoy@7)uV@IfX>ay_BC9j(QAv~DwpF^fqw?6qctJ=sN&zRa9A
zy+SNw{GfS;E;JOMxZC;uYHZd8uz8FwQhuOBX+HKvGzV6rbKWSW7%rZW=7akCYF)0l
zSGB}M?{*w{DVgo_>rjkoXR1zg%K;ss3aYq~H~AT=fHAISYv$x75zEC`K(tAimK0Da
zaL$nt_wcQc1$i;FdsEnGuXJZt2mHvnGlVHc1JyyvaARigJK=Ey$d(fB_h07YQCE%3
zP+>j#)hVHtey-6S&}S~$dD=!s{}T`^0!f(V32e^pX^~6X6aBJo_0tW_<0Z5gu}9Uc
zqhd$W7*wMRwyK3Ple{=(KP35DLlM8Ar;QCW;I0}Z#1LTYCFy0TXQ(~6=R3k164FKs
zPiO(f`!-U1=vgeh*WhW}bOc*`yJ4x~(~>-?ZfeM=5E7WGW@k7+v42@3W5}7mL7F#l
zbtaZ~fxQ<gf7_v|IWS9<_@kN9%hU>R-ImjyK_4S#pw0kR+|Y4f_Dh=t5laZ5*{vL|
zph5~G{EEoih6`TNT<UR0G<pgupbzHj?k)l5D#ciZ(Tg5>`ItfdnsE4UZbv>NIwD#B
zEz}TSQ&s}K-C!N|X$a?m@FA3V-0#li$0R2+h}r?97=nA9!~;U<v7teC9}8DT>sLt1
z^2>JZ)q72Mx~yKDAHWu~@p}u*@j5Y-*PQ9FPIq<0+8c?aNN=Luw|NaCq5OsL_d@JD
zNuD7xxT{!Bc>o+jA`@h}NX$W>ZrSU}^O$>{**)nOfNr|zb73MoIy|-1_HxrlPH^tS
zn!FDaTDqk~qlAp!fA!-!3UV!x@b>oRPzyC2d5BjVSS#who@N@NZN0pKBmH56DjENC
zGG|2m<?>WN269uxrFU99{~*a|F68?1Kn#a`o-#a8q`AGO+-(rz@JBRnmEvqT@SSr#
z7V%C58SFf8^^O|1M0Nk#I$2DJeXe{zbho>XF{@#An?7-XbRzpOsIDyU>v{enP+m{#
zCVSYz88DMJvqbyA?8;fwA!g9h8lIr-Znz?%g$^vjsU4Swwt%a()cYWhkvHhu)NC^B
zoOqa0A13f;>LUI-GgHu?_!vVRu@n`O)(5GshR!qi(ZB7jg@kWbn}Z};u1{h192KuC
zZa3!cp|aT4^i3>zS880_$1xAspj_X)^*djaf8XBTm|q}TX2Fknf^Oq9tE)S`+sO<0
zZtJz7=x4_kNEAv%7t|kRACK60Z4KdG>Rzi_^KPR)QXgME*}?Qz-CWv~ZA970G^50=
ztn{rl@KiL{(%CK0?hbOjE49ZWV3VTL+k&DQ)HAJT(qm(Qxi}MP<G#kH%iEPCC*Rdk
zw=Kx<eEpxZaVpqX;rkvksfpt5c<H|SH8=tRlGXiVxbD7%%h8vXuh*f)=ivxE@unA;
z!O2Vbq4`fMatPFQo2p@$PdO&ip<AtDviz-ii43suGEDQt#F`pdFU2|NK*=M9;997I
zQfsdUQl=u*EO$g=K^(i=sqKZZ{XxNsYTv>7k6#S1$k45vkVnG~`~`>`@BSA%?--xg
z*0ql|Zrs>OV>^u++qP}qv8~2tW81c!#z|v0wsD_y@9y(|-{;xq>-lhg=iAblYs@i+
z<~7DzLi8G^c^AI4$s-Ftis?;N5T}E`r1PBRx8d~_hIodN+7D7KFdW_r2gcz`jm6<g
zC!tDHaLB#1QE-&;0vYHxd`f&=xXH54v?L33gKCn<7=yv-xIvy6T5dwRg~4J5_6?RW
z6I3ao$QT&)Uu0z?cOj`&NOC)xAomi!kjeD4LhVY^MH9KwXD-w=d#1H+@Uo`(6qgwz
zY@Ee3?MZdh^Nt61_J^C);T2I?IpmS+nUM~1_QSrM1iG^M;21g(1`-))XcYQcyxO)S
z{qS+!Tk~v2#~mndUlZY=fDICKHNji0v0nKxLvHD!94b4Srs?(^-Nk&sJP6`b7l(^r
zd|LtIab@%in=H3&o532+VVmSshxQzDZtN=H{|;$PpX{EWjHa0w7M2NZ7gmIrQiTAP
zD0SOXx@$*lY#f_b(4hi^k$MNkY8fQ4KVzFV9iav&eP;ZJgZDL$&^ibmqeQCXCG<tt
zS!Zc^1bQ{qk!o!C!qjSNbcA+KgG=%$v~8eByB<2Oan<!{Xho`95(6ieX(WpWfMGYr
z<_=ILb5ZRjMHmic`fge`T{$hX4W#H3V3JD`rHx5H7z^FKdi5N7sbAd-$9;uc>@CGa
za1aa}%@u!2jcB?Hp=ZDf27g`{B&rMczk)H)CpFi+oLJ4P;#}IzNhkX<K7nm0%M}OE
z7c5l%k_`J;Q(8Zve%qMkhup=mH_8|VP6q~}k)jo>-YI2>3jge3Z`kdJf9s$RbBi6k
z3uS8~>wQB6T@zu(tq>R*w;9E5(}9O8NQ6IVREdym3+}SA+TEG+lR}O8+hGB|)#Fnn
zIml@Lto|2R?x)jvW)Cl&8V&Ucv^j<bt_saIRF&G@E6cvIlwOL#-m5%J)~m1WuWBhO
z=y*wXT0l~-$D9b+_C|7K#y*hpn=cFvpZBxx@@^{|8fj&@RL~I^KV|gj2&}*4xrp{X
z^tzsv$P$Z$cwY6{e1y|HEPrs1mFm@LVb}j3J8MvowqR2GCr)NA3fuBnpnyND;PrO1
zG6vBRyn2NLT)-MfP+(ukW1=@ZsgDA*c`#!rP2yqi)f^A!-YJ`?dPp_bO!*>LyC=b~
z!+{72{)kOvtbIDJ)`;yvJ3bWADhEtd5L4Qp5WsDwxLl=FoReU{MCoqF+oN$k#d0Cf
z#saSU*GMJZY<TF{H3=hu4y(%er^d%TgeZ|3FX(}oqs#1)V}!yxVT25vz-FfD09!MB
z;w!yTGURO~h4p@RW{Nkhh|Mc_{e_Ku&0B;p=2aWFG8vZ;s$T-1H-*`)=+#zGlMX^X
z)wmWQPtFS+zFdWai}C%{-X7}zuGXQx8hsY*i*dKbjd>4>*2XRjb{(3iusSrniHi>s
zI9P7}*$apGH~_cAAtn!aJkCm>`lUR8B62}|WeA}vxbgaSo+Zf;>Uo>Fc#+>{2WO)j
zqm$3;GQ4O4{g0o6^^@g&MJ4dO0AZQ9>OLez{7fCSgUCEn%;j53a*z2YBE)7_u9bks
zdqZ>^3a3nG+lfzlfk%xZp6rMv=~Q9WMzkWX>2xJmVRdy47#}g%J5IbjlwHjSE`W&n
z$11HXWj1-xh=O8#|8R~;_XOwQNlupSEjRXBoY_ny>6g$+Z+jx&r86V)NT4Z6*x(V@
z?tXXl${Txsjs25H-pe?6h~od?EW;?(%TcQAb96;vQbzV?X||$Xi#pNr63IvtXsFiV
zR;mRRx#i@`B~;;*sZ|2TadMO;0?;DyAD|Nm`GUl;DBibp%;b6wdaf1{3#~t=yLGFW
zhsI$36EoZ_{~gg5gwzS36G-Kv_ZJpwDI@+H6LP)%ctOiiwVqKe`mbP979$9i6weN{
z-u1uUuEKx6t<%AwAN{XTDvu$kQi|swO85T1LYg|<zmWrXhhF^H576!JFMD1+xHv4z
z>g+~W`|=O+!V7xTB>yVH^!F()(x&odC`8k5hz$g!Z7nLA=jj)6M1tU-srmhc_I%h1
zk?V?u`<p}2-_WK(5AFLcNxsc8-B+r&9o{!E;M+M+MlxQKVFQ=wZ*<EEbhLI?wd)BD
z0RbV~n;7eF7Nb74-$6l(wyhHV)zK{bIelU~x$A|LDHYBe_`IR}0^$((M;dZ|z8b-K
zG?EFm{U&wF!vlZys5EE1zrQ8pdQ$#hp=c$-Zc+~AO@@DmWdXlIZouSM(SJpg<$iyq
z^8eHRzd+lKQJT;A7bzWypA~Dk?%P%Juo2V4>$#5);m|OD>>q%X7M$n4Wva)fY3H||
zS+Q!;3a5npMF#&D{5=zq1V;L<6F1-qwY#Rg&sd!|1@v1JY#aRtyue4vslX3^z+-y9
zjn^}mhf`ah@OS<Gs0(~rEMaMB4*?aGdFLnieJ;k?4By^4-$s5Ip!fD$)b+vBeH>MF
zG!ApG9sGy$<V4@v`j?wo*~_gEg6()&o}R_dyN0oE{yV=xc0c6b^(X&8q~CaY>TlHz
z>}hS~)JWFa4clM(n-L4L>~dN>1Ss#f>#Rks;J?3GVfwV0H$TQOhD-cDWj|l{xVv{2
zVn^dZk!=3dSDZm5^mFk^epD?Q^CGi*zuN)zyPGH%YL*2hvD<=fzx!#4;T?hd`5zMx
z{E%Fn8Hj!z_fCucyEc=Qy3hWv9>ap{-33k*r^Np2I@W%AU&q>UmLc(fT}S5MAApDq
zMEt8KOa84P$;O2oGXDyVr$Kw>>}OQj4W95LuXtb`>f>QIkS*zMbtWBaSeU{-Px%Im
zAZAQWKT1)Bt-Z2TvasZq2tX8B=V^6WMn2Q5R2D=(zO_`k%h^&Z62<o}obiA&a7j-x
zVPPtx_;HDbz~Z}jNeicxAp1pM9`A-c=vD!dI$!pxHX~al9x-MALCr({H)?)6aiJ7r
zU6D7M?;OMB*iOVG0{JyedkLpOVVQ>>al|rXB4_f<cjZ)wLw+vfd~RjNo5(G+4F5jd
zc5H5$IV)=%B<|4kit~ipj{R8oNKLA5d!O{P9SAC!dbzB#0gcVLiryAuaKp7DGubP_
z$$%F2udc3O{Hc*IWF@!y;0Je`zq+E$qKn4$J)T%cl{5_JmYcpy(C7m={RcbM;hI`4
zPeco>u=-m)km7cIF9`1D2y58G4n@sxCMNUdtp!;dqSiNYH!*uP>W^0`cc~&@jECZP
zmOlYq?|pL5&+#`=6rI@Ks(|0l8(+dGgVX=1addvPqJ__Pnf&xiSk=FNc#!I$Fo{t+
zpgs8;d@dVm_s`kP*%6Cn5|gjN_D=fZ$zYK>85fF2m~fCz%QI9f7`r*O%1?Ga*4R__
zU*#Gb0kO+Ua6Rjv&TP4YpiCJS0Fen{U+W%YTjQsp9iuAJG^XuLjqzzGF)D4C8b&6@
z1U6sjM@Fo6bY#?X$!Oa#Mei~uGS{pfmu%=4SQa_q(kH6j?N+F%HLtAI5|$fS?MppP
z*Y5P+H(wqeOJ2^UHhVBD(@eZUv9b0K*l=$pu5cb6(5R(Ndvu+-TyC9MoZ;S?Ku)X1
z)l2cHqLgvnt!D}KD--5H!Fzk&oBM|(Sl6p)l!r@O8F||9e=2XL;+uT<GGYG@V8596
zUtoV9?en4W7o_L^0rn4b*@#n7yBzF}db<rjI~s!Fv;g;l2q}^JgpA4r3QSQe#ti8K
zX4NAa25r7CzvSn(*7l>N^p5_7#HZiz!+>5rgU<`@%O6~4!g&wP?DsJ7yC&csqB|hl
z;Y*dyjYiJZ?3^EbEU7C;x_H@rhfS`EgRNkqO+;^RRKyXZ=nRfGDLCS_hEDjZW6tgo
z^~~2Os#pfWa-}mPtqd%^px-PP89p)2AT;J;!awC4-8=_ievc$Fo<1RIQd)~U(4f{R
zSU0;e`#f?RI%l1*`22;z&q=ZMXv;4_Hx2K{irilE_>KbB_*RO2T3zYs_g_T*Z=TQI
za8g1sEVsOgu1c7?Wf8WFt%eobX27M!x}}*F6oeLzv`8{X;UyIzmQiNtj>`THEV$v9
zlxITJPpO!nRC;ZPHj~9awt<A9?6+WYjUI@<p_lBkA{(%#@<>T~Vvt21+1r}P?VG=f
zfsjjfEf7qg@4ppy=H(n}9*qQA*c!-tUnGA@VEna%8Pkbg$PzG7pdL_?cCIquNSREh
z!U2GTG>#&krZ6#HuM)@iu~U(vhz~{IUy5E9)hryW6B7gadzZ*g@qQ~l+?+TOVk8_Y
zItqV6L>M=?E*30wpEGHA11WJb7saIK`DS2Fq+4`Do<=hlFHH&<y8coRNnVW^hGkxO
zT@v${xc-1yQ*y3<l;s_9JJ8jm`#P^X;=@LU?h_Gx{rWZ`d)XIuo}(%IOx^y>?c|MJ
zGO~1kc{azpHFV57ULd(lVDtHL)=A2-to03M?OaB0M>Xi@g*^aFal>QLtnAt2Ve6@K
zeP)Q)i-2Hwp^4<QqN?4Gt#c;SrE7(h5g3LjwRgR?&Gvr^Y|D-k=Y>teUuzL!q5Q31
z6@O^q<L*NdG9|@bSB6DY80Ae5+-6uMPubmkm$vz~nrB2YvO-mBE~CQ+FxqAF64)hG
zp8E12ygy@{D+QWIG*s#l4%MgqQAWrCkUcCMyDadwX{KYsY%#m%8QXQ!_(J4keHJRD
z!9AxP3niY*RkQcDmPR0mphvI$2|ee`!M{R;Ad$v6>D6hOD~rr)a_n{4NNE&&k7rv<
zPW7ImXCcfWwWU|hMJUPYb_)GqJ|uT{_OpLox@c`p|GCg^r}^AwLTuywtBkkzoR<=Z
zJTn%pwctq7qq~wr;$UZ;x2ytQ$}ii*JsH-yHcbYuGqm`8QRAm_3xnUS59|k$fL#MN
zj9KV<>506{4*qe{yBpZtg)=%qvVeg}o4|z8rJSB)9zHIlA*o!H<q*qX7NdH1?ohpj
zaffOjJ8Ho3ZB~U9O;Fgr+TxVZ!Kaxqqj=blubl;2yMbBfhDVVjKlyY<nWoY(X-c}b
zsU|t@3TRltB|->VF-JCp@)AT|?5gSGD4eSu&~V9;`#Q-Zuj<UtYNcs?%AX2*phEus
zJW~a+1Sq&u5u~V(OY(+y7C3qOK{_V&O|bNd{Tgi_#uz#L7e4HvN7`a|fGh6hJeH#k
z|GAF{ogH4&HF1&^Q|AvgHsp}8=9P81RhB4Q4@>z}rTuzzcPIOkkrcN3^Bl=R?T_aA
zw6j@w=afSH-X>MUOFIglE>0K~(%8;>z1Y!X`9q3JiQ#3=%|Smbv`of8fM_^(S%HL#
z5oLZrJXvLXTAqLY1)wr7n~yZZl+5^W;d4NI*Nd4xelF&;#W)_i5r3$1AfMlvI8ezD
zw+>yDm+#0$GK$ZZDbqBZur6dHk>j=}7KbpTdJtFwkAuV!=WLkUFR$pO)T2Wbp=Zi?
zaA8D`&5a`$^86$eGDo>H9^^<AT(gduIZ|`zVwG3qA%*b)7Xa6SILC;ZWN4-;#e}h0
zGwyc#_Gq87p7=I$Nq-GMo%tB;G@7;qU(XrWyoQ7d+7hD{WG-=CbFly1hp70VcNj%M
zt@Z0^(&b{S>+Rz?a18H7@!HFg&D)>A+XeaD=Zeh6(F@AwTh@-Kr0hksA#ZOM_esxI
zi1^C^RC@Du&+)@Tg=Tlx8_K#55b9y&9^@br2)6MUzp?4J3+(CV-Ad;@8N}&Y=iAtL
z`;gUs)|=(hu*r4|jJOA0p4&Z$5_;ZOpuZ#ouS_5IHEmIsNPV7AyjC6y7GdpI|1^nk
zfjc`pU+j*=*MiwtSqVu>N-o!{QqJt(g=)bE`m@#GVESzo_3YX3b=0B3#x7{7Cc-UK
z0$Ra9YT#_dDh=oyal&pubNfo`DRHfG^Bg{zhhPZqXfI*3d?C4V*U)XXr61P+s{$uS
zklvI1u`%a@0arTGE)+NFiHwEy=dA>r>F@em9}XsR_^y}KWY~Dp($LN?h7*I!3+Jlg
zi<yOCC7kM4{6R=*rj8QLed%;J(MH89Us>8|moNepGz3=DX%33KTS$g8%kHCHTpO1`
zMj-pQ!4CD<i9Wjqc>Ph!p?Ht@*46V*sa3*O`6xuh8^ib#v@I$K1GeJslB#rjq}P3>
z%S?t7pOIj~Db8cs``me>c&zN$5lCMBhG(}mMXET1E+U50UcHxuKxXGDYYWFhE=zbq
zeIrNYKK7}0ggSn~Q_gG590`y>YGE#1lCn_T^~!UZA3QV1AMlKSXrlZuZXmjAquvfN
zoyG9G0rO!sb@2h2S}Dy?`;m~1@vqX}&a7s12+>|cYi=U?BC7ijo7<f;0dT}3(2FqS
z4^vEH!h*r?F}(X*`LV~-4datGl?QIlElKUvF1jYVvPGwTONn+2>;nuaLSARNw>(qh
zt!xDWEMl_##yP5VbIzdML!l#cU*sMo@y<FftD>keu0j=)pl5mdZpnjJeqFczzT8iz
z9P1ZCB3KtB^%i1YG!ePv-n?vmZ)3ryj<{pC-H?7G!q_p_Rrcs3=0=6DM@0Gl!Eff~
zKBqjOJOrNjPC1fW@2M4Xa~+X&+1veb%TD}#%v@6xPn5MLT_Z}%SIY(y<@qKq<MCr1
zGl+GFWrEnpxNLatgc}GJG;LgKgGsC(v$Kr1eK9>MG;D{tbW2Fq9ww@kk|fPG{4H%I
zvkqgTYm3zvj_|~3NQ@*B^+m8(U@@{7M>|w9QQ<jSne~U1e1z$xR82ea9Eyf&m`qO*
z-|KJ0p6q`43ntj?AhK24xqwi+MDUauSjb%O8OOMmGsh5YYGJliNwFsj^P2{yyyy`(
zWGW^#8^ITGLgr6+=fyJ{kX~!r2PUaP+`>zb)wBhd@TKEE!{@#X?^}%e;B9mXAmUlO
zHj^EU?m#exun1^GEzUg!WYm)QNL7wRd%YD;G&y*8!runM?%V@GHj)g1Yc-55N1<ms
z8{QC}FVrXAL@ES%8$&K#v<CxCUE$}ikLht~s(P3k+CDyr=WheLn`_hO{9yuB8<+$4
zT`Ls_1j>)V<Q~J<kX)J`whLW?H!%0kwa9ZXpwDI!%iV6s`OXg8YP0t%?e08j*V`r0
z+g(rB;SgXf3pENmkI4J)%u@>nR9afP*?vc4L~Sa(R_MHWBH-)T^+z*={$A#7!#ot*
zjrJ(ZQ4QkQnY#R45H+>NLX}+1yQVx#SCFwCp8USqrJ7KtV?z0)(ENJjj_^un-e8P=
zfFgL}#SO}(G{z!<hWS5b*emT%%NkZ+|1QHK_R)HH<tAXASp?HIR8mWNDpJRF!JcaO
zEvexrLj_)SOYgS2icyNPtm<}_X%apc=(=G^AyWmX+F<EU_6mEsQ24lg+^pQ7-Js<9
zWE{qB$A5Fi@N=cD`g3ho1p1#ktb3b#!mZ2Sby#72IeFCT!^epcC-{j1!$hd)x4kdr
z6|~7*Qi^D<o?cg!h^S47H&3-A;B$E$gd566v*Lus`ug_Rrxg`u=U9uhCN~jiJmar5
zhuTU6^FuZ+mSziA2$ln_?w72C2EH!svRO?q(u`@~nd#jvjSS0Ct7Gu(;x<nT0OGW-
zr@Nr&vUg*OE<4+D*@l*UZL4*Zq>=`e7>m2D`H!HkMW&b)X(*bKEjY)f=_$CYbKzk<
z-|(HA6st!d%=f&B7xqTn#l}GlTN4FxoM(fzSPncQV5Oa*F17FkUugkYaho=Yu(4!K
z6RZ?X#DJ*do&&a-(`}?x>P8~_FlAyulkARn-X)8VfgVEHs3#EyfOz3v>($F_;X5A3
zKz@a8{SBeKECGHh<NhcGEC#m{W|3?2=pIXFhV+q&T0<(|`GjSwlg#G}gr^q+7;>1X
z3azuhYRBIM-qbsNpz|Y+&FMmzcuLlt7b@r)sUChLABVIlql)LU`%Y9|OCB92@*Z*1
z0+?|IGu6_pPFaXDEfo?&ZEgD~zp<jVb59I<{_=Q?ZhetYh-QCs2LCZ*l<f62ZN(_~
zTRC-9EuJ-{uugoZN5eAtPwFpu7BbdmSvmqc`>kqjfefEj6fXPa$&Zx^wLac72s(0B
zhZn%zWRcKUvPwi${~)pWLI{&oPQiY6??9RvRxtC~2>U`RwYd1x#vpTzg*@BCw^ONm
z>G9C3A&h1SpxxJcWGMB9`>8$45Wih2&zY>395;$lVKgnj7e@1dsw#r`8gcG7E${Y6
z>E`P+7*DK4;i1dCjnKl~$fgTK;JMey+pccS!-lti)|*gf%u7+kk5qz!-PrHE+*IY{
zEI@TaFrBGm6{FaxDjuZ~f=z<AeOq5yp6S_s<LE#i;j0~+UxTC}U4y`vAx5sHgy0OH
zs2{v9!u(;mfIkqb7Ty1>sw*11jKRMMpuVQU-Nm;p#qF)<{Gb~2XS5187SsG0<Fro(
zB}9b$*jOpk<gPM+G6I+8a2tBc7*Sr9g8RvB_d@QTG#7_3bnbOFT8J$ELPpXs2RwuJ
zsgI0XV3&%t6B|*`de{Umm5fXUH&t2ryO;%(J@+w+{QiTp(d<0}_NjZqn|(upv<*A5
zD3Wnwed7n4W;_lK?WCY^<01UGPdkp#SSO`bOSq8v(}G@b;ye0EMmV=F8%QloeyNkk
zDfVti7fn69JP1wgXY!edi}*B#$`IB72ZJ)DfI4+m|8ZgDtGGy&nr)qg43O8iKFBVv
zA1Jm&_Uba3uKp9%58w$(q&*Ah3H{WBnqDVZH7fGObx;OKs3*c|*warKc13Fy63o9t
zEqfOXN<*;xcS841wo`aDMC^nuDfOBY*SiaK<gJjhEWyJblC^M#h+!!-k}<!l^EZ2z
zpKxkgMXFjmdl&a(akL5?hd23>3fn6ZK2cGGBi0x#!IXuklbZ3wr>gNxkdDUYjYYSb
zH$vW{wR|Z1j6v@pMl<T(vnsrpL-!4YzIUscBfL|azG{9nq}5X!a5^%dCd>I$$sjY|
z+T!9|0cAOc-%o@@Qxcw)@)%UWtN)0ksdI;sk#{yy6|Va8tK-v;{ZAI=Ib{3qfq0<N
zfi|3UYTArsk}O^yeqSbS_C$4>RP_K$9up1$n^(oJgwkk#u$q&ZikHuv+a-NLk50K(
zdwYA{8bG2__>~lG_%bOAGRHuIr#lX4Jsci+vw77RHZY0aTN6hN9b}j*x2`oMpLiIs
zwkm@S<rHa$4MlH+JqJUHM8#4Ary;_E-s2$&7(XxAgPzQI<E7hA9~d3@`K)@*lU9(o
zUQD}FTxQEqq{@XH9-bM`y=T80t)$DlKA?2Iao8!Gp^G8e)b)aZ4czP6c_mIJ84OKW
zCkf#r?YI=-e>TWZ=iP7&^B=J87i$@8>ZBZvr{~vox=zp9w0$bPJ)Vp_kJ!=P(0sI*
z_+pp-r`Zo_m|FU7k8spYE!Z$K6U+^4dx`k#nN)pvI}L&&ciP(qT@p!8I=|J~Nnh2N
z7o984S`d^@WbL>bI?PyKIuldy@Ob3ohJv}&^*6N196TSbA|pzuBWXa(k)%p;*FaI|
zPsR|fz@`?YGf&UFU>xsTzA+myGp7Lw$aD&aDA>+S?}s(f3J4)ThYkniGJ}q3$9alV
zWNO!@;VcoeKvi|fm9^&WIU$ZMegp0((K5-8;StmZc%at?#%DCvk8<U_yRjzby<vvC
z#?XR1<0Cj0aXYp7TqLZdJ9WXJf-lKh$)p@q51_BV+8n^n*YK%rZ*>dT9GRfwFQO$3
zRgLB^uNrM)^Yo9l5@>pO!)p=`QS-$3K4xeJiJN>?s2;y~`gwyR_$4po*<L;{e?WrH
zKc7aNK|5quf?|^0c52jp5FKs=kYPT}CpvK6w^W)kJCgSVqI<SYwr}fFq<IS_#9^-y
zd776~fpyq#%{_^flH3qCQS0Tq41kFT<4(UMyfa4dvXr$6b@_2(i(F7sei<L$)ykcz
z@d$)Tt$QN9|J7?wVie<<&~})WtV+f<2C=25ZR6-LCIM3*+{V-NEx}BC-iZm{TQ46M
zvmvc^<f-#$r~ZzQ!z4{xx|h1pDONv+45J^R<ul9|D-*~c#XsYLl<FEYrMmfupR_d+
zA%x-0lAzVtzIa=$+({ERsX=ou#}Xi`+r}?z^iQnE^gmZ$Ikw8J@L#Fxx4HH~R%v9C
z@^Hbeg~HNKObl}&g~O?5=9NkIYxGx_7ia&7g^8bHx-!qz&s^Mwlx<9w-U&<d<Y1cP
zRPvHA{%*k$B>rfaTi*h?1|v2|y<b%4LcXb@E_B^lPi3DQW4?qzuEktd+%`=-W*;2s
zkR!MN0vj<ukxwC&rUXr#k?jM3NknuKaWtTd$k%-$#%x;Lpw7C_81kk;mn0a*Y<+w4
z*<6Vn?DlEB|8Nd`Fq4-#74*c@eT&<b`I39kc8*>yGB=Z6kkxic?$kAS50sTpYJY=|
z*uY^fm$s<N;P@MPr(*{xU>Tv7nVgl&BHe=zB?`B_d-zcr80=a7)sf?g4<CL`TOPS#
zn8vH`#}#KFm^}l5#8Fi|_jq!wEw`nBpl*Iqww65G@}JfbQ4O7^7=M$Gm919Z+D6x`
zu?^%bc|@8zI+NTnj!idV%EFyn3G5w+e>IM<lLAXAK9QxtKT0|)YRX1PlzQ&ds$HpD
z!AG`!87!o^##)GY4*9Ef1gbl%K%Ha&n~XLIFDL(DI-ZmxjfOH!?w);n!<ac$#OF<4
zr4u;Qebzc05VXFh$@N4RaZ6FUom96>?||ITeQAuWSX;hWaj+&!!7&xG7kRk)nymIT
zoFKfbGmIV4GDmu)H3PDcC|5e3L)yhNi#BM30%TbfR^K*D@4XVT)c3Biw#x#a{MOB(
zoMKedg2{^M8l8aS9;iUpUV(~ZAY98$f`Kc~kRq^-Wh%f@@jB|Ku*$Bk%>y6FhP|1B
zBrIeFw>Tr)&l|>GqqNRP8ZnGxa7Bpc;aecWh=I!7qD6ltZrr){3+JAQl@fu^v=vF~
zJ`62OKNs@mn9S<fSOQP`#=#{sj{I&D1e@8$t>b5e{j9D6T}0FZiDx8bKVawTw&52>
zT;9_zz>QdLmK}CJ+_12@ydiX`t%i4|>gzI7aoEnvpa@GCak49WWKEO`7t(REqZIB;
zDO{yJc<VQ7>L|+<GG0)BSbxc+C`Y}u#n82s6EQpRmsTb-(e>KAULE#O%NkaiDonOr
zccZgDN)?`37}lW@EIKz0d)GelPxFYu8dTfVzm_Mglx&$f2E^DOSPcM-Z}QPPyAYoF
zmzzDvOlMx>6T4CQt6LhYMLX$@Edy6#-rBu~%8oiK7{}ya$Oj)9kQirCzh<Xs2#^2|
zz54Xk*BiznO<aN?sqU+^Kpe8xXaNx;B!vTJjdg-gd3d3<7FAj`4oLSk^BN?J#~CX~
zUbZ_UWSx(}I9(b(p#<$!<Kk~<ypOlK0*Aa7h)&IK$v#m)o=5s$=?}yaohwAOTbzYH
z7xWLiI6mK8_GmfM6;h8ieIQ?6hL#@G8uEH^T#ujFWS5fU<Nkc^L~@~yVi#@;w<sm2
z<NCwzw8Y*`Zy%LZ1P19+7&(3tA`RD0Cox337UKl9DC^n_@J#Q00|`}=hVYp|AKwpt
zqREJ|Y54Gap7Z#9xL#^R`1~dAjP><4a5s2Zih282gR19p7$Pg_x#Y@`&Dy!Ve+uCq
z9j(ZZO<R$=A}nG6F)zxAP~Que#_Cn}MP|F10DklOA%TcPRy|r)d=sM1!1pcmxq^iO
z!m^`V=zs}IFC=vtb?7|krha`LE1C83Wrk>Pa~7<w5PmoIpRDw_GgrQ9xTOor2h+qb
z;p1n8lZW3ZlB^J#DqU04Bl&QUFsj2mK7PxnL?tWT2W**@+gMFDew#`X*$KjEWNI0R
z(`?ztfejh3GS#|=Dh3=va?XU`Ha~<UK#6e@&s$lcl(069DttunDrsTgjx0A68cb@&
zU^y!R2j<+={amWzam!vrF)JCWREx(+;zuTZNw7tML}s@HJ(xW#Gn3y4$Dsh_)?kcx
zhZmIiN=Zm_eEbdHcV%^3PC`eP3?t8xD?<E|wZi5^yAx?unH=E7oHS4_SwMXZE~rkF
z*<6$~U^E$3ct@yiL1bP_Vl1<6hO*v~Ysp6nDce6JPKbJJ)(<s;M>8y41{0Q1+n)o`
z-=oB*YO*_qryYN#Lg^Go(n(M_bn83=eON~!>8#xX@=Z4OG~X={p?MC1rL#!2B#d<2
zwM=nik{*6~h213M@ol$j?d|LKXQj%BD=_3tB>L5@K&v)}T87H6TJyolu!l9(IW+dJ
z&o%8!bR8J9UD&~aKYyYFv9`IK`-=uCSZQ);VkwbDD;1mR(FLiRHAS`*ue1GW6ech=
z2eJUT6r!nA&7iccfc~u(eW77fRY^nrwqhS9V%j{xAUA1SZWO4D7QIYW#*VqZ>HIy1
z)J_MmMMJ<!DS~FatJM@9;uc3lSncjNYPRhD);EdzZJrXC%3lqr3y!;YH}qgM!N~+i
zlQX*%eHJq6+wiMBcr_NaEw9^LstK41pXsb+CWD+RJ7a^09OUvkcb-+v)>+<ic~;Ud
z?ezOMDGtIFl3c;8p8^8>3rpoj$~rGO-}<#XqbKP{%Dgt7SZ%y^q)$44(GM$KZ<;Tg
zSv~=_UdP7@pMwZqejT{(jOo%*YPDjD8oUh;-wkSVKRlnWc9R3|rcz#xy9Rd=->@E@
zvUY%v>rS32FD;qovPmyeG8;XJ-WLI@Kp(ITDlPw1q(3FpAYbjiICd{<hp=)E*3ijG
z8OJ*Wq6|BIv82>rh<w(gjOD|JhnSFUU#F*ON0DpHQgja&35pLTWdPf89VL><9y2vq
zjxLVb9(E!T1i`xlAQJ-lI!0t}etz`@37_%41M28bBgVqfxFp)^S{QMERFm7%<F<ED
z0t(p$v{8#n)0*M2PDDgS+4{{eUa!YuJe-%fTN;JTXQ*MaY~;rug!bi`lJiy-a{Q%C
zzh`i=3vo$@7!dJ?j^>ZWbQwAX%$Pty7RYb>;1WsuZueXybhlts(o!8)zrNzoOth1(
zoOIHfaX6dEZgJ8xLhHrRRckdVUZvn6Q%s9xiT>OsaaD;fL`XUoru0#a;3`+|jfc{)
zZBeiOT+k=|;|{c2cYAv5>Wqnvx0Q`seALJ5%a)b6CX{&1t4&$xdxHr@at`X~HNSic
zaix!I=*bX0*%ZBykwEz`s&FKBci=kD0fBW@ck@;9=EU$&61DpbK85M6-_b%8C15ql
zlb{!jxGO4Uk{Z<%rO*=AP!BS$Ad#GAE$>VfSS`i#<r`&e=E~U8Ed{UClT4E4iit`i
z>+1Pbu5e@;N29b;OcGSuMOcR#wTr77YZC76>lr1moMt$9_|sc16Tc41$VrMX7)D#$
z7Z%_q&5wX6I60cmbj9OElLokfARRdkZ#)dLT?El*boi}pZ4Ch)aE@XG86_WuUJ??h
zL@n^<2zeH0#dI)y$R#}g`B|?YhUn(3Ebjmmf#+wLy#|a$G59a0i5a<Pp2Ev=D(eaP
z?aF=?t#ajnquR1K>9M_u#k|1dQYQJzjn;^QR+Yvz4dYua;|A}&y_(wl4@^9-%Oy7(
zoFBv);w*49E7nR#v$hiszN67MHo~xxy1hNNlRBy5d5GJH#B{?F+L@z~(Fc-IlllR(
zI-VoVNjk2Dfu}ysGLYv+i&i9|M4I;|{AnzsIxP+)v!WLJ!cqwkHmG&6aP+}ROlq7U
zli*8YfB(w3Q9s`1T*8s)3$3-`A$V?}i2P10UA<%XOkqWOsEo>|Q;vNRLsn*28&;D^
zZD#JZ`+F{BV;lw+7DuqVCX<LUWm)c9t}H-X=F?-z5GwmEC_S?t;D~w(RKXV%HTwg^
z-6wWhka+HILj%9hWP~=Y*5e$AlvXJrDEL5N<o<r>&*1=3x372&uK7az|GfJ5p&uA5
zgC0PSiY))be^F+ufnzdICJ|4#EBO8wrJWuKq!fbGK;VB32?B!}{sD|^0FbXP`yZVA
zK187D_8svnNr?ePr2zN4K9~}GbtEGH=WZ?N(Q5HzY{p*%pQ-H_zm9RhWMuQXgN;Qm
z`o=LSDJOOL`{!5Jwtt(bKvr_4+7ctJZf`|k*DeMm<3GPChOw(G#w&EdC?$P$-laDV
z6IZvA(W(UWbsC<EcS@Dh7<!>llobou)F_6bl}wRIWGE0csb@J#MCrp_x`I-&%jxV7
z8q1<d$SMYb&u-am_95~LxjmM-W_{nC-sz<Ldmd0251RpqHyl@+nhd1BrPzzXelJzn
zTSaE+`V(S?I==ZQ7a2&n%=pxok-a;~%$czZ-Hxa)?DnSi2xynk%RXYxKZ74dX@@$2
ziQ>FzLq@jNE)0tb4IKc5Bn?VQg`_BY9{+<maLk#M@{Vtelqq%B`1@&8%zKSThIsUv
z2GG**c-t)w00T1%$c8gTMaukH^OvW^E)jKgED1?T`%9vo!LQNSx{AMr%6Iv(IFq#N
zdF}k-?fHBsl5O30&D(u)dB6cxO%X<JvmWL`VyhlM)qpzL36KP9xk6pi24CvagT3nR
z<6H#w%FR8~SFl}hvT??6Z!)I%wGHR>m0K-&ozA!_{|ss)tdG{5R4+FZK;E`ijCgY?
zLCj<ZDVd>j<M<?Bi#BxH6Z1eejRBYEe)bR`*Rsbk-fr=+6mrYf=UKD7s%qzOwkTvd
z!~Bn6AxN`r`s6$4v1llZ`$k9KuMCmAs|zDPQ@SDY((r!#x|)dV32QH)?OWO^K7q!{
z&rQmv&POprH@b))rwrSG6|t~3(D@BBe$5IfPGPF3k(Im@owyZkrA4S@ob{&<tr`|r
zH=mb#j{s863Xr;-QPXGgBn6i-Ukga=<Q8YEJS6i`7z0IYh-<NvNk}iiHKvyp!WA3>
zgid%wf(6wQ0WBRoN+gk-yZgzh$(rihHOA$+pqZSXzpHg`Zn9X_eqTiIJ8hE}V=caL
zGH5Pim0dPA=Jb2c`9wy<_<i9NI=i9{Lb;UB#A_QFwe<Su#ZFCI=-77Lw+|vAnw#r7
z(&`SOBV0O~`(!e@urJ$Hg=wWsED*MmZrft{ARdm`vo-8g7NEuV3F(>{<MA+Qo?EcG
z?5W=!s{WUeb*FyP>)w^ZEhM5bq6#jof^1sbj*SRJiV(6hG(q?R=;+{@_B$qo2Bau5
zVGU@|d@H#9nqp&busI<ze&j^w+QG+y-B+Hk>msGE1&Y$5$cZKD%1XqKhNuCyrxqy^
zJHe4Y6CbBT5k^tT>S&4~LH|vx7%_GU9o=>w?DE;{BZA2SxoMx<^(aXU5-<Mbqy#qN
z3%4}IO5966eoTnGH?c9xYDnyuGG^r(mX(;^jRjcmGTb|ZcG~{r_vp4c$mVrC@<I+w
zQX+z8xb{2KcG8nc^sJV*>Egiw&B&LZKNSl`E(VOWm=n8_I%RZz@vjE2)G~HLW^k){
zwWIzIpHn5_E2!T^Wqx)b2U@ezCsN&y)twM=d}(G6X-$_XjJ%e^kx!b<qz5VKDX8dr
z^9!jk*wdZBGRORII;J;i7CO01#vgLF*~t={4NN8vjwyJcawJpRAYRkRhHlc(-X7`t
zo`f$h)w8&yTA$7cTvE#qM=jx%$DM&L2O%{#AhaLo8?<6l-9I0UrF{43!61<|VzwB8
zW>=jV2`+Q9k)GVj%~yn_Cq|~&)+jw56rmSJt#=|jgQFrJh`!C)kyup)%xuIyPxu&@
zrV@ud8Y4qdf~vp~?J30Rwa)AO@HC{qPZ2^9Y-jeVXCG3lLm_;mAkfM<U?Sq$i1Xv#
zL^v$v|8~w92q1S19C$;11xsX~n~G^lJj_1mn)1QN6Do4NbXb3c5Cp__g-r;}oOls6
z9nQ5XgEm_}GoBwNc<|!d4bx)uF}r-y3?;<I?p70Ww<B??1$(WL#22g5t9I*`I`5r;
z>QhKkBFma6VBk!$0VzmN#V08XlWv}Pt-pQB2>`p3XrDh65Q6mLo+IhWO_QJuSq)Uw
zJ{U+ja*8vRAe+Fmq0_H66fX)*ZPW0g>G_6T)RGAMmL|dN)AAE40_$-(A8OQbEPa?Z
zQxekcyA2?Hg&R1cbJjx(jZd1CT>ZJjx3I5n|5DtbJP%}#Ia<y~5`Svy8|8mQs0^6*
z=p{3tuSeJjyF~JlP;xhSL!Ih+-^ihK)9=f2B-Wv@f&r}po6k~Hgz5~~0I<+WG8$#Q
z^@Ha$1CfapVcke3Gay}3ka?F3kNZ|uI$I-Aoa_<8h?{hgRc?!RDCuNI^&n8%rhwmK
zR*llfnsm9gk4D90kKe?|E>;QwYMG}6QZs0gMmEu^jTBfwf@=UFB@s(Ia|ef4*rZ&3
z@QP}u;LW*|GP4vhmE&Qgf}jE)9P(;bS}LNr_yM^_yyc6y_oG;0;Ej&FAA!t&MA*r1
z@8Q>UPYg|+Lvq~m<w6M6I@29GC?Dy2vo%FR@@AaV>36uDEeV{LMCbe@@{9f3nEXrq
zqxHRUT5iPsR>v1(^UwanC;UWYl&iMMjQr#IewR?i$(uop%X$zPo`OwGJ7F|a(nMEk
zcUq?cS_V)S*lleefOZuL+U^BHh|6t4#(Iz@b0^;MeKx_$o`TJ!&x*5ySGXp`#}s8{
zNw1ncksW}VJZ~=D^Jqu1NfaEMK80I&rEo#2PTv&^2IMcwEn76p0!sJZVYzJrHl`Mg
zkZVp743c;v1I7LlmjxU&1Mzk$3)y#pP+rQy2SWclYtiF<U)sCbtyUD|>b$}Rf-B7i
zcdeLUJtd&VxYb;!UVVegPV}htuVj8^$h_{*h{T%BvTh3@o#9=$hrI(g)reYh;*ZiQ
z*%sXXv3Nakr(QG>yGOR}d!3Vu8p!x(eKRJw>40NN;VIN7O)%dVC7b*z5NgC@xzvc!
z&lROsSJW)l(ie@x?uQdZ&_7~4DI`hdQ0f3<z;;#jtD^PJIWO7|2VzQ)?x%fd%evjE
zLQAXq(HmXdmpMAi_R>e3L{5oFX4BIT`;`^Xr0lu5@(VSgLH^CyaeQG3J*|pj5Y=-_
z^petEPmKhs>7t-yZMEB=|Kah9BzyxpGfVq=deyqdEL|22P1>O>G8T<!K#A411y&{~
z>y<c+N^ZV2GX~&i$@mq6OF9k{F$8`E@Y__C56OM6v2nKgM7*WkoDpn$vQ>JcT9eLJ
zn$p2c<KFV1YM5=6zF?phU*?n8^=_5gOx@++lt$jtgCf&C$VC`}ifo_pv~Qj+-$yPR
z#Sd$dBR7osCBAT;c}E$ZxMY$<xp7x8Ka*$j5nuW9auyPeJ<;cYttVz~LnV<Gr!NP}
zUiYbv+P2O|JJqzQrRUu9*CJ?QQ3DlFm@p|$sFc)d+c%JQqS3EJY`ZDXRBJtLw7Q-D
znVCv}Pjbf}CL{z6Wb^5O+``h8LIwBL3?(+c<V#AdT@&&{3`O}0XuN7nCasFpIS8+F
z<2mbVcx#J9qST7MnY36boZ$^{o<t#Jtk=3@Jxdj^epZfq2*oS#z=MSrri@R>uaitm
z?)BD#|Ie)XVjC1LrM(%i>EE(xJ_uJy89#hAmGFN_!!a=4Blf^)GwHwN?+{e)`TPIp
z3GHh5jt4B{->)tyZZ6kxtJ*{S5u6#s<ag?yrFGlCpTB}((2GkBdXH*;0w_!9B#bzL
z3rwt^U{B5Jc>Z4gPk!GI_>UWYCLIh0d}M-$ppg6ZzAC6sNG7lE<Nbon1{a^Jv-nVY
zV9G(C*%O-m%kd`n&%ULZj||fw6E=%GkvWH^eloUY3PPsm=r5jBH#4+YsvVv>g|x)q
z<A*ZH@vOAhaLM3?qWP!N5ttY*W#|YXsh>`PZn}f#KjUTcO+Ly@jb>dRkx<TZI4L9?
zzPP2vt5cV>XjJVG{IxfGPjAH;@vIjTL4`^5AS9J6ry|0CnWB-@=p6fokyL|{Q<e5&
z0+2ey)s%lfFHDi`9`_3+hYQOu&h$wgLUfL*L5f?mY6A0{j!K|bIn(=ecR|}pi-tEo
zl=DEqXz(@M87c68nlBTA5aEfn9aoY?nP2XAEp}_rA+P@#bcFV2>&4dt{Y!_$ginYw
zPRv(`Tj_^T<~#uhO6KAg@(wGWL*pi{8sT4CAEft1{460Q_$~xWkof>1wu@bH2w|n_
zT@*ALHyAgrJ`}fKZt6uzWjCDP)8uu_?Eeu)sc*)y5<LnU4hOkk94wO$|2};N6kVx9
zVR^INx?1IABxf+uvD-JAIX3WPVGx)T^7q8wn^Q~l{YB~^^VN#nl1hfM+)7h%<W~oV
zZkIx!<OE|cC=D|ES;GWqN;Nh^jL+#A%dK^rf7Hzr6i^pQqXL3*+tJIc#pR>po;Y0B
z-bo^lGQV>bmw|KJgkVyI(h!FKiB&gPOXRnvbwj*wcrU=lkL0t}Ae0Q{Af%Pb<i31R
zu0lqmS&riy85EUe0P?=!0k5{u-(JOQU~1O?=<uc@;LAl9Fbv-I%{EKm&~m@P4<=6R
z!vOY<(04`B&fc)!BA$k}`>~k&b+?=W0!Ejw;ZUhs=$>YpTOxvQWP!Z<Ih|l<onE1N
zzcmoJQ+IH2C|Qa&9QL=7$Yp>6k9SNTx;A`*p@6kPw%U)xo{hW6Rv4e79cI9U*D?*)
zI`f{tqmm<AO25mx;)6#D>S>PY0Hs_CsK`6}4AX0pHy8#YoBhr32f(LfpT(Xy>?S-6
zI<1(>VZbcwKUxqA<0)Yy*>Oh@ah7z1d)VbEA8mQ1BonPtgzO}v+_YD$SaxQukgrnC
z`p%T+Z@b!HG>xQ`y8sm_?>Ad2S+RHQ7Q%KrYRmv$0&Q|0uPm#VtvK}*E-=eK|835j
z9H2+Afxrh2G5UCEugaI*)Yk9Hw{tAs#&jq&ZZbSt(!W>Y2l&IhMGl_)LI@}-1Go~g
z?7JG*a}w+2f|4KHq>xtmr1c<oO8;>lNxm>C>_!YIUn-M1RZDeaW{c#$u#~68F8&20
zpyvHXBV6ayO<_<2e2+M3Zdu$@in9=SihSTjm9@PT2gCmHQ02Z(;iYeT>}!2O5Ypot
zkvne8umc?L>=ge-LQ4B4MisKz!I@4u9h7{i?Q*?2Q&9eKU>>l=4#s41xiZ=NCCm;s
zYaWV~IlmXq?zfCq35|o^pCgSq<Sy56HIX$i{H*r$j{~eu=G)gQ2_O}zCvlKjvm~Y~
z`c0Spo9>sNal<<uQp{kc#X|{e*7OG>M3heYKd*d-E#{wfnEbw<jPPvR*YJBV7)4)@
z_+GBca<unx75UuLQd|tqwfYwS@w6$RPg*0-wh!LF&$HjPeGA9$zdiN4@qKD;-nqqc
zPZjZeWK_`fttbag+>2sXa#o&0RWT@A5`w1UN_35#Ay-MN>4Z*DRwA^$oyAe}Zih@r
z$SJLTL3<W^O)Bu#q}S<6*4R`69V<KboeiRLF<;l_USvC0(P}R01{uF!O`>*&etCPn
zzj!<6?X}E$#O1kPUUaTF_><CftD}gKCLw7?5!Yn;uN@|^0=|@9u>xEcX%f}=J;z#1
z+idR9=^etRCtZ|WotvgB?qVhyD?YG>pxC%@oU9~u24d6#)jVO7%U0=qbU6li-*)0f
zh-#u}ThM7J9rA7p`u3E9>x4<|Ou)zv`$4g*?o*+teW9XTV}P~y3HVcvxE(#87dHF9
z4{#{qJrTHJ!{RM6CV~Gv8_z4Sa2Y1Wi{5m%lkx}so|0who|8QedtCCQ%`5The4>7Z
zbBfu6OvT_{2YV*yVLe6vU5=Gded#yqV|OwNeC%9t*eyGN&PRbIzxVdk*_xbtx@WwU
z!SPNSMt{1s1VZ=#Ps^6pZ$>K*aQ_%iJuHoE<Ia<s5{9Aysh9+gs&r=#CEQ}`?Tfb$
zax8)tB1DAqnm2S-lS~6NPOF`pCvpS*&&>ob&iwBL!?Pk&^&wYDeIZ}3`-W%Br_!H<
z(MwtFF5JZ`dGT{#hU6B((6^VOqJQcV1?vfZs>$$zvKh}V+gJAC&rtj@iC*5F+Ch3?
zzw1274^50Md(h4UTgQqC%wMbS*c|BUv!0vXTH0Y6u`!_`xbw(&4U^-z{TkIFrmSMf
zST0_bvGXxx<vae({Y|#du;J3~2(YDdNWO|_w9keuz@7Zcn+EsSz`2*GKWWuY#oMR1
zOM>(4XG^-5mA><xwfjbxqPTMCzoSTUcd%y(Q4g~0W-vGxzP`;F5<cx@_7IfNQ)_jG
zJ5R`(JdrLkXVm(BBI}j{0N$j1|MBZ&vcOL+8}-gSl(5(ttE{F--WX0ggK1BxNSD#4
zkC27Qk&g7oRW{KrOs5;fi?_aeT#Y*cf#CHdYTIy|ljB_I2c|y`A$r${LkX&Bq(uDs
zK4wh&isQ}_w#<{5!btN@x;1z>8{2^LcM&u+G+bTedFf%dFeV9|blyBLEItRMq-ZWD
ziF@i}pDwtM5HIog1~p$Eepka3W>|_kEHI{#y4xO2q)u5#EvhNMFS}ER?aIgc9<Fa{
zc5s=od&)LjFWWt?a+lRRlfPRr>NP-hZ#3zi7g|%G9?^(nd=I7E;(Ve{teIFZWF)#0
zfEBVH#<5#INv7mbf+ls-*hg>NWsv0KPMIkkFSGe(R;5#QgmLn{`zkXPWNO95-BA6`
zG)eksb^Yr%HG!jAq&~jtu?V6ehFm;{(Hx0{IF{2>Gh2dzZ*B_OnfNh_{ETd~g-K3n
z+4*6Tz>fJnOqGH$)3=wp^Qwm{|E;npzb-t7Ww89ac58)mVlNuf3f)m3A9v6W6|6Zn
zbf&6xkFha_U$?qFiFeOWuX=MGYg}}rGv#fg+O~^y=NyzxZf5gMD5qBw!q30_*LAv}
z3f}VKXEBw7Tg&;S=t!CNBrC?l@|;fQJzP;GJr<0C_nEhuS<Sp5BOuhWJ_{OXnq7-?
z9``U7dtMxjc#Na9QywIWONw8vk%$D(^?s291B1f4dfB=jrQKKz^|rGvVwER1fH1t6
zu22*1YiyTyUyn9&YFP0f@z?R6px?~5p!VID@1Vj%ffgWO6I4~UxsRtHG@Z#K@B{-G
zj5m`jgPmy`J&5Qea>a!e$}eVzhV7RXgf9aaywvbDix&i%!9O<E!s&hX=R<@e1up6T
zn6eq@Vg9tv<$`N1ckbz4u_ccGkaEztD(DPZ8ot@0^(pnt!n=aRECAjp@pR*yqc_Af
zsjZ)bTxEI_GG?J1afBOIUS}#7t%=NK??#<`Eg;rUEd=cJWSZ(6(>>i;;(3<ZI=DM?
zR-9&ZlG-aDJQ$nmYh9jy(galqb&ADphOK!vb9*~-`ZX9eid+_$gIkiy*3lYkdlb{$
zG(<MYjB=SbPS0L)ER#{3&Y#@+TChP{LNT3+X$Nv2wE}dH4yPJ9oHSlV-F2fOk#Mz{
zq$9pi&jM(FSh5!wZ5+8vd>y`&Uxa*2OS^1YdzQ17q$Wtb)^U;@GW<C9l=D^l$(gn-
z4_A7o&B(JI-dH5|AsKXt%8tx-M0^09<c%s`2;KIMeR>*CfQbh9d4<c(c3y0N?8j=6
zP1gr59eUPWc_CBLAI)&%vd^(`KH2bVM_HL1;so7ty37Weip|RBA_n>&BG>BN3&wUJ
z4CEhu&}#;rRyA=$xLdxZ+<1qM04ya6nyR^`X|=)Xz7NEW6yL;z8koN#6oM@bM1p^K
z0?Y{g0UqJeA=d+2G%1@z@37(l(c&$qY8jPv&OyUVVkSJP8Ny8o$CEG3tL?Rh5;U6@
zf-aN2Bt$tpLI#>@?aGKAlh{rMDP~q8VnK@qY{82ie#Hr1BnzQ89d0bjg$(Wu{62c>
z>7>MjTG9ReyXaIEK?@Gs9M4IJr-fD6<P;rYxB<U@V&}#x2cA7K;EX{s)L%E8i1QUS
zal|SODZe>XHRjI5ix?TH=zvVmL)0%ce(u2SDbEL4Rp?;vt-GQFxcyKF;CgH_dFc&U
zsL-uF)Ijx$%qw<h(YyN;XS|;fwIM2K_rpERh$MplRU~oEb@o@>mofm{ywBAgW8nm9
zWBwU!i&OF!ixoW*e;j6qV*5hluWnP~4ulRcYsds{Q~G@&v?H#P9Z<^at==Z<mf{gk
zEP9q&Hp``I!jcYIHXqpcxKGyQ&bO-DLsSbS_a7=Xd+&VCA0uB+U8f{Vkj^X<JPa`8
zk0bKh2#a5x%nj;>AB*(RFHX3;F8D#aGTQxgdxHvXy<iDmUPN8*P1!EukG`5!K49`b
z+<jhueQ?sUd_sSN>*|RnBiJT*@(!fmu<TiYvVU2jPqy1hPQFNNS_k!hLur3LyT4p>
z@w>7Fl6T&=Z0uC#1K+x3FAjLk1})F&b8p)=hK7>09yAo;y}K?H+n*7AA}eG=F76Jz
zi8snV=)OE0Jgom;?7dZ7TxruU8YBUN6Wrb19TMCf8Yj5BJ0Zb>yF+j%xLeT1-Ccvb
z+i7Oz{U$SS_PN-<eRJflyVrWws;X60|EgzIRrACEBt1iC28zed)ND4s;`VGFG=Bpq
zz62@^5_(2PulM)&3knO}Bs^TX=H{1FPQ<6bt)>9rFWQgK+qdY2%-raD@-2qaBu73K
zhmBu35|2(qRNm0`d{_!1>t&kBtsPEcj~^YK^~;&~I{ZXlBGn`?xfGOhvG?<gliA9$
ze167gH*J*T6G8(c^p~d9k`iB~c@N4`VUaIFCXKA~LE*M2%Yqc1M*En!F;}jZc!=AL
ztKx%e#pa2x=F~<at49c)F}?7(ta?-Rw}$5(bo)Gs*-LF|Tp9*0lf!ZqSe?bKTEH&u
z`x$vS$*mqJt@#s$y5|eD7Cx^P?RQ1a_yyKM<qpk2?@SV#8-DHrFb7!J(?##bw~%eb
zlO{OvjK8I}w8}f5Wcvc3q^%R;A}eKOtdnu(Ov9;sqE}row8YZ(gZx2)Y*~BzQO)XB
z)XbvMbKJiP4d4^hArGyc(2{6fv>5-6U5zNswenCyJw=ih=oGEc__(LjO5FQK$C6I2
zzf{CPk%6Mwsr2V=6tm?DtggZ;0CJc>ioTpRhBco2gL_1oAYRedXF?*lq^v~m=5IUB
zPZB?U0Oo~IR-JW>d_GWM8HlaamxyeB3&!7tm+r5`8^QP^p>vb7{OgbtcIdFwr>Xq?
zr!QAJFX}A?9EA9b!X&&<B?5UizC2t?l0Ga?qCRXDV=|T_O|>LYuM`qx$kw4JPh;>+
zi}C~2N(s~+fs@tIvG%z}f|?1T64Z6!i<(_GrFMgh(3tyM<rTW;xyA4-m5<p;c3zcH
zK?onBT**tBVtP_jl_xi&kHWuFKSHp0IU+@+QdY~7B0t<y1BhdGO4%2&GkRLSz4An{
z{iL-?vHd~xdly=J=pw}J&oPMV2IW1<53qJ@F)VyOD;2vRy_gUu*Or?%>o{Kv(F7zR
zHlN*vt8+xO?$~?oK$S0r38vX86PrKpveBxOiHk;w7X!qE8SH9q<>SwTHP)|ofNekK
zv1N7Jj_~gUUE-9#&P2sNILk)las;Q-zH`gKa*A{)OPV$2FGjrkcIuJXs1z}^V7x^3
ziZhos7q;kQlCVo((5&Wy`bd(cVGqE#^i<E&Sb-oyw(1b6vBg(_R8?9xv&I2{O>mAG
z?IXZ%lLRT?th!Bj%;(@Ed+rMKkXXiYm+Ws#==!0}0$A^m(N1^cn$vtXAN*|c6Br~?
zKkBn%bLw<^;M!C!_kjZC{^ru7UF`VdrNJsq%SvZm8+`_i?lb%H?fib_RkXU$M#HX+
z^~Pb_4Q%t$eK<m`cH{KdW3MLl{9~2f=Y%NFH7FF?j)W7J>nC(NU7H@Bm3y&fG9Hf`
zf0t7mf=3++_v<6=hX<A^Q}er!>hJL<kH^*er(O;&e{S;lWueM<L<b@g=sP)~!NS6t
z47BTf!BOHsKH)@$iRk-cOVWC`t&&|QO8ad;8c=U_K^w^s)A(>{x`*AX+$Pt`ir3R0
zo;UbG{1e%DUTRX)mppfY#-7}rJXYl&ort+mmdZXvySvT)n%drzlXtm?jzU)z0oU|y
zqinPWTfkyfn0`k#mCkg)Xa~y5XlRbj2QMWI^!&Rmk1R&wapQ>ogor)tjp0eUrTuw^
zE$jpay9|ynR;fqj2-Nej%pN@9S9K58ZnCRokWz-PFb0?QK6rV(>v3A(3?A!y8%<Np
zeV>Ou)!B^SIiUpY>NUGh??q#)UxPl?Q(L*W<P`VB_f+UMI3jm=$1G!|v}F<3#w0vw
zK|i%%pc?OZM^BO#`Zcp!h$28iSM%##y!VoUs8!uetS0`hDM`#-mCw?YQ&8hF<^fL3
z@vz4z$@JdWlYrvvk;AF%tM*{<Kr~JdK54}WJ05f8s>KSbY!aJYM7A1AUSy$^d}lSs
zie^Raeqi0{S^d*C+L8e=(#;!<#~R86)1Q@5c=12{0gYrBbt%-P$@=2raCwd1m@d?z
z_@oer2IEp48aCP`*oA9*9kx=XN0Ny;QIv%`2Qka=)_gl<aj-TKiy4&H2;4|B1Eii{
zJ~FxKZCZyAgB@j-ieK;6B$R3C#N~XE=6i|9v)e=U#P=2v6Ki$aT3-n@Kz`noyl-sO
zrfS(3BqEBJaX5c@4;C6?j#hI%_1W{L{?L3n@xZ9SMKVXXHaJYX7ws1A`Ud<)R0_kK
zZwrt<Xc*8DPSz4O1!H(=2R=^sqhBIDqs|6v?XI<u40%^FaDFoE>DJ9rk_|Vvk}$1*
zlB@2Bi|4(HmtbRvxJ@=0R~{Stgl=xo+UbT-7l~+6iaE7ml3f<i+Gc^pC!<Z2Kq)YE
z@~Arz0rG%e2>Vne8^N!vPQHxtP{ma$3q7g=;LNeDwUhR7au2zMG`h`jx`jm#|C9Z0
z^ep*G<!4gY+6F$(TAKVrSS>576HK1KwyJjqL-wod#k17qV;DE)awJ1G`obT)TiZ2H
zT&7ZX9nQIKJVv&PIl>b*m_6~iypmLwm{%;z1Zj$f&Tcdoa(ajKj>3nhANG9^T=Fn_
zGuDf`IK3}Cf@7PnL>>-(n*679A8_CKJi|WhVVv1KujH6-sa}$XHQ!Vn^tg*$Ca}QR
z0z*psWcZK0GF6{ZeD2kJUVA=N=uo7U8s2d|W%xW-CU@jAJen--7muCmK3Br7JPaeA
zW@kLURnu%ONH|6OE3NcJqpdJ6{X}lgEyX8;Yu(^WkRhZ={l&?wiFUwh_}eJ$-6v$;
z_;eyCpp$lfMTc{P_{xv?p*)YU;x84hZ>QW#?_vU?9MSy`$FE`*zLQaf%GM)4><MMa
z-oh{8vvNc`N8g<(%8duaZ@01L)@_z+CufS@GZD9NDx%=c&PNaC<d-GmOEUJ>5wo<~
zWd8Vuu`7^Zv6q8v#U4`mwQk6554?WcIr*@e^hjzXoUJP=y0-jIQjMUa4|CoqU$YUx
zZexHFD<Jb?nqxEhy?Y^tPIu72SKl^-rzh|Ft$h7Wo)LdJp1mUWY93t0eLnKtsd*}y
zhl<_Ai^;<7y&s=R;eOVp<L$wUmuuAxeq_CpFDoW)q@y3|gpkb@<u*G%R=bW!4mET_
zX~!<0OTh4U9k4Ww#OFZVusYe%8Nsz30j0%{ki%N-!b>B@S~~quE8<A-4K-hvdp4Bm
za`KmIfoo<R56Wo76BCKb&#t*C8UX&TA7@0oY+DK87CqJE8R0s&b&V=VLTMA^E6oFR
zNaNac><fOGx8HV@2_(T7etg{UXLb=w&l|Y=F%K~Ip5#oU1d>J@U6l^f804XnB^4hp
zI^iT<_@EgW8)+|d@1j+O+IAIrvEyj6LvU{L^P>@sZ~)8U_Nl1QN>Ad8&!IfWX*$X4
zT*O6;(r(}9D#c|PS>vlXAWJ{HDq1h73rSnQQ;3**qN>JLmvHoguYJ3Vo_}5xo#~(2
z?)aRz=o_5sc(qh#S>jCB?Hq5+sF$Fwo;~aVm5e*SHR6w?Z$Z=-iNNf}=-3%pafBRt
z;Vh*-Rmt7ZA|5WJHAG-(ui0v^$kmtQ4gkd1&+)mf0#j9Tquutb9gbYz?Mqj(F9;dW
z@x>OQ`>{#r$;#P#Oymub@D=AVVkGrMP;7CQ0S^IdOpiYkj#4fcWa*)Nj^i4uj;$@~
zda4w{$14{vxr`RlZ=_olNy0rf;vTY9;IyADVC=*Jn_=dY4_kHer&R>&O9zpp)Nzmk
zn;%gMRLWc8gIfz~7V>AbQS|I^1`L}*7@is|pRt;~$NDZTeALrqo*Rm9=5q=3nVLR3
z{JAYH49??EraCpEIBH139^875u!vcZP+J0*=tEWc_@7w-8f0~I1KB$6(U2=}`esIW
z-b>Za9hz&y)pazR>;?@AfYxT<L{B8U#}_AhG}MUeWL8?dn|CSZsay(sqgWbRD1-`!
zyjV)4Rb8n}7_P-MtF_ZAuC_xAx_iJn&&EQN1$@KrJGH$fR?fWl8nwEMP^7*NHFii<
z;~v>(l~J=~d`(N%#WDb}@;$5r+ic-hQm<;jm)Q@f*CrIm`1>(|pXse78Me;wc%l<D
z$L|e1czj%v{psv7^OWYNy{dw)2W-L4$V&5llnD^oocmQ8$i!q?1#vWNv^pc2KpgLr
zU_}fZL+lS-X0+^iOK_A;(Ou4k#LwJpeeIZ&j-*L}-J!H~^kYG1oNKSXs2+{+gq~JW
z$Jo*wN24L0>9lYcq>yXzND0LTm^!i}lsm$w9AU@z?WZoz%u?(c@kS{(;TIEAYr+Ao
z7;5fTmfviXn{4%bWmaygLuw$HxP5Ki?-em+@6<$OP$1q;+F-?SMttqA5jI&$zFT%}
zE5eUNb0|(Hw>q>>r2aEz0kAw?eEkq3yZ#LlX%ecjQBC1k^~h)tgRz0e$PBw6sv1T*
zq9D1?(7PUoVNy5cVlt8fIKkm4<()os6RDmaqt|Dku6n2%Tp9B@U#v-NYk36QvHy@W
zE1<#e&Baj2yd~Tr|9Kaw_G=sXnZ3hFU$rV^h2of_uZr;p7tLNxk*=mW2y()?36a=x
zB0chEu1eRo3fhE$7A1@9-y6uzoA&bK8&2WNJqHLOQAm)uVKV!Idq}E~TLjTx?_FX%
zHv~$m?npPC%k3+DY{lEQB!69W((m;S1rXBb%Jo!)UmwjpJL}M@EzcF3XtQCtG!Z1b
z$j;2bFg7z=)Q>{kwc&~#ccv54OWbpZ=VRbv5*4`+*Kc&Y@kQOBbaDEUVxJj0A#_*2
zX_~lh!x8AA5^m$a2t_MfC1nSbsBG-O-Q{7k;K83FM9zqW150v5Fv@3w&+x#>A<{AE
zgQ`2;5uMj|E9Tkq<HqH*xTeYVI-`<f3%9v4;UqsJYBKn3wdcJRfGF<z*$h0U&29s>
zOv)8cpqs%PKcPa2I@D6&4jx^FG2qXa3aGh)Mn<{S@b<$SCh{Lyp5$9ILq8UF2U-bi
z?b}L90g{);u`74q#8j(mG*#+`TX!*Hhh&SoS7BR`WuI}I4f;>-#!K6Zyf!-O8Bj3(
zDwUP<01yJlui`85=3Om<G~UZ86<B3D`@Rt7(0Bk~u$`&iJCzHqfx)`q54B&(&=X>7
zG$!+9l!vdYKnXUg`e@NQd~JBCS1~;|K<${~Bw>BNd)DVlR7rePCZ;xgLt6n<=*s1g
zR&;m%ysk1{wZ!0bVjx(vZ|Iqj>xyDEouICIOO`S9CFsFvfaE#0(Bf%oAwFL1KG*X7
zVtj=(@g8^g{`CHgK~dUH%)&t65dOsYgcvoG)yh%;d$`e2+~gZ{<!t5TadX1O$Gs!!
zsP=@5oAA<nvP8qpG>tgj@yXm(g15MB?MZJFb2b#b{PHpH#B6{fI_QQlOpXO#Z%0|#
z_nK-i<K!V=MYeSOOslc>`ItZ1drreS7uej<$Ya?OQ$LH}W1FAKyGM|cFlQFuaUAT4
zWda|*$0i_Sabyy2#lx;gEp<d&DqN&$^AFx_t$Q&RS^Jr`e<}wrMs_2LVbNRukgdyi
zEQjK9EK9tl(>p6ZD_#Olz@=ngi&G;(K)vZQ6~-qB4i$$Y8!s+yT-mvR{pyo_n~^Sr
zD*p60#h$C6pCRsssAqZ7k`_IfrmWQHcGZO)d09PBDFZw2yK9&^$v9&|FV-Z_h`?pB
zPL$qwswhP~{0K{~q$t}tZpy3C^@SoMXQYJ47nQFd>XkkohViN4en&_0%|ScH2D>cN
z+ElV}t>H5IfS~CCH*J#1oRh1&c~U3b!X8)Jz2K+UlSI$bC{4)&#ifLW$-HHnb6J$m
ztG(9Y$dHnO;{^_3XNtb2uJA*rh#wX)_wQx)YgJ+R=af(yS@NQ`$!W#Cvc~viVNo(I
z3c|97V<K1MqIwqAqin+$ZHkB`&cw@bAmWo;DA(qP_0;oHM|_TrqWh)G!kWlm<u~8P
zpd8v*0us(F4f|u7hSZauO-*c&t5&zaliW?McalBaT39#N*&?p^sEIIohwC;!C&-^h
z_{*_tJr0zw1^NpJ?YHNT-8+X>$D=boJZ7wIFg#){yB!YP3~=}oJYAHZUi-{5fMKsv
ztl$JRLi{W(f0*lV>5TpB&7TtKYCL<alzaF!8~f_1e4FPOrBz$3Co-i$Q~|n5=6LYg
z0GL^d1Ws`U28T`U4?4QK1w6b&nKww7eWjszQ#L@l6MG&hgK`Ltg`73g86-SB1M%sl
z*i*SOi6$rEH|{M6a)qHCdGp^ZZM;%E<ID|l4wrzzX0f-$3fd}R_zjT+Fzi_e+cJ~&
zxp>Y^5C-;3cG;z{Q>B&VKNBDBR*e>a7WvUt5JFVqSL0DORgs%jxsxd(P4iJw4=ptM
z|D<aQW}h?DavygI9g>t6!&S!7d81szWt}Agj$SxLc9_#@T*b502+zaL4KEh~2Zqx`
zH{_#2aa~)RT%&oJT3U=Fm0iPZEcNA-1mS8?dAoTrpfo`H05&jpLADJOd%y__kE;8F
zau07TLu7T-yp<tLFn3);#p!0rMPDdf7f*{Xexc@p^C%{c!kMB!9cEqiPI;5AbyRtb
zFHqcoLvl00p1R^w)IJe#Bydl%xAyVm_3Ln<RcZJ;>;&EU(HOXJvo|a(Z&aS@Lfsnl
zCIv)N)JX^spKzGla~}rc5!+9KLW%Lhfz7ad8;=FCh~RQF%En%#mXK1Z%k0uJ1?dRR
zHv#ufIV@N)x_nW3z#=Jrwo6h2gFcR@B(sIUkWdIB|GujmWeu3kKD4I0!4t>;+k6=>
zaX`#aa+HaKj@QX7jgj&(cMCna*TEerKyf`<PJyi(z4n<l5l%cMRPwvw5TNu;d1>6a
zw6WqXP<d}R+RtR`gX;DSDP@j7**L6$>0W^IXmE*ua~)hOnZOo#a14qsW^7c0ie>lK
zen%;HouO)2p+}E<gIq6Md|$y9O5aHnUi4RFyxKhwE-sLL;%A|6VKyAd(V7(7ibo#%
z@LUgfRa8|hSndc`owub85r=IdS!{kG@uB6+jppJ<5qGBoeDz*S3G+abG|uexuz&}k
zZib2igU=!%YH`P?y^@_Rv1lZ)_FKwXYd_!gH2St3yRLP4(;XRsiVMcPwd^;M2nWUR
z=@ctt^V=;#u2G%aDN;W5EsmLfL6(zvVU`Y<OK+Sqm(HUrlW;HPWjTL?kB{CLm!Ze4
zGv|!QEwr-R)66Y>3Sl1hyi*=B2nF;JYFZa<scA;F{odvo3~LTY4_|1W2Q8RC17}XB
z6Lfm#o1T4-y?2^!p5%NY$~{H0u*W0spCY{dXPz$PT&yfFae-x#WEt!_Emz&>4?}fj
zYa6=HsQxRr2yfb+l~%*b*V<YgR8VGD_aAvYMck8lAJzz4&zIiwN^AX?c^X(*W8klQ
z^okowarlo>)32WBDbC9~(VG=tJ7rc>AcxKHAcZ%KQq?6n78ct#VPmS!rvst6lX1pI
zX**CF#9O&0@;s*ZG-V}2-MOh#9GfVxu--ceK_v5t=6swDE=)I<kPj)Nx&?!tOL+T<
zm9@XS@gQH<d-gp?(}A_4#J!b_cT#1xhr}K4fMCHp=7J*DmLBfpvC&bu-Rj~6Gd4w9
zvA6~Xm}IR4U%4tsW6$wz1uH_6R?RQ=$2@b+083lR2{x<{aaiyIOXf0NVgtO&kvEQg
zvR-K%V<ftyjgLZ&VO%`Ks+C9X*O-zy-q}x*=h#2;{W*({Iy#K_Qhj4Z&GluB4J_5P
zCjh!Chog_=Fyg>NVe_}pAycR&CC9Nu@S9DYNBaR|jn!ZFbG9&Wgk0Ik3XL+hPb-?X
z5*$6xzFY$8a;&;mE8*M-%T;XfQ*su|kEl;3SR9l-Nu3SEF>~5xKYUOaEL?_S4)|(0
z5DeZ+XM2<+-J7<%JH$W-!GYy3%ylp=aGW|WY08?L)yUrP#c;-5onm3$(mp~zUB&^F
z?xX<K-gtO*SXtQ%?6jsN-@96KYjaP$=a0sPqKs_JpTM-F_F0->=1eG9tG}|^%0K$Z
zCpFP;h&06fD&Z}47~=g_HKBmdPC|xGykLB5si`I^jnB|k`Tg>7$BiQh*_@PHB@%zs
z>$aLj8W2N~9^cc^`I{Aj4OrSAL>%+QwejzP{KK(vdF4UPltTQzT(v_xh1}EzRxQ6<
zfRE1^+;avm|Gaz1G2IiskM1=^z3b@>&#aY|7ik8vD5s%RW3DIdM(hDXIBvDG=FLx%
zDW$FGP?xM^#0849Hrja?+StRC6STj|QRVz7<kD9cK<QRmaYlzl?fDHN#>kq|*>`Qu
zK-irrA@;c900;YUucR33{DOT881@6}2pkXg9-OGzb_bj-(G<0s!}HvlGlj5wuLWV_
zFHR`{G`eH&YwP@^l(yNJsh$xJc;d^6l_kkr7ga%3%wh!9It&`Er_$J%t+aRr%R>(>
z8^Dw5ymrH(ri+<Tkws+lj8&8UI{4e>@9n3$OwG0mI^6+heibVsS)SvY&##n?Vw^l4
z41BDC*F)D_ngosu{&^Ek9^swg#D$0zd;)!>hppLW$9+;<M;>qpX)9%Tsk7i-I3bYI
z)0+#S<^3c)Q{QUxc<=2q8XoDcy%F;!VA3qKUP~IzGt3&+?I3#Y!aF?U?(xMneLQ+t
zHX4>up*&apE<Dvs-Vwd@F}!nfGM+<Tf6Mmbp)~bI`p>cyPCjrbv;2b@`X!xr*-H&x
z>Q_@8=S;O@R_h1bJli^oDJCmdiRRhIlmVBDH7ljJY7eRVjcVV8(Wp4Imx+%wuRC@8
zH<utV6jvL-MbH`D%AnrKuYP$wS<mKh&H?}c1TCGk8*Te#L=r6ImG*(V;I}{Kj+;I<
zELyX%lBS6+8Qte?NdCK-i8JvP1UZz0KJ{B%X+iJlhP+l7HYh1C%R=0^se)48+Ji*o
ze^o$cVQ?z>x1v9e5x*2FlKMHg0y%UD3LO^{|0-QQ1Lsvse_+ys0i8TS((Vh~<wB>0
zc};l|4e6LD9Pvg|*g&g|RLWTDkE?#6C)|<bGC89O_#iM`Lhw@i_|lY>)y0aM**=FF
zIlat<HLS}w+;;HsaU>5(O6E^mX2~*#lcsNDqGGgpwO$g9C=eeaj^EW)-lE3%hDR83
z$M$g;q3}lOifsO;xVoJmd{4{FvsW)&cnj#-G9s!a@@Gve=TD12>pi<^Gml%5Urn|1
zK#>5lwi(h_@JPIk$>@z4r_=u6E<{!Ek`$OW*`Syqz_KH6(88^4Etk}Uw)4`UfSL!Q
z;ftHrh*l{I%>ZBpvY)z0{>b&VTaIiUpe>h`Qvx1WDP-|nHlRYucSTSt_tD4=Ek%>8
z;6(Z8F8E_Ht?Z0ZeT3VN>ar>yB14KOFM8*hB(B6<{h)eqk@-lif#Ix`5pAg#uGfmH
zEW?fEn-8H2cD}GhYc5BHi}8=N=dK;84Oo8_oa#ZAFd&qiZ!|cJY^J*Dtn??t<oz^-
z=_GsYFshFHR(`b|94-+zF$6|8UGR^RAab=$E0^st#mh4i^58G@kiFBZmQDT*=p4jD
zGsw|z-xxk?_qIGc;<n8AN4BgDuj3XuLmHw)5q=^n^jt;2cT&NlIlpqpXFd+YbZ^5J
zCY1}Gw;s;SZPc1JjKEusx(hSeGdaW=e(5JWe2cmTymG|=&KT_E_~o~e#q6AqPi$t*
zO;=%mxpg*W!#ywEVE#|}6h<H9duQb??&m^>Ty7J|Md9IZ+cw(;F;o<P7L&I7N+9E3
zOaP1mH6_WIAW{yeVu!8OFzzjE_wl&p9UP#;FX@zHTRwx&;xS$acs3-=Tx9oFghz)|
z8kBqHr6cqboyQZ($$sy``1v{C5--N!qXNVSJb2p?+AL9OV>}+hfPE5JS62D#YokLP
zYma4jf=a<a$+CH;k#y{9o#M>k#&<iPnwu#{icU>DRBWn+;*x{^>Q|wl$Q%ya!z~<+
z!`S>boVJHs)aE9yD_GDW6AH3Wv}ljKmxAk%*O-iM-K&dB?_ZAt(qTy)c|z+Ki~LbI
zJn2eJi?7@FGNWEv#%Mp=($ep5IVbd+S6A0`C|TzOF-RM*@&>D<fvuLE5RXoM!M+||
zeUBY{W6*^UAzO}!Q(*=t+x4BVC-Ou8Zf{r__M8uP#XZqtdJrM~m_JGcRH;>3K`AvG
zb%N}ww<+YezM|%MdnoG6?W^R;QW~bYTcdonXz_@!vG<=h*e9plknT?*vx*+b(0=0L
zi5?DDN*%|&w4T*rpi{x{PhDPQk1y_u@&?>zXB#I;uI}TCsFiw@6B9AH@Jv+Y_?RPK
zqFl(wtQ-rS>^Z@Ny&{R?G}l-(w{uQD?8))LmuYBmWDlL%bCn*bC@O%-T+aR=&R{a$
zfdag1W<5|I6>f=V&%i%XVFTw<_)pbgoiDdq(QFX6QISIde?-yiZ416mfj{h2*cU8@
zm}}IeG`S*}yg|l@PV>MJWvwF<Qp{QsF~FP<O(^EVw=XC1a;%0;m`t3BUm(14_7!%M
z$>kM&1SIkQR9wU?h?Zo2t?|DM{3uNN*7mkkHI`0}7<*{bl1yO?)zT>!8P8Pkx<r_C
zkP7Q-=CM0u3JTz)$?tyrUSD1W^@4N@!AJ)HTgPWpDj+QE+-iSI#|pIK0Zs)$$}2~O
zo#D(0kIis~6p2AJ)=65wDOM=dJOX!Ej@bi(kmv^q=3q_~^CjE5{S>kJ(5j+wTzZu6
zXaq?Qu^OVM@poZ{?`mt?4-lkEnzo!Oqa;>21GhZRUZ`w}!-q<5D>O-<VT+4PWWmW7
zX7KN6Zr>af-l<B<6a@mg4B%q&i+q^=r(^XBwLY_#kt=@$q@vVB?|9=F2q)#>2WbDa
zFtYYz&98g58BzU`jE1vt@ssc}Yh&4Bi49ncZv__o8a``{$|0t7L~}2u_<R=os&ul8
z%Cy@Z*&eSo%9BPv`SK?EhE959F;f0BlU344gIq&hzw#S$CV{q~?rx}`z=rSFPO6<z
z07ic@`o&01Mdi7kg-~IVY}gzBlDbc1U|2gsrEN1dv9vBe3p-&gDUV9bb>*C1kBJF~
z1fed;z?rB;tc>qXb`Ewr{f$Al9(-JLck)VWeQs9Ve3*eVT1B7m%_VbluBC^C4u3G8
z-7p-#rJuvgrDR|TG!UCCH1Wg*OWUA*b6hT7p1An9pr>?-mUPx*8miKJrM47UI`5?V
zz3V2AmL~vMaTtX4m-4-pZpZEv&fpnxDCEx9Fi1rOIH}|PQPKMLdmyltSIZ3rd{>zF
z9h_OI(>`&m+Q1>FY=Z~|l~7s^f7kXSTgxKHWQe4f_L1oG126ZM`HI3`<kyFfi-kcF
za$%Hj=6e}&!i<XaKT|L>xQxsma$_R32?QZKu&C+bzBH#<c1X8T@#%2eO6gb?9TA#`
z@b?5#)uqRc8IBb}iM*!vDm_6EMPi%Ay(u5jg-~G&%-8sYYv6wGX;e3WN%d!^+u*{N
z6vTk3QKBGCDe%jHm<?u6log<DPQuvP_NAp9p2UjtF+c9M6>G(mle(hWwmxqzJBqk<
zQKTfyVnZD?7sEhiixspkA`v+|NtxlWv-9MN`{%n<G6pa9Iu>A6{#kA!cKgw8dXr54
z#LM3j6#I+GWgMkhkHFP``YTrGe?2_VPKwYFc72}l%zH4t4CDZL`3r_9=-^b?tr`1^
zSP$8uI^={Gp;O9(0)w{~?diMb>N__1BohlC0{n-tw3L6mDdGv}l1|N?L;9p`>@)%m
zlic-VFTq4VxnnoFLJC~xbLSXD6=}Ta80C8eKDT?OIim|=3G0$%H`0oa#e%o-2V-hb
z`3IUuZ-2ylLS$3yYDZBeP4<4I=O2t|>Kc4czj>X3f@x(sjOAbmKBek{=Fq9=0>oFJ
z9RxG0D#oKmQanV_1xt^!(|BXPI$R?A@va#D4&w{q`y4Ut1QrWrrb8953lAa8P;%s$
zAvyg@_k@C@&hdGcHe{CVDLJz36y@)m8PB&Fr%5B8qMrn<wd!q&beZY1|7!Cy^ONJh
zh4i`UBskgEea5zFJ{4Wg47Mv{9Zs0$QdvsM?tL@C$2pQ_27#Xb0+=5mF&Vi+(I;9_
zz?z1d>*WGYZFAAQr@oL@_%4V(2+1BL$gi`8pri+74Jk43Nh&6qx++}@p2Exga99z?
zt-pPxP3``@!Z!#~IvT3rz4;bDHun!vNi`h&Ma5ejCG}i2V`aizgzUOEp@N^__<5-O
zUc2tERwjYP)gaS$?Hfj_QYBqTDrn+5OYWaU)a<m>%C32PK>RT72H!w5^i}OW>hkE;
zI*6+$t9v|19ls(M?BP>zg1>UN6SJmKtQ)6YN$@im>H@Qw3m>Z8tbw?E<UqbN@1@_r
z8OM!Zm*AwakiSQP@~U~8+k{vgPCQ<(1m9{>G}DLAC#^gZE%3A<&|@NSuZ~Bnu+siN
zeH+QXd+*IIX%%)_89diun~EuSB%K;P$y=n9kEN4<j;wQOiBf-@So;#fd3laVA5P{v
z8&j8eM0SzgWt~aU4uu63>VA##{TvQc&uxS>F7T<eMz?GWYHK<AJu4(hL1a3?c;S0;
ziidF?V(*1MI{RyS>P_|}@s++Z*qgy8L-M9)I$?J*T?-A^>=7Sb??MwL_efX6_E}j-
zQouXe;jGhs?!8SBR?FC-38g^tx(nkdtIo5Z7MAToR35^wmBKlV2I}~-t07(9bOV!r
zbb0~iLk*M~o0Ko4zYS<aoj0rLa7pO7%&Zx&vU8K7#GvlHF-qeB(uvvZYKET)>q{2f
zRrP+|j!OLmT>UPU?S-is^Iq3zFhN7k+PGJs9D;OjpYicNkQ$JM?Wt-LvvjXyP+uUL
zeJ3GuML&1gN%rTvGEVS4-W^Bo)0CA5a+_Soa+E0{r8FJ}%pFB9$+*cqlfXZ)nUWmL
zJ4{1b>>hPys`0+7Y`|3PFbwNrvSCw25eiqCwrlIKYtk_0;$x(yz~W^h*0G-~(MGKB
zjPhH=yWZn=lI*Cvfcs0rav%WHAB9%ksW8?&WX(>C{>+LRBPkS**yXv_s;;U)Q)-$N
zkaZ>p%tqB#x<)$TG~y3XX929kFSf(`<W}gsQN1jjGM-Db9|%`F=68q**GNipj_ua?
zh%TcuKLloRZfV1@|Iw-%y)!vhCC+&vcF0mwyDoR`>PPrq8CK{u)S#D%TH~HOBg;hA
zaY#S?ko=xV+!H<?V4Oi(4vS{mwIRE&XFTEYI_Y2)E8RP*G4&vQlEXUVZZaQ}c24F$
zGSdU6*2`)ooV94C-_SBk<$x{OD?xb4q=aBoV<;={gg1r#Ca4Gvq;e)XiBObhZ;NSF
z{U*kF1TT~2{S&P+3^i}bFjFj>dh3lBVhGOSu&?!{`fJsmL>mkb;#%H%_dTX**>@^L
zC=mDLH*in)Cb_F3PGKq|I*rs`J}lj`_Ow0CS*0>z)n7~L-l5Rz80I%wF?zoLvt^Cy
zWE1%A;Vhx;b8l74fXNBP@kU##*~nsg(I=Wcc9l!{7O4_^@@a?n>)#b$*s+Inb&B-w
zm{X$6^r;}v_Yh7ep5G$o_j!9;lak=-RDJ|jdjv78M0=oJ=2<9r&fICI#=FOgq23>l
z!>b@t15TOWJWGrJR|T=~>q!i_X@E|{j^Y~$*^BSCJ0SN319K9e`tH+?HI<-W0z>4&
zsM7iLenOkc(O*p-w(PG<&U2lHtJ6n}tpMgPT!_8XYu_~WUQ7n%vk>5_8^>^{aUy@U
zFQ(SN8cCt>h6cO>-7prKQO{ly0rD$|`(|9fMVlV`9o^yOM4G<{vV`4Cr*YUBaV`b8
z|4|f44oY9YHrUaCj-kSCTC8qqI)@auXZ;le$VwBgaIvgZzM~;@c}enD(O?+$&O$O9
zaDFp0WH|h#qj?8Vkpp59`Ss1=EHYRF*PrgG`PE3=Yo8$X_n>Paz2s%!UnTz4^8WIX
z5&?vOAsd`k@xN(z!TkUVd4=?temgyd2$Uq*;hIcG|E8r;=tU^dwB)(J>G$M(=@|;&
z7}WUP^c3iqMBT4D=XcXn0$=)->{8XGem6Y@L=BMWdt&Twh*?L{YtP{fXR(m@FYYtj
ziC&Nm5<TWO#K_~m^cwZr8PoknZk(S%)C9KcEB=O<5FwD*);Whu$Uyl-MEmXe&gmvF
z#!J!muf4BKTgXW+xwL!EKc0E}6Zk{U;!2<eNI8j-Y&mgnPC604X6BU;|9SSSmzgS=
z!(M;Re$n%JY2&_L(*Rut8j}C{c4Wh)?H=#xQujHIPbOs5wJPKf5>x~)Y2A)nuD@4Q
zfH@s)2>;a?rM2k8HuJ(OrRU3^mT@e*LbN>|+Elc*hUd#=pnK=43;n4U++a>P;d|;?
z!)|+vy?-`>U18|88~PBG<-X)Xf^4{LCtny)C9KqC{vm=@H}Gb%9k&l!a{n!D!7-3B
zD>??IqUHU!Vt^LHCGyGz?f*_oxnH#OD6;AYNL~Xd;`tLvB@?@-mF3J|5t(8{xyjr%
zH{F85lK%PlIkR3tdGQewa=dho>A`G1t@|z=eMfIwt-^DL^66N8eOiz8D;eRm?fB$k
z<c4p4r+vvUDDEt*PVk!t9{w`BCkiGB>^FAu1!V6Me|7Brmuix{Oc^r#VEo@4X9|9M
zk(H@f?B%!L$g1zfqLU)A{+kv`dD9oQokuqE`fp-TIV(YI{QoTeZ?I@vF-qO_M{^>j
zrynZHDQT@GJ7?OK?JR6tPYKblOLS^LH!0Uhy?=?eZ6W=XJrTmfyu`ORk?WcK%aYGh
z$x{F67sILBHSNQx`wm|;znR$&QdH%okU1^MZBQWbLkb48OC3qPyU~}`@P7ya^+gEX
zAC1YVUV6yI4Xg=+{O*}(rE53(<7mzbM2-#N%xESi-;%rg7fkJ!wG$k4e^?CC>)H`r
zBdCv<{qea$r#21n!P5w=rG~nkrr`2gpDGFnzk7r7=99O9Zq0jX+OEs=@yel+!5a9w
zZ$*n>Vud(#+K-in@B`aVjvt=B{jbC){}ViApJ@=`%^2UC3q<&DrDc#&6@<nc)O}Gu
zgbi3eM8V(O1u{+&ywXQ@ggV9niyKlY8A2eQ#S;~@+K;gk!ZWoz5*?p0$kF|pne8<#
z-d6EBpa%iigq!xr2VHLf?ZlzaS_|gk#%8_T4B=zsJQ{r?seGQmW%b1y6Cm*Gqia?K
z3;%c~+0eiO(kR-unBSloj_8&@g{w@e60<J^^__7)7@2h$3P#nQ!c@EBDz<3UD@mEQ
zTD)cpExpe-mOqX+VzU+|847~xVOriA!xeQGGJgMwN@DV(vGpr=<>)(ZE$g<B*0n&>
zl&kDUZkog(nXC#1aMwV2CF?_mrgVpYqRm&3F`TVCFGl|n(5k^JH+LrXuR4Hzi@jj1
zP+OnQcIz@=k`C`d(tb<QNM0BU2pY89#XvJk3Ufkl#Rj&g9we!lk<Lv0P=~9PLN&I4
zJrm*#5}m4qR-N!xF09^#-2QO*6Luh+H!ZP2<*PJ0H5JAG(x|#AGk*}06|L`bzA0nh
zs}SLBeYK|%xO!_x@Bzo8xIkq_QrRY!k30bb&DzB{x7S1F69oe2RJ1bOq0O6b`jmd(
zJWOMj>EYrH3pj;-HF$%U$Z3``2^pjZq2T7es%%IW&y!hp17U;ZB@sl9&u-Y%o0UA1
z3RzjiOo$r!ntET9**B+Cnwaw>8nnI1c8VaSQl08K*nA~vI?kQDFaIgRZ?8Fj?tcT;
zzo?ldxTePi`rM#j5Unt>Tvr7vpYL|$qAUqS1OM>tR!VBl{ouU9qiTK$;<pMHY?@$5
z)%d(ITwEbnuCQvj6YTh!<+|osjj)eqW<bv_!=LK^oEXz?_p<F`XU@z3!dk-DsVa)4
zTT3d%wzEdiG460vGT981VLg$O8zP!1h~MNPTh>$-8??v=rt7S<8V}>#iKH$b`Fyi0
zVU&dSnG^S+lZ|-Q*topX688#w?mm=z<KgX3)NTI6xQl>wLC+66m8pc~68mTP^?r4c
zB`N$nAIFQour-G)iKqgh^oOD19Z>o%ERfFY27dYT{#cIb>2jnsmN|dIY<37)Yr<^z
z{G-ce!|rxwQ#?KyRfCn7s8`Jy@6UMYzpn3!?6)en+&k*S9q|=|VXyZKEJh~&&PYaY
zgTu~6RlnMh!%LDY4+nnmQ4vlo$q5wq>I4f~>vht1L}$y4dx*Gyx6S&8@ym+(8YHHM
z@?1;)CdQ&d2WbQ<0WNyjZ}1`JWpIMwVuRXmJhE&B$dl&ZtbRBBjW16P1s$Z=7;gDp
z9Qm^U&D9MRD3bjfWHEe+`LJA$;(kMp(u)_P;^(Br{tXIHyu5k>*8gj)*k9!6zl=^g
z?f5wMJ50iQIoOlt@tc4clm&ngG6WIftLSfJ2YiX7nU5A}enU<^02F5`dD;S4e<wRp
z(7_nH9i86=uiYRwkh<>Q`Jb%gAF^Y9IrxA6QMPw0X|eyc?hGbJNxX!j!l<famo~67
zo#D^zxWAW(y<CdYeKG#!rZni{bSu3nGf;JhHCCQ)=+e)u25vt6lcVHUHbAaqg1SH6
ze!P8+f~nGhB8QWQPpfa|{WeX95Eb`5@8jFA9ooO%2NXera*<E|gVc&IxBM-HCSi)0
zzkb*9esa%AZ58oKpD2BtCu}6_hkz|X#TOWd7E7Lr&o}+x?iMOKYV!NX-HOC9IOC^e
zaFCBZt>*rTfFK;SSwJ@kLY>~M(${nz*=Eo0M3KQ@day+Qr|tDWf_DTdNw{?%E=ZK%
z7_(XtADtP4j+ioiOrfou$bv#&GZi;E<uH!ThRPd4v_28RT|)T+AeTDsMFou<&@8I_
zp`8Pf<rnS@7v!O^Q<|bKE-`m!h<}=9u#MZ$e*0D-bVe^`;)4i&g!y493^UB?RW2Jq
zOG{WP7fvIqhe<uX^QWG)dn#+kke&3~2kpMSUnJFR{sN;#-3=gcT^)p(bqsE)uXBZ^
zR`r{g>@vndR@Vt^qYVQnx_gDn^>Gp-)Sw(qq9h+{Aj28#KNVt478i(y;f#s1tozx8
zx)d%GF;48O(~2{a1#=G$!V5-7D(VIf9IB0RJRn(3c+VbEudtHiEO#XysL7;rBTlAs
z{Zl!5Uq+yusxyPIEi>}978_R!CkRA=vqV%4VLdv*ni1Q`5#5Yj*g}p}p+A!aF)NUg
z=EfPQ`%7Mh_-z(P!3|3E3SM|(1D)7dzIHeV2UuFY_lAZVE6_miFrSa0P7A|(Ds-F7
zSq}<zBw?Km+AR{fnHv&*Z}+RqYp-}QOxn=F&mbsg2Sa;9r4T3E%Vb-l5J9(o`dWU5
z8*(J#9x0l~^eTC>$b#(t0>;iwVa?fu{o1u$;-m}gUIXs>*#vue-aM8Ym(oS~+g1<!
zVw*c2Y*C%mFndxMm(V}VuQ?Lr?HIax!d|{${uWk0fMB&{CU`!pi^@kIzgo7=(7I|a
zNM^k()J!p6M^s4{nu9k&Ua3fNfV4%PeX7cCCn9;{pHsqc{a-SsH^Rp6U-m8Ar}0}v
z95a8ExEm6MxDtow?t-xfZaQOQ^<CNxGpyiB_l57(ag&)rhqX)qBuKwkvW9K1V*VH~
z<6Kmc=QwlZK-8m37xYy3Hp^$CG)RBt9ijPT|4-Zqm-6M44ws6)ec3poSuKe!qB}0r
z`6A>!Uss7Q<TUXU)+w7QXWVscdRvGR^}UTNnhSjbkeQEBf*hjQLEIS3Fu1i1%2t{E
zqq!+wm=}p@I3`tUtE}{;@;(C9JD0mLFE1p#u&V8C{EG-gBac)=mMz?W8Xcsc!-ygG
zkE_L(+_Ak7`8)q`I=|Ojw(@j=+s${6u4kJtli9~@0^K(=0{4pjsj~S)x)o91WHwEF
zJ|@_S>A1?7-EQgqfw64fSSB8#+&&G66f2E~RJS32-GcG|7HuW|7ifF(<8QP*V8i2k
zZn59C|A%K4gt3Kt*NXTXyvb~T+17FPJ^9^CDOA1o&&U70<mKh(%f<yBq33TlN?yGT
zMe+FWC4w(QQS{mkp`dktgTsO#DsJ%qdkN?x56Jb-f&EDM%?0Is!QQn({eOn7XCIGi
zf@~G9W0(gBID`Y{mR#S%P~`jr`WzL<nNuAR>53-$S^C5U!Dm6|;zNSLJXltRXw{$a
ziH;gFMGb`$+xpI$^VUQ%YdYC6syj~#^$Me98={4cgEF(oig{|^99@hdARvyoMp#T-
zIYYBMrMK3&%42YcZ_^1@99qjAm`64ij=2!Qz`4NuBoKt7UV(u_LL(6h`u_ESkkJnD
zm#=?*um^W)s3d;*MY&jTrDOIqCVxF_xwRmLox-|tANKUi!nW%E95=(?OVp};@yXRL
zwj9nNp;5(FZF%RevRx1Rg2l(9F%OQz64LM9^WLs6bQ6s#{=JAG3$%!UxK;?6(DuvQ
zR4!B=@9!kbt~<(;Y=dELEOI?-+4<{v3|2w=h)=BE<7jp>X%6dOOmsuc=yb!&y}nVU
zuT-#HITC~``6Ewk4@RIBx1n-q<JtXGlj}j$4Y`p^nd$jdh%A=zEWvwwux5JO?{DXF
z5G)qcUzWarN`XKS(rUO8&`{SiUqhomzdzFZ?Q^;H^4ZPwJkR>zKF@l&_nijr{Jmmo
zgOv!W3f3=TOB4j-lO{(}Qh|h?%xX`%nL<ntopHZ6V9e{jAmw%2khi(W;70bMfZC9L
z4(6Qlq2%V)33(^cZbwb@^KQ*x>~#LyPl8l*2kgD9w(GFj+nei+(IoL&AD%aIE!uAt
z6-(c>m=%oc7FnD~`zYG@;O-rT$4u;WRd;l7+Wq|EN(-ZqH`2gwo%+06?*Wt{+aw8$
zPA3O4mfDql&mmnS_*=y9XfgwVUG7C;ulzLLaZccAx0q#PZwzR*#$UYULguOE$1cwW
zig(Mq9InqsUO+Z*>qOW*sx;agkAL0Vw|l$@+G%?p`pIces&l}PMJIG`=;OIB8pJcM
zL#i30Lu$9)J$v_4$*$;r%Jp7KH`t?15kX4lvFW&XI3b*rZK_+_#jA0hb`a%n1!GhI
zcTbd#&2fiDDp2<u-=JrS7PFINVcDonG1i%!mRoUB)8f0(k~UME!E}iEPKviZY(Xm%
z(QH@G8kSQoIqtT}7bv%)fgq}HEVal=GG}>Wdyy{9A%M+;|JWlBU?z$8adKE3V|5(8
zE*X0Ji%!#v2<q8WnO_kJX3B#DV_1<NmrgZwxgA)qnl-#}$?3=t=SVj~>s!qz@gzP)
zj$Z*gxpIeMYABYeY*skisHk$mdJA12P2Gy0S`|^EX?X;2-T7cu!@Jg=9B&6r3#2@1
zJsEVQijw0mjBoEqRzi6yg|{EdwtrO`LcbEV8%ULWY|yvK#P-SCv1mu6xdjhm@3E_}
zn{E%*a{7A<ZZ93J3`aq?-L7x0XZLMEP1{%9RW><=z18*J)<STtItY@>u6y~XF6VDH
za*r0P_<-?`<&Ui1oL+X)Jd0?#`F_U35oQdJ`Zr9ON)*dM8N7Gq7ikjXNjVt({?A4t
zaNTUjcFySUet9ISAZ6~MHueCAd`r&A#(zBpU*Y=HoR|>KK_4D(ksk+#otHoHK*BV!
z0gE%;lW#KJT}YxmcKX3(*Qlbd?8&^E^nL%O%W~X>m_&Ld*BBmy6JEI4M8AZT5gkjp
zRp?QIj<^nM%4aI4nV!9xjIXVv-?8wcF@~<v#dVMte5kR++-gl+p;&(LOQ9-+_dZz$
zOCwjHA1Q+bb;qkVJ;vBLN#Z@XEKVD^#5RCpy5jTvB-`3NZ0Ljc?!0H+xFX{Nn^L;Z
zs;OLVl@}JA@bGAl0?F22ZTQDgyu5bhP&u?lSvEI2?D@`*?#w;y-jgoC^_;Zo;;wNv
zbW;DSqITfmF~L>J@4&#>s78^#9=9?zrn}Q!@z0@q1kQ8X05LZ1`mKpbs=f9ub}=pm
zsBGBTU_OY>x_y7B9|kJz8gRpt*s%Ptqb2^^t?I46h9rMyQzQxwX)c|)TkEkA6^~|j
z)5l}Sd`q=bjI+}-7$QsZZfbFN#)paB$4g{#$TG2jdP?YT$J|c#7FwDfdDt4{VWsuV
zh0e~~ef9`RcHNjAKBrT>&Ysr#Tid4yS98m!Y|&C7{^joFRY1HIHR8$!{0j&Q-hl9d
zP3!f}zn}nGInK8|r-(i<hUi~Mirx$ADZ;CDaQz!TRLBS!3yTKU459yd#LpZFDN(so
z#TEhbpGO2$V4$Uo_Ut*a{z<H0CN?A_`Txt<pqJ1i48OYQs_>JVpOgJn=ZOg!v0nF5
zzYtp`IKqP1%U7%_BIcsYmXYT`@;_Iz6#=P1S>M2R4h#}yV|)A9j{a0<8d*Sb8Fgd8
z)!$~F=nCcs>`Ez$dgYglf*G_^TiY{j(x^WYerY#AS4X;0Ia{4g6Oi$Fmj`o!qo${F
zyirr%Xg_auLh0yo?0nIn!hWA+tj6Si^v-bQ@IGs2HGQ_4wsb!pP;0Mrz{9Pj33qYu
zwX~FGpjTrWd*S+GQ#hi><!BC<u6U-~sevuz7tW+ZecKK7ai>1`3c|x)Tsw>Oc9vG0
zo(9obSyfoyhW_+yX5)4rkIZJME!TK=nAWSm8((X>P|2ND%)(yFuY{m{*R)X@9+>U4
zF$_pMYGR$M^Aal2sA39d@G5A2)J&`R=q2WMZ*U*oYspUP#L*3*i61gGq&?PZr@}k!
zWC^I>ukgq+n1(oAa&qZ8Sj#p3)hUbnH3pYRYrp7@h~L>ehOg@;47|v&dok$rnn>Ds
z#aZWqHYJw0L1i1r`?XdP_nO$_abt^h4AT#sON@B^9yW8AjwPnD@k?{K_dGMgBYRdA
zhaK_b=v#+URTUI4O5wd{u6GTkW3lua6};AfHcoaQ51W#O7G_x&tBC0|<Q1>0Wzzxy
z%pHT+v!^GrUtEShNNe706rh7#hW2VB56KWuzmNf~O!^nIV=4E<NroT_ohPRYN2l)a
z-bVfB*0hS}Qo~|<^ytA<dbDj0gk!BD{oS-3g1kZk9X6z1kBKR~(~~>WFI-;S<JU0<
zD;f0rp+^Si*)27E@wI$-F7b`=lL;P)lODkm)P}!!!>AW;IH`;Q2L1(E+#nLm%mT_?
ze}8>5!902{KDXH5cD~m1c426YUvehGaVi?i%qI34vrH59JS8Pit(I0J`ZERmsgHL9
zTjO}H96xSv25<ZY{cZ$n%C1HYr+1T)nx}_|L*w)>hSUxT4J}RnN&yYz>C_0l-dkYD
zTh3j6xQ$9Ne9}AK7<(GLPs)iJu$_rs3o{v%G;Y$+KRmi8`Klc5bQnZHam=dTVyaZ)
zu_GwlD8r3=9DG&Bz22BRV4x7ALvDon{I{!5#C)+4&Y~}`{IJnEA3+K69nJh=gNYBV
z);zA*wM_*4A#j5gNW$92*XYT)P%!HlJ9k(A*a{V`O%S1yg1zpsk1ld?5CM;aAF(me
zhJjet%y&fKek{=toj%)EMG{})Wy)ECm1|%8i^gI4gRB7#z)mKZnFwBmPJSrM?YtRy
z3x5fukyaI6I9sY{@G>Ydm#YJy?oZQ&U0n^&R#)+OI|><8mR#sZuPvD%ju^23qp`Mb
z172VEl+`W+YHoQd@~WCGr^li6XN2lZa56FwNRQ<u0!li8w`jk{AeiOtIW93Do8x9P
z{(y<dM=l<hBdwhC-HU^{s$4r;TgGv_^Yb131znv-3a%wT()I!ZcmMr%LEW=1nNDcL
zCC^bI#4gacS=qDcnUZ0|#{9!SA6hPSHUFh^^%4`;-rk<%Ml6*QF&>3nI&KWP47JRJ
z`-Izz_X{D+43t1Ft7JzZJoyH#{08Sz0>Io#wA&JWp~v)#&$M-eB-c&v<faDuw=Z=E
z0qK;7RVvoMj@TxF%q0P4`6JA~-1QzB$Xy@T*ct!JUAG&dASG&%y9Sc|8xhn%h|n_A
zlZ5;)L`aYTg^)?Bc=7)R9UTzpT<YMMi2i-LQ~EX7t5-P9FS7vt_)&`-q-#c>Tmb(M
zW$6Dn69vV~N)CVUU|Z2HcyXE5YI~}pCL-kZ_+=pWSCvfw*^8E^GdYOEKpMu;3FHjz
z%e2M!Gu`F7tpeEgQfR+iyWSB*VD7?P%u9ON*naA-4P;X59ZA>GMvi1v9`yN{zv=ro
zf#!<sJksW8mFB3ROo@UKX~fDZtaQY&I~{L-BVN;5qQ|JhOiT^V5bD1`azagG;eP`p
z4aGv1SDZy@bx~oHle5fRC+iF``{4eT3JmB8N+ac%gC2pl-_vs0PuF@jc7FVd+)}z}
zx(wvBh&oX*Ic)oj?kg3Gtd?^C?b0~9m8Pngqf-wE-TVC{eO#KSPHn5L7qN;byb{Ro
zYi)v5EZBQaa}nd}d_Ztoa!hICW2w7XWiF)XqQv`s>l<Kc5$zC1t=mAmSF(3+SC$+P
zC*V^GsjYggH)m?$5>2Mj-}2)31dG`8yx9&H_iaZbw^iBo#ONN;aV192IabxKC2ZtY
z71{Ay2F!6HY4?&$TP@&U*X8i>#fvzsv;xjI4#-NjTIvqmxm8&y297MlAJZ(dOfG9@
zuk@q}x6iI}=VoI*Q}r6S@jfn2n@VDo0`NIXba7MKS~#W;6A2`G;|)!N=~gsxs_qcF
zI#U)5Hj2VdvoUJBe;h>alE3*y?|MLy8x}@J8Yn;tZFh1JO?HV5>;brI3w!8}cjkD%
z=RG|u&(1HVaps*yyT3jReY7FdjH`+?B!3i1iBDYNY<4IN$#o$|gM;7kSv4jMzs`f@
zSzo)9c<XTYf3;`r@ldW^TNCdlZ3<h-c1Yt;4ui&_!c67RI9A%BkTPK;%K0?Lv^Odu
z<21%OcC?ckA~_7ZqMS2w7-WhZCW;KEVVL(G_V;`J=KXztf8QU?U-Qg!&%M^Y)_Sh%
zTI&gfBBCW%SjBCJ3y+AL&K;;!zeheqvh1yVRW=d(eTFn^+V8h=>Eiw;sAqbcDqb5r
zP%WWCU+kihdxfaG(dL8m_}qb-(BCAkL&<Nbz2wNN=bv)EOnBMl<%cEhb*Tg^WXFwT
zr=^=X6B8fPG~?5uA5q8KZ!Z(m{!pIWntn4@NRzBao6p>8j1td?dAUN|q-)(G0cC$<
z)3OBcH$;nIUN$cYnzgQK2>+CJg&C~TU|tx42={;fq#srDI>D(0;i5?nX0h``O!_MK
zMP=9ZpwD(KIo91b9?Xq8l%AH`kE${b*QSc8J=~?Q!ril3JgIGgVRO__i$IZAK#J*w
z&raaX;*YRql5z`;$$qRp$DUjx+myODi_d;(h_oj&)G8LQuVBTY(?jmP_upTio9Z^K
z_6sS+V2y(1ci&vTACqkIrh=Vo^Uc}8ZsFHZtv-6iAt$PYl^@aAvi|HQ_}bjFs%ooa
zspE}J9l7+Ad37()W=}Qga#=$L&3`QgW|@(F-&4K(W)p0V)Q(vg6d5DJVFT<@uYFFZ
z!zrrRR}&)xy?wF|^>M0wf$1Sxl?(WR#kXJn6x%<9>ywu4_etz{^iqAScBm@!<FwF=
zZJUY=rp<Vd-i_1q=0WfHt~YDhIY&aYsO-S-r5PI4(9m!<qngbQAb){9UQ5ZIX+%;*
z(NjYEwr<6u8oRY$95+x{c)L~SZOCEjGm1yh1gq4@H7ZAU1M(gsr|tbLhU8KT%gV~&
zwwb!h)a&z~T68efA}ajR!5jk~<_bf?iBcaAT-gVp?l$uBlT&$rD38e!M$}Q_>D{rd
zV|S`@f;RUTE&%MBeLckavAY>yw_X%pFNu!@cGm*no$*-WpALFE13DSo<;di3jL4$G
z|5pY+d)Hw}7GO!dpf8OxW7ejzao=p07n_+CZ=1i$BL^f>JVn${if`L3kev|8kS+X5
zLs3;xy9KW%!S9`*%2)oS(MVgQ8)54yD1X-}Y(2bHkpC3f(T&ib?w#OU3YyC5pZ?3U
z|7B`>GH(4_85|$$Sie9b(zW%LN7%)o9EA}Ib<c;$|1jd2deHZNh9ye^-;gnlsuQov
zxJEEiu}53ktq4Ev@lxC;12W<~+H#YQs1`CJ9P~Z*3%L03Qo`%zRaVAJ!tameZZ8gr
zzoLY6n!_VC`mj+;aX}J^{~1u^@8H$rsO}Xg5Efe3f;dxI24+kJ?vD3C3i0WO>@9y=
ztY_N#tWK8=WTj5fqwFJDbXPf>p0?@H_ROj9ah%z7PeXj%IfShG<n~vTkq6gT>KNl#
zJI>z2Nv0b0-`u-To+J2hU*Nq~FSENz$}EnVPyHb$htFpI`ib((*kLAJ%#`zRqIxf_
zV0Ny+k;(i@&0XP!D-M3G)eq;gkPl`y4Mqi3%#m)oI*HzUk@>Mgdp_ScJwBH0b*tj~
z+?+z;#ZHStOlP)Z!~Exg+KBK-76NW=PhE4b$0dvq<wa$u3&;EHnh8+t=icG-p26W*
ziFDInzpOUwR9HO$@8CF=X3OZj?N|6|xj6mV1tUZ{6pxzqTvL*-U35oX^(-uAq1%bZ
z`$!Wml3gSH3gQhtI~H3=WA>h}E6z_g&A?9{I=I87A<S66ftDe)eRCt78g1dPVtLwF
zQ21Rb^7(8tE%a*x7h6hOx-`tZAZ}4pO8z#sGjG|e-Ety{a$WJOFHVOtyfz*BH79<*
z7-imaxQ7D!$`13x(5F_49XW59&%ely{@qn{u_beW%${}sZH0NA)t52$A@e4U`S?~=
zaRwJ{pce)85Epy(H}vGK2Pnge?-K({nf@2j;*)$tHfu?x{J54sOK5Qdc*wTwgieDv
z(&~zPw`73(Q5OlfI<~h))TpBmJEZ?rnO}QSbL{eI*j*^IWH(_%>9NaqD}B&5`WWVP
zK<n*2($)^x-AOwS4)*Ig*9+lr&v4E(!U{qNG-StBv(7i%S}4e7=QU^sYpi(<Ukjkd
zj4QZmK3Wpr<jvTw9mE9s$)7<7c~TJzzYmY}zQ|cdxY~#BYH4i2PoWfO7;AZ&%-Szm
z1z!%V4c=c_%3a1CS2rhR-=Wz5{!%@Wt0Q9hxzmhZJ1(zc>?eO9Mw#)i_YFo8#wa(c
zQC;Qc8IQ`b{84p|>6v0N@S~KKTgx5X*=<%J-u|UDZ0Wo2Rd+&EXZPPSqz9m(DUtUG
zzA1kwVQh651D_(w4GzZ!*UnOoTv}{T`DOsijql>L$#jQabuYgkS^C|;LDVWX+j>(4
z6amOo((5&gM%rvkRk$TnkLk$E-X)GT5rIt@m|IDtL;b?<^jdko{?;AR_Q+VemP<xR
zj~MQ&iee@@E?7$3hIb}jW_m!AK0?1)Q7b+*wlq5$s)mX9On;i1v5CS=P9$Y~HXK;3
zb#~c2!bz~mA8v>+(i_MCmwKAlv=YVZ4@2qg_`eU5S(6r{Zsin{)$y#RfRsGB++Qv1
zieTEA63^(7HVZjM8T3aSYQJcDuAEj7hr<q?xHfM|V;sCh8=WY4QiKSewWT}xYfw1M
zTtgB?Fxc09IO2*sBf~#jZ1EN8g4m*=Oj*nJ&AHu4T=3ORD2A*6Y|cL?SdQ?V?97P|
zG|9;|j;Ml*iHVsX_KjL|4qQ!gP~oIb;_mJB(6de&<9-ijtSZHu1lc$TjfRj}tc=hS
zyY@uomM+QH5AXvk6HOOSoa2^aJnyaG(vw1NS&(HnXiA#LA%$NOTTVGRIP595&Xiyn
zhRuH>!ZD{YB;V{#Sso$_0%`mY8{_=(U+FBfqOrG6xE<F`lu|enU0xU4s;9eb-=%IM
zf}K2^Rf><{CzE8rmu8gZL0dkGNKga1Ho55-KmEM{a!=_3_Npo${g_LEhv3bnz5L{X
z2Bebwm{KLFMvTrosxctczdkzNT@l^Ys*^&)^QIv?i0|f_df^a3E$NaxjxUG#@V;~1
z3yF;l-0%w(I;#orb+!lt(l$&q06@~s#uMBSjq`n+<eOP*O|P#M{Yg6d57y>iK5Ac-
zm&~|}^+>lG$61^^`+UTRNA;%w)yF&hmc<Km3Fk&eCvGjJ<*%ejBVX>Blw6gUmg~d1
z{1OPJi_oP}r~fZ5ZHDTJUJIxw(HgV?K|JF|t!;_E0nAkLrWsbnpcZ81yK;?X89;+M
zk|;fh-3^~JrTi9cZsP+|ybBnE|GW@FDPp%z*2IR41$4|dXUhcXTy9M*d8lsJ!){4Y
z6;E;^5^P|M=wKyq#$TX{+RtxjrQ0hb-2(BEZiMuTCq@1wAyr0stDEwB6Ilxcp>jRQ
zA6g|({GRAjy8Rf{4XTieZlhvq>}s&mspuYcyG9vFpw4|DLGDAted~QTenHe(nuKOD
z;E4Mdmd&@B&$pG={PnD<Ghsbhbq&bnL&TqHo|i7W5js4l4-_+^*sB#a)_~woPJ^_c
zYj`nek>3bOyYQXLZq0`(Bo<9qT)sho(BULdJ|L01838(?RtJjNU%ZK?Jv{0B7l4p6
z^6DZxswITV=k^_8J<X0$rolzc%3(3=C(!eGy%#ssKp7gpz|@i}@2a1vAnU53CM(8i
zOHNtLai8b=dAV}}xodN97!sCpR9v}~VOs$VQ89<nZ9N!iVo_U+@`D@rbv<XJxLRiw
zH^cOM`UE<plGR6wS>lE2cc70<ZW68nWp+uB3JXrdTP&Huay;;;L1J>cL##^L&t;{L
z{hx<zR9y#z;pq}p!r`=;$o6!-=0sMxjIS|t*T+gAKl`b@eP<y;5+$6|8CVf(+)mYq
zA>83StW4>4%L6ZyTiK9q%=$R#9TB;9Q0J=al8oVLM}lTs)q~-NW-oXgaJ6uou(kO(
znIM2ax8n_EYCM97E<g=7x4wm{_a7UoTtAI)5rpP>Q9myYoboQZC(x-XSDxpB25@1%
zw?7!7ci?VRi`CY<tmX0yAyr!N{^KUv4^Hjr*mxcEvfk?S?S+cD)n=a~f#6(fBp}ed
z9GoLWq)Zh>k5e)F=(crt18bl9Y&^7;2kvs6+gllM*`BJ&$t%6bYk6q||3ky&ra|!T
z2~lAY7y*K<dYn&KjfUuna?E(}#JUDVKH7%PyQ2_z?xEPA8K{SDK^0|g@&{aTq6%7W
z3&f!gIiB}iTo>15;J9@|{H+M1kD_X5KV{<bK9{N>c|0ThKQodrJSegA2GsJv_Ys<1
zO9wXwO%C^vm$grat?koPz&MSY@C*Yq#Q!tqyM~WOeu9VzZRAj52cdc=Z{$-D9YS=T
zDlm;kZV{ZnAS|RNR6Rvn*TlO-J|V<mgN+a#nesY;IawqV6zd%As{CdgJ0Yav&acfu
zFis-f{0rhF_$4}0T$07FqLGTQ{5X`WX(rzdwK|ZJxn}|b|Fs-+1o3K;d{$$C){t70
z7U1{g6M*rsotOF1dJa6cFX#{f{<Z)Zg~IMx^KByK3L^0Rya2!NcY)DQW~uyRwHKg6
z+J+Mq;1A3^Fj{w0m!AnjL7G1LZ4uySAYhcR>y!%LCfmUI_j5D__+$PC7@b#Y<=^BZ
zIDbrokN|&A0|?_s(0>H|N6>!+{YTJ$1pWVO&^fs2If`6T#@j>z@Ijf`nwA}NyYX)@
CDikCD

